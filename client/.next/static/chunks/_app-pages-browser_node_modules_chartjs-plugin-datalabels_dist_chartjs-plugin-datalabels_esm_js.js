"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_chartjs-plugin-datalabels_dist_chartjs-plugin-datalabels_esm_js"],{

/***/ "(app-pages-browser)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ plugin; }\n/* harmony export */ });\n/* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chart.js/helpers */ \"(app-pages-browser)/./node_modules/chart.js/helpers/helpers.mjs\");\n/* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chart.js */ \"(app-pages-browser)/./node_modules/chart.js/dist/chart.mjs\");\n/*!\n * chartjs-plugin-datalabels v2.2.0\n * https://chartjs-plugin-datalabels.netlify.app\n * (c) 2017-2022 chartjs-plugin-datalabels contributors\n * Released under the MIT license\n */ \n\nvar devicePixelRatio = function() {\n    if (true) {\n        if (window.devicePixelRatio) {\n            return window.devicePixelRatio;\n        }\n        // devicePixelRatio is undefined on IE10\n        // https://stackoverflow.com/a/20204180/8837887\n        // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85\n        var screen = window.screen;\n        if (screen) {\n            return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);\n        }\n    }\n    return 1;\n}();\nvar utils = {\n    // @todo move this in Chart.helpers.toTextLines\n    toTextLines: function(inputs) {\n        var lines = [];\n        var input;\n        inputs = [].concat(inputs);\n        while(inputs.length){\n            input = inputs.pop();\n            if (typeof input === \"string\") {\n                lines.unshift.apply(lines, input.split(\"\\n\"));\n            } else if (Array.isArray(input)) {\n                inputs.push.apply(inputs, input);\n            } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(inputs)) {\n                lines.unshift(\"\" + input);\n            }\n        }\n        return lines;\n    },\n    // @todo move this in Chart.helpers.canvas.textSize\n    // @todo cache calls of measureText if font doesn't change?!\n    textSize: function(ctx, lines, font) {\n        var items = [].concat(lines);\n        var ilen = items.length;\n        var prev = ctx.font;\n        var width = 0;\n        var i;\n        ctx.font = font.string;\n        for(i = 0; i < ilen; ++i){\n            width = Math.max(ctx.measureText(items[i]).width, width);\n        }\n        ctx.font = prev;\n        return {\n            height: ilen * font.lineHeight,\n            width: width\n        };\n    },\n    /**\n   * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).\n   * @todo move this method in Chart.helpers.bound\n   * https://doc.qt.io/qt-5/qtglobal.html#qBound\n   */ bound: function(min, value, max) {\n        return Math.max(min, Math.min(value, max));\n    },\n    /**\n   * Returns an array of pair [value, state] where state is:\n   * * -1: value is only in a0 (removed)\n   * *  1: value is only in a1 (added)\n   */ arrayDiff: function(a0, a1) {\n        var prev = a0.slice();\n        var updates = [];\n        var i, j, ilen, v;\n        for(i = 0, ilen = a1.length; i < ilen; ++i){\n            v = a1[i];\n            j = prev.indexOf(v);\n            if (j === -1) {\n                updates.push([\n                    v,\n                    1\n                ]);\n            } else {\n                prev.splice(j, 1);\n            }\n        }\n        for(i = 0, ilen = prev.length; i < ilen; ++i){\n            updates.push([\n                prev[i],\n                -1\n            ]);\n        }\n        return updates;\n    },\n    /**\n   * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70\n   */ rasterize: function(v) {\n        return Math.round(v * devicePixelRatio) / devicePixelRatio;\n    }\n};\nfunction orient(point, origin) {\n    var x0 = origin.x;\n    var y0 = origin.y;\n    if (x0 === null) {\n        return {\n            x: 0,\n            y: -1\n        };\n    }\n    if (y0 === null) {\n        return {\n            x: 1,\n            y: 0\n        };\n    }\n    var dx = point.x - x0;\n    var dy = point.y - y0;\n    var ln = Math.sqrt(dx * dx + dy * dy);\n    return {\n        x: ln ? dx / ln : 0,\n        y: ln ? dy / ln : -1\n    };\n}\nfunction aligned(x, y, vx, vy, align) {\n    switch(align){\n        case \"center\":\n            vx = vy = 0;\n            break;\n        case \"bottom\":\n            vx = 0;\n            vy = 1;\n            break;\n        case \"right\":\n            vx = 1;\n            vy = 0;\n            break;\n        case \"left\":\n            vx = -1;\n            vy = 0;\n            break;\n        case \"top\":\n            vx = 0;\n            vy = -1;\n            break;\n        case \"start\":\n            vx = -vx;\n            vy = -vy;\n            break;\n        case \"end\":\n            break;\n        default:\n            // clockwise rotation (in degree)\n            align *= Math.PI / 180;\n            vx = Math.cos(align);\n            vy = Math.sin(align);\n            break;\n    }\n    return {\n        x: x,\n        y: y,\n        vx: vx,\n        vy: vy\n    };\n}\n// Line clipping (Cohen–Sutherland algorithm)\n// https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm\nvar R_INSIDE = 0;\nvar R_LEFT = 1;\nvar R_RIGHT = 2;\nvar R_BOTTOM = 4;\nvar R_TOP = 8;\nfunction region(x, y, rect) {\n    var res = R_INSIDE;\n    if (x < rect.left) {\n        res |= R_LEFT;\n    } else if (x > rect.right) {\n        res |= R_RIGHT;\n    }\n    if (y < rect.top) {\n        res |= R_TOP;\n    } else if (y > rect.bottom) {\n        res |= R_BOTTOM;\n    }\n    return res;\n}\nfunction clipped(segment, area) {\n    var x0 = segment.x0;\n    var y0 = segment.y0;\n    var x1 = segment.x1;\n    var y1 = segment.y1;\n    var r0 = region(x0, y0, area);\n    var r1 = region(x1, y1, area);\n    var r, x, y;\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        if (!(r0 | r1) || r0 & r1) {\n            break;\n        }\n        // at least one point is outside\n        r = r0 || r1;\n        if (r & R_TOP) {\n            x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);\n            y = area.top;\n        } else if (r & R_BOTTOM) {\n            x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);\n            y = area.bottom;\n        } else if (r & R_RIGHT) {\n            y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);\n            x = area.right;\n        } else if (r & R_LEFT) {\n            y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);\n            x = area.left;\n        }\n        if (r === r0) {\n            x0 = x;\n            y0 = y;\n            r0 = region(x0, y0, area);\n        } else {\n            x1 = x;\n            y1 = y;\n            r1 = region(x1, y1, area);\n        }\n    }\n    return {\n        x0: x0,\n        x1: x1,\n        y0: y0,\n        y1: y1\n    };\n}\nfunction compute$1(range, config) {\n    var anchor = config.anchor;\n    var segment = range;\n    var x, y;\n    if (config.clamp) {\n        segment = clipped(segment, config.area);\n    }\n    if (anchor === \"start\") {\n        x = segment.x0;\n        y = segment.y0;\n    } else if (anchor === \"end\") {\n        x = segment.x1;\n        y = segment.y1;\n    } else {\n        x = (segment.x0 + segment.x1) / 2;\n        y = (segment.y0 + segment.y1) / 2;\n    }\n    return aligned(x, y, range.vx, range.vy, config.align);\n}\nvar positioners = {\n    arc: function(el, config) {\n        var angle = (el.startAngle + el.endAngle) / 2;\n        var vx = Math.cos(angle);\n        var vy = Math.sin(angle);\n        var r0 = el.innerRadius;\n        var r1 = el.outerRadius;\n        return compute$1({\n            x0: el.x + vx * r0,\n            y0: el.y + vy * r0,\n            x1: el.x + vx * r1,\n            y1: el.y + vy * r1,\n            vx: vx,\n            vy: vy\n        }, config);\n    },\n    point: function(el, config) {\n        var v = orient(el, config.origin);\n        var rx = v.x * el.options.radius;\n        var ry = v.y * el.options.radius;\n        return compute$1({\n            x0: el.x - rx,\n            y0: el.y - ry,\n            x1: el.x + rx,\n            y1: el.y + ry,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    bar: function(el, config) {\n        var v = orient(el, config.origin);\n        var x = el.x;\n        var y = el.y;\n        var sx = 0;\n        var sy = 0;\n        if (el.horizontal) {\n            x = Math.min(el.x, el.base);\n            sx = Math.abs(el.base - el.x);\n        } else {\n            y = Math.min(el.y, el.base);\n            sy = Math.abs(el.base - el.y);\n        }\n        return compute$1({\n            x0: x,\n            y0: y + sy,\n            x1: x + sx,\n            y1: y,\n            vx: v.x,\n            vy: v.y\n        }, config);\n    },\n    fallback: function(el, config) {\n        var v = orient(el, config.origin);\n        return compute$1({\n            x0: el.x,\n            y0: el.y,\n            x1: el.x + (el.width || 0),\n            y1: el.y + (el.height || 0),\n            vx: v.x,\n            vy: v.y\n        }, config);\n    }\n};\nvar rasterize = utils.rasterize;\nfunction boundingRects(model) {\n    var borderWidth = model.borderWidth || 0;\n    var padding = model.padding;\n    var th = model.size.height;\n    var tw = model.size.width;\n    var tx = -tw / 2;\n    var ty = -th / 2;\n    return {\n        frame: {\n            x: tx - padding.left - borderWidth,\n            y: ty - padding.top - borderWidth,\n            w: tw + padding.width + borderWidth * 2,\n            h: th + padding.height + borderWidth * 2\n        },\n        text: {\n            x: tx,\n            y: ty,\n            w: tw,\n            h: th\n        }\n    };\n}\nfunction getScaleOrigin(el, context) {\n    var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;\n    if (!scale) {\n        return null;\n    }\n    if (scale.xCenter !== undefined && scale.yCenter !== undefined) {\n        return {\n            x: scale.xCenter,\n            y: scale.yCenter\n        };\n    }\n    var pixel = scale.getBasePixel();\n    return el.horizontal ? {\n        x: pixel,\n        y: null\n    } : {\n        x: null,\n        y: pixel\n    };\n}\nfunction getPositioner(el) {\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.ArcElement) {\n        return positioners.arc;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.PointElement) {\n        return positioners.point;\n    }\n    if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.BarElement) {\n        return positioners.bar;\n    }\n    return positioners.fallback;\n}\nfunction drawRoundedRect(ctx, x, y, w, h, radius) {\n    var HALF_PI = Math.PI / 2;\n    if (radius) {\n        var r = Math.min(radius, h / 2, w / 2);\n        var left = x + r;\n        var top = y + r;\n        var right = x + w - r;\n        var bottom = y + h - r;\n        ctx.moveTo(x, top);\n        if (left < right && top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, -HALF_PI);\n            ctx.arc(right, top, r, -HALF_PI, 0);\n            ctx.arc(right, bottom, r, 0, HALF_PI);\n            ctx.arc(left, bottom, r, HALF_PI, Math.PI);\n        } else if (left < right) {\n            ctx.moveTo(left, y);\n            ctx.arc(right, top, r, -HALF_PI, HALF_PI);\n            ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);\n        } else if (top < bottom) {\n            ctx.arc(left, top, r, -Math.PI, 0);\n            ctx.arc(left, bottom, r, 0, Math.PI);\n        } else {\n            ctx.arc(left, top, r, -Math.PI, Math.PI);\n        }\n        ctx.closePath();\n        ctx.moveTo(x, y);\n    } else {\n        ctx.rect(x, y, w, h);\n    }\n}\nfunction drawFrame(ctx, rect, model) {\n    var bgColor = model.backgroundColor;\n    var borderColor = model.borderColor;\n    var borderWidth = model.borderWidth;\n    if (!bgColor && (!borderColor || !borderWidth)) {\n        return;\n    }\n    ctx.beginPath();\n    drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);\n    ctx.closePath();\n    if (bgColor) {\n        ctx.fillStyle = bgColor;\n        ctx.fill();\n    }\n    if (borderColor && borderWidth) {\n        ctx.strokeStyle = borderColor;\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = \"miter\";\n        ctx.stroke();\n    }\n}\nfunction textGeometry(rect, align, font) {\n    var h = font.lineHeight;\n    var w = rect.w;\n    var x = rect.x;\n    var y = rect.y + h / 2;\n    if (align === \"center\") {\n        x += w / 2;\n    } else if (align === \"end\" || align === \"right\") {\n        x += w;\n    }\n    return {\n        h: h,\n        w: w,\n        x: x,\n        y: y\n    };\n}\nfunction drawTextLine(ctx, text, cfg) {\n    var shadow = ctx.shadowBlur;\n    var stroked = cfg.stroked;\n    var x = rasterize(cfg.x);\n    var y = rasterize(cfg.y);\n    var w = rasterize(cfg.w);\n    if (stroked) {\n        ctx.strokeText(text, x, y, w);\n    }\n    if (cfg.filled) {\n        if (shadow && stroked) {\n            // Prevent drawing shadow on both the text stroke and fill, so\n            // if the text is stroked, remove the shadow for the text fill.\n            ctx.shadowBlur = 0;\n        }\n        ctx.fillText(text, x, y, w);\n        if (shadow && stroked) {\n            ctx.shadowBlur = shadow;\n        }\n    }\n}\nfunction drawText(ctx, lines, rect, model) {\n    var align = model.textAlign;\n    var color = model.color;\n    var filled = !!color;\n    var font = model.font;\n    var ilen = lines.length;\n    var strokeColor = model.textStrokeColor;\n    var strokeWidth = model.textStrokeWidth;\n    var stroked = strokeColor && strokeWidth;\n    var i;\n    if (!ilen || !filled && !stroked) {\n        return;\n    }\n    // Adjust coordinates based on text alignment and line height\n    rect = textGeometry(rect, align, font);\n    ctx.font = font.string;\n    ctx.textAlign = align;\n    ctx.textBaseline = \"middle\";\n    ctx.shadowBlur = model.textShadowBlur;\n    ctx.shadowColor = model.textShadowColor;\n    if (filled) {\n        ctx.fillStyle = color;\n    }\n    if (stroked) {\n        ctx.lineJoin = \"round\";\n        ctx.lineWidth = strokeWidth;\n        ctx.strokeStyle = strokeColor;\n    }\n    for(i = 0, ilen = lines.length; i < ilen; ++i){\n        drawTextLine(ctx, lines[i], {\n            stroked: stroked,\n            filled: filled,\n            w: rect.w,\n            x: rect.x,\n            y: rect.y + rect.h * i\n        });\n    }\n}\nvar Label = function(config, ctx, el, index) {\n    var me = this;\n    me._config = config;\n    me._index = index;\n    me._model = null;\n    me._rects = null;\n    me._ctx = ctx;\n    me._el = el;\n};\n_c = Label;\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(Label.prototype, {\n    /**\n   * @private\n   */ _modelize: function(display, lines, config, context) {\n        var me = this;\n        var index = me._index;\n        var font = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.font,\n            {}\n        ], context, index));\n        var color = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.color,\n            chart_js__WEBPACK_IMPORTED_MODULE_1__.defaults.color\n        ], context, index);\n        return {\n            align: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.align,\n                \"center\"\n            ], context, index),\n            anchor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.anchor,\n                \"center\"\n            ], context, index),\n            area: context.chart.chartArea,\n            backgroundColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.backgroundColor,\n                null\n            ], context, index),\n            borderColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderColor,\n                null\n            ], context, index),\n            borderRadius: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderRadius,\n                0\n            ], context, index),\n            borderWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.borderWidth,\n                0\n            ], context, index),\n            clamp: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clamp,\n                false\n            ], context, index),\n            clip: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.clip,\n                false\n            ], context, index),\n            color: color,\n            display: display,\n            font: font,\n            lines: lines,\n            offset: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.offset,\n                4\n            ], context, index),\n            opacity: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.opacity,\n                1\n            ], context, index),\n            origin: getScaleOrigin(me._el, context),\n            padding: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.padding,\n                4\n            ], context, index)),\n            positioner: getPositioner(me._el),\n            rotation: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.rotation,\n                0\n            ], context, index) * (Math.PI / 180),\n            size: utils.textSize(me._ctx, lines, font),\n            textAlign: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textAlign,\n                \"start\"\n            ], context, index),\n            textShadowBlur: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowBlur,\n                0\n            ], context, index),\n            textShadowColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textShadowColor,\n                color\n            ], context, index),\n            textStrokeColor: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeColor,\n                color\n            ], context, index),\n            textStrokeWidth: (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n                config.textStrokeWidth,\n                0\n            ], context, index)\n        };\n    },\n    update: function(context) {\n        var me = this;\n        var model = null;\n        var rects = null;\n        var index = me._index;\n        var config = me._config;\n        var value, label, lines;\n        // We first resolve the display option (separately) to avoid computing\n        // other options in case the label is hidden (i.e. display: false).\n        var display = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)([\n            config.display,\n            true\n        ], context, index);\n        if (display) {\n            value = context.dataset.data[index];\n            label = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(config.formatter, [\n                value,\n                context\n            ]), value);\n            lines = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(label) ? [] : utils.toTextLines(label);\n            if (lines.length) {\n                model = me._modelize(display, lines, config, context);\n                rects = boundingRects(model);\n            }\n        }\n        me._model = model;\n        me._rects = rects;\n    },\n    geometry: function() {\n        return this._rects ? this._rects.frame : {};\n    },\n    rotation: function() {\n        return this._model ? this._model.rotation : 0;\n    },\n    visible: function() {\n        return this._model && this._model.opacity;\n    },\n    model: function() {\n        return this._model;\n    },\n    draw: function(chart, center) {\n        var me = this;\n        var ctx = chart.ctx;\n        var model = me._model;\n        var rects = me._rects;\n        var area;\n        if (!this.visible()) {\n            return;\n        }\n        ctx.save();\n        if (model.clip) {\n            area = model.area;\n            ctx.beginPath();\n            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n            ctx.clip();\n        }\n        ctx.globalAlpha = utils.bound(0, model.opacity, 1);\n        ctx.translate(rasterize(center.x), rasterize(center.y));\n        ctx.rotate(model.rotation);\n        drawFrame(ctx, rects.frame, model);\n        drawText(ctx, model.lines, rects.text, model);\n        ctx.restore();\n    }\n});\nvar MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger\nvar MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991; // eslint-disable-line es/no-number-maxsafeinteger\nfunction rotated(point, center, angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var cx = center.x;\n    var cy = center.y;\n    return {\n        x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n        y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n    };\n}\nfunction projected(points, axis) {\n    var min = MAX_INTEGER;\n    var max = MIN_INTEGER;\n    var origin = axis.origin;\n    var i, pt, vx, vy, dp;\n    for(i = 0; i < points.length; ++i){\n        pt = points[i];\n        vx = pt.x - origin.x;\n        vy = pt.y - origin.y;\n        dp = axis.vx * vx + axis.vy * vy;\n        min = Math.min(min, dp);\n        max = Math.max(max, dp);\n    }\n    return {\n        min: min,\n        max: max\n    };\n}\nfunction toAxis(p0, p1) {\n    var vx = p1.x - p0.x;\n    var vy = p1.y - p0.y;\n    var ln = Math.sqrt(vx * vx + vy * vy);\n    return {\n        vx: (p1.x - p0.x) / ln,\n        vy: (p1.y - p0.y) / ln,\n        origin: p0,\n        ln: ln\n    };\n}\nvar HitBox = function() {\n    this._rotation = 0;\n    this._rect = {\n        x: 0,\n        y: 0,\n        w: 0,\n        h: 0\n    };\n};\n_c1 = HitBox;\n(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(HitBox.prototype, {\n    center: function() {\n        var r = this._rect;\n        return {\n            x: r.x + r.w / 2,\n            y: r.y + r.h / 2\n        };\n    },\n    update: function(center, rect, rotation) {\n        this._rotation = rotation;\n        this._rect = {\n            x: rect.x + center.x,\n            y: rect.y + center.y,\n            w: rect.w,\n            h: rect.h\n        };\n    },\n    contains: function(point) {\n        var me = this;\n        var margin = 1;\n        var rect = me._rect;\n        point = rotated(point, me.center(), -me._rotation);\n        return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);\n    },\n    // Separating Axis Theorem\n    // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169\n    intersects: function(other) {\n        var r0 = this._points();\n        var r1 = other._points();\n        var axes = [\n            toAxis(r0[0], r0[1]),\n            toAxis(r0[0], r0[3])\n        ];\n        var i, pr0, pr1;\n        if (this._rotation !== other._rotation) {\n            // Only separate with r1 axis if the rotation is different,\n            // else it's enough to separate r0 and r1 with r0 axis only!\n            axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));\n        }\n        for(i = 0; i < axes.length; ++i){\n            pr0 = projected(r0, axes[i]);\n            pr1 = projected(r1, axes[i]);\n            if (pr0.max < pr1.min || pr1.max < pr0.min) {\n                return false;\n            }\n        }\n        return true;\n    },\n    /**\n   * @private\n   */ _points: function() {\n        var me = this;\n        var rect = me._rect;\n        var angle = me._rotation;\n        var center = me.center();\n        return [\n            rotated({\n                x: rect.x,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y\n            }, center, angle),\n            rotated({\n                x: rect.x + rect.w,\n                y: rect.y + rect.h\n            }, center, angle),\n            rotated({\n                x: rect.x,\n                y: rect.y + rect.h\n            }, center, angle)\n        ];\n    }\n});\nfunction coordinates(el, model, geometry) {\n    var point = model.positioner(el, model);\n    var vx = point.vx;\n    var vy = point.vy;\n    if (!vx && !vy) {\n        // if aligned center, we don't want to offset the center point\n        return {\n            x: point.x,\n            y: point.y\n        };\n    }\n    var w = geometry.w;\n    var h = geometry.h;\n    // take in account the label rotation\n    var rotation = model.rotation;\n    var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));\n    var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));\n    // scale the unit vector (vx, vy) to get at least dx or dy equal to\n    // w or h respectively (else we would calculate the distance to the\n    // ellipse inscribed in the bounding rect)\n    var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));\n    dx *= vx * vs;\n    dy *= vy * vs;\n    // finally, include the explicit offset\n    dx += model.offset * vx;\n    dy += model.offset * vy;\n    return {\n        x: point.x + dx,\n        y: point.y + dy\n    };\n}\nfunction collide(labels, collider) {\n    var i, j, s0, s1;\n    // IMPORTANT Iterate in the reverse order since items at the end of the\n    // list have an higher weight/priority and thus should be less impacted\n    // by the overlapping strategy.\n    for(i = labels.length - 1; i >= 0; --i){\n        s0 = labels[i].$layout;\n        for(j = i - 1; j >= 0 && s0._visible; --j){\n            s1 = labels[j].$layout;\n            if (s1._visible && s0._box.intersects(s1._box)) {\n                collider(s0, s1);\n            }\n        }\n    }\n    return labels;\n}\nfunction compute(labels) {\n    var i, ilen, label, state, geometry, center, proxy;\n    // Initialize labels for overlap detection\n    for(i = 0, ilen = labels.length; i < ilen; ++i){\n        label = labels[i];\n        state = label.$layout;\n        if (state._visible) {\n            // Chart.js 3 removed el._model in favor of getProps(), making harder to\n            // abstract reading values in positioners. Also, using string arrays to\n            // read values (i.e. var {a,b,c} = el.getProps([\"a\",\"b\",\"c\"])) would make\n            // positioners inefficient in the normal case (i.e. not the final values)\n            // and the code a bit ugly, so let's use a Proxy instead.\n            proxy = new Proxy(label._el, {\n                get: (el, p)=>el.getProps([\n                        p\n                    ], true)[p]\n            });\n            geometry = label.geometry();\n            center = coordinates(proxy, label.model(), geometry);\n            state._box.update(center, geometry, label.rotation());\n        }\n    }\n    // Auto hide overlapping labels\n    return collide(labels, function(s0, s1) {\n        var h0 = s0._hidable;\n        var h1 = s1._hidable;\n        if (h0 && h1 || h1) {\n            s1._visible = false;\n        } else if (h0) {\n            s0._visible = false;\n        }\n    });\n}\nvar layout = {\n    prepare: function(datasets) {\n        var labels = [];\n        var i, j, ilen, jlen, label;\n        for(i = 0, ilen = datasets.length; i < ilen; ++i){\n            for(j = 0, jlen = datasets[i].length; j < jlen; ++j){\n                label = datasets[i][j];\n                labels.push(label);\n                label.$layout = {\n                    _box: new HitBox(),\n                    _hidable: false,\n                    _visible: true,\n                    _set: i,\n                    _idx: label._index\n                };\n            }\n        }\n        // TODO New `z` option: labels with a higher z-index are drawn\n        // of top of the ones with a lower index. Lowest z-index labels\n        // are also discarded first when hiding overlapping labels.\n        labels.sort(function(a, b) {\n            var sa = a.$layout;\n            var sb = b.$layout;\n            return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;\n        });\n        this.update(labels);\n        return labels;\n    },\n    update: function(labels) {\n        var dirty = false;\n        var i, ilen, label, model, state;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            model = label.model();\n            state = label.$layout;\n            state._hidable = model && model.display === \"auto\";\n            state._visible = label.visible();\n            dirty |= state._hidable;\n        }\n        if (dirty) {\n            compute(labels);\n        }\n    },\n    lookup: function(labels, point) {\n        var i, state;\n        // IMPORTANT Iterate in the reverse order since items at the end of\n        // the list have an higher z-index, thus should be picked first.\n        for(i = labels.length - 1; i >= 0; --i){\n            state = labels[i].$layout;\n            if (state && state._visible && state._box.contains(point)) {\n                return labels[i];\n            }\n        }\n        return null;\n    },\n    draw: function(chart, labels) {\n        var i, ilen, label, state, geometry, center;\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            label = labels[i];\n            state = label.$layout;\n            if (state._visible) {\n                geometry = label.geometry();\n                center = coordinates(label._el, label.model(), geometry);\n                state._box.update(center, geometry, label.rotation());\n                label.draw(chart, center);\n            }\n        }\n    }\n};\nvar formatter = function(value) {\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value)) {\n        return null;\n    }\n    var label = value;\n    var keys, klen, k;\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)) {\n        if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.label)) {\n            label = value.label;\n        } else if (!(0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(value.r)) {\n            label = value.r;\n        } else {\n            label = \"\";\n            keys = Object.keys(value);\n            for(k = 0, klen = keys.length; k < klen; ++k){\n                label += (k !== 0 ? \", \" : \"\") + keys[k] + \": \" + value[keys[k]];\n            }\n        }\n    }\n    return \"\" + label;\n};\n/**\n * IMPORTANT: make sure to also update tests and TypeScript definition\n * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)\n */ var defaults = {\n    align: \"center\",\n    anchor: \"center\",\n    backgroundColor: null,\n    borderColor: null,\n    borderRadius: 0,\n    borderWidth: 0,\n    clamp: false,\n    clip: false,\n    color: undefined,\n    display: true,\n    font: {\n        family: undefined,\n        lineHeight: 1.2,\n        size: undefined,\n        style: undefined,\n        weight: null\n    },\n    formatter: formatter,\n    labels: undefined,\n    listeners: {},\n    offset: 4,\n    opacity: 1,\n    padding: {\n        top: 4,\n        right: 4,\n        bottom: 4,\n        left: 4\n    },\n    rotation: 0,\n    textAlign: \"start\",\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    textShadowBlur: 0,\n    textShadowColor: undefined\n};\n/**\n * @see https://github.com/chartjs/Chart.js/issues/4176\n */ var EXPANDO_KEY = \"$datalabels\";\nvar DEFAULT_KEY = \"$default\";\nfunction configure(dataset, options) {\n    var override = dataset.datalabels;\n    var listeners = {};\n    var configs = [];\n    var labels, keys;\n    if (override === false) {\n        return null;\n    }\n    if (override === true) {\n        override = {};\n    }\n    options = (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n        options,\n        override\n    ]);\n    labels = options.labels || {};\n    keys = Object.keys(labels);\n    delete options.labels;\n    if (keys.length) {\n        keys.forEach(function(key) {\n            if (labels[key]) {\n                configs.push((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [\n                    options,\n                    labels[key],\n                    {\n                        _key: key\n                    }\n                ]));\n            }\n        });\n    } else {\n        // Default label if no \"named\" label defined.\n        configs.push(options);\n    }\n    // listeners: {<event-type>: {<label-key>: <fn>}}\n    listeners = configs.reduce(function(target, config) {\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.each)(config.listeners || {}, function(fn, event) {\n            target[event] = target[event] || {};\n            target[event][config._key || DEFAULT_KEY] = fn;\n        });\n        delete config.listeners;\n        return target;\n    }, {});\n    return {\n        labels: configs,\n        listeners: listeners\n    };\n}\nfunction dispatchEvent(chart, listeners, label, event) {\n    if (!listeners) {\n        return;\n    }\n    var context = label.$context;\n    var groups = label.$groups;\n    var callback$1;\n    if (!listeners[groups._set]) {\n        return;\n    }\n    callback$1 = listeners[groups._set][groups._key];\n    if (!callback$1) {\n        return;\n    }\n    if ((0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(callback$1, [\n        context,\n        event\n    ]) === true) {\n        // Users are allowed to tweak the given context by injecting values that can be\n        // used in scriptable options to display labels differently based on the current\n        // event (e.g. highlight an hovered label). That's why we update the label with\n        // the output context and schedule a new chart render by setting it dirty.\n        chart[EXPANDO_KEY]._dirty = true;\n        label.update(context);\n    }\n}\nfunction dispatchMoveEvents(chart, listeners, previous, label, event) {\n    var enter, leave;\n    if (!previous && !label) {\n        return;\n    }\n    if (!previous) {\n        enter = true;\n    } else if (!label) {\n        leave = true;\n    } else if (previous !== label) {\n        leave = enter = true;\n    }\n    if (leave) {\n        dispatchEvent(chart, listeners.leave, previous, event);\n    }\n    if (enter) {\n        dispatchEvent(chart, listeners.enter, label, event);\n    }\n}\nfunction handleMoveEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var listeners = expando._listeners;\n    var previous, label;\n    if (!listeners.enter && !listeners.leave) {\n        return;\n    }\n    if (event.type === \"mousemove\") {\n        label = layout.lookup(expando._labels, event);\n    } else if (event.type !== \"mouseout\") {\n        return;\n    }\n    previous = expando._hovered;\n    expando._hovered = label;\n    dispatchMoveEvents(chart, listeners, previous, label, event);\n}\nfunction handleClickEvents(chart, event) {\n    var expando = chart[EXPANDO_KEY];\n    var handlers = expando._listeners.click;\n    var label = handlers && layout.lookup(expando._labels, event);\n    if (label) {\n        dispatchEvent(chart, handlers, label, event);\n    }\n}\nvar plugin = {\n    id: \"datalabels\",\n    defaults: defaults,\n    beforeInit: function(chart) {\n        chart[EXPANDO_KEY] = {\n            _actives: []\n        };\n    },\n    beforeUpdate: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        expando._listened = false;\n        expando._listeners = {}; // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}\n        expando._datasets = []; // per dataset labels: [Label[]]\n        expando._labels = []; // layouted labels: Label[]\n    },\n    afterDatasetUpdate: function(chart, args, options) {\n        var datasetIndex = args.index;\n        var expando = chart[EXPANDO_KEY];\n        var labels = expando._datasets[datasetIndex] = [];\n        var visible = chart.isDatasetVisible(datasetIndex);\n        var dataset = chart.data.datasets[datasetIndex];\n        var config = configure(dataset, options);\n        var elements = args.meta.data || [];\n        var ctx = chart.ctx;\n        var i, j, ilen, jlen, cfg, key, el, label;\n        ctx.save();\n        for(i = 0, ilen = elements.length; i < ilen; ++i){\n            el = elements[i];\n            el[EXPANDO_KEY] = [];\n            if (visible && el && chart.getDataVisibility(i) && !el.skip) {\n                for(j = 0, jlen = config.labels.length; j < jlen; ++j){\n                    cfg = config.labels[j];\n                    key = cfg._key;\n                    label = new Label(cfg, ctx, el, i);\n                    label.$groups = {\n                        _set: datasetIndex,\n                        _key: key || DEFAULT_KEY\n                    };\n                    label.$context = {\n                        active: false,\n                        chart: chart,\n                        dataIndex: i,\n                        dataset: dataset,\n                        datasetIndex: datasetIndex\n                    };\n                    label.update(label.$context);\n                    el[EXPANDO_KEY].push(label);\n                    labels.push(label);\n                }\n            }\n        }\n        ctx.restore();\n        // Store listeners at the chart level and per event type to optimize\n        // cases where no listeners are registered for a specific event.\n        (0,chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(expando._listeners, config.listeners, {\n            merger: function(event, target, source) {\n                target[event] = target[event] || {};\n                target[event][args.index] = source[event];\n                expando._listened = true;\n            }\n        });\n    },\n    afterUpdate: function(chart) {\n        chart[EXPANDO_KEY]._labels = layout.prepare(chart[EXPANDO_KEY]._datasets);\n    },\n    // Draw labels on top of all dataset elements\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29\n    // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32\n    afterDatasetsDraw: function(chart) {\n        layout.draw(chart, chart[EXPANDO_KEY]._labels);\n    },\n    beforeEvent: function(chart, args) {\n        // If there is no listener registered for this chart, `listened` will be false,\n        // meaning we can immediately ignore the incoming event and avoid useless extra\n        // computation for users who don't implement label interactions.\n        if (chart[EXPANDO_KEY]._listened) {\n            var event = args.event;\n            switch(event.type){\n                case \"mousemove\":\n                case \"mouseout\":\n                    handleMoveEvents(chart, event);\n                    break;\n                case \"click\":\n                    handleClickEvents(chart, event);\n                    break;\n            }\n        }\n    },\n    afterEvent: function(chart) {\n        var expando = chart[EXPANDO_KEY];\n        var previous = expando._actives;\n        var actives = expando._actives = chart.getActiveElements();\n        var updates = utils.arrayDiff(previous, actives);\n        var i, ilen, j, jlen, update, label, labels;\n        for(i = 0, ilen = updates.length; i < ilen; ++i){\n            update = updates[i];\n            if (update[1]) {\n                labels = update[0].element[EXPANDO_KEY] || [];\n                for(j = 0, jlen = labels.length; j < jlen; ++j){\n                    label = labels[j];\n                    label.$context.active = update[1] === 1;\n                    label.update(label.$context);\n                }\n            }\n        }\n        if (expando._dirty || updates.length) {\n            layout.update(expando._labels);\n            chart.render();\n        }\n        delete expando._dirty;\n    }\n};\n\nvar _c, _c1;\n$RefreshReg$(_c, \"Label\");\n$RefreshReg$(_c1, \"HitBox\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDNkg7QUFDdEM7QUFFeEYsSUFBSWMsbUJBQW9CO0lBQ3RCLElBQUksSUFBa0IsRUFBYTtRQUNqQyxJQUFJQyxPQUFPRCxnQkFBZ0IsRUFBRTtZQUMzQixPQUFPQyxPQUFPRCxnQkFBZ0I7UUFDaEM7UUFFQSx3Q0FBd0M7UUFDeEMsK0NBQStDO1FBQy9DLGlFQUFpRTtRQUNqRSxJQUFJRSxTQUFTRCxPQUFPQyxNQUFNO1FBQzFCLElBQUlBLFFBQVE7WUFDVixPQUFPLENBQUNBLE9BQU9DLFVBQVUsSUFBSSxLQUFNRCxDQUFBQSxPQUFPRSxXQUFXLElBQUk7UUFDM0Q7SUFDRjtJQUVBLE9BQU87QUFDVDtBQUVBLElBQUlDLFFBQVE7SUFDViwrQ0FBK0M7SUFDL0NDLGFBQWEsU0FBU0MsTUFBTTtRQUMxQixJQUFJQyxRQUFRLEVBQUU7UUFDZCxJQUFJQztRQUVKRixTQUFTLEVBQUUsQ0FBQ0csTUFBTSxDQUFDSDtRQUNuQixNQUFPQSxPQUFPSSxNQUFNLENBQUU7WUFDcEJGLFFBQVFGLE9BQU9LLEdBQUc7WUFDbEIsSUFBSSxPQUFPSCxVQUFVLFVBQVU7Z0JBQzdCRCxNQUFNSyxPQUFPLENBQUNDLEtBQUssQ0FBQ04sT0FBT0MsTUFBTU0sS0FBSyxDQUFDO1lBQ3pDLE9BQU8sSUFBSUMsTUFBTUMsT0FBTyxDQUFDUixRQUFRO2dCQUMvQkYsT0FBT1csSUFBSSxDQUFDSixLQUFLLENBQUNQLFFBQVFFO1lBQzVCLE9BQU8sSUFBSSxDQUFDdkIsK0RBQWFBLENBQUNxQixTQUFTO2dCQUNqQ0MsTUFBTUssT0FBTyxDQUFDLEtBQUtKO1lBQ3JCO1FBQ0Y7UUFFQSxPQUFPRDtJQUNUO0lBRUEsbURBQW1EO0lBQ25ELDREQUE0RDtJQUM1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LE1BQU0sRUFBRUcsRUFBRztZQUNoRG1LLFNBQVNySixPQUFPLENBQUNkLEVBQUU7WUFDbkIsSUFBSW1LLE1BQU0sQ0FBQyxFQUFFLEVBQUU7Z0JBQ2I2QyxTQUFTN0MsTUFBTSxDQUFDLEVBQUUsQ0FBQzJJLE9BQU8sQ0FBQ3hELFlBQVksSUFBSSxFQUFFO2dCQUM3QyxJQUFLdk8sSUFBSSxHQUFHcU4sT0FBT3BCLE9BQU8vTixNQUFNLEVBQUU4QixJQUFJcU4sTUFBTSxFQUFFck4sRUFBRztvQkFDL0NzSixRQUFRMkMsTUFBTSxDQUFDak0sRUFBRTtvQkFDakJzSixNQUFNK0YsUUFBUSxDQUFDZ0MsTUFBTSxHQUFJakksTUFBTSxDQUFDLEVBQUUsS0FBSztvQkFDdkNFLE1BQU1GLE1BQU0sQ0FBQ0UsTUFBTStGLFFBQVE7Z0JBQzdCO1lBQ0Y7UUFDRjtRQUVBLElBQUlVLFFBQVFOLE1BQU0sSUFBSTFQLFFBQVE3QixNQUFNLEVBQUU7WUFDcENnUCxPQUFPOUQsTUFBTSxDQUFDMkcsUUFBUUcsT0FBTztZQUM3QjlLLE1BQU00TSxNQUFNO1FBQ2Q7UUFFQSxPQUFPakMsUUFBUU4sTUFBTTtJQUN2QjtBQUNGO0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2Rpc3QvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5lc20uanM/MGQwZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGNoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMgdjIuMi4wXG4gKiBodHRwczovL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMubmV0bGlmeS5hcHBcbiAqIChjKSAyMDE3LTIwMjIgY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pbXBvcnQgeyBpc051bGxPclVuZGVmLCBtZXJnZSwgdG9Gb250LCByZXNvbHZlLCB0b1BhZGRpbmcsIHZhbHVlT3JEZWZhdWx0LCBjYWxsYmFjaywgaXNPYmplY3QsIGVhY2ggfSBmcm9tICdjaGFydC5qcy9oZWxwZXJzJztcbmltcG9ydCB7IGRlZmF1bHRzIGFzIGRlZmF1bHRzJDEsIEFyY0VsZW1lbnQsIFBvaW50RWxlbWVudCwgQmFyRWxlbWVudCB9IGZyb20gJ2NoYXJ0LmpzJztcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykge1xuICAgICAgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cblxuICAgIC8vIGRldmljZVBpeGVsUmF0aW8gaXMgdW5kZWZpbmVkIG9uIElFMTBcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjAyMDQxODAvODgzNzg4N1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzg1XG4gICAgdmFyIHNjcmVlbiA9IHdpbmRvdy5zY3JlZW47XG4gICAgaWYgKHNjcmVlbikge1xuICAgICAgcmV0dXJuIChzY3JlZW4uZGV2aWNlWERQSSB8fCAxKSAvIChzY3JlZW4ubG9naWNhbFhEUEkgfHwgMSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDE7XG59KCkpO1xuXG52YXIgdXRpbHMgPSB7XG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLnRvVGV4dExpbmVzXG4gIHRvVGV4dExpbmVzOiBmdW5jdGlvbihpbnB1dHMpIHtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICB2YXIgaW5wdXQ7XG5cbiAgICBpbnB1dHMgPSBbXS5jb25jYXQoaW5wdXRzKTtcbiAgICB3aGlsZSAoaW5wdXRzLmxlbmd0aCkge1xuICAgICAgaW5wdXQgPSBpbnB1dHMucG9wKCk7XG4gICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xuICAgICAgICBsaW5lcy51bnNoaWZ0LmFwcGx5KGxpbmVzLCBpbnB1dC5zcGxpdCgnXFxuJykpO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dHMucHVzaC5hcHBseShpbnB1dHMsIGlucHV0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWYoaW5wdXRzKSkge1xuICAgICAgICBsaW5lcy51bnNoaWZ0KCcnICsgaW5wdXQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaW5lcztcbiAgfSxcblxuICAvLyBAdG9kbyBtb3ZlIHRoaXMgaW4gQ2hhcnQuaGVscGVycy5jYW52YXMudGV4dFNpemVcbiAgLy8gQHRvZG8gY2FjaGUgY2FsbHMgb2YgbWVhc3VyZVRleHQgaWYgZm9udCBkb2Vzbid0IGNoYW5nZT8hXG4gIHRleHRTaXplOiBmdW5jdGlvbihjdHgsIGxpbmVzLCBmb250KSB7XG4gICAgdmFyIGl0ZW1zID0gW10uY29uY2F0KGxpbmVzKTtcbiAgICB2YXIgaWxlbiA9IGl0ZW1zLmxlbmd0aDtcbiAgICB2YXIgcHJldiA9IGN0eC5mb250O1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgdmFyIGk7XG5cbiAgICBjdHguZm9udCA9IGZvbnQuc3RyaW5nO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgd2lkdGggPSBNYXRoLm1heChjdHgubWVhc3VyZVRleHQoaXRlbXNbaV0pLndpZHRoLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgY3R4LmZvbnQgPSBwcmV2O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGhlaWdodDogaWxlbiAqIGZvbnQubGluZUhlaWdodCxcbiAgICAgIHdpZHRoOiB3aWR0aFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdmFsdWUgYm91bmRlZCBieSBtaW4gYW5kIG1heC4gVGhpcyBpcyBlcXVpdmFsZW50IHRvIG1heChtaW4sIG1pbih2YWx1ZSwgbWF4KSkuXG4gICAqIEB0b2RvIG1vdmUgdGhpcyBtZXRob2QgaW4gQ2hhcnQuaGVscGVycy5ib3VuZFxuICAgKiBodHRwczovL2RvYy5xdC5pby9xdC01L3F0Z2xvYmFsLmh0bWwjcUJvdW5kXG4gICAqL1xuICBib3VuZDogZnVuY3Rpb24obWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHBhaXIgW3ZhbHVlLCBzdGF0ZV0gd2hlcmUgc3RhdGUgaXM6XG4gICAqICogLTE6IHZhbHVlIGlzIG9ubHkgaW4gYTAgKHJlbW92ZWQpXG4gICAqICogIDE6IHZhbHVlIGlzIG9ubHkgaW4gYTEgKGFkZGVkKVxuICAgKi9cbiAgYXJyYXlEaWZmOiBmdW5jdGlvbihhMCwgYTEpIHtcbiAgICB2YXIgcHJldiA9IGEwLnNsaWNlKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSBbXTtcbiAgICB2YXIgaSwgaiwgaWxlbiwgdjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBhMS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHYgPSBhMVtpXTtcbiAgICAgIGogPSBwcmV2LmluZGV4T2Yodik7XG5cbiAgICAgIGlmIChqID09PSAtMSkge1xuICAgICAgICB1cGRhdGVzLnB1c2goW3YsIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYuc3BsaWNlKGosIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwcmV2Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdXBkYXRlcy5wdXNoKFtwcmV2W2ldLCAtMV0pO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy83MFxuICAgKi9cbiAgcmFzdGVyaXplOiBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodiAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxufTtcblxuZnVuY3Rpb24gb3JpZW50KHBvaW50LCBvcmlnaW4pIHtcbiAgdmFyIHgwID0gb3JpZ2luLng7XG4gIHZhciB5MCA9IG9yaWdpbi55O1xuXG4gIGlmICh4MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMCwgeTogLTF9O1xuICB9XG4gIGlmICh5MCA9PT0gbnVsbCkge1xuICAgIHJldHVybiB7eDogMSwgeTogMH07XG4gIH1cblxuICB2YXIgZHggPSBwb2ludC54IC0geDA7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5MDtcbiAgdmFyIGxuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICByZXR1cm4ge1xuICAgIHg6IGxuID8gZHggLyBsbiA6IDAsXG4gICAgeTogbG4gPyBkeSAvIGxuIDogLTFcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWxpZ25lZCh4LCB5LCB2eCwgdnksIGFsaWduKSB7XG4gIHN3aXRjaCAoYWxpZ24pIHtcbiAgY2FzZSAnY2VudGVyJzpcbiAgICB2eCA9IHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnYm90dG9tJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAxO1xuICAgIGJyZWFrO1xuICBjYXNlICdyaWdodCc6XG4gICAgdnggPSAxO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAnbGVmdCc6XG4gICAgdnggPSAtMTtcbiAgICB2eSA9IDA7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RvcCc6XG4gICAgdnggPSAwO1xuICAgIHZ5ID0gLTE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXJ0JzpcbiAgICB2eCA9IC12eDtcbiAgICB2eSA9IC12eTtcbiAgICBicmVhaztcbiAgY2FzZSAnZW5kJzpcbiAgICAvLyBrZWVwIG5hdHVyYWwgb3JpZW50YXRpb25cbiAgICBicmVhaztcbiAgZGVmYXVsdDpcbiAgICAvLyBjbG9ja3dpc2Ugcm90YXRpb24gKGluIGRlZ3JlZSlcbiAgICBhbGlnbiAqPSAoTWF0aC5QSSAvIDE4MCk7XG4gICAgdnggPSBNYXRoLmNvcyhhbGlnbik7XG4gICAgdnkgPSBNYXRoLnNpbihhbGlnbik7XG4gICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeSxcbiAgICB2eDogdngsXG4gICAgdnk6IHZ5XG4gIH07XG59XG5cbi8vIExpbmUgY2xpcHBpbmcgKENvaGVu4oCTU3V0aGVybGFuZCBhbGdvcml0aG0pXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2hlbuKAk1N1dGhlcmxhbmRfYWxnb3JpdGhtXG5cbnZhciBSX0lOU0lERSA9IDA7XG52YXIgUl9MRUZUID0gMTtcbnZhciBSX1JJR0hUID0gMjtcbnZhciBSX0JPVFRPTSA9IDQ7XG52YXIgUl9UT1AgPSA4O1xuXG5mdW5jdGlvbiByZWdpb24oeCwgeSwgcmVjdCkge1xuICB2YXIgcmVzID0gUl9JTlNJREU7XG5cbiAgaWYgKHggPCByZWN0LmxlZnQpIHtcbiAgICByZXMgfD0gUl9MRUZUO1xuICB9IGVsc2UgaWYgKHggPiByZWN0LnJpZ2h0KSB7XG4gICAgcmVzIHw9IFJfUklHSFQ7XG4gIH1cbiAgaWYgKHkgPCByZWN0LnRvcCkge1xuICAgIHJlcyB8PSBSX1RPUDtcbiAgfSBlbHNlIGlmICh5ID4gcmVjdC5ib3R0b20pIHtcbiAgICByZXMgfD0gUl9CT1RUT007XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBjbGlwcGVkKHNlZ21lbnQsIGFyZWEpIHtcbiAgdmFyIHgwID0gc2VnbWVudC54MDtcbiAgdmFyIHkwID0gc2VnbWVudC55MDtcbiAgdmFyIHgxID0gc2VnbWVudC54MTtcbiAgdmFyIHkxID0gc2VnbWVudC55MTtcbiAgdmFyIHIwID0gcmVnaW9uKHgwLCB5MCwgYXJlYSk7XG4gIHZhciByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICB2YXIgciwgeCwgeTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCEocjAgfCByMSkgfHwgKHIwICYgcjEpKSB7XG4gICAgICAvLyBib3RoIHBvaW50cyBpbnNpZGUgb3Igb24gdGhlIHNhbWUgc2lkZTogbm8gY2xpcHBpbmdcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIGF0IGxlYXN0IG9uZSBwb2ludCBpcyBvdXRzaWRlXG4gICAgciA9IHIwIHx8IHIxO1xuXG4gICAgaWYgKHIgJiBSX1RPUCkge1xuICAgICAgeCA9IHgwICsgKHgxIC0geDApICogKGFyZWEudG9wIC0geTApIC8gKHkxIC0geTApO1xuICAgICAgeSA9IGFyZWEudG9wO1xuICAgIH0gZWxzZSBpZiAociAmIFJfQk9UVE9NKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS5ib3R0b20gLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChyICYgUl9SSUdIVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEucmlnaHQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX0xFRlQpIHtcbiAgICAgIHkgPSB5MCArICh5MSAtIHkwKSAqIChhcmVhLmxlZnQgLSB4MCkgLyAoeDEgLSB4MCk7XG4gICAgICB4ID0gYXJlYS5sZWZ0O1xuICAgIH1cblxuICAgIGlmIChyID09PSByMCkge1xuICAgICAgeDAgPSB4O1xuICAgICAgeTAgPSB5O1xuICAgICAgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDEgPSB4O1xuICAgICAgeTEgPSB5O1xuICAgICAgcjEgPSByZWdpb24oeDEsIHkxLCBhcmVhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHgwOiB4MCxcbiAgICB4MTogeDEsXG4gICAgeTA6IHkwLFxuICAgIHkxOiB5MVxuICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlJDEocmFuZ2UsIGNvbmZpZykge1xuICB2YXIgYW5jaG9yID0gY29uZmlnLmFuY2hvcjtcbiAgdmFyIHNlZ21lbnQgPSByYW5nZTtcbiAgdmFyIHgsIHk7XG5cbiAgaWYgKGNvbmZpZy5jbGFtcCkge1xuICAgIHNlZ21lbnQgPSBjbGlwcGVkKHNlZ21lbnQsIGNvbmZpZy5hcmVhKTtcbiAgfVxuXG4gIGlmIChhbmNob3IgPT09ICdzdGFydCcpIHtcbiAgICB4ID0gc2VnbWVudC54MDtcbiAgICB5ID0gc2VnbWVudC55MDtcbiAgfSBlbHNlIGlmIChhbmNob3IgPT09ICdlbmQnKSB7XG4gICAgeCA9IHNlZ21lbnQueDE7XG4gICAgeSA9IHNlZ21lbnQueTE7XG4gIH0gZWxzZSB7XG4gICAgeCA9IChzZWdtZW50LngwICsgc2VnbWVudC54MSkgLyAyO1xuICAgIHkgPSAoc2VnbWVudC55MCArIHNlZ21lbnQueTEpIC8gMjtcbiAgfVxuXG4gIHJldHVybiBhbGlnbmVkKHgsIHksIHJhbmdlLnZ4LCByYW5nZS52eSwgY29uZmlnLmFsaWduKTtcbn1cblxudmFyIHBvc2l0aW9uZXJzID0ge1xuICBhcmM6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgYW5nbGUgPSAoZWwuc3RhcnRBbmdsZSArIGVsLmVuZEFuZ2xlKSAvIDI7XG4gICAgdmFyIHZ4ID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgIHZhciB2eSA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgcjAgPSBlbC5pbm5lclJhZGl1cztcbiAgICB2YXIgcjEgPSBlbC5vdXRlclJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggKyB2eCAqIHIwLFxuICAgICAgeTA6IGVsLnkgKyB2eSAqIHIwLFxuICAgICAgeDE6IGVsLnggKyB2eCAqIHIxLFxuICAgICAgeTE6IGVsLnkgKyB2eSAqIHIxLFxuICAgICAgdng6IHZ4LFxuICAgICAgdnk6IHZ5XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBwb2ludDogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgcnggPSB2LnggKiBlbC5vcHRpb25zLnJhZGl1cztcbiAgICB2YXIgcnkgPSB2LnkgKiBlbC5vcHRpb25zLnJhZGl1cztcblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IGVsLnggLSByeCxcbiAgICAgIHkwOiBlbC55IC0gcnksXG4gICAgICB4MTogZWwueCArIHJ4LFxuICAgICAgeTE6IGVsLnkgKyByeSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfSxcblxuICBiYXI6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG4gICAgdmFyIHggPSBlbC54O1xuICAgIHZhciB5ID0gZWwueTtcbiAgICB2YXIgc3ggPSAwO1xuICAgIHZhciBzeSA9IDA7XG5cbiAgICBpZiAoZWwuaG9yaXpvbnRhbCkge1xuICAgICAgeCA9IE1hdGgubWluKGVsLngsIGVsLmJhc2UpO1xuICAgICAgc3ggPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBNYXRoLm1pbihlbC55LCBlbC5iYXNlKTtcbiAgICAgIHN5ID0gTWF0aC5hYnMoZWwuYmFzZSAtIGVsLnkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wdXRlJDEoe1xuICAgICAgeDA6IHgsXG4gICAgICB5MDogeSArIHN5LFxuICAgICAgeDE6IHggKyBzeCxcbiAgICAgIHkxOiB5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGZhbGxiYWNrOiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCxcbiAgICAgIHkwOiBlbC55LFxuICAgICAgeDE6IGVsLnggKyAoZWwud2lkdGggfHwgMCksXG4gICAgICB5MTogZWwueSArIChlbC5oZWlnaHQgfHwgMCksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH1cbn07XG5cbnZhciByYXN0ZXJpemUgPSB1dGlscy5yYXN0ZXJpemU7XG5cbmZ1bmN0aW9uIGJvdW5kaW5nUmVjdHMobW9kZWwpIHtcbiAgdmFyIGJvcmRlcldpZHRoID0gbW9kZWwuYm9yZGVyV2lkdGggfHwgMDtcbiAgdmFyIHBhZGRpbmcgPSBtb2RlbC5wYWRkaW5nO1xuICB2YXIgdGggPSBtb2RlbC5zaXplLmhlaWdodDtcbiAgdmFyIHR3ID0gbW9kZWwuc2l6ZS53aWR0aDtcbiAgdmFyIHR4ID0gLXR3IC8gMjtcbiAgdmFyIHR5ID0gLXRoIC8gMjtcblxuICByZXR1cm4ge1xuICAgIGZyYW1lOiB7XG4gICAgICB4OiB0eCAtIHBhZGRpbmcubGVmdCAtIGJvcmRlcldpZHRoLFxuICAgICAgeTogdHkgLSBwYWRkaW5nLnRvcCAtIGJvcmRlcldpZHRoLFxuICAgICAgdzogdHcgKyBwYWRkaW5nLndpZHRoICsgYm9yZGVyV2lkdGggKiAyLFxuICAgICAgaDogdGggKyBwYWRkaW5nLmhlaWdodCArIGJvcmRlcldpZHRoICogMlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgeDogdHgsXG4gICAgICB5OiB0eSxcbiAgICAgIHc6IHR3LFxuICAgICAgaDogdGhcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlT3JpZ2luKGVsLCBjb250ZXh0KSB7XG4gIHZhciBzY2FsZSA9IGNvbnRleHQuY2hhcnQuZ2V0RGF0YXNldE1ldGEoY29udGV4dC5kYXRhc2V0SW5kZXgpLnZTY2FsZTtcblxuICBpZiAoIXNjYWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoc2NhbGUueENlbnRlciAhPT0gdW5kZWZpbmVkICYmIHNjYWxlLnlDZW50ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7eDogc2NhbGUueENlbnRlciwgeTogc2NhbGUueUNlbnRlcn07XG4gIH1cblxuICB2YXIgcGl4ZWwgPSBzY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgcmV0dXJuIGVsLmhvcml6b250YWwgP1xuICAgIHt4OiBwaXhlbCwgeTogbnVsbH0gOlxuICAgIHt4OiBudWxsLCB5OiBwaXhlbH07XG59XG5cbmZ1bmN0aW9uIGdldFBvc2l0aW9uZXIoZWwpIHtcbiAgaWYgKGVsIGluc3RhbmNlb2YgQXJjRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5hcmM7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgUG9pbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLnBvaW50O1xuICB9XG4gIGlmIChlbCBpbnN0YW5jZW9mIEJhckVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMuYmFyO1xuICB9XG4gIHJldHVybiBwb3NpdGlvbmVycy5mYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gZHJhd1JvdW5kZWRSZWN0KGN0eCwgeCwgeSwgdywgaCwgcmFkaXVzKSB7XG4gIHZhciBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XG5cbiAgaWYgKHJhZGl1cykge1xuICAgIHZhciByID0gTWF0aC5taW4ocmFkaXVzLCBoIC8gMiwgdyAvIDIpO1xuICAgIHZhciBsZWZ0ID0geCArIHI7XG4gICAgdmFyIHRvcCA9IHkgKyByO1xuICAgIHZhciByaWdodCA9IHggKyB3IC0gcjtcbiAgICB2YXIgYm90dG9tID0geSArIGggLSByO1xuXG4gICAgY3R4Lm1vdmVUbyh4LCB0b3ApO1xuICAgIGlmIChsZWZ0IDwgcmlnaHQgJiYgdG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIC1IQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIDApO1xuICAgICAgY3R4LmFyYyhyaWdodCwgYm90dG9tLCByLCAwLCBIQUxGX1BJKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCBIQUxGX1BJLCBNYXRoLlBJKTtcbiAgICB9IGVsc2UgaWYgKGxlZnQgPCByaWdodCkge1xuICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB5KTtcbiAgICAgIGN0eC5hcmMocmlnaHQsIHRvcCwgciwgLUhBTEZfUEksIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIEhBTEZfUEksIE1hdGguUEkgKyBIQUxGX1BJKTtcbiAgICB9IGVsc2UgaWYgKHRvcCA8IGJvdHRvbSkge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCAwKTtcbiAgICAgIGN0eC5hcmMobGVmdCwgYm90dG9tLCByLCAwLCBNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyhsZWZ0LCB0b3AsIHIsIC1NYXRoLlBJLCBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LnJlY3QoeCwgeSwgdywgaCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ZyYW1lKGN0eCwgcmVjdCwgbW9kZWwpIHtcbiAgdmFyIGJnQ29sb3IgPSBtb2RlbC5iYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciBib3JkZXJDb2xvciA9IG1vZGVsLmJvcmRlckNvbG9yO1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aDtcblxuICBpZiAoIWJnQ29sb3IgJiYgKCFib3JkZXJDb2xvciB8fCAhYm9yZGVyV2lkdGgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gIGRyYXdSb3VuZGVkUmVjdChcbiAgICBjdHgsXG4gICAgcmFzdGVyaXplKHJlY3QueCkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QueSkgKyBib3JkZXJXaWR0aCAvIDIsXG4gICAgcmFzdGVyaXplKHJlY3QudykgLSBib3JkZXJXaWR0aCxcbiAgICByYXN0ZXJpemUocmVjdC5oKSAtIGJvcmRlcldpZHRoLFxuICAgIG1vZGVsLmJvcmRlclJhZGl1cyk7XG5cbiAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gIGlmIChiZ0NvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJnQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIGlmIChib3JkZXJDb2xvciAmJiBib3JkZXJXaWR0aCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSAnbWl0ZXInO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpIHtcbiAgdmFyIGggPSBmb250LmxpbmVIZWlnaHQ7XG4gIHZhciB3ID0gcmVjdC53O1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0LnkgKyBoIC8gMjtcblxuICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCArPSB3IC8gMjtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcgfHwgYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IHc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGg6IGgsXG4gICAgdzogdyxcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gZHJhd1RleHRMaW5lKGN0eCwgdGV4dCwgY2ZnKSB7XG4gIHZhciBzaGFkb3cgPSBjdHguc2hhZG93Qmx1cjtcbiAgdmFyIHN0cm9rZWQgPSBjZmcuc3Ryb2tlZDtcbiAgdmFyIHggPSByYXN0ZXJpemUoY2ZnLngpO1xuICB2YXIgeSA9IHJhc3Rlcml6ZShjZmcueSk7XG4gIHZhciB3ID0gcmFzdGVyaXplKGNmZy53KTtcblxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5zdHJva2VUZXh0KHRleHQsIHgsIHksIHcpO1xuICB9XG5cbiAgaWYgKGNmZy5maWxsZWQpIHtcbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIC8vIFByZXZlbnQgZHJhd2luZyBzaGFkb3cgb24gYm90aCB0aGUgdGV4dCBzdHJva2UgYW5kIGZpbGwsIHNvXG4gICAgICAvLyBpZiB0aGUgdGV4dCBpcyBzdHJva2VkLCByZW1vdmUgdGhlIHNoYWRvdyBmb3IgdGhlIHRleHQgZmlsbC5cbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gMDtcbiAgICB9XG5cbiAgICBjdHguZmlsbFRleHQodGV4dCwgeCwgeSwgdyk7XG5cbiAgICBpZiAoc2hhZG93ICYmIHN0cm9rZWQpIHtcbiAgICAgIGN0eC5zaGFkb3dCbHVyID0gc2hhZG93O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3VGV4dChjdHgsIGxpbmVzLCByZWN0LCBtb2RlbCkge1xuICB2YXIgYWxpZ24gPSBtb2RlbC50ZXh0QWxpZ247XG4gIHZhciBjb2xvciA9IG1vZGVsLmNvbG9yO1xuICB2YXIgZmlsbGVkID0gISFjb2xvcjtcbiAgdmFyIGZvbnQgPSBtb2RlbC5mb250O1xuICB2YXIgaWxlbiA9IGxpbmVzLmxlbmd0aDtcbiAgdmFyIHN0cm9rZUNvbG9yID0gbW9kZWwudGV4dFN0cm9rZUNvbG9yO1xuICB2YXIgc3Ryb2tlV2lkdGggPSBtb2RlbC50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciBzdHJva2VkID0gc3Ryb2tlQ29sb3IgJiYgc3Ryb2tlV2lkdGg7XG4gIHZhciBpO1xuXG4gIGlmICghaWxlbiB8fCAoIWZpbGxlZCAmJiAhc3Ryb2tlZCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBBZGp1c3QgY29vcmRpbmF0ZXMgYmFzZWQgb24gdGV4dCBhbGlnbm1lbnQgYW5kIGxpbmUgaGVpZ2h0XG4gIHJlY3QgPSB0ZXh0R2VvbWV0cnkocmVjdCwgYWxpZ24sIGZvbnQpO1xuXG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIGN0eC50ZXh0QWxpZ24gPSBhbGlnbjtcbiAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICBjdHguc2hhZG93Qmx1ciA9IG1vZGVsLnRleHRTaGFkb3dCbHVyO1xuICBjdHguc2hhZG93Q29sb3IgPSBtb2RlbC50ZXh0U2hhZG93Q29sb3I7XG5cbiAgaWYgKGZpbGxlZCkge1xuICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgfVxuICBpZiAoc3Ryb2tlZCkge1xuICAgIGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yO1xuICB9XG5cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRyYXdUZXh0TGluZShjdHgsIGxpbmVzW2ldLCB7XG4gICAgICBzdHJva2VkOiBzdHJva2VkLFxuICAgICAgZmlsbGVkOiBmaWxsZWQsXG4gICAgICB3OiByZWN0LncsXG4gICAgICB4OiByZWN0LngsXG4gICAgICB5OiByZWN0LnkgKyByZWN0LmggKiBpXG4gICAgfSk7XG4gIH1cbn1cblxudmFyIExhYmVsID0gZnVuY3Rpb24oY29uZmlnLCBjdHgsIGVsLCBpbmRleCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIG1lLl9jb25maWcgPSBjb25maWc7XG4gIG1lLl9pbmRleCA9IGluZGV4O1xuICBtZS5fbW9kZWwgPSBudWxsO1xuICBtZS5fcmVjdHMgPSBudWxsO1xuICBtZS5fY3R4ID0gY3R4O1xuICBtZS5fZWwgPSBlbDtcbn07XG5cbm1lcmdlKExhYmVsLnByb3RvdHlwZSwge1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tb2RlbGl6ZTogZnVuY3Rpb24oZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBmb250ID0gdG9Gb250KHJlc29sdmUoW2NvbmZpZy5mb250LCB7fV0sIGNvbnRleHQsIGluZGV4KSk7XG4gICAgdmFyIGNvbG9yID0gcmVzb2x2ZShbY29uZmlnLmNvbG9yLCBkZWZhdWx0cyQxLmNvbG9yXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFsaWduOiByZXNvbHZlKFtjb25maWcuYWxpZ24sICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYW5jaG9yOiByZXNvbHZlKFtjb25maWcuYW5jaG9yLCAnY2VudGVyJ10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGFyZWE6IGNvbnRleHQuY2hhcnQuY2hhcnRBcmVhLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiByZXNvbHZlKFtjb25maWcuYmFja2dyb3VuZENvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyQ29sb3I6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJDb2xvciwgbnVsbF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlclJhZGl1czogcmVzb2x2ZShbY29uZmlnLmJvcmRlclJhZGl1cywgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGJvcmRlcldpZHRoOiByZXNvbHZlKFtjb25maWcuYm9yZGVyV2lkdGgsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBjbGFtcDogcmVzb2x2ZShbY29uZmlnLmNsYW1wLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsaXA6IHJlc29sdmUoW2NvbmZpZy5jbGlwLCBmYWxzZV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgIGRpc3BsYXk6IGRpc3BsYXksXG4gICAgICBmb250OiBmb250LFxuICAgICAgbGluZXM6IGxpbmVzLFxuICAgICAgb2Zmc2V0OiByZXNvbHZlKFtjb25maWcub2Zmc2V0LCA0XSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgb3BhY2l0eTogcmVzb2x2ZShbY29uZmlnLm9wYWNpdHksIDFdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcmlnaW46IGdldFNjYWxlT3JpZ2luKG1lLl9lbCwgY29udGV4dCksXG4gICAgICBwYWRkaW5nOiB0b1BhZGRpbmcocmVzb2x2ZShbY29uZmlnLnBhZGRpbmcsIDRdLCBjb250ZXh0LCBpbmRleCkpLFxuICAgICAgcG9zaXRpb25lcjogZ2V0UG9zaXRpb25lcihtZS5fZWwpLFxuICAgICAgcm90YXRpb246IHJlc29sdmUoW2NvbmZpZy5yb3RhdGlvbiwgMF0sIGNvbnRleHQsIGluZGV4KSAqIChNYXRoLlBJIC8gMTgwKSxcbiAgICAgIHNpemU6IHV0aWxzLnRleHRTaXplKG1lLl9jdHgsIGxpbmVzLCBmb250KSxcbiAgICAgIHRleHRBbGlnbjogcmVzb2x2ZShbY29uZmlnLnRleHRBbGlnbiwgJ3N0YXJ0J10sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dCbHVyOiByZXNvbHZlKFtjb25maWcudGV4dFNoYWRvd0JsdXIsIDBdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U2hhZG93Q29sb3I6IHJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Q29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZUNvbG9yOiByZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZUNvbG9yLCBjb2xvcl0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTdHJva2VXaWR0aDogcmVzb2x2ZShbY29uZmlnLnRleHRTdHJva2VXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgbW9kZWwgPSBudWxsO1xuICAgIHZhciByZWN0cyA9IG51bGw7XG4gICAgdmFyIGluZGV4ID0gbWUuX2luZGV4O1xuICAgIHZhciBjb25maWcgPSBtZS5fY29uZmlnO1xuICAgIHZhciB2YWx1ZSwgbGFiZWwsIGxpbmVzO1xuXG4gICAgLy8gV2UgZmlyc3QgcmVzb2x2ZSB0aGUgZGlzcGxheSBvcHRpb24gKHNlcGFyYXRlbHkpIHRvIGF2b2lkIGNvbXB1dGluZ1xuICAgIC8vIG90aGVyIG9wdGlvbnMgaW4gY2FzZSB0aGUgbGFiZWwgaXMgaGlkZGVuIChpLmUuIGRpc3BsYXk6IGZhbHNlKS5cbiAgICB2YXIgZGlzcGxheSA9IHJlc29sdmUoW2NvbmZpZy5kaXNwbGF5LCB0cnVlXSwgY29udGV4dCwgaW5kZXgpO1xuXG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIHZhbHVlID0gY29udGV4dC5kYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgbGFiZWwgPSB2YWx1ZU9yRGVmYXVsdChjYWxsYmFjayhjb25maWcuZm9ybWF0dGVyLCBbdmFsdWUsIGNvbnRleHRdKSwgdmFsdWUpO1xuICAgICAgbGluZXMgPSBpc051bGxPclVuZGVmKGxhYmVsKSA/IFtdIDogdXRpbHMudG9UZXh0TGluZXMobGFiZWwpO1xuXG4gICAgICBpZiAobGluZXMubGVuZ3RoKSB7XG4gICAgICAgIG1vZGVsID0gbWUuX21vZGVsaXplKGRpc3BsYXksIGxpbmVzLCBjb25maWcsIGNvbnRleHQpO1xuICAgICAgICByZWN0cyA9IGJvdW5kaW5nUmVjdHMobW9kZWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lLl9tb2RlbCA9IG1vZGVsO1xuICAgIG1lLl9yZWN0cyA9IHJlY3RzO1xuICB9LFxuXG4gIGdlb21ldHJ5OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVjdHMgPyB0aGlzLl9yZWN0cy5mcmFtZSA6IHt9O1xuICB9LFxuXG4gIHJvdGF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgPyB0aGlzLl9tb2RlbC5yb3RhdGlvbiA6IDA7XG4gIH0sXG5cbiAgdmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsICYmIHRoaXMuX21vZGVsLm9wYWNpdHk7XG4gIH0sXG5cbiAgbW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgY2VudGVyKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgY3R4ID0gY2hhcnQuY3R4O1xuICAgIHZhciBtb2RlbCA9IG1lLl9tb2RlbDtcbiAgICB2YXIgcmVjdHMgPSBtZS5fcmVjdHM7XG4gICAgdmFyIGFyZWE7XG5cbiAgICBpZiAoIXRoaXMudmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmIChtb2RlbC5jbGlwKSB7XG4gICAgICBhcmVhID0gbW9kZWwuYXJlYTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5yZWN0KFxuICAgICAgICBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEudG9wLFxuICAgICAgICBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LFxuICAgICAgICBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuXG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdXRpbHMuYm91bmQoMCwgbW9kZWwub3BhY2l0eSwgMSk7XG4gICAgY3R4LnRyYW5zbGF0ZShyYXN0ZXJpemUoY2VudGVyLngpLCByYXN0ZXJpemUoY2VudGVyLnkpKTtcbiAgICBjdHgucm90YXRlKG1vZGVsLnJvdGF0aW9uKTtcblxuICAgIGRyYXdGcmFtZShjdHgsIHJlY3RzLmZyYW1lLCBtb2RlbCk7XG4gICAgZHJhd1RleHQoY3R4LCBtb2RlbC5saW5lcywgcmVjdHMudGV4dCwgbW9kZWwpO1xuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufSk7XG5cbnZhciBNSU5fSU5URUdFUiA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSIHx8IC05MDA3MTk5MjU0NzQwOTkxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVzL25vLW51bWJlci1taW5zYWZlaW50ZWdlclxudmFyIE1BWF9JTlRFR0VSID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgOTAwNzE5OTI1NDc0MDk5MTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1heHNhZmVpbnRlZ2VyXG5cbmZ1bmN0aW9uIHJvdGF0ZWQocG9pbnQsIGNlbnRlciwgYW5nbGUpIHtcbiAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgdmFyIGN4ID0gY2VudGVyLng7XG4gIHZhciBjeSA9IGNlbnRlci55O1xuXG4gIHJldHVybiB7XG4gICAgeDogY3ggKyBjb3MgKiAocG9pbnQueCAtIGN4KSAtIHNpbiAqIChwb2ludC55IC0gY3kpLFxuICAgIHk6IGN5ICsgc2luICogKHBvaW50LnggLSBjeCkgKyBjb3MgKiAocG9pbnQueSAtIGN5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9qZWN0ZWQocG9pbnRzLCBheGlzKSB7XG4gIHZhciBtaW4gPSBNQVhfSU5URUdFUjtcbiAgdmFyIG1heCA9IE1JTl9JTlRFR0VSO1xuICB2YXIgb3JpZ2luID0gYXhpcy5vcmlnaW47XG4gIHZhciBpLCBwdCwgdngsIHZ5LCBkcDtcblxuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgcHQgPSBwb2ludHNbaV07XG4gICAgdnggPSBwdC54IC0gb3JpZ2luLng7XG4gICAgdnkgPSBwdC55IC0gb3JpZ2luLnk7XG4gICAgZHAgPSBheGlzLnZ4ICogdnggKyBheGlzLnZ5ICogdnk7XG4gICAgbWluID0gTWF0aC5taW4obWluLCBkcCk7XG4gICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkcCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1pbjogbWluLFxuICAgIG1heDogbWF4XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvQXhpcyhwMCwgcDEpIHtcbiAgdmFyIHZ4ID0gcDEueCAtIHAwLng7XG4gIHZhciB2eSA9IHAxLnkgLSBwMC55O1xuICB2YXIgbG4gPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXG4gIHJldHVybiB7XG4gICAgdng6IChwMS54IC0gcDAueCkgLyBsbixcbiAgICB2eTogKHAxLnkgLSBwMC55KSAvIGxuLFxuICAgIG9yaWdpbjogcDAsXG4gICAgbG46IGxuXG4gIH07XG59XG5cbnZhciBIaXRCb3ggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcm90YXRpb24gPSAwO1xuICB0aGlzLl9yZWN0ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB3OiAwLFxuICAgIGg6IDBcbiAgfTtcbn07XG5cbm1lcmdlKEhpdEJveC5wcm90b3R5cGUsIHtcbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IHRoaXMuX3JlY3Q7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHIueCArIHIudyAvIDIsXG4gICAgICB5OiByLnkgKyByLmggLyAyXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNlbnRlciwgcmVjdCwgcm90YXRpb24pIHtcbiAgICB0aGlzLl9yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMuX3JlY3QgPSB7XG4gICAgICB4OiByZWN0LnggKyBjZW50ZXIueCxcbiAgICAgIHk6IHJlY3QueSArIGNlbnRlci55LFxuICAgICAgdzogcmVjdC53LFxuICAgICAgaDogcmVjdC5oXG4gICAgfTtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtYXJnaW4gPSAxO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG5cbiAgICBwb2ludCA9IHJvdGF0ZWQocG9pbnQsIG1lLmNlbnRlcigpLCAtbWUuX3JvdGF0aW9uKTtcblxuICAgIHJldHVybiAhKHBvaW50LnggPCByZWN0LnggLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnkgPCByZWN0LnkgLSBtYXJnaW5cbiAgICAgIHx8IHBvaW50LnggPiByZWN0LnggKyByZWN0LncgKyBtYXJnaW4gKiAyXG4gICAgICB8fCBwb2ludC55ID4gcmVjdC55ICsgcmVjdC5oICsgbWFyZ2luICogMik7XG4gIH0sXG5cbiAgLy8gU2VwYXJhdGluZyBBeGlzIFRoZW9yZW1cbiAgLy8gaHR0cHM6Ly9nYW1lZGV2ZWxvcG1lbnQudHV0c3BsdXMuY29tL3R1dG9yaWFscy9jb2xsaXNpb24tZGV0ZWN0aW9uLXVzaW5nLXRoZS1zZXBhcmF0aW5nLWF4aXMtdGhlb3JlbS0tZ2FtZWRldi0xNjlcbiAgaW50ZXJzZWN0czogZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2YXIgcjAgPSB0aGlzLl9wb2ludHMoKTtcbiAgICB2YXIgcjEgPSBvdGhlci5fcG9pbnRzKCk7XG4gICAgdmFyIGF4ZXMgPSBbXG4gICAgICB0b0F4aXMocjBbMF0sIHIwWzFdKSxcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbM10pXG4gICAgXTtcbiAgICB2YXIgaSwgcHIwLCBwcjE7XG5cbiAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IG90aGVyLl9yb3RhdGlvbikge1xuICAgICAgLy8gT25seSBzZXBhcmF0ZSB3aXRoIHIxIGF4aXMgaWYgdGhlIHJvdGF0aW9uIGlzIGRpZmZlcmVudCxcbiAgICAgIC8vIGVsc2UgaXQncyBlbm91Z2ggdG8gc2VwYXJhdGUgcjAgYW5kIHIxIHdpdGggcjAgYXhpcyBvbmx5IVxuICAgICAgYXhlcy5wdXNoKFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzFdKSxcbiAgICAgICAgdG9BeGlzKHIxWzBdLCByMVszXSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGF4ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHByMCA9IHByb2plY3RlZChyMCwgYXhlc1tpXSk7XG4gICAgICBwcjEgPSBwcm9qZWN0ZWQocjEsIGF4ZXNbaV0pO1xuXG4gICAgICBpZiAocHIwLm1heCA8IHByMS5taW4gfHwgcHIxLm1heCA8IHByMC5taW4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BvaW50czogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgcmVjdCA9IG1lLl9yZWN0O1xuICAgIHZhciBhbmdsZSA9IG1lLl9yb3RhdGlvbjtcbiAgICB2YXIgY2VudGVyID0gbWUuY2VudGVyKCk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55fSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LnggKyByZWN0LncsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54LCB5OiByZWN0LnkgKyByZWN0Lmh9LCBjZW50ZXIsIGFuZ2xlKVxuICAgIF07XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBjb29yZGluYXRlcyhlbCwgbW9kZWwsIGdlb21ldHJ5KSB7XG4gIHZhciBwb2ludCA9IG1vZGVsLnBvc2l0aW9uZXIoZWwsIG1vZGVsKTtcbiAgdmFyIHZ4ID0gcG9pbnQudng7XG4gIHZhciB2eSA9IHBvaW50LnZ5O1xuXG4gIGlmICghdnggJiYgIXZ5KSB7XG4gICAgLy8gaWYgYWxpZ25lZCBjZW50ZXIsIHdlIGRvbid0IHdhbnQgdG8gb2Zmc2V0IHRoZSBjZW50ZXIgcG9pbnRcbiAgICByZXR1cm4ge3g6IHBvaW50LngsIHk6IHBvaW50Lnl9O1xuICB9XG5cbiAgdmFyIHcgPSBnZW9tZXRyeS53O1xuICB2YXIgaCA9IGdlb21ldHJ5Lmg7XG5cbiAgLy8gdGFrZSBpbiBhY2NvdW50IHRoZSBsYWJlbCByb3RhdGlvblxuICB2YXIgcm90YXRpb24gPSBtb2RlbC5yb3RhdGlvbjtcbiAgdmFyIGR4ID0gTWF0aC5hYnModyAvIDIgKiBNYXRoLmNvcyhyb3RhdGlvbikpICsgTWF0aC5hYnMoaCAvIDIgKiBNYXRoLnNpbihyb3RhdGlvbikpO1xuICB2YXIgZHkgPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSk7XG5cbiAgLy8gc2NhbGUgdGhlIHVuaXQgdmVjdG9yICh2eCwgdnkpIHRvIGdldCBhdCBsZWFzdCBkeCBvciBkeSBlcXVhbCB0b1xuICAvLyB3IG9yIGggcmVzcGVjdGl2ZWx5IChlbHNlIHdlIHdvdWxkIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgdG8gdGhlXG4gIC8vIGVsbGlwc2UgaW5zY3JpYmVkIGluIHRoZSBib3VuZGluZyByZWN0KVxuICB2YXIgdnMgPSAxIC8gTWF0aC5tYXgoTWF0aC5hYnModngpLCBNYXRoLmFicyh2eSkpO1xuICBkeCAqPSB2eCAqIHZzO1xuICBkeSAqPSB2eSAqIHZzO1xuXG4gIC8vIGZpbmFsbHksIGluY2x1ZGUgdGhlIGV4cGxpY2l0IG9mZnNldFxuICBkeCArPSBtb2RlbC5vZmZzZXQgKiB2eDtcbiAgZHkgKz0gbW9kZWwub2Zmc2V0ICogdnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludC54ICsgZHgsXG4gICAgeTogcG9pbnQueSArIGR5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxpZGUobGFiZWxzLCBjb2xsaWRlcikge1xuICB2YXIgaSwgaiwgczAsIHMxO1xuXG4gIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2YgdGhlXG4gIC8vIGxpc3QgaGF2ZSBhbiBoaWdoZXIgd2VpZ2h0L3ByaW9yaXR5IGFuZCB0aHVzIHNob3VsZCBiZSBsZXNzIGltcGFjdGVkXG4gIC8vIGJ5IHRoZSBvdmVybGFwcGluZyBzdHJhdGVneS5cblxuICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICBzMCA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgZm9yIChqID0gaSAtIDE7IGogPj0gMCAmJiBzMC5fdmlzaWJsZTsgLS1qKSB7XG4gICAgICBzMSA9IGxhYmVsc1tqXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoczEuX3Zpc2libGUgJiYgczAuX2JveC5pbnRlcnNlY3RzKHMxLl9ib3gpKSB7XG4gICAgICAgIGNvbGxpZGVyKHMwLCBzMSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGxhYmVscztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZShsYWJlbHMpIHtcbiAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlciwgcHJveHk7XG5cbiAgLy8gSW5pdGlhbGl6ZSBsYWJlbHMgZm9yIG92ZXJsYXAgZGV0ZWN0aW9uXG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAvLyBDaGFydC5qcyAzIHJlbW92ZWQgZWwuX21vZGVsIGluIGZhdm9yIG9mIGdldFByb3BzKCksIG1ha2luZyBoYXJkZXIgdG9cbiAgICAgIC8vIGFic3RyYWN0IHJlYWRpbmcgdmFsdWVzIGluIHBvc2l0aW9uZXJzLiBBbHNvLCB1c2luZyBzdHJpbmcgYXJyYXlzIHRvXG4gICAgICAvLyByZWFkIHZhbHVlcyAoaS5lLiB2YXIge2EsYixjfSA9IGVsLmdldFByb3BzKFtcImFcIixcImJcIixcImNcIl0pKSB3b3VsZCBtYWtlXG4gICAgICAvLyBwb3NpdGlvbmVycyBpbmVmZmljaWVudCBpbiB0aGUgbm9ybWFsIGNhc2UgKGkuZS4gbm90IHRoZSBmaW5hbCB2YWx1ZXMpXG4gICAgICAvLyBhbmQgdGhlIGNvZGUgYSBiaXQgdWdseSwgc28gbGV0J3MgdXNlIGEgUHJveHkgaW5zdGVhZC5cbiAgICAgIHByb3h5ID0gbmV3IFByb3h5KGxhYmVsLl9lbCwge2dldDogKGVsLCBwKSA9PiBlbC5nZXRQcm9wcyhbcF0sIHRydWUpW3BdfSk7XG5cbiAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgIGNlbnRlciA9IGNvb3JkaW5hdGVzKHByb3h5LCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICBzdGF0ZS5fYm94LnVwZGF0ZShjZW50ZXIsIGdlb21ldHJ5LCBsYWJlbC5yb3RhdGlvbigpKTtcbiAgICB9XG4gIH1cblxuICAvLyBBdXRvIGhpZGUgb3ZlcmxhcHBpbmcgbGFiZWxzXG4gIHJldHVybiBjb2xsaWRlKGxhYmVscywgZnVuY3Rpb24oczAsIHMxKSB7XG4gICAgdmFyIGgwID0gczAuX2hpZGFibGU7XG4gICAgdmFyIGgxID0gczEuX2hpZGFibGU7XG5cbiAgICBpZiAoKGgwICYmIGgxKSB8fCBoMSkge1xuICAgICAgczEuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGgwKSB7XG4gICAgICBzMC5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBsYXlvdXQgPSB7XG4gIHByZXBhcmU6IGZ1bmN0aW9uKGRhdGFzZXRzKSB7XG4gICAgdmFyIGxhYmVscyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCBqbGVuLCBsYWJlbDtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBkYXRhc2V0c1tpXS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgbGFiZWwgPSBkYXRhc2V0c1tpXVtqXTtcbiAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICBsYWJlbC4kbGF5b3V0ID0ge1xuICAgICAgICAgIF9ib3g6IG5ldyBIaXRCb3goKSxcbiAgICAgICAgICBfaGlkYWJsZTogZmFsc2UsXG4gICAgICAgICAgX3Zpc2libGU6IHRydWUsXG4gICAgICAgICAgX3NldDogaSxcbiAgICAgICAgICBfaWR4OiBsYWJlbC5faW5kZXhcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPIE5ldyBgemAgb3B0aW9uOiBsYWJlbHMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3blxuICAgIC8vIG9mIHRvcCBvZiB0aGUgb25lcyB3aXRoIGEgbG93ZXIgaW5kZXguIExvd2VzdCB6LWluZGV4IGxhYmVsc1xuICAgIC8vIGFyZSBhbHNvIGRpc2NhcmRlZCBmaXJzdCB3aGVuIGhpZGluZyBvdmVybGFwcGluZyBsYWJlbHMuXG4gICAgbGFiZWxzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIHNhID0gYS4kbGF5b3V0O1xuICAgICAgdmFyIHNiID0gYi4kbGF5b3V0O1xuXG4gICAgICByZXR1cm4gc2EuX2lkeCA9PT0gc2IuX2lkeFxuICAgICAgICA/IHNiLl9zZXQgLSBzYS5fc2V0XG4gICAgICAgIDogc2IuX2lkeCAtIHNhLl9pZHg7XG4gICAgfSk7XG5cbiAgICB0aGlzLnVwZGF0ZShsYWJlbHMpO1xuXG4gICAgcmV0dXJuIGxhYmVscztcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGxhYmVscykge1xuICAgIHZhciBkaXJ0eSA9IGZhbHNlO1xuICAgIHZhciBpLCBpbGVuLCBsYWJlbCwgbW9kZWwsIHN0YXRlO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgbW9kZWwgPSBsYWJlbC5tb2RlbCgpO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuICAgICAgc3RhdGUuX2hpZGFibGUgPSBtb2RlbCAmJiBtb2RlbC5kaXNwbGF5ID09PSAnYXV0byc7XG4gICAgICBzdGF0ZS5fdmlzaWJsZSA9IGxhYmVsLnZpc2libGUoKTtcbiAgICAgIGRpcnR5IHw9IHN0YXRlLl9oaWRhYmxlO1xuICAgIH1cblxuICAgIGlmIChkaXJ0eSkge1xuICAgICAgY29tcHV0ZShsYWJlbHMpO1xuICAgIH1cbiAgfSxcblxuICBsb29rdXA6IGZ1bmN0aW9uKGxhYmVscywgcG9pbnQpIHtcbiAgICB2YXIgaSwgc3RhdGU7XG5cbiAgICAvLyBJTVBPUlRBTlQgSXRlcmF0ZSBpbiB0aGUgcmV2ZXJzZSBvcmRlciBzaW5jZSBpdGVtcyBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIGxpc3QgaGF2ZSBhbiBoaWdoZXIgei1pbmRleCwgdGh1cyBzaG91bGQgYmUgcGlja2VkIGZpcnN0LlxuXG4gICAgZm9yIChpID0gbGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBzdGF0ZSA9IGxhYmVsc1tpXS4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUgJiYgc3RhdGUuX3Zpc2libGUgJiYgc3RhdGUuX2JveC5jb250YWlucyhwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIGxhYmVsc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkcmF3OiBmdW5jdGlvbihjaGFydCwgbGFiZWxzKSB7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBzdGF0ZSwgZ2VvbWV0cnksIGNlbnRlcjtcblxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICAgIHN0YXRlID0gbGFiZWwuJGxheW91dDtcblxuICAgICAgaWYgKHN0YXRlLl92aXNpYmxlKSB7XG4gICAgICAgIGdlb21ldHJ5ID0gbGFiZWwuZ2VvbWV0cnkoKTtcbiAgICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMobGFiZWwuX2VsLCBsYWJlbC5tb2RlbCgpLCBnZW9tZXRyeSk7XG4gICAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgICAgICBsYWJlbC5kcmF3KGNoYXJ0LCBjZW50ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZvcm1hdHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxhYmVsID0gdmFsdWU7XG4gIHZhciBrZXlzLCBrbGVuLCBrO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlLmxhYmVsKSkge1xuICAgICAgbGFiZWwgPSB2YWx1ZS5sYWJlbDtcbiAgICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlLnIpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gJyc7XG4gICAgICBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgZm9yIChrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICAgIGxhYmVsICs9IChrICE9PSAwID8gJywgJyA6ICcnKSArIGtleXNba10gKyAnOiAnICsgdmFsdWVba2V5c1trXV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnICsgbGFiZWw7XG59O1xuXG4vKipcbiAqIElNUE9SVEFOVDogbWFrZSBzdXJlIHRvIGFsc28gdXBkYXRlIHRlc3RzIGFuZCBUeXBlU2NyaXB0IGRlZmluaXRpb25cbiAqIGZpbGVzIChgL3Rlc3Qvc3BlY3MvZGVmYXVsdHMuc3BlYy5qc2AgYW5kIGAvdHlwZXMvb3B0aW9ucy5kLnRzYClcbiAqL1xuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFsaWduOiAnY2VudGVyJyxcbiAgYW5jaG9yOiAnY2VudGVyJyxcbiAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICBib3JkZXJDb2xvcjogbnVsbCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMCxcbiAgY2xhbXA6IGZhbHNlLFxuICBjbGlwOiBmYWxzZSxcbiAgY29sb3I6IHVuZGVmaW5lZCxcbiAgZGlzcGxheTogdHJ1ZSxcbiAgZm9udDoge1xuICAgIGZhbWlseTogdW5kZWZpbmVkLFxuICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICBzaXplOiB1bmRlZmluZWQsXG4gICAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgICB3ZWlnaHQ6IG51bGxcbiAgfSxcbiAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXG4gIGxhYmVsczogdW5kZWZpbmVkLFxuICBsaXN0ZW5lcnM6IHt9LFxuICBvZmZzZXQ6IDQsXG4gIG9wYWNpdHk6IDEsXG4gIHBhZGRpbmc6IHtcbiAgICB0b3A6IDQsXG4gICAgcmlnaHQ6IDQsXG4gICAgYm90dG9tOiA0LFxuICAgIGxlZnQ6IDRcbiAgfSxcbiAgcm90YXRpb246IDAsXG4gIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgdGV4dFN0cm9rZUNvbG9yOiB1bmRlZmluZWQsXG4gIHRleHRTdHJva2VXaWR0aDogMCxcbiAgdGV4dFNoYWRvd0JsdXI6IDAsXG4gIHRleHRTaGFkb3dDb2xvcjogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQxNzZcbiAqL1xuXG52YXIgRVhQQU5ET19LRVkgPSAnJGRhdGFsYWJlbHMnO1xudmFyIERFRkFVTFRfS0VZID0gJyRkZWZhdWx0JztcblxuZnVuY3Rpb24gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpIHtcbiAgdmFyIG92ZXJyaWRlID0gZGF0YXNldC5kYXRhbGFiZWxzO1xuICB2YXIgbGlzdGVuZXJzID0ge307XG4gIHZhciBjb25maWdzID0gW107XG4gIHZhciBsYWJlbHMsIGtleXM7XG5cbiAgaWYgKG92ZXJyaWRlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChvdmVycmlkZSA9PT0gdHJ1ZSkge1xuICAgIG92ZXJyaWRlID0ge307XG4gIH1cblxuICBvcHRpb25zID0gbWVyZ2Uoe30sIFtvcHRpb25zLCBvdmVycmlkZV0pO1xuICBsYWJlbHMgPSBvcHRpb25zLmxhYmVscyB8fCB7fTtcbiAga2V5cyA9IE9iamVjdC5rZXlzKGxhYmVscyk7XG4gIGRlbGV0ZSBvcHRpb25zLmxhYmVscztcblxuICBpZiAoa2V5cy5sZW5ndGgpIHtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAobGFiZWxzW2tleV0pIHtcbiAgICAgICAgY29uZmlncy5wdXNoKG1lcmdlKHt9LCBbXG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBsYWJlbHNba2V5XSxcbiAgICAgICAgICB7X2tleToga2V5fVxuICAgICAgICBdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRGVmYXVsdCBsYWJlbCBpZiBubyBcIm5hbWVkXCIgbGFiZWwgZGVmaW5lZC5cbiAgICBjb25maWdzLnB1c2gob3B0aW9ucyk7XG4gIH1cblxuICAvLyBsaXN0ZW5lcnM6IHs8ZXZlbnQtdHlwZT46IHs8bGFiZWwta2V5PjogPGZuPn19XG4gIGxpc3RlbmVycyA9IGNvbmZpZ3MucmVkdWNlKGZ1bmN0aW9uKHRhcmdldCwgY29uZmlnKSB7XG4gICAgZWFjaChjb25maWcubGlzdGVuZXJzIHx8IHt9LCBmdW5jdGlvbihmbiwgZXZlbnQpIHtcbiAgICAgIHRhcmdldFtldmVudF0gPSB0YXJnZXRbZXZlbnRdIHx8IHt9O1xuICAgICAgdGFyZ2V0W2V2ZW50XVtjb25maWcuX2tleSB8fCBERUZBVUxUX0tFWV0gPSBmbjtcbiAgICB9KTtcblxuICAgIGRlbGV0ZSBjb25maWcubGlzdGVuZXJzO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0sIHt9KTtcblxuICByZXR1cm4ge1xuICAgIGxhYmVsczogY29uZmlncyxcbiAgICBsaXN0ZW5lcnM6IGxpc3RlbmVyc1xuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMsIGxhYmVsLCBldmVudCkge1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gbGFiZWwuJGNvbnRleHQ7XG4gIHZhciBncm91cHMgPSBsYWJlbC4kZ3JvdXBzO1xuICB2YXIgY2FsbGJhY2skMTtcblxuICBpZiAoIWxpc3RlbmVyc1tncm91cHMuX3NldF0pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjYWxsYmFjayQxID0gbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XVtncm91cHMuX2tleV07XG4gIGlmICghY2FsbGJhY2skMSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjYWxsYmFjayhjYWxsYmFjayQxLCBbY29udGV4dCwgZXZlbnRdKSA9PT0gdHJ1ZSkge1xuICAgIC8vIFVzZXJzIGFyZSBhbGxvd2VkIHRvIHR3ZWFrIHRoZSBnaXZlbiBjb250ZXh0IGJ5IGluamVjdGluZyB2YWx1ZXMgdGhhdCBjYW4gYmVcbiAgICAvLyB1c2VkIGluIHNjcmlwdGFibGUgb3B0aW9ucyB0byBkaXNwbGF5IGxhYmVscyBkaWZmZXJlbnRseSBiYXNlZCBvbiB0aGUgY3VycmVudFxuICAgIC8vIGV2ZW50IChlLmcuIGhpZ2hsaWdodCBhbiBob3ZlcmVkIGxhYmVsKS4gVGhhdCdzIHdoeSB3ZSB1cGRhdGUgdGhlIGxhYmVsIHdpdGhcbiAgICAvLyB0aGUgb3V0cHV0IGNvbnRleHQgYW5kIHNjaGVkdWxlIGEgbmV3IGNoYXJ0IHJlbmRlciBieSBzZXR0aW5nIGl0IGRpcnR5LlxuICAgIGNoYXJ0W0VYUEFORE9fS0VZXS5fZGlydHkgPSB0cnVlO1xuICAgIGxhYmVsLnVwZGF0ZShjb250ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCkge1xuICB2YXIgZW50ZXIsIGxlYXZlO1xuXG4gIGlmICghcHJldmlvdXMgJiYgIWxhYmVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFwcmV2aW91cykge1xuICAgIGVudGVyID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICghbGFiZWwpIHtcbiAgICBsZWF2ZSA9IHRydWU7XG4gIH0gZWxzZSBpZiAocHJldmlvdXMgIT09IGxhYmVsKSB7XG4gICAgbGVhdmUgPSBlbnRlciA9IHRydWU7XG4gIH1cblxuICBpZiAobGVhdmUpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMubGVhdmUsIHByZXZpb3VzLCBldmVudCk7XG4gIH1cbiAgaWYgKGVudGVyKSB7XG4gICAgZGlzcGF0Y2hFdmVudChjaGFydCwgbGlzdGVuZXJzLmVudGVyLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU1vdmVFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgbGlzdGVuZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzO1xuICB2YXIgcHJldmlvdXMsIGxhYmVsO1xuXG4gIGlmICghbGlzdGVuZXJzLmVudGVyICYmICFsaXN0ZW5lcnMubGVhdmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlbW92ZScpIHtcbiAgICBsYWJlbCA9IGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQudHlwZSAhPT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHByZXZpb3VzID0gZXhwYW5kby5faG92ZXJlZDtcbiAgZXhwYW5kby5faG92ZXJlZCA9IGxhYmVsO1xuICBkaXNwYXRjaE1vdmVFdmVudHMoY2hhcnQsIGxpc3RlbmVycywgcHJldmlvdXMsIGxhYmVsLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrRXZlbnRzKGNoYXJ0LCBldmVudCkge1xuICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgdmFyIGhhbmRsZXJzID0gZXhwYW5kby5fbGlzdGVuZXJzLmNsaWNrO1xuICB2YXIgbGFiZWwgPSBoYW5kbGVycyAmJiBsYXlvdXQubG9va3VwKGV4cGFuZG8uX2xhYmVscywgZXZlbnQpO1xuICBpZiAobGFiZWwpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBoYW5kbGVycywgbGFiZWwsIGV2ZW50KTtcbiAgfVxufVxuXG52YXIgcGx1Z2luID0ge1xuICBpZDogJ2RhdGFsYWJlbHMnLFxuXG4gIGRlZmF1bHRzOiBkZWZhdWx0cyxcblxuICBiZWZvcmVJbml0OiBmdW5jdGlvbihjaGFydCkge1xuICAgIGNoYXJ0W0VYUEFORE9fS0VZXSA9IHtcbiAgICAgIF9hY3RpdmVzOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgYmVmb3JlVXBkYXRlOiBmdW5jdGlvbihjaGFydCkge1xuICAgIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gZmFsc2U7XG4gICAgZXhwYW5kby5fbGlzdGVuZXJzID0ge307ICAgICAvLyB7PGV2ZW50LXR5cGU+OiB7PGRhdGFzZXQtaW5kZXg+OiB7PGxhYmVsLWtleT46IDxmbj59fX1cbiAgICBleHBhbmRvLl9kYXRhc2V0cyA9IFtdOyAgICAgIC8vIHBlciBkYXRhc2V0IGxhYmVsczogW0xhYmVsW11dXG4gICAgZXhwYW5kby5fbGFiZWxzID0gW107ICAgICAgICAvLyBsYXlvdXRlZCBsYWJlbHM6IExhYmVsW11cbiAgfSxcblxuICBhZnRlckRhdGFzZXRVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0LCBhcmdzLCBvcHRpb25zKSB7XG4gICAgdmFyIGRhdGFzZXRJbmRleCA9IGFyZ3MuaW5kZXg7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIGxhYmVscyA9IGV4cGFuZG8uX2RhdGFzZXRzW2RhdGFzZXRJbmRleF0gPSBbXTtcbiAgICB2YXIgdmlzaWJsZSA9IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KTtcbiAgICB2YXIgZGF0YXNldCA9IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICB2YXIgY29uZmlnID0gY29uZmlndXJlKGRhdGFzZXQsIG9wdGlvbnMpO1xuICAgIHZhciBlbGVtZW50cyA9IGFyZ3MubWV0YS5kYXRhIHx8IFtdO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGNmZywga2V5LCBlbCwgbGFiZWw7XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZWwgPSBlbGVtZW50c1tpXTtcbiAgICAgIGVsW0VYUEFORE9fS0VZXSA9IFtdO1xuXG4gICAgICBpZiAodmlzaWJsZSAmJiBlbCAmJiBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhZWwuc2tpcCkge1xuICAgICAgICBmb3IgKGogPSAwLCBqbGVuID0gY29uZmlnLmxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBjZmcgPSBjb25maWcubGFiZWxzW2pdO1xuICAgICAgICAgIGtleSA9IGNmZy5fa2V5O1xuXG4gICAgICAgICAgbGFiZWwgPSBuZXcgTGFiZWwoY2ZnLCBjdHgsIGVsLCBpKTtcbiAgICAgICAgICBsYWJlbC4kZ3JvdXBzID0ge1xuICAgICAgICAgICAgX3NldDogZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgX2tleToga2V5IHx8IERFRkFVTFRfS0VZXG4gICAgICAgICAgfTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dCA9IHtcbiAgICAgICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICBjaGFydDogY2hhcnQsXG4gICAgICAgICAgICBkYXRhSW5kZXg6IGksXG4gICAgICAgICAgICBkYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgICBlbFtFWFBBTkRPX0tFWV0ucHVzaChsYWJlbCk7XG4gICAgICAgICAgbGFiZWxzLnB1c2gobGFiZWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcblxuICAgIC8vIFN0b3JlIGxpc3RlbmVycyBhdCB0aGUgY2hhcnQgbGV2ZWwgYW5kIHBlciBldmVudCB0eXBlIHRvIG9wdGltaXplXG4gICAgLy8gY2FzZXMgd2hlcmUgbm8gbGlzdGVuZXJzIGFyZSByZWdpc3RlcmVkIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICAgIG1lcmdlKGV4cGFuZG8uX2xpc3RlbmVycywgY29uZmlnLmxpc3RlbmVycywge1xuICAgICAgbWVyZ2VyOiBmdW5jdGlvbihldmVudCwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICAgIHRhcmdldFtldmVudF1bYXJncy5pbmRleF0gPSBzb3VyY2VbZXZlbnRdO1xuICAgICAgICBleHBhbmRvLl9saXN0ZW5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgYWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMgPSBsYXlvdXQucHJlcGFyZShjaGFydFtFWFBBTkRPX0tFWV0uX2RhdGFzZXRzKTtcbiAgfSxcblxuICAvLyBEcmF3IGxhYmVscyBvbiB0b3Agb2YgYWxsIGRhdGFzZXQgZWxlbWVudHNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMjlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvMzJcbiAgYWZ0ZXJEYXRhc2V0c0RyYXc6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgbGF5b3V0LmRyYXcoY2hhcnQsIGNoYXJ0W0VYUEFORE9fS0VZXS5fbGFiZWxzKTtcbiAgfSxcblxuICBiZWZvcmVFdmVudDogZnVuY3Rpb24oY2hhcnQsIGFyZ3MpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBsaXN0ZW5lciByZWdpc3RlcmVkIGZvciB0aGlzIGNoYXJ0LCBgbGlzdGVuZWRgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gbWVhbmluZyB3ZSBjYW4gaW1tZWRpYXRlbHkgaWdub3JlIHRoZSBpbmNvbWluZyBldmVudCBhbmQgYXZvaWQgdXNlbGVzcyBleHRyYVxuICAgIC8vIGNvbXB1dGF0aW9uIGZvciB1c2VycyB3aG8gZG9uJ3QgaW1wbGVtZW50IGxhYmVsIGludGVyYWN0aW9ucy5cbiAgICBpZiAoY2hhcnRbRVhQQU5ET19LRVldLl9saXN0ZW5lZCkge1xuICAgICAgdmFyIGV2ZW50ID0gYXJncy5ldmVudDtcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vtb3ZlJzpcbiAgICAgIGNhc2UgJ21vdXNlb3V0JzpcbiAgICAgICAgaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2NsaWNrJzpcbiAgICAgICAgaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGFmdGVyRXZlbnQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgdmFyIHByZXZpb3VzID0gZXhwYW5kby5fYWN0aXZlcztcbiAgICB2YXIgYWN0aXZlcyA9IGV4cGFuZG8uX2FjdGl2ZXMgPSBjaGFydC5nZXRBY3RpdmVFbGVtZW50cygpO1xuICAgIHZhciB1cGRhdGVzID0gdXRpbHMuYXJyYXlEaWZmKHByZXZpb3VzLCBhY3RpdmVzKTtcbiAgICB2YXIgaSwgaWxlbiwgaiwgamxlbiwgdXBkYXRlLCBsYWJlbCwgbGFiZWxzO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHVwZGF0ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZVsxXSkge1xuICAgICAgICBsYWJlbHMgPSB1cGRhdGVbMF0uZWxlbWVudFtFWFBBTkRPX0tFWV0gfHwgW107XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbHMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgICAgbGFiZWwgPSBsYWJlbHNbal07XG4gICAgICAgICAgbGFiZWwuJGNvbnRleHQuYWN0aXZlID0gKHVwZGF0ZVsxXSA9PT0gMSk7XG4gICAgICAgICAgbGFiZWwudXBkYXRlKGxhYmVsLiRjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChleHBhbmRvLl9kaXJ0eSB8fCB1cGRhdGVzLmxlbmd0aCkge1xuICAgICAgbGF5b3V0LnVwZGF0ZShleHBhbmRvLl9sYWJlbHMpO1xuICAgICAgY2hhcnQucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGV4cGFuZG8uX2RpcnR5O1xuICB9XG59O1xuXG5leHBvcnQgeyBwbHVnaW4gYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImlzTnVsbE9yVW5kZWYiLCJtZXJnZSIsInRvRm9udCIsInJlc29sdmUiLCJ0b1BhZGRpbmciLCJ2YWx1ZU9yRGVmYXVsdCIsImNhbGxiYWNrIiwiaXNPYmplY3QiLCJlYWNoIiwiZGVmYXVsdHMiLCJkZWZhdWx0cyQxIiwiQXJjRWxlbWVudCIsIlBvaW50RWxlbWVudCIsIkJhckVsZW1lbnQiLCJkZXZpY2VQaXhlbFJhdGlvIiwid2luZG93Iiwic2NyZWVuIiwiZGV2aWNlWERQSSIsImxvZ2ljYWxYRFBJIiwidXRpbHMiLCJ0b1RleHRMaW5lcyIsImlucHV0cyIsImxpbmVzIiwiaW5wdXQiLCJjb25jYXQiLCJsZW5ndGgiLCJwb3AiLCJ1bnNoaWZ0IiwiYXBwbHkiLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsInB1c2giLCJ0ZXh0U2l6ZSIsImN0eCIsImZvbnQiLCJpdGVtcyIsImlsZW4iLCJwcmV2Iiwid2lkdGgiLCJpIiwic3RyaW5nIiwiTWF0aCIsIm1heCIsIm1lYXN1cmVUZXh0IiwiaGVpZ2h0IiwibGluZUhlaWdodCIsImJvdW5kIiwibWluIiwidmFsdWUiLCJhcnJheURpZmYiLCJhMCIsImExIiwic2xpY2UiLCJ1cGRhdGVzIiwiaiIsInYiLCJpbmRleE9mIiwic3BsaWNlIiwicmFzdGVyaXplIiwicm91bmQiLCJvcmllbnQiLCJwb2ludCIsIm9yaWdpbiIsIngwIiwieCIsInkwIiwieSIsImR4IiwiZHkiLCJsbiIsInNxcnQiLCJhbGlnbmVkIiwidngiLCJ2eSIsImFsaWduIiwiUEkiLCJjb3MiLCJzaW4iLCJSX0lOU0lERSIsIlJfTEVGVCIsIlJfUklHSFQiLCJSX0JPVFRPTSIsIlJfVE9QIiwicmVnaW9uIiwicmVjdCIsInJlcyIsImxlZnQiLCJyaWdodCIsInRvcCIsImJvdHRvbSIsImNsaXBwZWQiLCJzZWdtZW50IiwiYXJlYSIsIngxIiwieTEiLCJyMCIsInIxIiwiciIsImNvbXB1dGUkMSIsInJhbmdlIiwiY29uZmlnIiwiYW5jaG9yIiwiY2xhbXAiLCJwb3NpdGlvbmVycyIsImFyYyIsImVsIiwiYW5nbGUiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJpbm5lclJhZGl1cyIsIm91dGVyUmFkaXVzIiwicngiLCJvcHRpb25zIiwicmFkaXVzIiwicnkiLCJiYXIiLCJzeCIsInN5IiwiaG9yaXpvbnRhbCIsImJhc2UiLCJhYnMiLCJmYWxsYmFjayIsImJvdW5kaW5nUmVjdHMiLCJtb2RlbCIsImJvcmRlcldpZHRoIiwicGFkZGluZyIsInRoIiwic2l6ZSIsInR3IiwidHgiLCJ0eSIsImZyYW1lIiwidyIsImgiLCJ0ZXh0IiwiZ2V0U2NhbGVPcmlnaW4iLCJjb250ZXh0Iiwic2NhbGUiLCJjaGFydCIsImdldERhdGFzZXRNZXRhIiwiZGF0YXNldEluZGV4IiwidlNjYWxlIiwieENlbnRlciIsInVuZGVmaW5lZCIsInlDZW50ZXIiLCJwaXhlbCIsImdldEJhc2VQaXhlbCIsImdldFBvc2l0aW9uZXIiLCJkcmF3Um91bmRlZFJlY3QiLCJIQUxGX1BJIiwibW92ZVRvIiwiY2xvc2VQYXRoIiwiZHJhd0ZyYW1lIiwiYmdDb2xvciIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiYmVnaW5QYXRoIiwiYm9yZGVyUmFkaXVzIiwiZmlsbFN0eWxlIiwiZmlsbCIsInN0cm9rZVN0eWxlIiwibGluZVdpZHRoIiwibGluZUpvaW4iLCJzdHJva2UiLCJ0ZXh0R2VvbWV0cnkiLCJkcmF3VGV4dExpbmUiLCJjZmciLCJzaGFkb3ciLCJzaGFkb3dCbHVyIiwic3Ryb2tlZCIsInN0cm9rZVRleHQiLCJmaWxsZWQiLCJmaWxsVGV4dCIsImRyYXdUZXh0IiwidGV4dEFsaWduIiwiY29sb3IiLCJzdHJva2VDb2xvciIsInRleHRTdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwidGV4dFN0cm9rZVdpZHRoIiwidGV4dEJhc2VsaW5lIiwidGV4dFNoYWRvd0JsdXIiLCJzaGFkb3dDb2xvciIsInRleHRTaGFkb3dDb2xvciIsIkxhYmVsIiwiaW5kZXgiLCJtZSIsIl9jb25maWciLCJfaW5kZXgiLCJfbW9kZWwiLCJfcmVjdHMiLCJfY3R4IiwiX2VsIiwicHJvdG90eXBlIiwiX21vZGVsaXplIiwiZGlzcGxheSIsImNoYXJ0QXJlYSIsImNsaXAiLCJvZmZzZXQiLCJvcGFjaXR5IiwicG9zaXRpb25lciIsInJvdGF0aW9uIiwidXBkYXRlIiwicmVjdHMiLCJsYWJlbCIsImRhdGFzZXQiLCJkYXRhIiwiZm9ybWF0dGVyIiwiZ2VvbWV0cnkiLCJ2aXNpYmxlIiwiZHJhdyIsImNlbnRlciIsInNhdmUiLCJnbG9iYWxBbHBoYSIsInRyYW5zbGF0ZSIsInJvdGF0ZSIsInJlc3RvcmUiLCJNSU5fSU5URUdFUiIsIk51bWJlciIsIk1JTl9TQUZFX0lOVEVHRVIiLCJNQVhfSU5URUdFUiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJyb3RhdGVkIiwiY3giLCJjeSIsInByb2plY3RlZCIsInBvaW50cyIsImF4aXMiLCJwdCIsImRwIiwidG9BeGlzIiwicDAiLCJwMSIsIkhpdEJveCIsIl9yb3RhdGlvbiIsIl9yZWN0IiwiY29udGFpbnMiLCJtYXJnaW4iLCJpbnRlcnNlY3RzIiwib3RoZXIiLCJfcG9pbnRzIiwiYXhlcyIsInByMCIsInByMSIsImNvb3JkaW5hdGVzIiwidnMiLCJjb2xsaWRlIiwibGFiZWxzIiwiY29sbGlkZXIiLCJzMCIsInMxIiwiJGxheW91dCIsIl92aXNpYmxlIiwiX2JveCIsImNvbXB1dGUiLCJzdGF0ZSIsInByb3h5IiwiUHJveHkiLCJnZXQiLCJwIiwiZ2V0UHJvcHMiLCJoMCIsIl9oaWRhYmxlIiwiaDEiLCJsYXlvdXQiLCJwcmVwYXJlIiwiZGF0YXNldHMiLCJqbGVuIiwiX3NldCIsIl9pZHgiLCJzb3J0IiwiYSIsImIiLCJzYSIsInNiIiwiZGlydHkiLCJsb29rdXAiLCJrZXlzIiwia2xlbiIsImsiLCJPYmplY3QiLCJmYW1pbHkiLCJzdHlsZSIsIndlaWdodCIsImxpc3RlbmVycyIsIkVYUEFORE9fS0VZIiwiREVGQVVMVF9LRVkiLCJjb25maWd1cmUiLCJvdmVycmlkZSIsImRhdGFsYWJlbHMiLCJjb25maWdzIiwiZm9yRWFjaCIsImtleSIsIl9rZXkiLCJyZWR1Y2UiLCJ0YXJnZXQiLCJmbiIsImV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIiRjb250ZXh0IiwiZ3JvdXBzIiwiJGdyb3VwcyIsImNhbGxiYWNrJDEiLCJfZGlydHkiLCJkaXNwYXRjaE1vdmVFdmVudHMiLCJwcmV2aW91cyIsImVudGVyIiwibGVhdmUiLCJoYW5kbGVNb3ZlRXZlbnRzIiwiZXhwYW5kbyIsIl9saXN0ZW5lcnMiLCJ0eXBlIiwiX2xhYmVscyIsIl9ob3ZlcmVkIiwiaGFuZGxlQ2xpY2tFdmVudHMiLCJoYW5kbGVycyIsImNsaWNrIiwicGx1Z2luIiwiaWQiLCJiZWZvcmVJbml0IiwiX2FjdGl2ZXMiLCJiZWZvcmVVcGRhdGUiLCJfbGlzdGVuZWQiLCJfZGF0YXNldHMiLCJhZnRlckRhdGFzZXRVcGRhdGUiLCJhcmdzIiwiaXNEYXRhc2V0VmlzaWJsZSIsImVsZW1lbnRzIiwibWV0YSIsImdldERhdGFWaXNpYmlsaXR5Iiwic2tpcCIsImFjdGl2ZSIsImRhdGFJbmRleCIsIm1lcmdlciIsInNvdXJjZSIsImFmdGVyVXBkYXRlIiwiYWZ0ZXJEYXRhc2V0c0RyYXciLCJiZWZvcmVFdmVudCIsImFmdGVyRXZlbnQiLCJhY3RpdmVzIiwiZ2V0QWN0aXZlRWxlbWVudHMiLCJlbGVtZW50IiwicmVuZGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/dist/chart.mjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.mjs ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: function() { return /* binding */ Animation; },\n/* harmony export */   Animations: function() { return /* binding */ Animations; },\n/* harmony export */   ArcElement: function() { return /* binding */ ArcElement; },\n/* harmony export */   BarController: function() { return /* binding */ BarController; },\n/* harmony export */   BarElement: function() { return /* binding */ BarElement; },\n/* harmony export */   BasePlatform: function() { return /* binding */ BasePlatform; },\n/* harmony export */   BasicPlatform: function() { return /* binding */ BasicPlatform; },\n/* harmony export */   BubbleController: function() { return /* binding */ BubbleController; },\n/* harmony export */   CategoryScale: function() { return /* binding */ CategoryScale; },\n/* harmony export */   Chart: function() { return /* binding */ Chart; },\n/* harmony export */   DatasetController: function() { return /* binding */ DatasetController; },\n/* harmony export */   Decimation: function() { return /* binding */ plugin_decimation; },\n/* harmony export */   DomPlatform: function() { return /* binding */ DomPlatform; },\n/* harmony export */   DoughnutController: function() { return /* binding */ DoughnutController; },\n/* harmony export */   Element: function() { return /* binding */ Element; },\n/* harmony export */   Filler: function() { return /* binding */ index; },\n/* harmony export */   Interaction: function() { return /* binding */ Interaction; },\n/* harmony export */   Legend: function() { return /* binding */ plugin_legend; },\n/* harmony export */   LineController: function() { return /* binding */ LineController; },\n/* harmony export */   LineElement: function() { return /* binding */ LineElement; },\n/* harmony export */   LinearScale: function() { return /* binding */ LinearScale; },\n/* harmony export */   LogarithmicScale: function() { return /* binding */ LogarithmicScale; },\n/* harmony export */   PieController: function() { return /* binding */ PieController; },\n/* harmony export */   PointElement: function() { return /* binding */ PointElement; },\n/* harmony export */   PolarAreaController: function() { return /* binding */ PolarAreaController; },\n/* harmony export */   RadarController: function() { return /* binding */ RadarController; },\n/* harmony export */   RadialLinearScale: function() { return /* binding */ RadialLinearScale; },\n/* harmony export */   Scale: function() { return /* binding */ Scale; },\n/* harmony export */   ScatterController: function() { return /* binding */ ScatterController; },\n/* harmony export */   SubTitle: function() { return /* binding */ plugin_subtitle; },\n/* harmony export */   Ticks: function() { return /* binding */ Ticks; },\n/* harmony export */   TimeScale: function() { return /* binding */ TimeScale; },\n/* harmony export */   TimeSeriesScale: function() { return /* binding */ TimeSeriesScale; },\n/* harmony export */   Title: function() { return /* binding */ plugin_title; },\n/* harmony export */   Tooltip: function() { return /* binding */ plugin_tooltip; },\n/* harmony export */   _adapters: function() { return /* binding */ adapters; },\n/* harmony export */   _detectPlatform: function() { return /* binding */ _detectPlatform; },\n/* harmony export */   animator: function() { return /* binding */ animator; },\n/* harmony export */   controllers: function() { return /* binding */ controllers; },\n/* harmony export */   defaults: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d; },\n/* harmony export */   elements: function() { return /* binding */ elements; },\n/* harmony export */   layouts: function() { return /* binding */ layouts; },\n/* harmony export */   plugins: function() { return /* binding */ plugins; },\n/* harmony export */   registerables: function() { return /* binding */ registerables; },\n/* harmony export */   registry: function() { return /* binding */ registry; },\n/* harmony export */   scales: function() { return /* binding */ scales; }\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update() {\n        let date = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, \"progress\");\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, \"complete\");\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), \"complete\");\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n}\nvar animator = new Animator();\nconst transparent = \"transparent\";\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? \"res\" : \"rej\";\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n}\nconst numbers = [\n    \"x\",\n    \"y\",\n    \"borderWidth\",\n    \"radius\",\n    \"tension\"\n];\nconst colors = [\n    \"color\",\n    \"borderColor\",\n    \"backgroundColor\"\n];\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animation\", {\n    delay: undefined,\n    duration: 1000,\n    easing: \"easeOutQuart\",\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined\n});\nconst animationOptions = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animation\", {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name)=>name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animations\", {\n    colors: {\n        type: \"color\",\n        properties: colors\n    },\n    numbers: {\n        type: \"number\",\n        properties: numbers\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animations\", {\n    _fallback: \"animation\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"transitions\", {\n    active: {\n        animation: {\n            duration: 400\n        }\n    },\n    resize: {\n        animation: {\n            duration: 0\n        }\n    },\n    show: {\n        animations: {\n            colors: {\n                from: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                duration: 0\n            }\n        }\n    },\n    hide: {\n        animations: {\n            colors: {\n                to: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                easing: \"linear\",\n                fn: (v)=>v | 0\n            }\n        }\n    }\n});\nclass Animations {\n    configure(config) {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === \"$\") {\n                continue;\n            }\n            if (prop === \"options\") {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex) {\n    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    const keys = stack.keys;\n    const singleMode = options.mode === \"single\";\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data) {\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            x: key,\n            y: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return \"\".concat(indexScale.id, \".\").concat(valueScale.id, \".\").concat(meta.stack || meta.type);\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: \"default\",\n        type: \"dataset\"\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: \"default\",\n        type: \"data\"\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === \"reset\" || mode === \"none\";\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === \"x\" ? x : axis === \"r\" ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n        const yid = meta.yAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n        const rid = meta.rAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update(\"reset\");\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            this._data = convertObjectDataToArray(data);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n            value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || \"default\");\n        meta._clip = toClip((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? \"active\" : \"default\";\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType) {\n        let mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"default\", index = arguments.length > 2 ? arguments[2] : void 0;\n        const active = mode === \"active\";\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + \"-\" + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            \"\".concat(elementType, \"Hover\"),\n            \"hover\",\n            elementType,\n            \"\"\n        ] : [\n            elementType,\n            \"\"\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = \"animation-\".concat(transition);\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count) {\n        let resetNewElements = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, \"reset\");\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            \"_insertElements\",\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            \"_removeElements\",\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            \"_removeElements\",\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                \"_removeElements\",\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                \"_insertElements\",\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            \"_insertElements\",\n            0,\n            arguments.length\n        ]);\n    }\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.initialize();\n    }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = \"left\";\n        end = \"right\";\n    } else {\n        reverse = properties.base < properties.y;\n        start = \"bottom\";\n        end = \"top\";\n    }\n    if (reverse) {\n        top = \"end\";\n        bottom = \"start\";\n    } else {\n        top = \"start\";\n        bottom = \"end\";\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === \"middle\" && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, param, ratio) {\n    let { inflateAmount } = param;\n    properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const skipNull = (meta)=>{\n            const parsed = meta.controller.getParsed(dataIndex);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nBarController.id = \"bar\";\nBarController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"base\",\n                \"width\",\n                \"height\"\n            ]\n        }\n    }\n};\nBarController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\",\n            offset: true,\n            grid: {\n                offset: true\n            }\n        },\n        _value_: {\n            type: \"linear\",\n            beginAtZero: true\n        }\n    }\n};\nclass BubbleController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: meta.label,\n            value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== \"active\") {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nBubbleController.id = \"bubble\";\nBubbleController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"borderWidth\",\n                \"radius\"\n            ]\n        }\n    }\n};\nBubbleController.overrides = {\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                }\n            }\n        }\n    }\n};\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = \"value\" } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== \"inner\") {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n}\nDoughnutController.id = \"doughnut\";\nDoughnutController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: false\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"circumference\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"startAngle\",\n                \"x\",\n                \"y\",\n                \"offset\",\n                \"borderWidth\",\n                \"spacing\"\n            ]\n        }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n};\nDoughnutController.descriptors = {\n    _scriptable: (name)=>name !== \"spacing\",\n    _indexable: (name)=>name !== \"spacing\"\n};\nDoughnutController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (tooltipItem) {\n                    let dataLabel = tooltipItem.label;\n                    const value = \": \" + tooltipItem.formattedValue;\n                    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(dataLabel)) {\n                        dataLabel = dataLabel.slice();\n                        dataLabel[0] += value;\n                    } else {\n                        dataLabel += value;\n                    }\n                    return dataLabel;\n                }\n            }\n        }\n    }\n};\nclass LineController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nLineController.id = \"line\";\nLineController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n};\nLineController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\"\n        },\n        _value_: {\n            type: \"linear\"\n        }\n    }\n};\nclass PolarAreaController extends DatasetController {\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n}\nPolarAreaController.id = \"polarArea\";\nPolarAreaController.defaults = {\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: true\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\"\n            ]\n        }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n};\nPolarAreaController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (context) {\n                    return context.chart.data.labels[context.dataIndex] + \": \" + context.formattedValue;\n                }\n            }\n        }\n    },\n    scales: {\n        r: {\n            type: \"radialLinear\",\n            angleLines: {\n                display: false\n            },\n            beginAtZero: true,\n            grid: {\n                circular: true\n            },\n            pointLabels: {\n                display: false\n            },\n            startAngle: 0\n        }\n    }\n};\nclass PieController extends DoughnutController {\n}\nPieController.id = \"pie\";\nPieController.defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n};\nclass RadarController extends DatasetController {\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== \"resize\") {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === \"reset\";\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nRadarController.id = \"radar\";\nRadarController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n        line: {\n            fill: \"start\"\n        }\n    }\n};\nRadarController.overrides = {\n    aspectRatio: 1,\n    scales: {\n        r: {\n            type: \"radialLinear\"\n        }\n    }\n};\nclass Element {\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n    constructor(){\n        this.x = undefined;\n        this.y = undefined;\n        this.active = false;\n        this.options = undefined;\n        this.$animations = undefined;\n    }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\nconst formatters = {\n    values (value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value) ? value : \"\" + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = \"scientific\";\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(Math.abs(delta));\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const remain = tickValue / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickValue)));\n        if (remain === 1 || remain === 2 || remain === 5) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return \"\";\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"scale\", {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: \"ticks\",\n    grace: 0,\n    grid: {\n        display: true,\n        lineWidth: 1,\n        drawBorder: true,\n        drawOnChartArea: true,\n        drawTicks: true,\n        tickLength: 8,\n        tickWidth: (_ctx, options)=>options.lineWidth,\n        tickColor: (_ctx, options)=>options.color,\n        offset: false,\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderWidth: 1\n    },\n    title: {\n        display: false,\n        text: \"\",\n        padding: {\n            top: 4,\n            bottom: 4\n        }\n    },\n    ticks: {\n        minRotation: 0,\n        maxRotation: 50,\n        mirror: false,\n        textStrokeWidth: 0,\n        textStrokeColor: \"\",\n        padding: 3,\n        display: true,\n        autoSkip: true,\n        autoSkipPadding: 3,\n        labelOffset: 0,\n        callback: Ticks.formatters.values,\n        minor: {},\n        major: {},\n        align: \"center\",\n        crossAlign: \"near\",\n        showLabelBackdrop: false,\n        backdropColor: \"rgba(255, 255, 255, 0.75)\",\n        backdropPadding: 2\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.ticks\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.title\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale\", {\n    _fallback: false,\n    _scriptable: (name)=>!name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"tickBorderDash\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scales\", {\n    _fallback: \"scale\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale.ticks\", {\n    _scriptable: (name)=>name !== \"backdropPadding\" && name !== \"callback\",\n    _indexable: (name)=>name !== \"backdropPadding\"\n});\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.font, fallback);\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    const lines = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        scale,\n        type: \"scale\"\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tick,\n        index,\n        type: \"tick\"\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(align);\n    if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === \"center\") {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === \"center\") {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n        rotation = position === \"left\" ? -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, min)),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n        this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = this.ticks.length;\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(Math.min(Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === \"start\") {\n                paddingRight = last.width;\n            } else if (align === \"end\") {\n                paddingLeft = first.width;\n            } else if (align !== \"inner\") {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === \"start\") {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === \"end\") {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === \"top\" || position === \"bottom\" || axis === \"x\";\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; ++i){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I)(this._alignToPixels ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== \"auto\") {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === \"top\") {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === \"bottom\") {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === \"left\") {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === \"right\") {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const optsAtIndex = grid.setContext(this.getContext(i));\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndex.borderDash || [];\n            const borderDashOffset = optsAtIndex.borderDashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = \"middle\";\n        if (position === \"top\") {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"bottom\") {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"left\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === \"right\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === \"y\") {\n            if (align === \"start\") {\n                textBaseline = \"top\";\n            } else if (align === \"end\") {\n                textBaseline = \"bottom\";\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === \"inner\") {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n                    } else {\n                        tickTextAlign = \"center\";\n                    }\n                }\n                if (position === \"top\") {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = y + textOffset - labelPadding.top;\n                let left = x - labelPadding.left;\n                switch(textBaseline){\n                    case \"middle\":\n                        top -= height / 2;\n                        break;\n                    case \"bottom\":\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case \"center\":\n                        left -= width / 2;\n                        break;\n                    case \"right\":\n                        left -= width;\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                rotation,\n                label,\n                font,\n                color,\n                strokeColor,\n                strokeWidth,\n                textOffset,\n                textAlign: tickTextAlign,\n                textBaseline,\n                translation: [\n                    x,\n                    y\n                ],\n                backdrop\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === \"top\" ? \"left\" : \"right\";\n        }\n        let align = \"center\";\n        if (ticks.align === \"start\") {\n            align = \"left\";\n        } else if (ticks.align === \"end\") {\n            align = \"right\";\n        } else if (ticks.align === \"inner\") {\n            align = \"inner\";\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === \"left\") {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x = this.left;\n                }\n            }\n        } else if (position === \"right\") {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = \"right\";\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === \"left\" || position === \"right\") {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === \"top\" || position === \"bottom\") {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { grid } } = this;\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.borderWidth;\n        ctx.strokeStyle = borderOpts.borderColor;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        }\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        let i, ilen;\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            const item = items[i];\n            const tickFont = item.font;\n            const label = item.label;\n            if (item.backdrop) {\n                ctx.fillStyle = item.backdrop.color;\n                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n            }\n            let y = item.textOffset;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, label, 0, y, tickFont, item);\n        }\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(title.font);\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === \"bottom\" || position === \"center\" || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: gz + 1,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + \"AxisID\";\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n}\nclass TypedRegistry {\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + \".\" + id;\n        if (!id) {\n            throw new Error(\"class does not have id: \" + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[id];\n            }\n        }\n    }\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V)(Object.create(null), [\n        parentScope ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split(\".\");\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join(\".\");\n        const parts = routes[property].split(\".\");\n        const targetName = parts.pop();\n        const targetScope = parts.join(\".\");\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return \"id\" in proto && \"defaults\" in proto;\n}\nclass Registry {\n    add() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args);\n    }\n    remove() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args);\n    }\n    addControllers() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.controllers);\n    }\n    addElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.elements);\n    }\n    addPlugins() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.plugins);\n    }\n    addScales() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"register\", args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, \"controller\");\n    }\n    getElement(id) {\n        return this._get(id, this.elements, \"element\");\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, \"plugin\");\n    }\n    getScale(id) {\n        return this._get(id, this.scales, \"scale\");\n    }\n    removeControllers() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.controllers);\n    }\n    removeElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.elements);\n    }\n    removePlugins() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.plugins);\n    }\n    removeScales() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        this._each(\"unregister\", args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W)(method);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"before\" + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"after\" + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n        }\n        return item;\n    }\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n        this.elements = new TypedRegistry(Element, \"elements\");\n        this.plugins = new TypedRegistry(Object, \"plugins\");\n        this.scales = new TypedRegistry(Scale, \"scales\");\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n}\nvar registry = new Registry();\nclass ScatterController extends DatasetController {\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = registry.getElement(\"line\");\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nScatterController.id = \"scatter\";\nScatterController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n};\nScatterController.overrides = {\n    interaction: {\n        mode: \"point\"\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (item) {\n                    return \"(\" + item.label + \", \" + item.formattedValue + \")\";\n                }\n            }\n        }\n    },\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    }\n};\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PolarAreaController: PolarAreaController,\n    PieController: PieController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\nfunction abstract() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nclass DateAdapter {\n    init(chartOptions) {}\n    formats() {\n        return abstract();\n    }\n    parse(value, format) {\n        return abstract();\n    }\n    format(timestamp, format) {\n        return abstract();\n    }\n    add(timestamp, amount, unit) {\n        return abstract();\n    }\n    diff(a, b, unit) {\n        return abstract();\n    }\n    startOf(timestamp, unit, weekday) {\n        return abstract();\n    }\n    endOf(timestamp, unit) {\n        return abstract();\n    }\n    constructor(options){\n        this.options = options || {};\n    }\n}\nDateAdapter.override = function(members) {\n    Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n    _date: DateAdapter\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === \"function\" && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf(\"x\") !== -1;\n    const useY = axis.indexOf(\"y\") !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            \"startAngle\",\n            \"endAngle\"\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"x\";\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    \"left\",\n    \"top\",\n    \"right\",\n    \"bottom\"\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n    const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos(\"top\");\n    chartArea.x += updatePos(\"left\");\n    updatePos(\"right\");\n    updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        \"left\",\n        \"right\"\n    ]) : marginForPositions([\n        \"top\",\n        \"bottom\"\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"layout\", {\n    autoPadding: true,\n    padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    }\n});\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || \"top\";\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === \"function\") {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext(\"2d\") || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = \"$chartjs\";\nconst EVENT_TYPES = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n};\nconst isNullOrEmpty = (value)=>value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute(\"height\");\n    const renderWidth = canvas.getAttribute(\"width\");\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || \"block\";\n    style.boxSizing = style.boxSizing || \"border-box\";\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"width\");\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === \"\") {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"height\");\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5 ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener(\"resize\", onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener(\"resize\", onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === \"resize\") {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart, (args)=>{\n        const event = args[0];\n        return [\n            event,\n            event.offsetX,\n            event.offsetY\n        ];\n    });\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            \"height\",\n            \"width\"\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass PluginService {\n    notify(chart, hook, args, filter) {\n        if (hook === \"beforeInit\") {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, \"install\");\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === \"afterDestroy\") {\n            this._notify(descriptors, chart, \"stop\");\n            this._notify(this._init, chart, \"uninstall\");\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, \"stop\");\n        this._notify(diff(descriptors, previousDescriptors), chart, \"start\");\n    }\n    constructor(){\n        this._init = [];\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, param, options, all) {\n    let { plugins, localIds } = param;\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, param, opts, context) {\n    let { plugin, local } = param;\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        \"\"\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === \"_index_\") {\n        axis = indexAxis;\n    } else if (id === \"_value_\") {\n        axis = indexAxis === \"x\" ? \"y\" : \"x\";\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction axisFromPosition(position) {\n    if (position === \"top\" || position === \"bottom\") {\n        return \"x\";\n    }\n    if (position === \"left\" || position === \"right\") {\n        return \"y\";\n    }\n}\nfunction determineAxis(id, scaleOptions) {\n    if (id === \"x\" || id === \"y\") {\n        return id;\n    }\n    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const firstIDs = Object.create(null);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(\"Invalid scale configuration for scale: \".concat(id));\n        }\n        if (scaleConf._proxy) {\n            return console.warn(\"Ignoring resolver passed as options for scale: \".concat(id));\n        }\n        const axis = determineAxis(id, scaleConf);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        firstIDs[axis] = firstIDs[axis] || id;\n        scales[id] = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + \"AxisID\"] || firstIDs[axis] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scale, [\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    \"datasets.\".concat(datasetType),\n                    \"\"\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(\"\".concat(datasetType, \".transition.\").concat(transition), ()=>[\n                [\n                    \"datasets.\".concat(datasetType, \".transitions.\").concat(transition),\n                    \"transitions.\".concat(transition)\n                ],\n                [\n                    \"datasets.\".concat(datasetType),\n                    \"\"\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(\"\".concat(datasetType, \"-\").concat(elementType), ()=>[\n                [\n                    \"datasets.\".concat(datasetType, \".elements.\").concat(elementType),\n                    \"datasets.\".concat(datasetType),\n                    \"elements.\".concat(elementType),\n                    \"\"\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(\"\".concat(type, \"-plugin-\").concat(id), ()=>[\n                [\n                    \"plugins.\".concat(id),\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {},\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7\n        ];\n    }\n    resolveNamedOptions(scopes, names, context) {\n        let prefixes = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [\n            \"\"\n        ];\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context) {\n        let prefixes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [\n            \"\"\n        ], descriptorDefaults = arguments.length > 3 ? arguments[3] : void 0;\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes(\"hover\"))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value[key]), false);\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"3.9.1\";\nconst KNOWN_POSITIONS = [\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"chartArea\"\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins(\"afterRender\");\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() && typeof item === \"string\") {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === \"mouseout\") {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    _initialize() {\n        this.notifyPlugins(\"beforeInit\");\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins(\"afterInit\");\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? \"resize\" : \"attach\";\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins(\"resize\", {\n            size: newSize\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === \"r\";\n                const isHorizontal = axis === \"x\";\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n                    dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n                };\n            }));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = \"\" + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass.prototype, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins(\"reset\");\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins(\"beforeUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins(\"beforeElementsUpdate\");\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins(\"afterUpdate\", {\n            mode\n        });\n        this._layers.sort(compare2Level(\"z\", \"_idx\"));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === \"_removeElements\" ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + \",\" + c.splice(1).join(\",\")));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(\",\")).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins(\"beforeLayout\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.boxes, (box)=>{\n            if (noArea && box.position === \"chartArea\") {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetUpdate\", args);\n    }\n    render() {\n        if (this.notifyPlugins(\"beforeRender\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resize(width, height);\n            this._resizeBeforeDraw = null;\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins(\"beforeDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = this.chartArea;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n            return;\n        }\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetDraw\", args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === \"function\") {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(null, {\n            chart: this,\n            type: \"chart\"\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? \"show\" : \"hide\";\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins(\"beforeDestroy\");\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        this.notifyPlugins(\"destroy\");\n        delete instances[this.id];\n        this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove(\"attach\", attached);\n            this.attached = true;\n            this.resize();\n            _add(\"resize\", listener);\n            _add(\"detach\", detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove(\"resize\", listener);\n            this._stop();\n            this._resize(0, 0);\n            _add(\"attach\", attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? \"set\" : \"remove\";\n        let meta, item, i, ilen;\n        if (mode === \"dataset\") {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map((param)=>{\n            let { datasetIndex, index } = param;\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"No dataset found at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterEvent\", args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"'\" + \" must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, \"complete\", onAnimationsComplete);\n        animator.listen(this, \"progress\", onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n}\nconst invalidatePlugins = ()=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(Chart.instances, (chart)=>chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n    defaults: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d\n    },\n    instances: {\n        enumerable,\n        value: instances\n    },\n    overrides: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U\n    },\n    registry: {\n        enumerable,\n        value: registry\n    },\n    version: {\n        enumerable,\n        value: version\n    },\n    getChart: {\n        enumerable,\n        value: getChart\n    },\n    register: {\n        enumerable,\n        value: function() {\n            for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){\n                items[_key] = arguments[_key];\n            }\n            registry.add(...items);\n            invalidatePlugins();\n        }\n    },\n    unregister: {\n        enumerable,\n        value: function() {\n            for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){\n                items[_key] = arguments[_key];\n            }\n            registry.remove(...items);\n            invalidatePlugins();\n        }\n    }\n});\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al)(value, [\n        \"outerStart\",\n        \"outerEnd\",\n        \"innerStart\",\n        \"innerEnd\"\n    ]);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerEnd, 0, innerLimit)\n    };\n}\nfunction rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            if (circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T === 0) {\n                endAngle += _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            }\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n    const { x, y, startAngle, pixelMargin, fullCircles } = element;\n    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n    const innerRadius = element.innerRadius + pixelMargin;\n    let i;\n    if (inner) {\n        clipArc(ctx, element, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, startAngle, true);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n    const { options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const inner = options.borderAlign === \"inner\";\n    if (!borderWidth) {\n        return;\n    }\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || \"round\";\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || \"bevel\";\n    }\n    if (element.fullCircles) {\n        drawFullCircleBorders(ctx, element, inner);\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n}\nclass ArcElement extends Element {\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const rAdjust = this.options.spacing / 2;\n        const _circumference = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const betweenAngles = _circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle);\n        const withinRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            \"x\",\n            \"y\",\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 2;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        let radiusOffset = 0;\n        if (offset) {\n            radiusOffset = offset / 2;\n            const halfAngle = (this.startAngle + this.endAngle) / 2;\n            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n            if (this.circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) {\n                radiusOffset = offset;\n            }\n        }\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n        ctx.restore();\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nArcElement.id = \"arc\";\nArcElement.defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true\n};\nArcElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n};\nfunction setStyle(ctx, options) {\n    let style = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : options;\n    ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment) {\n    let params = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nLineElement.id = \"line\";\nLineElement.defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n};\nLineElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nLineElement.descriptors = {\n    _scriptable: true,\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"fill\"\n};\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, \"x\", useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, \"y\", useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        return options.radius + options.hitRadius;\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nPointElement.id = \"point\";\nPointElement.defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n};\nPointElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        \"x\",\n        \"y\",\n        \"base\",\n        \"width\",\n        \"height\"\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        \"enableBorderRadius\"\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount) {\n    let refRect = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill(\"evenodd\");\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"horizontal\"\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === \"x\" ? this.width / 2 : this.height / 2;\n    }\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n}\nBarElement.id = \"bar\";\nBarElement.defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    LineElement: LineElement,\n    PointElement: PointElement,\n    BarElement: BarElement\n});\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, \"data\", {\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: \"decimation\",\n    defaults: {\n        algorithm: \"min-max\",\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === \"y\") {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, \"data\", {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case \"lttb\":\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case \"min-max\":\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(\"Unsupported decimation algorithm '\".concat(options.algorithm, \"'\"));\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === \"angle\") {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(start);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach((param)=>{\n        let { start, end } = param;\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        \"origin\",\n        \"start\",\n        \"end\",\n        \"stack\",\n        \"shape\"\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === \"-\" || firstCh === \"+\") {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === \"start\") {\n        pixel = scale.bottom;\n    } else if (fill === \"end\") {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === \"start\") {\n        value = startValue;\n    } else if (fill === \"end\") {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return \"origin\";\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas(\"line\");\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, \"x\");\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === \"stack\") {\n        return _buildStackLine(source);\n    }\n    if (fill === \"shape\") {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    if (target && line.points.length) {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale } = cfg;\n    const property = line._loop ? \"angle\" : cfg.axis;\n    ctx.save();\n    if (property === \"x\" && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top, bottom } = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === \"x\") {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: \"filler\",\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === \"beforeDraw\";\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== \"beforeDatasetsDraw\") {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: \"beforeDatasetDraw\"\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"middle\";\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const { color: fontColor, padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign(\"left\");\n        ctx.textBaseline = \"middle\";\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, \"butt\");\n            ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, \"miter\");\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor || fontColor;\n            ctx.fillStyle = legendItem.fontColor || fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(position));\n        ctx.textBaseline = \"middle\";\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n}\nfunction isListened(type, opts) {\n    if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: \"legend\",\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: \"top\",\n        align: \"center\",\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: 0,\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: \"center\",\n            text: \"\"\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith(\"on\"),\n        labels: {\n            _scriptable: (name)=>![\n                    \"generateLabels\",\n                    \"filter\",\n                    \"sort\"\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === \"top\" || pos === \"bottom\";\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === \"left\") {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, top, bottom);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(opts.align),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: \"title\",\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"bold\"\n        },\n        fullSize: true,\n        padding: 10,\n        position: \"top\",\n        text: \"\",\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: \"subtitle\",\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"normal\"\n        },\n        fullSize: true,\n        padding: 0,\n        position: \"top\",\n        text: \"\",\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let x = 0;\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                x += pos.x;\n                y += pos.y;\n                ++count;\n            }\n        }\n        return {\n            x: x / count,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n        return str.split(\"\\n\");\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(body, (bodyItem)=>{\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return \"top\";\n    } else if (y > chart.height - height / 2) {\n        return \"bottom\";\n    }\n    return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === \"left\" && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === \"right\" && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = \"center\";\n    if (yAlign === \"center\") {\n        xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n    } else if (x <= width / 2) {\n        xAlign = \"left\";\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = \"right\";\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = \"center\";\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === \"right\") {\n        x -= width;\n    } else if (xAlign === \"center\") {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === \"top\") {\n        y += paddingAndSize;\n    } else if (yAlign === \"bottom\") {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === \"center\") {\n        if (xAlign === \"left\") {\n            x += paddingAndSize;\n        } else if (xAlign === \"right\") {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === \"left\") {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === \"right\") {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tooltip,\n        tooltipItems,\n        type: \"tooltip\"\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = callbacks.beforeTitle.apply(this, [\n            context\n        ]);\n        const title = callbacks.title.apply(this, [\n            context\n        ]);\n        const afterTitle = callbacks.afterTitle.apply(this, [\n            context\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n            pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = callbacks.beforeFooter.apply(this, [\n            tooltipItems\n        ]);\n        const footer = callbacks.footer.apply(this, [\n            tooltipItems\n        ]);\n        const afterFooter = callbacks.afterFooter.apply(this, [\n            tooltipItems\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(scoped.labelColor.call(this, context));\n            labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n            labelTextColors.push(scoped.labelTextColor.call(this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === \"center\") {\n            y2 = ptY + height / 2;\n            if (xAlign === \"left\") {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === \"left\") {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === \"right\") {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === \"top\") {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = \"middle\";\n            titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColors = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        const colorX = getAlignedX(this, \"left\", options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.fillStyle = labelColors.backgroundColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.setLineDash(labelColors.borderDash || []);\n            ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(labelColors.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = \"middle\";\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = \"middle\";\n            footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === \"top\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === \"center\" && xAlign === \"right\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === \"bottom\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === \"center\" && xAlign === \"left\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map((param)=>{\n            let { datasetIndex, index } = param;\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay) {\n        let inChartArea = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart || config._chart;\n        this._chart = this.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n    id: \"tooltip\",\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins(\"beforeTooltipDraw\", args) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins(\"afterTooltipDraw\", args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n            weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: \"easeOutQuart\"\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"width\",\n                    \"height\",\n                    \"caretX\",\n                    \"caretY\"\n                ]\n            },\n            opacity: {\n                easing: \"linear\",\n                duration: 200\n            }\n        },\n        callbacks: {\n            beforeTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            title (tooltipItems) {\n                if (tooltipItems.length > 0) {\n                    const item = tooltipItems[0];\n                    const labels = item.chart.data.labels;\n                    const labelCount = labels ? labels.length : 0;\n                    if (this && this.options && this.options.mode === \"dataset\") {\n                        return item.dataset.label || \"\";\n                    } else if (item.label) {\n                        return item.label;\n                    } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                        return labels[item.dataIndex];\n                    }\n                }\n                return \"\";\n            },\n            afterTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            label (tooltipItem) {\n                if (this && this.options && this.options.mode === \"dataset\") {\n                    return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n                }\n                let label = tooltipItem.dataset.label || \"\";\n                if (label) {\n                    label += \": \";\n                }\n                const value = tooltipItem.formattedValue;\n                if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                    label += value;\n                }\n                return label;\n            },\n            labelColor (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    borderColor: options.borderColor,\n                    backgroundColor: options.backgroundColor,\n                    borderWidth: options.borderWidth,\n                    borderDash: options.borderDash,\n                    borderDashOffset: options.borderDashOffset,\n                    borderRadius: 0\n                };\n            },\n            labelTextColor () {\n                return this.options.bodyColor;\n            },\n            labelPointStyle (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    pointStyle: options.pointStyle,\n                    rotation: options.rotation\n                };\n            },\n            afterLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            footer: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF\n        }\n    },\n    defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: \"animation\"\n        }\n    },\n    additionalOptionScopes: [\n        \"interaction\"\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === \"string\") {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === \"ticks\") {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        const labels = this.getLabels();\n        if (value >= 0 && value < labels.length) {\n            return labels[value];\n        }\n        return value;\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== \"number\") {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n}\nCategoryScale.id = \"category\";\nCategoryScale.defaults = {\n    ticks: {\n        callback: CategoryScale.prototype.getLabelForValue\n    }\n};\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === \"ticks\") {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        ticks.push({\n            value: Math.round((niceMin + j * spacing) * factor) / factor\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, param) {\n    let { horizontal, minRotation } = param;\n    const rad = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * (\"\" + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = 1;\n            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n                offset = Math.abs(max * 0.05);\n            }\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(\"scales.\".concat(this.id, \".ticks.stepSize: \").concat(stepSize, \" would result generating up to \").concat(maxTicks, \" ticks. Limiting to 1000.\"));\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nLinearScale.id = \"linear\";\nLinearScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.numeric\n    }\n};\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal)));\n    return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n    const endExp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.max));\n    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n    const ticks = [];\n    let tickVal = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.min, Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.min))));\n    let exp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal));\n    let significand = Math.floor(tickVal / Math.pow(10, exp));\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    do {\n        ticks.push({\n            value: tickVal,\n            major: isMajor(tickVal)\n        });\n        ++significand;\n        if (significand === 10) {\n            significand = 1;\n            ++exp;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n    }while (exp < endExp || exp === endExp && significand < endSignificand);\n    const lastTick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.max, tickVal);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(tickVal)\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        const exp = (v, m)=>Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(v)) + m);\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(exp(min, -1));\n                setMax(exp(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(exp(max, -1));\n        }\n        if (max <= 0) {\n            setMax(exp(min, +1));\n        }\n        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n            setMin(exp(min, -1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? \"0\" : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n        this._valueRange = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(this.max) - (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n}\nLogarithmicScale.id = \"logarithmic\";\nLogarithmicScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.logarithmic,\n        major: {\n            enabled: true\n        }\n    }\n};\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const extra = getTickBackdropHeight(opts) / 2;\n    const outerDistance = scale.drawingArea;\n    const additionalAngle = opts.pointLabels.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(pointLabelPosition.angle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H)));\n        const size = labelSizes[i];\n        const y = yForAngle(pointLabelPosition.y, size.h, angle);\n        const textAlign = getTextAlignForAngle(angle);\n        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n        items.push({\n            x: pointLabelPosition.x,\n            y,\n            textAlign,\n            left,\n            top: y,\n            right: left + size.w,\n            bottom: y + size.h\n        });\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return \"center\";\n    } else if (angle < 180) {\n        return \"left\";\n    }\n    return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === \"right\") {\n        x -= w;\n    } else if (align === \"center\") {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n        const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];\n        const { backdropColor } = optsAtIndex;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(optsAtIndex.borderRadius);\n            const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n            ctx.fillStyle = backdropColor;\n            const backdropLeft = left - padding.left;\n            const backdropTop = top - padding.top;\n            const backdropWidth = right - left + padding.width;\n            const backdropHeight = bottom - top + padding.height;\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: backdropLeft,\n                    y: backdropTop,\n                    w: backdropWidth,\n                    h: backdropHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n            }\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: \"middle\"\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(gridLineOpts.borderDash);\n    ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        label,\n        index,\n        type: \"pointLabel\"\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : \"\";\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(index * angleMultiplier + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter) {\n        let additionalAngle = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;\n        const angle = this.getIndexAngle(index) - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const optsAtIndex = grid.setContext(this.getContext(index - 1));\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n}\nRadialLinearScale.id = \"radialLinear\";\nRadialLinearScale.defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n        display: true,\n        lineWidth: 1,\n        borderDash: [],\n        borderDashOffset: 0.0\n    },\n    grid: {\n        circular: false\n    },\n    startAngle: 0,\n    ticks: {\n        showLabelBackdrop: true,\n        callback: Ticks.formatters.numeric\n    },\n    pointLabels: {\n        backdropColor: undefined,\n        backdropPadding: 2,\n        display: true,\n        font: {\n            size: 10\n        },\n        callback (label) {\n            return label;\n        },\n        padding: 5,\n        centerPointLabels: false\n    }\n};\nRadialLinearScale.defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n};\nRadialLinearScale.descriptors = {\n    angleLines: {\n        _fallback: \"grid\"\n    }\n};\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === \"function\") {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === \"week\" && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    init(scaleOpts, opts) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || \"day\";\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === \"ticks\" && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets(timestamps) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(start, 0, limit);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(timeOpts.stepSize, 1);\n        const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, \"isoWeek\", weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n        }\n        const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === \"ticks\" || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort((a, b)=>a - b).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n        const formatter = options.ticks.callback;\n        return formatter ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(formatter, [\n            label,\n            index,\n            ticks\n        ], this) : label;\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = \"day\";\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n}\nTimeScale.id = \"time\";\nTimeScale.defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n        parser: false,\n        unit: false,\n        round: false,\n        isoWeekday: false,\n        minUnit: \"millisecond\",\n        displayFormats: {}\n    },\n    ticks: {\n        source: \"auto\",\n        major: {\n            enabled: false\n        }\n    }\n};\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"pos\", val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"time\", val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n}\nTimeSeriesScale.id = \"timeseries\";\nTimeSeriesScale.defaults = TimeScale.defaults;\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ29rRTtBQUN4Z0U7QUFFN0QsTUFBTWtOO0lBT0pDLFFBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNoQyxNQUFNQyxZQUFZSCxNQUFNSSxTQUFTLENBQUNGLEtBQUs7UUFDdkMsTUFBTUcsV0FBV0wsTUFBTU0sUUFBUTtRQUMvQkgsVUFBVUksT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHO2dCQUN6QlQ7Z0JBQ0FVLFNBQVNULE1BQU1TLE9BQU87Z0JBQ3RCSjtnQkFDQUssYUFBYUMsS0FBS0MsR0FBRyxDQUFDWCxPQUFPRCxNQUFNYSxLQUFLLEVBQUVSO1lBQzVDO0lBQ0Y7SUFDQVMsV0FBVztRQUNULElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQUU7WUFDakI7UUFDRjtRQUNBLElBQUksQ0FBQ0MsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0QsUUFBUSxHQUFHbk8sMERBQWdCQSxDQUFDcU8sSUFBSSxDQUFDQyxRQUFRO1lBQzVDLElBQUksQ0FBQ0MsT0FBTztZQUNaLElBQUksQ0FBQ0osUUFBUSxHQUFHO1lBQ2hCLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQUU7Z0JBQ2pCLElBQUksQ0FBQ0YsUUFBUTtZQUNmO1FBQ0Y7SUFDRjtJQUNBSyxVQUEyQjtZQUFuQmxCLE9BQUFBLGlFQUFPbUIsS0FBS0MsR0FBRztRQUNyQixJQUFJQyxZQUFZO1FBQ2hCLElBQUksQ0FBQ0MsT0FBTyxDQUFDaEIsT0FBTyxDQUFDLENBQUNQLE9BQU9EO1lBQzNCLElBQUksQ0FBQ0MsTUFBTXdCLE9BQU8sSUFBSSxDQUFDeEIsTUFBTXlCLEtBQUssQ0FBQ0MsTUFBTSxFQUFFO2dCQUN6QztZ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S0FBSyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQ2l4QyxZQUFZLElBQUksQ0FBQ3FoQixNQUFNLEVBQUV0eUQsU0FBUyxJQUFJLENBQUN3eUQsT0FBTyxJQUFJLElBQUksQ0FBQ0MsV0FBVztJQUM1RTtJQUNBcG9DLGlCQUFpQkMsS0FBSyxFQUFFO1FBQ3RCLE1BQU04bUMsVUFBVSxJQUFJLENBQUNULFFBQVE7UUFDN0IsTUFBTXBtQyxVQUFVLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNGLFNBQVM4bUMsUUFBUTkxRCxNQUFNLEdBQUc4MUQsUUFBUXp3RCxHQUFHO1FBQzdFLE9BQU9zd0MsWUFBWSxJQUFJLENBQUNxaEIsTUFBTSxFQUFFL25DLFVBQVUsSUFBSSxDQUFDa29DLFdBQVcsR0FBRyxJQUFJLENBQUNELE9BQU8sRUFBRTtJQUM3RTtJQTlEQTMzRCxZQUFZaUYsS0FBSyxDQUFFO1FBQ2pCLEtBQUssQ0FBQ0E7UUFDTixJQUFJLENBQUN3eUQsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDRSxPQUFPLEdBQUd6M0Q7UUFDZixJQUFJLENBQUMwM0QsV0FBVyxHQUFHMTNEO0lBQ3JCO0FBMERGO0FBQ0FxM0QsZ0JBQWdCeHZELEVBQUUsR0FBRztBQUNyQnd2RCxnQkFBZ0IxbkUsUUFBUSxHQUFHa2xFLFVBQVVsbEUsUUFBUTtBQUU3QyxJQUFJK1osU0FBUyxXQUFXLEdBQUUzRyxPQUFPc08sTUFBTSxDQUFDO0lBQ3hDZ21CLFdBQVc7SUFDWHExQixlQUFlQTtJQUNmc0MsYUFBYUE7SUFDYlMsa0JBQWtCQTtJQUNsQnFDLG1CQUFtQkE7SUFDbkIrQyxXQUFXQTtJQUNYd0MsaUJBQWlCQTtBQUNqQjtBQUVBLE1BQU1NLGdCQUFnQjtJQUNwQjloQztJQUNBOWxCO0lBQ0E2SztJQUNBbFI7Q0FDRDtBQUUyckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2hhcnQubWpzP2JjMTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5pbXBvcnQgeyByIGFzIHJlcXVlc3RBbmltRnJhbWUsIGEgYXMgcmVzb2x2ZSwgZSBhcyBlZmZlY3RzLCBjIGFzIGNvbG9yLCBkIGFzIGRlZmF1bHRzLCBpIGFzIGlzT2JqZWN0LCBiIGFzIGlzQXJyYXksIHYgYXMgdmFsdWVPckRlZmF1bHQsIHUgYXMgdW5saXN0ZW5BcnJheUV2ZW50cywgbCBhcyBsaXN0ZW5BcnJheUV2ZW50cywgZiBhcyByZXNvbHZlT2JqZWN0S2V5LCBnIGFzIGlzTnVtYmVyRmluaXRlLCBoIGFzIGNyZWF0ZUNvbnRleHQsIGogYXMgZGVmaW5lZCwgcyBhcyBzaWduLCBrIGFzIGlzTnVsbE9yVW5kZWYsIF8gYXMgX2FycmF5VW5pcXVlLCB0IGFzIHRvUmFkaWFucywgbSBhcyB0b1BlcmNlbnRhZ2UsIG4gYXMgdG9EaW1lbnNpb24sIFQgYXMgVEFVLCBvIGFzIGZvcm1hdE51bWJlciwgcCBhcyBfYW5nbGVCZXR3ZWVuLCBIIGFzIEhBTEZfUEksIFAgYXMgUEksIHEgYXMgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIHcgYXMgX3NjYWxlUmFuZ2VzQ2hhbmdlZCwgeCBhcyBpc051bWJlciwgeSBhcyBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUsIHogYXMgbG9nMTAsIEEgYXMgX2ZhY3Rvcml6ZSwgQiBhcyBmaW5pdGVPckRlZmF1bHQsIEMgYXMgY2FsbGJhY2ssIEQgYXMgX2FkZEdyYWNlLCBFIGFzIF9saW1pdFZhbHVlLCBGIGFzIHRvRGVncmVlcywgRyBhcyBfbWVhc3VyZVRleHQsIEkgYXMgX2ludDE2UmFuZ2UsIEogYXMgX2FsaWduUGl4ZWwsIEsgYXMgdG9QYWRkaW5nLCBMIGFzIGNsaXBBcmVhLCBNIGFzIHJlbmRlclRleHQsIE4gYXMgdW5jbGlwQXJlYSwgTyBhcyB0b0ZvbnQsIFEgYXMgZWFjaCwgUiBhcyBfdG9MZWZ0UmlnaHRDZW50ZXIsIFMgYXMgX2FsaWduU3RhcnRFbmQsIFUgYXMgb3ZlcnJpZGVzLCBWIGFzIG1lcmdlLCBXIGFzIF9jYXBpdGFsaXplLCBYIGFzIGdldFJlbGF0aXZlUG9zaXRpb24sIFkgYXMgX3Jsb29rdXBCeUtleSwgWiBhcyBfbG9va3VwQnlLZXksICQgYXMgX2lzUG9pbnRJbkFyZWEsIGEwIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBhMSBhcyBnZXRNYXhpbXVtU2l6ZSwgYTIgYXMgX2dldFBhcmVudE5vZGUsIGEzIGFzIHJlYWRVc2VkU2l6ZSwgYTQgYXMgdGhyb3R0bGVkLCBhNSBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBhNiBhcyBfaXNEb21TdXBwb3J0ZWQsIGE3IGFzIGRlc2NyaXB0b3JzLCBhOCBhcyBpc0Z1bmN0aW9uLCBhOSBhcyBfYXR0YWNoQ29udGV4dCwgYWEgYXMgX2NyZWF0ZVJlc29sdmVyLCBhYiBhcyBfZGVzY3JpcHRvcnMsIGFjIGFzIG1lcmdlSWYsIGFkIGFzIHVpZCwgYWUgYXMgZGVib3VuY2UsIGFmIGFzIHJldGluYVNjYWxlLCBhZyBhcyBjbGVhckNhbnZhcywgYWggYXMgc2V0c0VxdWFsLCBhaSBhcyBfZWxlbWVudHNFcXVhbCwgYWogYXMgX2lzQ2xpY2tFdmVudCwgYWsgYXMgX2lzQmV0d2VlbiwgYWwgYXMgX3JlYWRWYWx1ZVRvUHJvcHMsIGFtIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhbiBhcyBfY29tcHV0ZVNlZ21lbnRzLCBhbyBhcyBfYm91bmRTZWdtZW50cywgYXAgYXMgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLCBhcSBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYXIgYXMgX3BvaW50SW5MaW5lLCBhcyBhcyBfc3RlcHBlZExpbmVUbywgYXQgYXMgX2JlemllckN1cnZlVG8sIGF1IGFzIGRyYXdQb2ludCwgYXYgYXMgYWRkUm91bmRlZFJlY3RQYXRoLCBhdyBhcyB0b1RSQkwsIGF4IGFzIHRvVFJCTENvcm5lcnMsIGF5IGFzIF9ib3VuZFNlZ21lbnQsIGF6IGFzIF9ub3JtYWxpemVBbmdsZSwgYUEgYXMgZ2V0UnRsQWRhcHRlciwgYUIgYXMgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCBhQyBhcyBfdGV4dFgsIGFEIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhRSBhcyBkcmF3UG9pbnRMZWdlbmQsIGFGIGFzIG5vb3AsIGFHIGFzIGRpc3RhbmNlQmV0d2VlblBvaW50cywgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhSSBhcyBuaWNlTnVtLCBhSiBhcyBhbG1vc3RXaG9sZSwgYUsgYXMgYWxtb3N0RXF1YWxzLCBhTCBhcyBfZGVjaW1hbFBsYWNlcywgYU0gYXMgX2xvbmdlc3RUZXh0LCBhTiBhcyBfZmlsdGVyQmV0d2VlbiwgYU8gYXMgX2xvb2t1cCB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMnO1xuZXhwb3J0IHsgZCBhcyBkZWZhdWx0cyB9IGZyb20gJy4vY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanMnO1xuXG5jbGFzcyBBbmltYXRvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgIHRoaXMuX2NoYXJ0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fbGFzdERhdGUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsIHR5cGUpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgY29uc3QgbnVtU3RlcHMgPSBhbmltcy5kdXJhdGlvbjtcbiAgICBjYWxsYmFja3MuZm9yRWFjaChmbiA9PiBmbih7XG4gICAgICBjaGFydCxcbiAgICAgIGluaXRpYWw6IGFuaW1zLmluaXRpYWwsXG4gICAgICBudW1TdGVwcyxcbiAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgIH0pKTtcbiAgfVxuICBfcmVmcmVzaCgpIHtcbiAgICBpZiAodGhpcy5fcmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XG4gICAgICAgIHRoaXMuX3JlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgbGV0IHJlbWFpbmluZyA9IDA7XG4gICAgdGhpcy5fY2hhcnRzLmZvckVhY2goKGFuaW1zLCBjaGFydCkgPT4ge1xuICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBkcmF3ID0gZmFsc2U7XG4gICAgICBsZXQgaXRlbTtcbiAgICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgICBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpdGVtLl9hY3RpdmUpIHtcbiAgICAgICAgICBpZiAoaXRlbS5fdG90YWwgPiBhbmltcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgYW5pbXMuZHVyYXRpb24gPSBpdGVtLl90b3RhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbS50aWNrKGRhdGUpO1xuICAgICAgICAgIGRyYXcgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1zW2ldID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNoYXJ0LmRyYXcoKTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICB9XG4gICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICBhbmltcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX25vdGlmeShjaGFydCwgYW5pbXMsIGRhdGUsICdjb21wbGV0ZScpO1xuICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRlID0gZGF0ZTtcbiAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIF9nZXRBbmltcyhjaGFydCkge1xuICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICBsZXQgYW5pbXMgPSBjaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zKSB7XG4gICAgICBhbmltcyA9IHtcbiAgICAgICAgcnVubmluZzogZmFsc2UsXG4gICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgbGlzdGVuZXJzOiB7XG4gICAgICAgICAgY29tcGxldGU6IFtdLFxuICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY2hhcnRzLnNldChjaGFydCwgYW5pbXMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbXM7XG4gIH1cbiAgbGlzdGVuKGNoYXJ0LCBldmVudCwgY2IpIHtcbiAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgfVxuICBhZGQoY2hhcnQsIGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5pdGVtcy5wdXNoKC4uLml0ZW1zKTtcbiAgfVxuICBoYXMoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gIH1cbiAgc3RhcnQoY2hhcnQpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYW5pbXMucnVubmluZyA9IHRydWU7XG4gICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIGFuaW1zLmR1cmF0aW9uID0gYW5pbXMuaXRlbXMucmVkdWNlKChhY2MsIGN1cikgPT4gTWF0aC5tYXgoYWNjLCBjdXIuX2R1cmF0aW9uKSwgMCk7XG4gICAgdGhpcy5fcmVmcmVzaCgpO1xuICB9XG4gIHJ1bm5pbmcoY2hhcnQpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc3RvcChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcyB8fCAhYW5pbXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBpID49IDA7IC0taSkge1xuICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgfVxuICAgIGFuaW1zLml0ZW1zID0gW107XG4gICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gIH1cbiAgcmVtb3ZlKGNoYXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYXJ0cy5kZWxldGUoY2hhcnQpO1xuICB9XG59XG52YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IoKTtcblxuY29uc3QgdHJhbnNwYXJlbnQgPSAndHJhbnNwYXJlbnQnO1xuY29uc3QgaW50ZXJwb2xhdG9ycyA9IHtcbiAgYm9vbGVhbihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgfSxcbiAgY29sb3IoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgY29uc3QgYzEgPSBjMC52YWxpZCAmJiBjb2xvcih0byB8fCB0cmFuc3BhcmVudCk7XG4gICAgcmV0dXJuIGMxICYmIGMxLnZhbGlkXG4gICAgICA/IGMxLm1peChjMCwgZmFjdG9yKS5oZXhTdHJpbmcoKVxuICAgICAgOiB0bztcbiAgfSxcbiAgbnVtYmVyKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICB9XG59O1xuY2xhc3MgQW5pbWF0aW9uIHtcbiAgY29uc3RydWN0b3IoY2ZnLCB0YXJnZXQsIHByb3AsIHRvKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID0gdGFyZ2V0W3Byb3BdO1xuICAgIHRvID0gcmVzb2x2ZShbY2ZnLnRvLCB0bywgY3VycmVudFZhbHVlLCBjZmcuZnJvbV0pO1xuICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5fZm4gPSBjZmcuZm4gfHwgaW50ZXJwb2xhdG9yc1tjZmcudHlwZSB8fCB0eXBlb2YgZnJvbV07XG4gICAgdGhpcy5fZWFzaW5nID0gZWZmZWN0c1tjZmcuZWFzaW5nXSB8fCBlZmZlY3RzLmxpbmVhcjtcbiAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgIHRoaXMuX2R1cmF0aW9uID0gdGhpcy5fdG90YWwgPSBNYXRoLmZsb29yKGNmZy5kdXJhdGlvbik7XG4gICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuX3Byb3AgPSBwcm9wO1xuICAgIHRoaXMuX2Zyb20gPSBmcm9tO1xuICAgIHRoaXMuX3RvID0gdG87XG4gICAgdGhpcy5fcHJvbWlzZXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gIH1cbiAgdXBkYXRlKGNmZywgdG8sIGRhdGUpIHtcbiAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fdGFyZ2V0W3RoaXMuX3Byb3BdO1xuICAgICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICAgIGNvbnN0IHJlbWFpbiA9IHRoaXMuX2R1cmF0aW9uIC0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gZGF0ZTtcbiAgICAgIHRoaXMuX2R1cmF0aW9uID0gTWF0aC5mbG9vcihNYXRoLm1heChyZW1haW4sIGNmZy5kdXJhdGlvbikpO1xuICAgICAgdGhpcy5fdG90YWwgKz0gZWxhcHNlZDtcbiAgICAgIHRoaXMuX2xvb3AgPSAhIWNmZy5sb29wO1xuICAgICAgdGhpcy5fdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgICB0aGlzLl9mcm9tID0gcmVzb2x2ZShbY2ZnLmZyb20sIGN1cnJlbnRWYWx1ZSwgdG9dKTtcbiAgICB9XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMudGljayhEYXRlLm5vdygpKTtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5fbm90aWZ5KGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgdGljayhkYXRlKSB7XG4gICAgY29uc3QgZWxhcHNlZCA9IGRhdGUgLSB0aGlzLl9zdGFydDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX2R1cmF0aW9uO1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLl9mcm9tO1xuICAgIGNvbnN0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgbGV0IGZhY3RvcjtcbiAgICB0aGlzLl9hY3RpdmUgPSBmcm9tICE9PSB0byAmJiAobG9vcCB8fCAoZWxhcHNlZCA8IGR1cmF0aW9uKSk7XG4gICAgaWYgKCF0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IHRvO1xuICAgICAgdGhpcy5fbm90aWZ5KHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZhY3RvciA9IChlbGFwc2VkIC8gZHVyYXRpb24pICUgMjtcbiAgICBmYWN0b3IgPSBsb29wICYmIGZhY3RvciA+IDEgPyAyIC0gZmFjdG9yIDogZmFjdG9yO1xuICAgIGZhY3RvciA9IHRoaXMuX2Vhc2luZyhNYXRoLm1pbigxLCBNYXRoLm1heCgwLCBmYWN0b3IpKSk7XG4gICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gIH1cbiAgd2FpdCgpIHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8ICh0aGlzLl9wcm9taXNlcyA9IFtdKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBwcm9taXNlcy5wdXNoKHtyZXMsIHJlan0pO1xuICAgIH0pO1xuICB9XG4gIF9ub3RpZnkocmVzb2x2ZWQpIHtcbiAgICBjb25zdCBtZXRob2QgPSByZXNvbHZlZCA/ICdyZXMnIDogJ3Jlaic7XG4gICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9taXNlc1tpXVttZXRob2RdKCk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IG51bWJlcnMgPSBbJ3gnLCAneScsICdib3JkZXJXaWR0aCcsICdyYWRpdXMnLCAndGVuc2lvbiddO1xuY29uc3QgY29sb3JzID0gWydjb2xvcicsICdib3JkZXJDb2xvcicsICdiYWNrZ3JvdW5kQ29sb3InXTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9uJywge1xuICBkZWxheTogdW5kZWZpbmVkLFxuICBkdXJhdGlvbjogMTAwMCxcbiAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0JyxcbiAgZm46IHVuZGVmaW5lZCxcbiAgZnJvbTogdW5kZWZpbmVkLFxuICBsb29wOiB1bmRlZmluZWQsXG4gIHRvOiB1bmRlZmluZWQsXG4gIHR5cGU6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnb25Qcm9ncmVzcycgJiYgbmFtZSAhPT0gJ29uQ29tcGxldGUnICYmIG5hbWUgIT09ICdmbicsXG59KTtcbmRlZmF1bHRzLnNldCgnYW5pbWF0aW9ucycsIHtcbiAgY29sb3JzOiB7XG4gICAgdHlwZTogJ2NvbG9yJyxcbiAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgfSxcbiAgbnVtYmVyczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIHByb3BlcnRpZXM6IG51bWJlcnNcbiAgfSxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ2FuaW1hdGlvbnMnLCB7XG4gIF9mYWxsYmFjazogJ2FuaW1hdGlvbicsXG59KTtcbmRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gIGFjdGl2ZToge1xuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMFxuICAgIH1cbiAgfSxcbiAgcmVzaXplOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogMFxuICAgIH1cbiAgfSxcbiAgc2hvdzoge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICBmcm9tOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICB9LFxuICAgIH1cbiAgfSxcbiAgaGlkZToge1xuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIGNvbG9yczoge1xuICAgICAgICB0bzogJ3RyYW5zcGFyZW50J1xuICAgICAgfSxcbiAgICAgIHZpc2libGU6IHtcbiAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICBlYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICBmbjogdiA9PiB2IHwgMFxuICAgICAgfSxcbiAgICB9XG4gIH1cbn0pO1xuY2xhc3MgQW5pbWF0aW9ucyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjb25maWcpIHtcbiAgICB0aGlzLl9jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25maWd1cmUoY29uZmlnKTtcbiAgfVxuICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNvbmZpZykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgY2ZnID0gY29uZmlnW2tleV07XG4gICAgICBpZiAoIWlzT2JqZWN0KGNmZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgcmVzb2x2ZWRbb3B0aW9uXSA9IGNmZ1tvcHRpb25dO1xuICAgICAgfVxuICAgICAgKGlzQXJyYXkoY2ZnLnByb3BlcnRpZXMpICYmIGNmZy5wcm9wZXJ0aWVzIHx8IFtrZXldKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgYW5pbWF0ZWRQcm9wcy5zZXQocHJvcCwgcmVzb2x2ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHJlc29sdmVUYXJnZXRPcHRpb25zKHRhcmdldCwgbmV3T3B0aW9ucyk7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSB0aGlzLl9jcmVhdGVBbmltYXRpb25zKG9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIGlmIChuZXdPcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgIGF3YWl0QWxsKHRhcmdldC5vcHRpb25zLiRhbmltYXRpb25zLCBuZXdPcHRpb25zKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICBjb25zdCBwcm9wcyA9IE9iamVjdC5rZXlzKHZhbHVlcyk7XG4gICAgY29uc3QgZGF0ZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwcm9wLmNoYXJBdCgwKSA9PT0gJyQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHByb3AgPT09ICdvcHRpb25zJykge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1twcm9wXTtcbiAgICAgIGxldCBhbmltYXRpb24gPSBydW5uaW5nW3Byb3BdO1xuICAgICAgY29uc3QgY2ZnID0gYW5pbWF0ZWRQcm9wcy5nZXQocHJvcCk7XG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIGlmIChjZmcgJiYgYW5pbWF0aW9uLmFjdGl2ZSgpKSB7XG4gICAgICAgICAgYW5pbWF0aW9uLnVwZGF0ZShjZmcsIHZhbHVlLCBkYXRlKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghY2ZnIHx8ICFjZmcuZHVyYXRpb24pIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBpZiAodGhpcy5fcHJvcGVydGllcy5zaXplID09PSAwKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgdmFsdWVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgIGlmIChhbmltYXRpb25zLmxlbmd0aCkge1xuICAgICAgYW5pbWF0b3IuYWRkKHRoaXMuX2NoYXJ0LCBhbmltYXRpb25zKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXdhaXRBbGwoYW5pbWF0aW9ucywgcHJvcGVydGllcykge1xuICBjb25zdCBydW5uaW5nID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgaWYgKGFuaW0gJiYgYW5pbS5hY3RpdmUoKSkge1xuICAgICAgcnVubmluZy5wdXNoKGFuaW0ud2FpdCgpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gIGlmICghbmV3T3B0aW9ucykge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgb3B0aW9ucyA9IHRhcmdldC5vcHRpb25zO1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICB0YXJnZXQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7JHNoYXJlZDogZmFsc2UsICRhbmltYXRpb25zOiB7fX0pO1xuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBjb25zdCBvcHRzID0gc2NhbGUgJiYgc2NhbGUub3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgcmV2ZXJzZSA9IG9wdHMucmV2ZXJzZTtcbiAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIGNvbnN0IG1heCA9IG9wdHMubWF4ID09PSB1bmRlZmluZWQgPyBhbGxvd2VkT3ZlcmZsb3cgOiAwO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiByZXZlcnNlID8gbWF4IDogbWluLFxuICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENsaXAoeFNjYWxlLCB5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICBpZiAoYWxsb3dlZE92ZXJmbG93ID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgY29uc3QgeSA9IHNjYWxlQ2xpcCh5U2NhbGUsIGFsbG93ZWRPdmVyZmxvdyk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LmVuZCxcbiAgICByaWdodDogeC5lbmQsXG4gICAgYm90dG9tOiB5LnN0YXJ0LFxuICAgIGxlZnQ6IHguc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHRvQ2xpcCh2YWx1ZSkge1xuICBsZXQgdCwgciwgYiwgbDtcbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgciA9IHZhbHVlLnJpZ2h0O1xuICAgIGIgPSB2YWx1ZS5ib3R0b207XG4gICAgbCA9IHZhbHVlLmxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wOiB0LFxuICAgIHJpZ2h0OiByLFxuICAgIGJvdHRvbTogYixcbiAgICBsZWZ0OiBsLFxuICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCBmaWx0ZXJWaXNpYmxlKSB7XG4gIGNvbnN0IGtleXMgPSBbXTtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICBsZXQgaSwgaWxlbjtcbiAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBhcHBseVN0YWNrKHN0YWNrLCB2YWx1ZSwgZHNJbmRleCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICBjb25zdCBzaW5nbGVNb2RlID0gb3B0aW9ucy5tb2RlID09PSAnc2luZ2xlJztcbiAgbGV0IGksIGlsZW4sIGRhdGFzZXRJbmRleCwgb3RoZXJWYWx1ZTtcbiAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBrZXlzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGRhdGFzZXRJbmRleCA9ICtrZXlzW2ldO1xuICAgIGlmIChkYXRhc2V0SW5kZXggPT09IGRzSW5kZXgpIHtcbiAgICAgIGlmIChvcHRpb25zLmFsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKGlzTnVtYmVyRmluaXRlKG90aGVyVmFsdWUpICYmIChzaW5nbGVNb2RlIHx8ICh2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpKSB7XG4gICAgICB2YWx1ZSArPSBvdGhlclZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb252ZXJ0T2JqZWN0RGF0YVRvQXJyYXkoZGF0YSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgbGV0IGksIGlsZW4sIGtleTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5ID0ga2V5c1tpXTtcbiAgICBhZGF0YVtpXSA9IHtcbiAgICAgIHg6IGtleSxcbiAgICAgIHk6IGRhdGFba2V5XVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gIGNvbnN0IHN0YWNrZWQgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gIHJldHVybiBzdGFja2VkIHx8IChzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFN0YWNrS2V5KGluZGV4U2NhbGUsIHZhbHVlU2NhbGUsIG1ldGEpIHtcbiAgcmV0dXJuIGAke2luZGV4U2NhbGUuaWR9LiR7dmFsdWVTY2FsZS5pZH0uJHttZXRhLnN0YWNrIHx8IG1ldGEudHlwZX1gO1xufVxuZnVuY3Rpb24gZ2V0VXNlckJvdW5kcyhzY2FsZSkge1xuICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICByZXR1cm4ge1xuICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICBtYXg6IG1heERlZmluZWQgPyBtYXggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICBjb25zdCBzdWJTdGFjayA9IHN0YWNrc1tzdGFja0tleV0gfHwgKHN0YWNrc1tzdGFja0tleV0gPSB7fSk7XG4gIHJldHVybiBzdWJTdGFja1tpbmRleFZhbHVlXSB8fCAoc3ViU3RhY2tbaW5kZXhWYWx1ZV0gPSB7fSk7XG59XG5mdW5jdGlvbiBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHBvc2l0aXZlLCB0eXBlKSB7XG4gIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICBpZiAoKHBvc2l0aXZlICYmIHZhbHVlID4gMCkgfHwgKCFwb3NpdGl2ZSAmJiB2YWx1ZSA8IDApKSB7XG4gICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiB1cGRhdGVTdGFja3MoY29udHJvbGxlciwgcGFyc2VkKSB7XG4gIGNvbnN0IHtjaGFydCwgX2NhY2hlZE1ldGE6IG1ldGF9ID0gY29udHJvbGxlcjtcbiAgY29uc3Qgc3RhY2tzID0gY2hhcnQuX3N0YWNrcyB8fCAoY2hhcnQuX3N0YWNrcyA9IHt9KTtcbiAgY29uc3Qge2lTY2FsZSwgdlNjYWxlLCBpbmRleDogZGF0YXNldEluZGV4fSA9IG1ldGE7XG4gIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gIGNvbnN0IGtleSA9IGdldFN0YWNrS2V5KGlTY2FsZSwgdlNjYWxlLCBtZXRhKTtcbiAgY29uc3QgaWxlbiA9IHBhcnNlZC5sZW5ndGg7XG4gIGxldCBzdGFjaztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCBpdGVtID0gcGFyc2VkW2ldO1xuICAgIGNvbnN0IHtbaUF4aXNdOiBpbmRleCwgW3ZBeGlzXTogdmFsdWV9ID0gaXRlbTtcbiAgICBjb25zdCBpdGVtU3RhY2tzID0gaXRlbS5fc3RhY2tzIHx8IChpdGVtLl9zdGFja3MgPSB7fSk7XG4gICAgc3RhY2sgPSBpdGVtU3RhY2tzW3ZBeGlzXSA9IGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBrZXksIGluZGV4KTtcbiAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgc3RhY2suX3RvcCA9IGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgdHJ1ZSwgbWV0YS50eXBlKTtcbiAgICBzdGFjay5fYm90dG9tID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBmYWxzZSwgbWV0YS50eXBlKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCBheGlzKSB7XG4gIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHNjYWxlcykuZmlsdGVyKGtleSA9PiBzY2FsZXNba2V5XS5heGlzID09PSBheGlzKS5zaGlmdCgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YXNldENvbnRleHQocGFyZW50LCBpbmRleCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsXG4gICAge1xuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFzZXRJbmRleDogaW5kZXgsXG4gICAgICBpbmRleCxcbiAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgIHR5cGU6ICdkYXRhc2V0J1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFDb250ZXh0KHBhcmVudCwgaW5kZXgsIGVsZW1lbnQpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgIHJhdzogdW5kZWZpbmVkLFxuICAgIGVsZW1lbnQsXG4gICAgaW5kZXgsXG4gICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgIHR5cGU6ICdkYXRhJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyU3RhY2tzKG1ldGEsIGl0ZW1zKSB7XG4gIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgY29uc3QgYXhpcyA9IG1ldGEudlNjYWxlICYmIG1ldGEudlNjYWxlLmF4aXM7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgZm9yIChjb25zdCBwYXJzZWQgb2YgaXRlbXMpIHtcbiAgICBjb25zdCBzdGFja3MgPSBwYXJzZWQuX3N0YWNrcztcbiAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRlbGV0ZSBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XTtcbiAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpID0+IG1vZGUgPT09ICdyZXNldCcgfHwgbW9kZSA9PT0gJ25vbmUnO1xuY29uc3QgY2xvbmVJZk5vdFNoYXJlZCA9IChjYWNoZWQsIHNoYXJlZCkgPT4gc2hhcmVkID8gY2FjaGVkIDogT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkKTtcbmNvbnN0IGNyZWF0ZVN0YWNrID0gKGNhblN0YWNrLCBtZXRhLCBjaGFydCkgPT4gY2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWRcbiAgJiYge2tleXM6IGdldFNvcnRlZERhdGFzZXRJbmRpY2VzKGNoYXJ0LCB0cnVlKSwgdmFsdWVzOiBudWxsfTtcbmNsYXNzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLl9jdHggPSBjaGFydC5jdHg7XG4gICAgdGhpcy5pbmRleCA9IGRhdGFzZXRJbmRleDtcbiAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgIHRoaXMuX2NhY2hlZE1ldGEgPSB0aGlzLmdldE1ldGEoKTtcbiAgICB0aGlzLl90eXBlID0gdGhpcy5fY2FjaGVkTWV0YS50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9vYmplY3REYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NoYXJlZE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RyYXdDb3VudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5saW5rU2NhbGVzKCk7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgIGlmICh0aGlzLmluZGV4ICE9PSBkYXRhc2V0SW5kZXgpIHtcbiAgICAgIGNsZWFyU3RhY2tzKHRoaXMuX2NhY2hlZE1ldGEpO1xuICAgIH1cbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBjaG9vc2VJZCA9IChheGlzLCB4LCB5LCByKSA9PiBheGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgY29uc3QgeGlkID0gbWV0YS54QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC54QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd4JykpO1xuICAgIGNvbnN0IHlpZCA9IG1ldGEueUF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueUF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneScpKTtcbiAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gbWV0YS5pbmRleEF4aXM7XG4gICAgY29uc3QgaWlkID0gbWV0YS5pQXhpc0lEID0gY2hvb3NlSWQoaW5kZXhBeGlzLCB4aWQsIHlpZCwgcmlkKTtcbiAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgIG1ldGEueFNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHhpZCk7XG4gICAgbWV0YS55U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeWlkKTtcbiAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgIG1ldGEuaVNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKGlpZCk7XG4gICAgbWV0YS52U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQodmlkKTtcbiAgfVxuICBnZXREYXRhc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbdGhpcy5pbmRleF07XG4gIH1cbiAgZ2V0TWV0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgfVxuICBnZXRTY2FsZUZvcklkKHNjYWxlSUQpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5zY2FsZXNbc2NhbGVJRF07XG4gIH1cbiAgX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICByZXR1cm4gc2NhbGUgPT09IG1ldGEuaVNjYWxlXG4gICAgICA/IG1ldGEudlNjYWxlXG4gICAgICA6IG1ldGEuaVNjYWxlO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3VwZGF0ZSgncmVzZXQnKTtcbiAgfVxuICBfZGVzdHJveSgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fZGF0YSkge1xuICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyh0aGlzLl9kYXRhLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgIH1cbiAgfVxuICBfZGF0YUNoZWNrKCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5kYXRhIHx8IChkYXRhc2V0LmRhdGEgPSBbXSk7XG4gICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGlmIChpc09iamVjdChkYXRhKSkge1xuICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKF9kYXRhICE9PSBkYXRhKSB7XG4gICAgICBpZiAoX2RhdGEpIHtcbiAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgIGxpc3RlbkFycmF5RXZlbnRzKGRhdGEsIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBpZiAodGhpcy5kYXRhc2V0RWxlbWVudFR5cGUpIHtcbiAgICAgIG1ldGEuZGF0YXNldCA9IG5ldyB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgfVxuICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgdGhpcy5fZGF0YUNoZWNrKCk7XG4gICAgY29uc3Qgb2xkU3RhY2tlZCA9IG1ldGEuX3N0YWNrZWQ7XG4gICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgaWYgKG1ldGEuc3RhY2sgIT09IGRhdGFzZXQuc3RhY2spIHtcbiAgICAgIHN0YWNrQ2hhbmdlZCA9IHRydWU7XG4gICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgIG1ldGEuc3RhY2sgPSBkYXRhc2V0LnN0YWNrO1xuICAgIH1cbiAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcbiAgICBpZiAoc3RhY2tDaGFuZ2VkIHx8IG9sZFN0YWNrZWQgIT09IG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRTY29wZUtleXModGhpcy5fdHlwZSk7XG4gICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzLCB0cnVlKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5fcGFyc2luZyA9IHRoaXMub3B0aW9ucy5wYXJzaW5nO1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gIH1cbiAgcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge19jYWNoZWRNZXRhOiBtZXRhLCBfZGF0YTogZGF0YX0gPSB0aGlzO1xuICAgIGNvbnN0IHtpU2NhbGUsIF9zdGFja2VkfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICBsZXQgcHJldiA9IHN0YXJ0ID4gMCAmJiBtZXRhLl9wYXJzZWRbc3RhcnQgLSAxXTtcbiAgICBsZXQgaSwgY3VyLCBwYXJzZWQ7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0FycmF5KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkID0gdGhpcy5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzTm90SW5PcmRlckNvbXBhcmVkVG9QcmV2ID0gKCkgPT4gY3VyW2lBeGlzXSA9PT0gbnVsbCB8fCAocHJldiAmJiBjdXJbaUF4aXNdIDwgcHJldltpQXhpc10pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXYgPSBjdXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG1ldGEuX3NvcnRlZCA9IHNvcnRlZDtcbiAgICB9XG4gICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICBbaUF4aXNdOiBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2luZGV4XSwgaW5kZXgpLFxuICAgICAgICBbdkF4aXNdOiB2U2NhbGUucGFyc2UoZGF0YVtpbmRleF0sIGluZGV4KVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICB5OiB5U2NhbGUucGFyc2UoaXRlbVsxXSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgeDogeFNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeEF4aXNLZXkpLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldFBhcnNlZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWRbaW5kZXhdO1xuICB9XG4gIGdldERhdGFFbGVtZW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gIH1cbiAgYXBwbHlTdGFjayhzY2FsZSwgcGFyc2VkLCBtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGNvbnN0IHN0YWNrID0ge1xuICAgICAga2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLFxuICAgICAgdmFsdWVzOiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXVxuICAgIH07XG4gICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7bW9kZX0pO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgIGNvbnN0IHZhbHVlcyA9IHN0YWNrICYmIHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdO1xuICAgIGlmIChzdGFjayAmJiB2YWx1ZXMpIHtcbiAgICAgIHN0YWNrLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHZhbHVlID0gYXBwbHlTdGFjayhzdGFjaywgcGFyc2VkVmFsdWUsIHRoaXMuX2NhY2hlZE1ldGEuaW5kZXgpO1xuICAgIH1cbiAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIHZhbHVlKTtcbiAgICByYW5nZS5tYXggPSBNYXRoLm1heChyYW5nZS5tYXgsIHZhbHVlKTtcbiAgfVxuICBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgX3BhcnNlZCA9IG1ldGEuX3BhcnNlZDtcbiAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IGlsZW4gPSBfcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBvdGhlclNjYWxlID0gdGhpcy5fZ2V0T3RoZXJTY2FsZShzY2FsZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBjb25zdCB7bWluOiBvdGhlck1pbiwgbWF4OiBvdGhlck1heH0gPSBnZXRVc2VyQm91bmRzKG90aGVyU2NhbGUpO1xuICAgIGxldCBpLCBwYXJzZWQ7XG4gICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgIGZvciAoaSA9IGlsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgZ2V0QWxsUGFyc2VkVmFsdWVzKHNjYWxlKSB7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcGFyc2VkLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICB9O1xuICB9XG4gIF91cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlKG1vZGUgfHwgJ2RlZmF1bHQnKTtcbiAgICBtZXRhLl9jbGlwID0gdG9DbGlwKHZhbHVlT3JEZWZhdWx0KHRoaXMub3B0aW9ucy5jbGlwLCBkZWZhdWx0Q2xpcChtZXRhLnhTY2FsZSwgbWV0YS55U2NhbGUsIHRoaXMuZ2V0TWF4T3ZlcmZsb3coKSkpKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge31cbiAgZHJhdygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3QgYWN0aXZlID0gW107XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuX2RyYXdDb3VudCB8fCAoZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgIGxldCBpO1xuICAgIGlmIChtZXRhLmRhdGFzZXQpIHtcbiAgICAgIG1ldGEuZGF0YXNldC5kcmF3KGN0eCwgYXJlYSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgIGlmIChlbGVtZW50LmhpZGRlbikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmFjdGl2ZSAmJiBkcmF3QWN0aXZlRWxlbWVudHNPblRvcCkge1xuICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuZHJhdyhjdHgsIGFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKSB7XG4gICAgICBhY3RpdmVbaV0uZHJhdyhjdHgsIGFyZWEpO1xuICAgIH1cbiAgfVxuICBnZXRTdHlsZShpbmRleCwgYWN0aXZlKSB7XG4gICAgY29uc3QgbW9kZSA9IGFjdGl2ZSA/ICdhY3RpdmUnIDogJ2RlZmF1bHQnO1xuICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldFxuICAgICAgPyB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSlcbiAgICAgIDogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4IHx8IDAsIG1vZGUpO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgbW9kZSkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICBsZXQgY29udGV4dDtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dCA9IGVsZW1lbnQuJGNvbnRleHQgfHxcbiAgICAgICAgKGVsZW1lbnQuJGNvbnRleHQgPSBjcmVhdGVEYXRhQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIGVsZW1lbnQpKTtcbiAgICAgIGNvbnRleHQucGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgY29udGV4dC5yYXcgPSBkYXRhc2V0LmRhdGFbaW5kZXhdO1xuICAgICAgY29udGV4dC5pbmRleCA9IGNvbnRleHQuZGF0YUluZGV4ID0gaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8XG4gICAgICAgICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgIH1cbiAgICBjb250ZXh0LmFjdGl2ZSA9ICEhYWN0aXZlO1xuICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cbiAgcmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRWxlbWVudE9wdGlvbnModGhpcy5kYXRhRWxlbWVudFR5cGUuaWQsIG1vZGUsIGluZGV4KTtcbiAgfVxuICBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgIGNvbnN0IGFjdGl2ZSA9IG1vZGUgPT09ICdhY3RpdmUnO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGVbY2FjaGVLZXldO1xuICAgIGNvbnN0IHNoYXJpbmcgPSB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgJiYgZGVmaW5lZChpbmRleCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IGFjdGl2ZSA/IFtgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsICdob3ZlcicsIGVsZW1lbnRUeXBlLCAnJ10gOiBbZWxlbWVudFR5cGUsICcnXTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgIGNvbnN0IG5hbWVzID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuZWxlbWVudHNbZWxlbWVudFR5cGVdKTtcbiAgICBjb25zdCBjb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUpO1xuICAgIGNvbnN0IHZhbHVlcyA9IGNvbmZpZy5yZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzKTtcbiAgICBpZiAodmFsdWVzLiRzaGFyZWQpIHtcbiAgICAgIHZhbHVlcy4kc2hhcmVkID0gc2hhcmluZztcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoY2xvbmVJZk5vdFNoYXJlZCh2YWx1ZXMsIHNoYXJpbmcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuICBfcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIHRyYW5zaXRpb24sIGFjdGl2ZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZERhdGFPcHRzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gYGFuaW1hdGlvbi0ke3RyYW5zaXRpb259YDtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgaWYgKGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyh0aGlzLl90eXBlLCB0cmFuc2l0aW9uKTtcbiAgICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgICBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgdGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIHRyYW5zaXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5fY2FjaGVhYmxlKSB7XG4gICAgICBjYWNoZVtjYWNoZUtleV0gPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2hhcmVkT3B0aW9ucyB8fCAodGhpcy5fc2hhcmVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpKTtcbiAgfVxuICBpbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKSB7XG4gICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gIH1cbiAgX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpIHtcbiAgICBjb25zdCBmaXJzdE9wdHMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zID0gdGhpcy5fc2hhcmVkT3B0aW9ucztcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHx8IChzaGFyZWRPcHRpb25zICE9PSBwcmV2aW91c2x5U2hhcmVkT3B0aW9ucyk7XG4gICAgdGhpcy51cGRhdGVTaGFyZWRPcHRpb25zKHNoYXJlZE9wdGlvbnMsIG1vZGUsIGZpcnN0T3B0cyk7XG4gICAgcmV0dXJuIHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc307XG4gIH1cbiAgdXBkYXRlRWxlbWVudChlbGVtZW50LCBpbmRleCwgcHJvcGVydGllcywgbW9kZSkge1xuICAgIGlmIChpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgbmV3T3B0aW9ucykge1xuICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfc2V0U3R5bGUoZWxlbWVudCwgaW5kZXgsIG1vZGUsIGFjdGl2ZSkge1xuICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLmdldFN0eWxlKGluZGV4LCBhY3RpdmUpO1xuICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlLCBhY3RpdmUpLnVwZGF0ZShlbGVtZW50LCB7XG4gICAgICBvcHRpb25zOiAoIWFjdGl2ZSAmJiB0aGlzLmdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykpIHx8IG9wdGlvbnNcbiAgICB9KTtcbiAgfVxuICByZW1vdmVIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgfVxuICBzZXRIb3ZlclN0eWxlKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIHRydWUpO1xuICB9XG4gIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIF9zZXREYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0O1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICBmb3IgKGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdIG9mIHRoaXMuX3N5bmNMaXN0KSB7XG4gICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgfVxuICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgY29uc3QgbnVtTWV0YSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1EYXRhID0gZGF0YS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMucGFyc2UoMCwgY291bnQpO1xuICAgIH1cbiAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICB9IGVsc2UgaWYgKG51bURhdGEgPCBudW1NZXRhKSB7XG4gICAgICB0aGlzLl9yZW1vdmVFbGVtZW50cyhudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICB9XG4gIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YSA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG1vdmUgPSAoYXJyKSA9PiB7XG4gICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgZm9yIChpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gZW5kOyBpLS0pIHtcbiAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICB9XG4gICAgfTtcbiAgICBtb3ZlKGRhdGEpO1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIGRhdGFbaV0gPSBuZXcgdGhpcy5kYXRhRWxlbWVudFR5cGUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZShzdGFydCwgY291bnQpO1xuICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGVsZW1lbnQsIHN0YXJ0LCBjb3VudCwgbW9kZSkge31cbiAgX3JlbW92ZUVsZW1lbnRzKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgY2xlYXJTdGFja3MobWV0YSwgcmVtb3ZlZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1ldGEuZGF0YS5zcGxpY2Uoc3RhcnQsIGNvdW50KTtcbiAgfVxuICBfc3luYyhhcmdzKSB7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFttZXRob2QsIGFyZzEsIGFyZzJdID0gYXJncztcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbdGhpcy5pbmRleCwgLi4uYXJnc10pO1xuICB9XG4gIF9vbkRhdGFQdXNoKCkge1xuICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgdGhpcy5nZXREYXRhc2V0KCkuZGF0YS5sZW5ndGggLSBjb3VudCwgY291bnRdKTtcbiAgfVxuICBfb25EYXRhUG9wKCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCB0aGlzLl9jYWNoZWRNZXRhLmRhdGEubGVuZ3RoIC0gMSwgMV0pO1xuICB9XG4gIF9vbkRhdGFTaGlmdCgpIHtcbiAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgMCwgMV0pO1xuICB9XG4gIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX3JlbW92ZUVsZW1lbnRzJywgc3RhcnQsIGNvdW50XSk7XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgaWYgKG5ld0NvdW50KSB7XG4gICAgICB0aGlzLl9zeW5jKFsnX2luc2VydEVsZW1lbnRzJywgc3RhcnQsIG5ld0NvdW50XSk7XG4gICAgfVxuICB9XG4gIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCAwLCBhcmd1bWVudHMubGVuZ3RoXSk7XG4gIH1cbn1cbkRhdGFzZXRDb250cm9sbGVyLmRlZmF1bHRzID0ge307XG5EYXRhc2V0Q29udHJvbGxlci5wcm90b3R5cGUuZGF0YXNldEVsZW1lbnRUeXBlID0gbnVsbDtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhRWxlbWVudFR5cGUgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICBpZiAoIXNjYWxlLl9jYWNoZS4kYmFyKSB7XG4gICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgbGV0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdmlzaWJsZU1ldGFzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICB9XG4gICAgc2NhbGUuX2NhY2hlLiRiYXIgPSBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG4gIH1cbiAgcmV0dXJuIHNjYWxlLl9jYWNoZS4kYmFyO1xufVxuZnVuY3Rpb24gY29tcHV0ZU1pblNhbXBsZVNpemUobWV0YSkge1xuICBjb25zdCBzY2FsZSA9IG1ldGEuaVNjYWxlO1xuICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgbGV0IG1pbiA9IHNjYWxlLl9sZW5ndGg7XG4gIGxldCBpLCBpbGVuLCBjdXJyLCBwcmV2O1xuICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCkgPT4ge1xuICAgIGlmIChjdXJyID09PSAzMjc2NyB8fCBjdXJyID09PSAtMzI3NjgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlZmluZWQocHJldikpIHtcbiAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5hYnMoY3VyciAtIHByZXYpIHx8IG1pbik7XG4gICAgfVxuICAgIHByZXYgPSBjdXJyO1xuICB9O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHByZXYgPSB1bmRlZmluZWQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgfVxuICByZXR1cm4gbWluO1xufVxuZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICBjb25zdCB0aGlja25lc3MgPSBvcHRpb25zLmJhclRoaWNrbmVzcztcbiAgbGV0IHNpemUsIHJhdGlvO1xuICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgc2l6ZSA9IHJ1bGVyLm1pbiAqIG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICAgIHJhdGlvID0gb3B0aW9ucy5iYXJQZXJjZW50YWdlO1xuICB9IGVsc2Uge1xuICAgIHNpemUgPSB0aGlja25lc3MgKiBzdGFja0NvdW50O1xuICAgIHJhdGlvID0gMTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbyxcbiAgICBzdGFydDogcnVsZXIucGl4ZWxzW2luZGV4XSAtIChzaXplIC8gMilcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHBpeGVscyA9IHJ1bGVyLnBpeGVscztcbiAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gIGxldCBwcmV2ID0gaW5kZXggPiAwID8gcGl4ZWxzW2luZGV4IC0gMV0gOiBudWxsO1xuICBsZXQgbmV4dCA9IGluZGV4IDwgcGl4ZWxzLmxlbmd0aCAtIDEgPyBwaXhlbHNbaW5kZXggKyAxXSA6IG51bGw7XG4gIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gIH1cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICBuZXh0ID0gY3VyciArIGN1cnIgLSBwcmV2O1xuICB9XG4gIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gIGNvbnN0IHNpemUgPSBNYXRoLmFicyhuZXh0IC0gcHJldikgLyAyICogcGVyY2VudDtcbiAgcmV0dXJuIHtcbiAgICBjaHVuazogc2l6ZSAvIHN0YWNrQ291bnQsXG4gICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGNvbnN0IHN0YXJ0VmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMF0sIGkpO1xuICBjb25zdCBlbmRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVsxXSwgaSk7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBsZXQgYmFyU3RhcnQgPSBtaW47XG4gIGxldCBiYXJFbmQgPSBtYXg7XG4gIGlmIChNYXRoLmFicyhtaW4pID4gTWF0aC5hYnMobWF4KSkge1xuICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgIGJhckVuZCA9IG1pbjtcbiAgfVxuICBpdGVtW3ZTY2FsZS5heGlzXSA9IGJhckVuZDtcbiAgaXRlbS5fY3VzdG9tID0ge1xuICAgIGJhclN0YXJ0LFxuICAgIGJhckVuZCxcbiAgICBzdGFydDogc3RhcnRWYWx1ZSxcbiAgICBlbmQ6IGVuZFZhbHVlLFxuICAgIG1pbixcbiAgICBtYXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICBpZiAoaXNBcnJheShlbnRyeSkpIHtcbiAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICB9IGVsc2Uge1xuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICBjb25zdCBsYWJlbHMgPSBpU2NhbGUuZ2V0TGFiZWxzKCk7XG4gIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gIGNvbnN0IHBhcnNlZCA9IFtdO1xuICBsZXQgaSwgaWxlbiwgaXRlbSwgZW50cnk7XG4gIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgIGVudHJ5ID0gZGF0YVtpXTtcbiAgICBpdGVtID0ge307XG4gICAgaXRlbVtpU2NhbGUuYXhpc10gPSBzaW5nbGVTY2FsZSB8fCBpU2NhbGUucGFyc2UobGFiZWxzW2ldLCBpKTtcbiAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpKTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgcmV0dXJuIGN1c3RvbSAmJiBjdXN0b20uYmFyU3RhcnQgIT09IHVuZGVmaW5lZCAmJiBjdXN0b20uYmFyRW5kICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiYXJTaWduKHNpemUsIHZTY2FsZSwgYWN0dWFsQmFzZSkge1xuICBpZiAoc2l6ZSAhPT0gMCkge1xuICAgIHJldHVybiBzaWduKHNpemUpO1xuICB9XG4gIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICBsZXQgcmV2ZXJzZSwgc3RhcnQsIGVuZCwgdG9wLCBib3R0b207XG4gIGlmIChwcm9wZXJ0aWVzLmhvcml6b250YWwpIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlID4gcHJvcGVydGllcy54O1xuICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgIGVuZCA9ICdyaWdodCc7XG4gIH0gZWxzZSB7XG4gICAgcmV2ZXJzZSA9IHByb3BlcnRpZXMuYmFzZSA8IHByb3BlcnRpZXMueTtcbiAgICBzdGFydCA9ICdib3R0b20nO1xuICAgIGVuZCA9ICd0b3AnO1xuICB9XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgdG9wID0gJ2VuZCc7XG4gICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSAnc3RhcnQnO1xuICAgIGJvdHRvbSA9ICdlbmQnO1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgcmV2ZXJzZSwgdG9wLCBib3R0b219O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgbGV0IGVkZ2UgPSBvcHRpb25zLmJvcmRlclNraXBwZWQ7XG4gIGNvbnN0IHJlcyA9IHt9O1xuICBpZiAoIWVkZ2UpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0ge3RvcDogdHJ1ZSwgcmlnaHQ6IHRydWUsIGJvdHRvbTogdHJ1ZSwgbGVmdDogdHJ1ZX07XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX0gPSBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKTtcbiAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgcHJvcGVydGllcy5lbmFibGVCb3JkZXJSYWRpdXMgPSB0cnVlO1xuICAgIGlmICgoc3RhY2suX3RvcCB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSB0b3A7XG4gICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc1twYXJzZUVkZ2UoYm90dG9tLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9XG4gIH1cbiAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSByZXM7XG59XG5mdW5jdGlvbiBwYXJzZUVkZ2UoZWRnZSwgYSwgYiwgcmV2ZXJzZSkge1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGVkZ2UgPSBzd2FwKGVkZ2UsIGEsIGIpO1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgfSBlbHNlIHtcbiAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gIH1cbiAgcmV0dXJuIGVkZ2U7XG59XG5mdW5jdGlvbiBzd2FwKG9yaWcsIHYxLCB2Mikge1xuICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogdiA9PT0gJ2VuZCcgPyBlbmQgOiB2O1xufVxuZnVuY3Rpb24gc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCB7aW5mbGF0ZUFtb3VudH0sIHJhdGlvKSB7XG4gIHByb3BlcnRpZXMuaW5mbGF0ZUFtb3VudCA9IGluZmxhdGVBbW91bnQgPT09ICdhdXRvJ1xuICAgID8gcmF0aW8gPT09IDEgPyAwLjMzIDogMFxuICAgIDogaW5mbGF0ZUFtb3VudDtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCB7eEF4aXNLZXkgPSAneCcsIHlBeGlzS2V5ID0gJ3knfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgaUF4aXNLZXkgPSBpU2NhbGUuYXhpcyA9PT0gJ3gnID8geEF4aXNLZXkgOiB5QXhpc0tleTtcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBpdGVtLCBvYmo7XG4gICAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgaXRlbSA9IHt9O1xuICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICBzdXBlci51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgdmFsdWUgPSBpc0Zsb2F0QmFyKGN1c3RvbSlcbiAgICAgID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXSdcbiAgICAgIDogJycgKyB2U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbdlNjYWxlLmF4aXNdKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYmFycywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpbmRleCwgX2NhY2hlZE1ldGE6IHt2U2NhbGV9fSA9IHRoaXM7XG4gICAgY29uc3QgYmFzZSA9IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKTtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHJ1bGVyID0gdGhpcy5fZ2V0UnVsZXIoKTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHZwaXhlbHMgPSByZXNldCB8fCBpc051bGxPclVuZGVmKHBhcnNlZFt2U2NhbGUuYXhpc10pID8ge2Jhc2UsIGhlYWQ6IGJhc2V9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIGhvcml6b250YWwsXG4gICAgICAgIGJhc2U6IHZwaXhlbHMuYmFzZSxcbiAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgKGluZGV4ID09PSBzdGFjay5fdG9wIHx8IGluZGV4ID09PSBzdGFjay5fYm90dG9tKSxcbiAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICB5OiBob3Jpem9udGFsID8gaXBpeGVscy5jZW50ZXIgOiB2cGl4ZWxzLmhlYWQsXG4gICAgICAgIGhlaWdodDogaG9yaXpvbnRhbCA/IGlwaXhlbHMuc2l6ZSA6IE1hdGguYWJzKHZwaXhlbHMuc2l6ZSksXG4gICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgfTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBiYXJzW2ldLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRpb25zID0gcHJvcGVydGllcy5vcHRpb25zIHx8IGJhcnNbaV0ub3B0aW9ucztcbiAgICAgIHNldEJvcmRlclNraXBwZWQocHJvcGVydGllcywgb3B0aW9ucywgc3RhY2ssIGluZGV4KTtcbiAgICAgIHNldEluZmxhdGVBbW91bnQocHJvcGVydGllcywgb3B0aW9ucywgcnVsZXIucmF0aW8pO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGJhcnNbaV0sIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgfVxuICBfZ2V0U3RhY2tzKGxhc3QsIGRhdGFJbmRleCkge1xuICAgIGNvbnN0IHtpU2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKVxuICAgICAgLmZpbHRlcihtZXRhID0+IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmdyb3VwZWQpO1xuICAgIGNvbnN0IHN0YWNrZWQgPSBpU2NhbGUub3B0aW9ucy5zdGFja2VkO1xuICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IG1ldGEuY29udHJvbGxlci5nZXRQYXJzZWQoZGF0YUluZGV4KTtcbiAgICAgIGNvbnN0IHZhbCA9IHBhcnNlZCAmJiBwYXJzZWRbbWV0YS52U2NhbGUuYXhpc107XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWwpIHx8IGlzTmFOKHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbWV0YXNldHMpIHtcbiAgICAgIGlmIChkYXRhSW5kZXggIT09IHVuZGVmaW5lZCAmJiBza2lwTnVsbChtZXRhKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHxcblx0XHRcdFx0KHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc3RhY2tzLmxlbmd0aCkge1xuICAgICAgc3RhY2tzLnB1c2godW5kZWZpbmVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbiAgfVxuICBfZ2V0U3RhY2tDb3VudChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTdGFja3ModW5kZWZpbmVkLCBpbmRleCkubGVuZ3RoO1xuICB9XG4gIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qgc3RhY2tzID0gdGhpcy5fZ2V0U3RhY2tzKGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KTtcbiAgICBjb25zdCBpbmRleCA9IChuYW1lICE9PSB1bmRlZmluZWQpXG4gICAgICA/IHN0YWNrcy5pbmRleE9mKG5hbWUpXG4gICAgICA6IC0xO1xuICAgIHJldHVybiAoaW5kZXggPT09IC0xKVxuICAgICAgPyBzdGFja3MubGVuZ3RoIC0gMVxuICAgICAgOiBpbmRleDtcbiAgfVxuICBfZ2V0UnVsZXIoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YS5kYXRhLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgfVxuICAgIGNvbnN0IGJhclRoaWNrbmVzcyA9IG9wdHMuYmFyVGhpY2tuZXNzO1xuICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluLFxuICAgICAgcGl4ZWxzLFxuICAgICAgc3RhcnQ6IGlTY2FsZS5fc3RhcnRQaXhlbCxcbiAgICAgIGVuZDogaVNjYWxlLl9lbmRQaXhlbCxcbiAgICAgIHN0YWNrQ291bnQ6IHRoaXMuX2dldFN0YWNrQ291bnQoKSxcbiAgICAgIHNjYWxlOiBpU2NhbGUsXG4gICAgICBncm91cGVkOiBvcHRzLmdyb3VwZWQsXG4gICAgICByYXRpbzogYmFyVGhpY2tuZXNzID8gMSA6IG9wdHMuY2F0ZWdvcnlQZXJjZW50YWdlICogb3B0cy5iYXJQZXJjZW50YWdlXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IHt2U2NhbGUsIF9zdGFja2VkfSwgb3B0aW9uczoge2Jhc2U6IGJhc2VWYWx1ZSwgbWluQmFyTGVuZ3RofX0gPSB0aGlzO1xuICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgbGV0IHZhbHVlID0gcGFyc2VkW3ZTY2FsZS5heGlzXTtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgbGV0IGhlYWQsIHNpemU7XG4gICAgaWYgKGxlbmd0aCAhPT0gdmFsdWUpIHtcbiAgICAgIHN0YXJ0ID0gbGVuZ3RoIC0gdmFsdWU7XG4gICAgICBsZW5ndGggPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGZsb2F0aW5nKSB7XG4gICAgICB2YWx1ZSA9IGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGxlbmd0aCA9IGN1c3RvbS5iYXJFbmQgLSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICBpZiAodmFsdWUgIT09IDAgJiYgc2lnbih2YWx1ZSkgIT09IHNpZ24oY3VzdG9tLmJhckVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0VmFsdWUgPSAhaXNOdWxsT3JVbmRlZihiYXNlVmFsdWUpICYmICFmbG9hdGluZyA/IGJhc2VWYWx1ZSA6IHN0YXJ0O1xuICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgaWYgKHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICBoZWFkID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnQgKyBsZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkID0gYmFzZTtcbiAgICB9XG4gICAgc2l6ZSA9IGhlYWQgLSBiYXNlO1xuICAgIGlmIChNYXRoLmFicyhzaXplKSA8IG1pbkJhckxlbmd0aCkge1xuICAgICAgc2l6ZSA9IGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSAqIG1pbkJhckxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZSA9PT0gYWN0dWFsQmFzZSkge1xuICAgICAgICBiYXNlIC09IHNpemUgLyAyO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMCk7XG4gICAgICBjb25zdCBlbmRQaXhlbCA9IHZTY2FsZS5nZXRQaXhlbEZvckRlY2ltYWwoMSk7XG4gICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFBpeGVsLCBlbmRQaXhlbCk7XG4gICAgICBiYXNlID0gTWF0aC5tYXgoTWF0aC5taW4oYmFzZSwgbWF4KSwgbWluKTtcbiAgICAgIGhlYWQgPSBiYXNlICsgc2l6ZTtcbiAgICB9XG4gICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzaXplLFxuICAgICAgYmFzZSxcbiAgICAgIGhlYWQsXG4gICAgICBjZW50ZXI6IGhlYWQgKyBzaXplIC8gMlxuICAgIH07XG4gIH1cbiAgX2NhbGN1bGF0ZUJhckluZGV4UGl4ZWxzKGluZGV4LCBydWxlcikge1xuICAgIGNvbnN0IHNjYWxlID0gcnVsZXIuc2NhbGU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBza2lwTnVsbCA9IG9wdGlvbnMuc2tpcE51bGw7XG4gICAgY29uc3QgbWF4QmFyVGhpY2tuZXNzID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5tYXhCYXJUaGlja25lc3MsIEluZmluaXR5KTtcbiAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgIGlmIChydWxlci5ncm91cGVkKSB7XG4gICAgICBjb25zdCBzdGFja0NvdW50ID0gc2tpcE51bGwgPyB0aGlzLl9nZXRTdGFja0NvdW50KGluZGV4KSA6IHJ1bGVyLnN0YWNrQ291bnQ7XG4gICAgICBjb25zdCByYW5nZSA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzID09PSAnZmxleCdcbiAgICAgICAgPyBjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudClcbiAgICAgICAgOiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KTtcbiAgICAgIGNvbnN0IHN0YWNrSW5kZXggPSB0aGlzLl9nZXRTdGFja0luZGV4KHRoaXMuaW5kZXgsIHRoaXMuX2NhY2hlZE1ldGEuc3RhY2ssIHNraXBOdWxsID8gaW5kZXggOiB1bmRlZmluZWQpO1xuICAgICAgY2VudGVyID0gcmFuZ2Uuc3RhcnQgKyAocmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4KSArIChyYW5nZS5jaHVuayAvIDIpO1xuICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbnRlciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaW5kZXgpW3NjYWxlLmF4aXNdLCBpbmRleCk7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCBydWxlci5taW4gKiBydWxlci5yYXRpbyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgY2VudGVyLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICBjb25zdCByZWN0cyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCkge1xuICAgICAgICByZWN0c1tpXS5kcmF3KHRoaXMuX2N0eCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5CYXJDb250cm9sbGVyLmlkID0gJ2Jhcic7XG5CYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgYmFyUGVyY2VudGFnZTogMC45LFxuICBncm91cGVkOiB0cnVlLFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddXG4gICAgfVxuICB9XG59O1xuQmFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIF9pbmRleF86IHtcbiAgICAgIHR5cGU6ICdjYXRlZ29yeScsXG4gICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICBncmlkOiB7XG4gICAgICAgIG9mZnNldDogdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEJ1YmJsZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgfVxuICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3hTY2FsZSwgeVNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgY29uc3QgeSA9IHlTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC55KTtcbiAgICBjb25zdCByID0gcGFyc2VkLl9jdXN0b207XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBtZXRhLmxhYmVsLFxuICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGV9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKykge1xuICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb25zdCBwYXJzZWQgPSAhcmVzZXQgJiYgdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge307XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IHJlc2V0ID8gaVNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwLjUpIDogaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0ID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCk7XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zLnJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgbGV0IHZhbHVlcyA9IHN1cGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWVzLCB7JHNoYXJlZDogZmFsc2V9KTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICBpZiAobW9kZSAhPT0gJ2FjdGl2ZScpIHtcbiAgICAgIHZhbHVlcy5yYWRpdXMgPSAwO1xuICAgIH1cbiAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG59XG5CdWJibGVDb250cm9sbGVyLmlkID0gJ2J1YmJsZSc7XG5CdWJibGVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cyddXG4gICAgfVxuICB9XG59O1xuQnViYmxlQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgbGV0IHJhdGlvWCA9IDE7XG4gIGxldCByYXRpb1kgPSAxO1xuICBsZXQgb2Zmc2V0WCA9IDA7XG4gIGxldCBvZmZzZXRZID0gMDtcbiAgaWYgKGNpcmN1bWZlcmVuY2UgPCBUQVUpIHtcbiAgICBjb25zdCBzdGFydEFuZ2xlID0gcm90YXRpb247XG4gICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICBjb25zdCBzdGFydFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgIGNvbnN0IGVuZFkgPSBNYXRoLnNpbihlbmRBbmdsZSk7XG4gICAgY29uc3QgY2FsY01heCA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgIGNvbnN0IGNhbGNNaW4gPSAoYW5nbGUsIGEsIGIpID0+IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCB0cnVlKSA/IC0xIDogTWF0aC5taW4oYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICBjb25zdCBtYXhZID0gY2FsY01heChIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIGNvbnN0IG1pblggPSBjYWxjTWluKFBJLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICByYXRpb1ggPSAobWF4WCAtIG1pblgpIC8gMjtcbiAgICByYXRpb1kgPSAobWF4WSAtIG1pblkpIC8gMjtcbiAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgIG9mZnNldFkgPSAtKG1heFkgKyBtaW5ZKSAvIDI7XG4gIH1cbiAgcmV0dXJuIHtyYXRpb1gsIHJhdGlvWSwgb2Zmc2V0WCwgb2Zmc2V0WX07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vZmZzZXRZID0gdW5kZWZpbmVkO1xuICB9XG4gIGxpbmtTY2FsZXMoKSB7fVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBnZXR0ZXIgPSAoaSkgPT4gK2RhdGFbaV07XG4gICAgICBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIGNvbnN0IHtrZXkgPSAndmFsdWUnfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGdldHRlciA9IChpKSA9PiArcmVzb2x2ZU9iamVjdEtleShkYXRhW2ldLCBrZXkpO1xuICAgICAgfVxuICAgICAgbGV0IGksIGlsZW47XG4gICAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgbWV0YS5fcGFyc2VkW2ldID0gZ2V0dGVyKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfZ2V0Um90YXRpb24oKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMucm90YXRpb24gLSA5MCk7XG4gIH1cbiAgX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRvUmFkaWFucyh0aGlzLm9wdGlvbnMuY2lyY3VtZmVyZW5jZSk7XG4gIH1cbiAgX2dldFJvdGF0aW9uRXh0ZW50cygpIHtcbiAgICBsZXQgbWluID0gVEFVO1xuICAgIGxldCBtYXggPSAtVEFVO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHJvdGF0aW9uID0gY29udHJvbGxlci5fZ2V0Um90YXRpb24oKTtcbiAgICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IGNvbnRyb2xsZXIuX2dldENpcmN1bWZlcmVuY2UoKTtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgcm90YXRpb24gKyBjaXJjdW1mZXJlbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBtaW4sXG4gICAgICBjaXJjdW1mZXJlbmNlOiBtYXggLSBtaW4sXG4gICAgfTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCB7Y2hhcnRBcmVhfSA9IGNoYXJ0O1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMuZ2V0TWF4Qm9yZGVyV2lkdGgoKSArIHRoaXMuZ2V0TWF4T2Zmc2V0KGFyY3MpICsgdGhpcy5vcHRpb25zLnNwYWNpbmc7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KChNYXRoLm1pbihjaGFydEFyZWEud2lkdGgsIGNoYXJ0QXJlYS5oZWlnaHQpIC0gc3BhY2luZykgLyAyLCAwKTtcbiAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgIGNvbnN0IGNoYXJ0V2VpZ2h0ID0gdGhpcy5fZ2V0UmluZ1dlaWdodCh0aGlzLmluZGV4KTtcbiAgICBjb25zdCB7Y2lyY3VtZmVyZW5jZSwgcm90YXRpb259ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgY29uc3Qge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfSA9IGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gKGNoYXJ0QXJlYS53aWR0aCAtIHNwYWNpbmcpIC8gcmF0aW9YO1xuICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgY29uc3QgbWF4UmFkaXVzID0gTWF0aC5tYXgoTWF0aC5taW4obWF4V2lkdGgsIG1heEhlaWdodCkgLyAyLCAwKTtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IHRvRGltZW5zaW9uKHRoaXMub3B0aW9ucy5yYWRpdXMsIG1heFJhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gdGhpcy5fZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFggKiBvdXRlclJhZGl1cztcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgbWV0YS50b3RhbCA9IHRoaXMuY2FsY3VsYXRlVG90YWwoKTtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMoYXJjcywgMCwgYXJjcy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIF9jaXJjdW1mZXJlbmNlKGksIHJlc2V0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgIGlmICgocmVzZXQgJiYgb3B0cy5hbmltYXRpb24uYW5pbWF0ZVJvdGF0ZSkgfHwgIXRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgfHwgbWV0YS5fcGFyc2VkW2ldID09PSBudWxsIHx8IG1ldGEuZGF0YVtpXS5oaWRkZW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBjZW50ZXJYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyO1xuICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gYW5pbWF0ZVNjYWxlID8gMCA6IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5vdXRlclJhZGl1cztcbiAgICBjb25zdCB7c2hhcmVkT3B0aW9ucywgaW5jbHVkZU9wdGlvbnN9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgbGV0IHN0YXJ0QW5nbGUgPSB0aGlzLl9nZXRSb3RhdGlvbigpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBzdGFydEFuZ2xlICs9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgY2lyY3VtZmVyZW5jZSA9IHRoaXMuX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpO1xuICAgICAgY29uc3QgYXJjID0gYXJjc1tpXTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHg6IGNlbnRlclggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIGlubmVyUmFkaXVzXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNhbGN1bGF0ZVRvdGFsKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFEYXRhID0gbWV0YS5kYXRhO1xuICAgIGxldCB0b3RhbCA9IDA7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG1ldGEuX3BhcnNlZFtpXTtcbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSkgJiYgIW1ldGFEYXRhW2ldLmhpZGRlbikge1xuICAgICAgICB0b3RhbCArPSBNYXRoLmFicyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0b3RhbDtcbiAgfVxuICBjYWxjdWxhdGVDaXJjdW1mZXJlbmNlKHZhbHVlKSB7XG4gICAgY29uc3QgdG90YWwgPSB0aGlzLl9jYWNoZWRNZXRhLnRvdGFsO1xuICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgY29uc3QgdmFsdWUgPSBmb3JtYXROdW1iZXIobWV0YS5fcGFyc2VkW2luZGV4XSwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBpZiAoY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBtZXRhLmNvbnRyb2xsZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhcmNzKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGFyY3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDAsIG9wdGlvbnMuaG92ZXJCb3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBnZXRNYXhPZmZzZXQoYXJjcykge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMub2Zmc2V0IHx8IDAsIG9wdGlvbnMuaG92ZXJPZmZzZXQgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG4gIH1cbiAgX2dldFJpbmdXZWlnaHRPZmZzZXQoZGF0YXNldEluZGV4KSB7XG4gICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgcmluZ1dlaWdodE9mZnNldCArPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodChkYXRhc2V0SW5kZXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodmFsdWVPckRlZmF1bHQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0ud2VpZ2h0LCAxKSwgMCk7XG4gIH1cbiAgX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aCkgfHwgMTtcbiAgfVxufVxuRG91Z2hudXRDb250cm9sbGVyLmlkID0gJ2RvdWdobnV0JztcbkRvdWdobnV0Q29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgYW5pbWF0aW9uOiB7XG4gICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICBhbmltYXRlU2NhbGU6IGZhbHNlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsnY2lyY3VtZmVyZW5jZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cycsICdzdGFydEFuZ2xlJywgJ3gnLCAneScsICdvZmZzZXQnLCAnYm9yZGVyV2lkdGgnLCAnc3BhY2luZyddXG4gICAgfSxcbiAgfSxcbiAgY3V0b3V0OiAnNTAlJyxcbiAgcm90YXRpb246IDAsXG4gIGNpcmN1bWZlcmVuY2U6IDM2MCxcbiAgcmFkaXVzOiAnMTAwJScsXG4gIHNwYWNpbmc6IDAsXG4gIGluZGV4QXhpczogJ3InLFxufTtcbkRvdWdobnV0Q29udHJvbGxlci5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnc3BhY2luZycsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgICBsZXQgZGF0YUxhYmVsID0gdG9vbHRpcEl0ZW0ubGFiZWw7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoZGF0YUxhYmVsKSkge1xuICAgICAgICAgICAgZGF0YUxhYmVsID0gZGF0YUxhYmVsLnNsaWNlKCk7XG4gICAgICAgICAgICBkYXRhTGFiZWxbMF0gKz0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFMYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGRhdGFMYWJlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgTGluZUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGluaXRpYWxpemUoKSB7XG4gICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIGRhdGE6IHBvaW50cyA9IFtdLCBfZGF0YXNldH0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgbGluZS5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgIH1cbiAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgIG9wdGlvbnNcbiAgICB9LCBtb2RlKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBib3JkZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KGJvcmRlciwgZmlyc3RQb2ludCwgbGFzdFBvaW50KSAvIDI7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBtZXRhLmRhdGFzZXQudXBkYXRlQ29udHJvbFBvaW50cyh0aGlzLmNoYXJ0LmNoYXJ0QXJlYSwgbWV0YS5pU2NhbGUuYXhpcyk7XG4gICAgc3VwZXIuZHJhdygpO1xuICB9XG59XG5MaW5lQ29udHJvbGxlci5pZCA9ICdsaW5lJztcbkxpbmVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxufTtcbkxpbmVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICB9LFxuICAgIF92YWx1ZV86IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgIH0sXG4gIH1cbn07XG5cbmNsYXNzIFBvbGFyQXJlYUNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpIHtcbiAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLnIsIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICB2YWx1ZSxcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGFyY3MgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy5fdXBkYXRlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgZ2V0TWluTWF4KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHJhbmdlID0ge21pbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWX07XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcbiAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBpZiAocGFyc2VkIDwgcmFuZ2UubWluKSB7XG4gICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQgPiByYW5nZS5tYXgpIHtcbiAgICAgICAgICByYW5nZS5tYXggPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH1cbiAgX3VwZGF0ZVJhZGl1cygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IG1pblNpemUgPSBNYXRoLm1pbihjaGFydEFyZWEucmlnaHQgLSBjaGFydEFyZWEubGVmdCwgY2hhcnRBcmVhLmJvdHRvbSAtIGNoYXJ0QXJlYS50b3ApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gTWF0aC5tYXgob3B0cy5jdXRvdXRQZXJjZW50YWdlID8gKG91dGVyUmFkaXVzIC8gMTAwKSAqIChvcHRzLmN1dG91dFBlcmNlbnRhZ2UpIDogMSwgMCk7XG4gICAgY29uc3QgcmFkaXVzTGVuZ3RoID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gY2hhcnQuZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIChyYWRpdXNMZW5ndGggKiB0aGlzLmluZGV4KTtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdGhpcy5vdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aDtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdHMgPSBjaGFydC5vcHRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IGNlbnRlclggPSBzY2FsZS54Q2VudGVyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgIGNvbnN0IGRhdGFzZXRTdGFydEFuZ2xlID0gc2NhbGUuZ2V0SW5kZXhBbmdsZSgwKSAtIDAuNSAqIFBJO1xuICAgIGxldCBhbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGRlZmF1bHRBbmdsZSA9IDM2MCAvIHRoaXMuY291bnRWaXNpYmxlRWxlbWVudHMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RhcnQ7ICsraSkge1xuICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlKSB7XG4gICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRpb25PcHRzLmFuaW1hdGVSb3RhdGUpIHtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGUgPSBkYXRhc2V0U3RhcnRBbmdsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgeTogY2VudGVyWSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IDAsXG4gICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIGNvdW50VmlzaWJsZUVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbWV0YS5kYXRhLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICBjb3VudCsrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb3VudDtcbiAgfVxuICBfY29tcHV0ZUFuZ2xlKGluZGV4LCBtb2RlLCBkZWZhdWx0QW5nbGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleClcbiAgICAgID8gdG9SYWRpYW5zKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkuYW5nbGUgfHwgZGVmYXVsdEFuZ2xlKVxuICAgICAgOiAwO1xuICB9XG59XG5Qb2xhckFyZWFDb250cm9sbGVyLmlkID0gJ3BvbGFyQXJlYSc7XG5Qb2xhckFyZWFDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogdHJ1ZVxuICB9LFxuICBhbmltYXRpb25zOiB7XG4gICAgbnVtYmVyczoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICdzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJ11cbiAgICB9LFxuICB9LFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc3RhcnRBbmdsZTogMCxcbn07XG5Qb2xhckFyZWFDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgYXNwZWN0UmF0aW86IDEsXG4gIHBsdWdpbnM6IHtcbiAgICBsZWdlbmQ6IHtcbiAgICAgIGxhYmVsczoge1xuICAgICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5kYXRhO1xuICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHtsYWJlbHM6IHtwb2ludFN0eWxlfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmxhYmVscy5tYXAoKGxhYmVsLCBpKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogbGFiZWwsXG4gICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICAgIGxlZ2VuZC5jaGFydC50b2dnbGVEYXRhVmlzaWJpbGl0eShsZWdlbmRJdGVtLmluZGV4KTtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmNoYXJ0LmRhdGEubGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XSArICc6ICcgKyBjb250ZXh0LmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgZGlzcGxheTogZmFsc2VcbiAgICAgIH0sXG4gICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgY2lyY3VsYXI6IHRydWVcbiAgICAgIH0sXG4gICAgICBwb2ludExhYmVsczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHN0YXJ0QW5nbGU6IDBcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xufVxuUGllQ29udHJvbGxlci5pZCA9ICdwaWUnO1xuUGllQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgY3V0b3V0OiAwLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJ1xufTtcblxuY2xhc3MgUmFkYXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogdlNjYWxlLmdldExhYmVscygpW2luZGV4XSxcbiAgICAgIHZhbHVlOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pXG4gICAgfTtcbiAgfVxuICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgcmV0dXJuIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZS5iaW5kKHRoaXMpKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICBjb25zdCBsYWJlbHMgPSBtZXRhLmlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICBvcHRpb25zLmJvcmRlcldpZHRoID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIF9sb29wOiB0cnVlLFxuICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG4gICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICBza2lwOiBpc05hTih4KSB8fCBpc05hTih5KSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG59XG5SYWRhckNvbnRyb2xsZXIuaWQgPSAncmFkYXInO1xuUmFkYXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBpbmRleEF4aXM6ICdyJyxcbiAgc2hvd0xpbmU6IHRydWUsXG4gIGVsZW1lbnRzOiB7XG4gICAgbGluZToge1xuICAgICAgZmlsbDogJ3N0YXJ0J1xuICAgIH1cbiAgfSxcbn07XG5SYWRhckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgc2NhbGVzOiB7XG4gICAgcjoge1xuICAgICAgdHlwZTogJ3JhZGlhbExpbmVhcicsXG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRhbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIGhhc1ZhbHVlKCkge1xuICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gIH1cbiAgZ2V0UHJvcHMocHJvcHMsIGZpbmFsKSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLiRhbmltYXRpb25zO1xuICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY29uc3QgcmV0ID0ge307XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIHJldFtwcm9wXSA9IGFuaW1zW3Byb3BdICYmIGFuaW1zW3Byb3BdLmFjdGl2ZSgpID8gYW5pbXNbcHJvcF0uX3RvIDogdGhpc1twcm9wXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG59XG5FbGVtZW50LmRlZmF1bHRzID0ge307XG5FbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG5cbmNvbnN0IGZvcm1hdHRlcnMgPSB7XG4gIHZhbHVlcyh2YWx1ZSkge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogJycgKyB2YWx1ZTtcbiAgfSxcbiAgbnVtZXJpYyh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgIGlmICh0aWNrVmFsdWUgPT09IDApIHtcbiAgICAgIHJldHVybiAnMCc7XG4gICAgfVxuICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgbGV0IG5vdGF0aW9uO1xuICAgIGxldCBkZWx0YSA9IHRpY2tWYWx1ZTtcbiAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgbm90YXRpb24gPSAnc2NpZW50aWZpYyc7XG4gICAgICB9XG4gICAgICBkZWx0YSA9IGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpO1xuICAgIH1cbiAgICBjb25zdCBsb2dEZWx0YSA9IGxvZzEwKE1hdGguYWJzKGRlbHRhKSk7XG4gICAgY29uc3QgbnVtRGVjaW1hbCA9IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtub3RhdGlvbiwgbWluaW11bUZyYWN0aW9uRGlnaXRzOiBudW1EZWNpbWFsLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWx9O1xuICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih0aWNrVmFsdWUsIGxvY2FsZSwgb3B0aW9ucyk7XG4gIH0sXG4gIGxvZ2FyaXRobWljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgcmVtYWluID0gdGlja1ZhbHVlIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWx1ZSkpKSk7XG4gICAgaWYgKHJlbWFpbiA9PT0gMSB8fCByZW1haW4gPT09IDIgfHwgcmVtYWluID09PSA1KSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1lcmljLmNhbGwodGhpcywgdGlja1ZhbHVlLCBpbmRleCwgdGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gIGxldCBkZWx0YSA9IHRpY2tzLmxlbmd0aCA+IDMgPyB0aWNrc1syXS52YWx1ZSAtIHRpY2tzWzFdLnZhbHVlIDogdGlja3NbMV0udmFsdWUgLSB0aWNrc1swXS52YWx1ZTtcbiAgaWYgKE1hdGguYWJzKGRlbHRhKSA+PSAxICYmIHRpY2tWYWx1ZSAhPT0gTWF0aC5mbG9vcih0aWNrVmFsdWUpKSB7XG4gICAgZGVsdGEgPSB0aWNrVmFsdWUgLSBNYXRoLmZsb29yKHRpY2tWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGRlbHRhO1xufVxudmFyIFRpY2tzID0ge2Zvcm1hdHRlcnN9O1xuXG5kZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICBkaXNwbGF5OiB0cnVlLFxuICBvZmZzZXQ6IGZhbHNlLFxuICByZXZlcnNlOiBmYWxzZSxcbiAgYmVnaW5BdFplcm86IGZhbHNlLFxuICBib3VuZHM6ICd0aWNrcycsXG4gIGdyYWNlOiAwLFxuICBncmlkOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgZHJhd0JvcmRlcjogdHJ1ZSxcbiAgICBkcmF3T25DaGFydEFyZWE6IHRydWUsXG4gICAgZHJhd1RpY2tzOiB0cnVlLFxuICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgdGlja1dpZHRoOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5saW5lV2lkdGgsXG4gICAgdGlja0NvbG9yOiAoX2N0eCwgb3B0aW9ucykgPT4gb3B0aW9ucy5jb2xvcixcbiAgICBvZmZzZXQ6IGZhbHNlLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMCxcbiAgICBib3JkZXJXaWR0aDogMVxuICB9LFxuICB0aXRsZToge1xuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIHRleHQ6ICcnLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNCxcbiAgICAgIGJvdHRvbTogNFxuICAgIH1cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICBtYXhSb3RhdGlvbjogNTAsXG4gICAgbWlycm9yOiBmYWxzZSxcbiAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgdGV4dFN0cm9rZUNvbG9yOiAnJyxcbiAgICBwYWRkaW5nOiAzLFxuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgYXV0b1NraXA6IHRydWUsXG4gICAgYXV0b1NraXBQYWRkaW5nOiAzLFxuICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLnZhbHVlcyxcbiAgICBtaW5vcjoge30sXG4gICAgbWFqb3I6IHt9LFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBjcm9zc0FsaWduOiAnbmVhcicsXG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgIGJhY2tkcm9wQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpJyxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gIH1cbn0pO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpY2tzJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdib3JkZXJDb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS50aXRsZScsICdjb2xvcicsICcnLCAnY29sb3InKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZScsIHtcbiAgX2ZhbGxiYWNrOiBmYWxzZSxcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ3RpY2tCb3JkZXJEYXNoJyxcbn0pO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgX2ZhbGxiYWNrOiAnc2NhbGUnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGUudGlja3MnLCB7XG4gIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnLFxufSk7XG5cbmZ1bmN0aW9uIGF1dG9Ta2lwKHNjYWxlLCB0aWNrcykge1xuICBjb25zdCB0aWNrT3B0cyA9IHNjYWxlLm9wdGlvbnMudGlja3M7XG4gIGNvbnN0IHRpY2tzTGltaXQgPSB0aWNrT3B0cy5tYXhUaWNrc0xpbWl0IHx8IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgY29uc3QgbnVtTWFqb3JJbmRpY2VzID0gbWFqb3JJbmRpY2VzLmxlbmd0aDtcbiAgY29uc3QgZmlyc3QgPSBtYWpvckluZGljZXNbMF07XG4gIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gIGNvbnN0IG5ld1RpY2tzID0gW107XG4gIGlmIChudW1NYWpvckluZGljZXMgPiB0aWNrc0xpbWl0KSB7XG4gICAgc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgbnVtTWFqb3JJbmRpY2VzIC8gdGlja3NMaW1pdCk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIGNvbnN0IHNwYWNpbmcgPSBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpO1xuICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGNvbnN0IGF2Z01ham9yU3BhY2luZyA9IG51bU1ham9ySW5kaWNlcyA+IDEgPyBNYXRoLnJvdW5kKChsYXN0IC0gZmlyc3QpIC8gKG51bU1ham9ySW5kaWNlcyAtIDEpKSA6IG51bGw7XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JJbmRpY2VzW2ldLCBtYWpvckluZGljZXNbaSArIDFdKTtcbiAgICB9XG4gICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGxhc3QsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IHRpY2tzLmxlbmd0aCA6IGxhc3QgKyBhdmdNYWpvclNwYWNpbmcpO1xuICAgIHJldHVybiBuZXdUaWNrcztcbiAgfVxuICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gIHJldHVybiBuZXdUaWNrcztcbn1cbmZ1bmN0aW9uIGRldGVybWluZU1heFRpY2tzKHNjYWxlKSB7XG4gIGNvbnN0IG9mZnNldCA9IHNjYWxlLm9wdGlvbnMub2Zmc2V0O1xuICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gIGNvbnN0IG1heFNjYWxlID0gc2NhbGUuX2xlbmd0aCAvIHRpY2tMZW5ndGggKyAob2Zmc2V0ID8gMCA6IDEpO1xuICBjb25zdCBtYXhDaGFydCA9IHNjYWxlLl9tYXhMZW5ndGggLyB0aWNrTGVuZ3RoO1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCkge1xuICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgY29uc3Qgc3BhY2luZyA9IHRpY2tzLmxlbmd0aCAvIHRpY2tzTGltaXQ7XG4gIGlmICghZXZlbk1ham9yU3BhY2luZykge1xuICAgIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbiAgfVxuICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBmYWN0b3JzLmxlbmd0aCAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBjb25zdCBmYWN0b3IgPSBmYWN0b3JzW2ldO1xuICAgIGlmIChmYWN0b3IgPiBzcGFjaW5nKSB7XG4gICAgICByZXR1cm4gZmFjdG9yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gTWF0aC5tYXgoc3BhY2luZywgMSk7XG59XG5mdW5jdGlvbiBnZXRNYWpvckluZGljZXModGlja3MpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgaWYgKHRpY2tzW2ldLm1ham9yKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHNraXBNYWpvcnModGlja3MsIG5ld1RpY2tzLCBtYWpvckluZGljZXMsIHNwYWNpbmcpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgbGV0IG5leHQgPSBtYWpvckluZGljZXNbMF07XG4gIGxldCBpO1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICBjb3VudCsrO1xuICAgICAgbmV4dCA9IG1ham9ySW5kaWNlc1tjb3VudCAqIHNwYWNpbmddO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIG1ham9yU3RhcnQsIG1ham9yRW5kKSB7XG4gIGNvbnN0IHN0YXJ0ID0gdmFsdWVPckRlZmF1bHQobWFqb3JTdGFydCwgMCk7XG4gIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbGVuZ3RoLCBpLCBuZXh0O1xuICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICBpZiAobWFqb3JFbmQpIHtcbiAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgc3BhY2luZyA9IGxlbmd0aCAvIE1hdGguZmxvb3IobGVuZ3RoIC8gc3BhY2luZyk7XG4gIH1cbiAgbmV4dCA9IHN0YXJ0O1xuICB3aGlsZSAobmV4dCA8IDApIHtcbiAgICBjb3VudCsrO1xuICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgfVxuICBmb3IgKGkgPSBNYXRoLm1heChzdGFydCwgMCk7IGkgPCBlbmQ7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFdmVuU3BhY2luZyhhcnIpIHtcbiAgY29uc3QgbGVuID0gYXJyLmxlbmd0aDtcbiAgbGV0IGksIGRpZmY7XG4gIGlmIChsZW4gPCAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuXG5jb25zdCByZXZlcnNlQWxpZ24gPSAoYWxpZ24pID0+IGFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpID0+IGVkZ2UgPT09ICd0b3AnIHx8IGVkZ2UgPT09ICdsZWZ0JyA/IHNjYWxlW2VkZ2VdICsgb2Zmc2V0IDogc2NhbGVbZWRnZV0gLSBvZmZzZXQ7XG5mdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3QgaW5jcmVtZW50ID0gYXJyLmxlbmd0aCAvIG51bUl0ZW1zO1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG4gIGZvciAoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCkge1xuICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldFBpeGVsRm9yR3JpZExpbmUoc2NhbGUsIGluZGV4LCBvZmZzZXRHcmlkTGluZXMpIHtcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUudGlja3MubGVuZ3RoO1xuICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICBjb25zdCBzdGFydCA9IHNjYWxlLl9zdGFydFBpeGVsO1xuICBjb25zdCBlbmQgPSBzY2FsZS5fZW5kUGl4ZWw7XG4gIGNvbnN0IGVwc2lsb24gPSAxZS02O1xuICBsZXQgbGluZVZhbHVlID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXgpO1xuICBsZXQgb2Zmc2V0O1xuICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgobGluZVZhbHVlIC0gc3RhcnQsIGVuZCAtIGxpbmVWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgb2Zmc2V0ID0gKHNjYWxlLmdldFBpeGVsRm9yVGljaygxKSAtIGxpbmVWYWx1ZSkgLyAyO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgIH1cbiAgICBsaW5lVmFsdWUgKz0gdmFsaWRJbmRleCA8IGluZGV4ID8gb2Zmc2V0IDogLW9mZnNldDtcbiAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpbmVWYWx1ZTtcbn1cbmZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gIGVhY2goY2FjaGVzLCAoY2FjaGUpID0+IHtcbiAgICBjb25zdCBnYyA9IGNhY2hlLmdjO1xuICAgIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgICBsZXQgaTtcbiAgICBpZiAoZ2NMZW4gPiBsZW5ndGgpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnY0xlbjsgKytpKSB7XG4gICAgICAgIGRlbGV0ZSBjYWNoZS5kYXRhW2djW2ldXTtcbiAgICAgIH1cbiAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuZHJhd1RpY2tzID8gb3B0aW9ucy50aWNrTGVuZ3RoIDogMDtcbn1cbmZ1bmN0aW9uIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMsIGZhbGxiYWNrKSB7XG4gIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkob3B0aW9ucy50ZXh0KSA/IG9wdGlvbnMudGV4dC5sZW5ndGggOiAxO1xuICByZXR1cm4gKGxpbmVzICogZm9udC5saW5lSGVpZ2h0KSArIHBhZGRpbmcuaGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlU2NhbGVDb250ZXh0KHBhcmVudCwgc2NhbGUpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgc2NhbGUsXG4gICAgdHlwZTogJ3NjYWxlJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpY2tDb250ZXh0KHBhcmVudCwgaW5kZXgsIHRpY2spIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdGljayxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAndGljaydcbiAgfSk7XG59XG5mdW5jdGlvbiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSkge1xuICBsZXQgcmV0ID0gX3RvTGVmdFJpZ2h0Q2VudGVyKGFsaWduKTtcbiAgaWYgKChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnKSB8fCAoIXJldmVyc2UgJiYgcG9zaXRpb24gPT09ICdyaWdodCcpKSB7XG4gICAgcmV0ID0gcmV2ZXJzZUFsaWduKHJldCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRpdGxlQXJncyhzY2FsZSwgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pIHtcbiAgY29uc3Qge3RvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgY2hhcnR9ID0gc2NhbGU7XG4gIGNvbnN0IHtjaGFydEFyZWEsIHNjYWxlc30gPSBjaGFydDtcbiAgbGV0IHJvdGF0aW9uID0gMDtcbiAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgY29uc3QgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVZID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpdGxlWSA9IG9mZnNldEZyb21FZGdlKHNjYWxlLCBwb3NpdGlvbiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgdGl0bGVYID0gKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIgLSB3aWR0aCArIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVYID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgIHJvdGF0aW9uID0gcG9zaXRpb24gPT09ICdsZWZ0JyA/IC1IQUxGX1BJIDogSEFMRl9QSTtcbiAgfVxuICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xufVxuY2xhc3MgU2NhbGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY2ZnLmlkO1xuICAgIHRoaXMudHlwZSA9IGNmZy50eXBlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmN0eCA9IGNmZy5jdHg7XG4gICAgdGhpcy5jaGFydCA9IGNmZy5jaGFydDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX21hcmdpbnMgPSB7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9O1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYXhpcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUm90YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5taW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcmFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aWNrcyA9IFtdO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gMDtcbiAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl91c2VyTWluID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSAwO1xuICAgIHRoaXMuX2JvcmRlclZhbHVlID0gMDtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5heGlzID0gb3B0aW9ucy5heGlzO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLm1heCk7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWluID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1pbik7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIHJldHVybiByYXc7XG4gIH1cbiAgZ2V0VXNlckJvdW5kcygpIHtcbiAgICBsZXQge191c2VyTWluLCBfdXNlck1heCwgX3N1Z2dlc3RlZE1pbiwgX3N1Z2dlc3RlZE1heH0gPSB0aGlzO1xuICAgIF91c2VyTWluID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1pbiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICBfc3VnZ2VzdGVkTWF4ID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgIG1pbkRlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWluKSxcbiAgICAgIG1heERlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWF4KVxuICAgIH07XG4gIH1cbiAgZ2V0TWluTWF4KGNhblN0YWNrKSB7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgcmFuZ2U7XG4gICAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHttaW4sIG1heH07XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzID0gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICByYW5nZSA9IG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0TWluTWF4KHRoaXMsIGNhblN0YWNrKTtcbiAgICAgIGlmICghbWluRGVmaW5lZCkge1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByYW5nZS5tYXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBtYXhEZWZpbmVkICYmIG1pbiA+IG1heCA/IG1heCA6IG1pbjtcbiAgICBtYXggPSBtaW5EZWZpbmVkICYmIG1pbiA+IG1heCA/IG1pbiA6IG1heDtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICB9O1xuICB9XG4gIGdldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICB9O1xuICB9XG4gIGdldFRpY2tzKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICB9XG4gIGdldExhYmVscygpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgfVxuICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gIH1cbiAgYmVmb3JlVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVVcGRhdGUsIFt0aGlzXSk7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICBjb25zdCB7YmVnaW5BdFplcm8sIGdyYWNlLCB0aWNrczogdGlja09wdHN9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuICAgIHRoaXMuYmVmb3JlVXBkYXRlKCk7XG4gICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgIHRoaXMuX21hcmdpbnMgPSBtYXJnaW5zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBsZWZ0OiAwLFxuICAgICAgcmlnaHQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgICBib3R0b206IDBcbiAgICB9LCBtYXJnaW5zKTtcbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICB0aGlzLl9ncmlkTGluZUl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICB0aGlzLmJlZm9yZVNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuX21heExlbmd0aCA9IHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHRcbiAgICAgIDogdGhpcy5oZWlnaHQgKyBtYXJnaW5zLnRvcCArIG1hcmdpbnMuYm90dG9tO1xuICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlQnVpbGRUaWNrcygpO1xuICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcbiAgICB0aGlzLmFmdGVyQnVpbGRUaWNrcygpO1xuICAgIGNvbnN0IHNhbXBsaW5nRW5hYmxlZCA9IHNhbXBsZVNpemUgPCB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcbiAgICB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgIHRoaXMuYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgKHRpY2tPcHRzLmF1dG9Ta2lwIHx8IHRpY2tPcHRzLnNvdXJjZSA9PT0gJ2F1dG8nKSkge1xuICAgICAgdGhpcy50aWNrcyA9IGF1dG9Ta2lwKHRoaXMsIHRoaXMudGlja3MpO1xuICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICB0aGlzLmFmdGVyQXV0b1NraXAoKTtcbiAgICB9XG4gICAgaWYgKHNhbXBsaW5nRW5hYmxlZCkge1xuICAgICAgdGhpcy5fY29udmVydFRpY2tzVG9MYWJlbHModGhpcy50aWNrcyk7XG4gICAgfVxuICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgdGhpcy5maXQoKTtcbiAgICB0aGlzLmFmdGVyRml0KCk7XG4gICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBsZXQgcmV2ZXJzZVBpeGVscyA9IHRoaXMub3B0aW9ucy5yZXZlcnNlO1xuICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMubGVmdDtcbiAgICAgIGVuZFBpeGVsID0gdGhpcy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQaXhlbCA9IHRoaXMudG9wO1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLmJvdHRvbTtcbiAgICAgIHJldmVyc2VQaXhlbHMgPSAhcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRQaXhlbCA9IHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fZW5kUGl4ZWwgPSBlbmRQaXhlbDtcbiAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICB0aGlzLl9sZW5ndGggPSBlbmRQaXhlbCAtIHN0YXJ0UGl4ZWw7XG4gICAgdGhpcy5fYWxpZ25Ub1BpeGVscyA9IHRoaXMub3B0aW9ucy5hbGlnblRvUGl4ZWxzO1xuICB9XG4gIGFmdGVyVXBkYXRlKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVTZXREaW1lbnNpb25zKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIHNldERpbWVuc2lvbnMoKSB7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgdGhpcy5sZWZ0ID0gMDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgdGhpcy5wYWRkaW5nTGVmdCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICB0aGlzLnBhZGRpbmdSaWdodCA9IDA7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gMDtcbiAgfVxuICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyU2V0RGltZW5zaW9ucywgW3RoaXNdKTtcbiAgfVxuICBfY2FsbEhvb2tzKG5hbWUpIHtcbiAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9uc1tuYW1lXSwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVEYXRhTGltaXRzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7fVxuICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckRhdGFMaW1pdHMnKTtcbiAgfVxuICBiZWZvcmVCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyQnVpbGRUaWNrcycpO1xuICB9XG4gIGJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHRpY2sgPSB0aWNrc1tpXTtcbiAgICAgIHRpY2subGFiZWwgPSBjYWxsYmFjayh0aWNrT3B0cy5jYWxsYmFjaywgW3RpY2sudmFsdWUsIGksIHRpY2tzXSwgdGhpcyk7XG4gICAgfVxuICB9XG4gIGFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbiwgW3RoaXNdKTtcbiAgfVxuICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uLCBbdGhpc10pO1xuICB9XG4gIGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgbnVtVGlja3MgPSB0aGlzLnRpY2tzLmxlbmd0aDtcbiAgICBjb25zdCBtaW5Sb3RhdGlvbiA9IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDA7XG4gICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICBsZXQgbGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgIGxldCB0aWNrV2lkdGgsIG1heEhlaWdodCwgbWF4TGFiZWxEaWFnb25hbDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBjb25zdCBtYXhMYWJlbEhlaWdodCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQ7XG4gICAgY29uc3QgbWF4V2lkdGggPSBfbGltaXRWYWx1ZSh0aGlzLmNoYXJ0LndpZHRoIC0gbWF4TGFiZWxXaWR0aCwgMCwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgIGlmIChtYXhMYWJlbFdpZHRoICsgNiA+IHRpY2tXaWR0aCkge1xuICAgICAgdGlja1dpZHRoID0gbWF4V2lkdGggLyAobnVtVGlja3MgLSAob3B0aW9ucy5vZmZzZXQgPyAwLjUgOiAxKSk7XG4gICAgICBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIGdldFRpY2tNYXJrTGVuZ3RoKG9wdGlvbnMuZ3JpZClcblx0XHRcdFx0LSB0aWNrT3B0cy5wYWRkaW5nIC0gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucy50aXRsZSwgdGhpcy5jaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgbWF4TGFiZWxEaWFnb25hbCA9IE1hdGguc3FydChtYXhMYWJlbFdpZHRoICogbWF4TGFiZWxXaWR0aCArIG1heExhYmVsSGVpZ2h0ICogbWF4TGFiZWxIZWlnaHQpO1xuICAgICAgbGFiZWxSb3RhdGlvbiA9IHRvRGVncmVlcyhNYXRoLm1pbihcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksXG4gICAgICAgIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKVxuICAgICAgKSk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gTWF0aC5tYXgobWluUm90YXRpb24sIE1hdGgubWluKG1heFJvdGF0aW9uLCBsYWJlbFJvdGF0aW9uKSk7XG4gICAgfVxuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gIH1cbiAgYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG4gIGJlZm9yZUZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbdGhpc10pO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCBtaW5TaXplID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGNvbnN0IHtjaGFydCwgb3B0aW9uczoge3RpY2tzOiB0aWNrT3B0cywgdGl0bGU6IHRpdGxlT3B0cywgZ3JpZDogZ3JpZE9wdHN9fSA9IHRoaXM7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMuX2lzVmlzaWJsZSgpO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgaWYgKGRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gZ2V0VGl0bGVIZWlnaHQodGl0bGVPcHRzLCBjaGFydC5vcHRpb25zLmZvbnQpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1pblNpemUuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHtmaXJzdCwgbGFzdCwgd2lkZXN0LCBoaWdoZXN0fSA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja1BhZGRpbmcgPSB0aWNrT3B0cy5wYWRkaW5nICogMjtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvcyA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICBjb25zdCBsYWJlbEhlaWdodCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBzaW4gKiB3aWRlc3Qud2lkdGggKyBjb3MgKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IE1hdGgubWluKHRoaXMubWF4SGVpZ2h0LCBtaW5TaXplLmhlaWdodCArIGxhYmVsSGVpZ2h0ICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogY29zICogd2lkZXN0LndpZHRoICsgc2luICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9sZW5ndGggPSBjaGFydC53aWR0aCAtIHRoaXMuX21hcmdpbnMubGVmdCAtIHRoaXMuX21hcmdpbnMucmlnaHQ7XG4gICAgICB0aGlzLmhlaWdodCA9IG1pblNpemUuaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndpZHRoID0gbWluU2l6ZS53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQuaGVpZ2h0IC0gdGhpcy5fbWFyZ2lucy50b3AgLSB0aGlzLl9tYXJnaW5zLmJvdHRvbTtcbiAgICB9XG4gIH1cbiAgX2NhbGN1bGF0ZVBhZGRpbmcoZmlyc3QsIGxhc3QsIHNpbiwgY29zKSB7XG4gICAgY29uc3Qge3RpY2tzOiB7YWxpZ24sIHBhZGRpbmd9LCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgaXNSb3RhdGVkID0gdGhpcy5sYWJlbFJvdGF0aW9uICE9PSAwO1xuICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIGNvbnN0IG9mZnNldExlZnQgPSB0aGlzLmdldFBpeGVsRm9yVGljaygwKSAtIHRoaXMubGVmdDtcbiAgICAgIGNvbnN0IG9mZnNldFJpZ2h0ID0gdGhpcy5yaWdodCAtIHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKHRoaXMudGlja3MubGVuZ3RoIC0gMSk7XG4gICAgICBsZXQgcGFkZGluZ0xlZnQgPSAwO1xuICAgICAgbGV0IHBhZGRpbmdSaWdodCA9IDA7XG4gICAgICBpZiAoaXNSb3RhdGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgcGFkZGluZ0xlZnQgPSBjb3MgKiBmaXJzdC53aWR0aDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBzaW4gKiBsYXN0LmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IHNpbiAqIGZpcnN0LmhlaWdodDtcbiAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoIC8gMjtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aCAvIDI7XG4gICAgICB9XG4gICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gTWF0aC5tYXgoKHBhZGRpbmdMZWZ0IC0gb2Zmc2V0TGVmdCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0TGVmdCksIDApO1xuICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSBNYXRoLm1heCgocGFkZGluZ1JpZ2h0IC0gb2Zmc2V0UmlnaHQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldFJpZ2h0KSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQgLyAyO1xuICAgICAgbGV0IHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQgLyAyO1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHBhZGRpbmdUb3AgPSAwO1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IGxhc3QuaGVpZ2h0O1xuICAgICAgICBwYWRkaW5nQm90dG9tID0gMDtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ1RvcCA9IHBhZGRpbmdUb3AgKyBwYWRkaW5nO1xuICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gcGFkZGluZ0JvdHRvbSArIHBhZGRpbmc7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgIGlmICh0aGlzLl9tYXJnaW5zKSB7XG4gICAgICB0aGlzLl9tYXJnaW5zLmxlZnQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdMZWZ0LCB0aGlzLl9tYXJnaW5zLmxlZnQpO1xuICAgICAgdGhpcy5fbWFyZ2lucy50b3AgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdUb3AsIHRoaXMuX21hcmdpbnMudG9wKTtcbiAgICAgIHRoaXMuX21hcmdpbnMucmlnaHQgPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdSaWdodCwgdGhpcy5fbWFyZ2lucy5yaWdodCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLmJvdHRvbSA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0JvdHRvbSwgdGhpcy5fbWFyZ2lucy5ib3R0b20pO1xuICAgIH1cbiAgfVxuICBhZnRlckZpdCgpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJGaXQsIFt0aGlzXSk7XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHtheGlzLCBwb3NpdGlvbn0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgYXhpcyA9PT0gJ3gnO1xuICB9XG4gIGlzRnVsbFNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mdWxsU2l6ZTtcbiAgfVxuICBfY29udmVydFRpY2tzVG9MYWJlbHModGlja3MpIHtcbiAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIHRoaXMuZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZih0aWNrc1tpXS5sYWJlbCkpIHtcbiAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICBpbGVuLS07XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICB9XG4gIF9nZXRMYWJlbFNpemVzKCkge1xuICAgIGxldCBsYWJlbFNpemVzID0gdGhpcy5fbGFiZWxTaXplcztcbiAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICB0aWNrcyA9IHNhbXBsZSh0aWNrcywgc2FtcGxlU2l6ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbGFiZWxTaXplcyA9IHRoaXMuX2NvbXB1dGVMYWJlbFNpemVzKHRpY2tzLCB0aWNrcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gbGFiZWxTaXplcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCkge1xuICAgIGNvbnN0IHtjdHgsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXN9ID0gdGhpcztcbiAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRzID0gW107XG4gICAgbGV0IHdpZGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGhpZ2hlc3RMYWJlbFNpemUgPSAwO1xuICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIGxhYmVsID0gdGlja3NbaV0ubGFiZWw7XG4gICAgICB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaSk7XG4gICAgICBjdHguZm9udCA9IGZvbnRTdHJpbmcgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tmb250U3RyaW5nXSA9IGNhY2hlc1tmb250U3RyaW5nXSB8fCB7ZGF0YToge30sIGdjOiBbXX07XG4gICAgICBsaW5lSGVpZ2h0ID0gdGlja0ZvbnQubGluZUhlaWdodDtcbiAgICAgIHdpZHRoID0gaGVpZ2h0ID0gMDtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihsYWJlbCkgJiYgIWlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBsYWJlbCk7XG4gICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsYWJlbC5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBuZXN0ZWRMYWJlbCA9IGxhYmVsW2pdO1xuICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgfVxuICAgIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKTtcbiAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgIGNvbnN0IGhpZ2hlc3QgPSBoZWlnaHRzLmluZGV4T2YoaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgdmFsdWVBdCA9IChpZHgpID0+ICh7d2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsIGhlaWdodDogaGVpZ2h0c1tpZHhdIHx8IDB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgZmlyc3Q6IHZhbHVlQXQoMCksXG4gICAgICBsYXN0OiB2YWx1ZUF0KGxlbmd0aCAtIDEpLFxuICAgICAgd2lkZXN0OiB2YWx1ZUF0KHdpZGVzdCksXG4gICAgICBoaWdoZXN0OiB2YWx1ZUF0KGhpZ2hlc3QpLFxuICAgICAgd2lkdGhzLFxuICAgICAgaGVpZ2h0cyxcbiAgICB9O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHt9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRQaXhlbEZvckRlY2ltYWwoZGVjaW1hbCkge1xuICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgfVxuICAgIGNvbnN0IHBpeGVsID0gdGhpcy5fc3RhcnRQaXhlbCArIGRlY2ltYWwgKiB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IChwaXhlbCAtIHRoaXMuX3N0YXJ0UGl4ZWwpIC8gdGhpcy5fbGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldEJhc2VWYWx1ZSgpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDpcbiAgICAgIG1pbiA+IDAgJiYgbWF4ID4gMCA/IG1pbiA6XG4gICAgICAwO1xuICB9XG4gIGdldENvbnRleHQoaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgICByZXR1cm4gdGljay4kY29udGV4dCB8fFxuXHRcdFx0XHQodGljay4kY29udGV4dCA9IGNyZWF0ZVRpY2tDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgdGljaykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVTY2FsZUNvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMpKTtcbiAgfVxuICBfdGlja1NpemUoKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3Qgcm90ID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4ocm90KSk7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgY29uc3QgdyA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLndpZGVzdC53aWR0aCArIHBhZGRpbmcgOiAwO1xuICAgIGNvbnN0IGggPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIHBhZGRpbmcgOiAwO1xuICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpXG4gICAgICA/IGggKiBjb3MgPiB3ICogc2luID8gdyAvIGNvcyA6IGggLyBzaW5cbiAgICAgIDogaCAqIHNpbiA8IHcgKiBjb3MgPyBoIC8gY29zIDogdyAvIHNpbjtcbiAgfVxuICBfaXNWaXNpYmxlKCkge1xuICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICBpZiAoZGlzcGxheSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gISFkaXNwbGF5O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2NvbXB1dGVHcmlkTGluZUl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2dyaWQsIHBvc2l0aW9ufSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZ3JpZC5vZmZzZXQ7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgdGlja3NMZW5ndGggPSB0aWNrcy5sZW5ndGggKyAob2Zmc2V0ID8gMSA6IDApO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgoZ3JpZCk7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCBib3JkZXJPcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBheGlzV2lkdGggPSBib3JkZXJPcHRzLmRyYXdCb3JkZXIgPyBib3JkZXJPcHRzLmJvcmRlcldpZHRoIDogMDtcbiAgICBjb25zdCBheGlzSGFsZldpZHRoID0gYXhpc1dpZHRoIC8gMjtcbiAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgfTtcbiAgICBsZXQgYm9yZGVyVmFsdWUsIGksIGxpbmVWYWx1ZSwgYWxpZ25lZExpbmVWYWx1ZTtcbiAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5ib3R0b20pO1xuICAgICAgdHkxID0gdGhpcy5ib3R0b20gLSB0bDtcbiAgICAgIHR5MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEudG9wKSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnRvcCk7XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLmJvdHRvbSkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHkyID0gdGhpcy50b3AgKyB0bDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMubGVmdCk7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5yaWdodCkgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdGhpcy5sZWZ0ICsgdGw7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyICsgMC41KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICB9XG4gICAgICB5MSA9IGNoYXJ0QXJlYS50b3A7XG4gICAgICB5MiA9IGNoYXJ0QXJlYS5ib3R0b207XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0eTEgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS5sZWZ0ICsgY2hhcnRBcmVhLnJpZ2h0KSAvIDIpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHR4MSA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR4MiA9IHR4MSAtIHRsO1xuICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgIHgyID0gY2hhcnRBcmVhLnJpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1heCgxLCBNYXRoLmNlaWwodGlja3NMZW5ndGggLyBsaW1pdCkpO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aWNrc0xlbmd0aDsgaSArPSBzdGVwKSB7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaSkpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG4gICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBhbGlnbmVkTGluZVZhbHVlID0gX2FsaWduUGl4ZWwoY2hhcnQsIGxpbmVWYWx1ZSwgbGluZVdpZHRoKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgdHgxID0gdHgyID0geDEgPSB4MiA9IGFsaWduZWRMaW5lVmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICB0eDEsXG4gICAgICAgIHR5MSxcbiAgICAgICAgdHgyLFxuICAgICAgICB0eTIsXG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyLFxuICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICBjb2xvcjogbGluZUNvbG9yLFxuICAgICAgICBib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICB0aWNrV2lkdGgsXG4gICAgICAgIHRpY2tDb2xvcixcbiAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgIHRpY2tCb3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSBib3JkZXJWYWx1ZTtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4aXM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiBvcHRpb25UaWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IHthbGlnbiwgY3Jvc3NBbGlnbiwgcGFkZGluZywgbWlycm9yfSA9IG9wdGlvblRpY2tzO1xuICAgIGNvbnN0IHRsID0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCBoVGlja0FuZFBhZGRpbmcgPSBtaXJyb3IgPyAtcGFkZGluZyA6IHRpY2tBbmRQYWRkaW5nO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgbGV0IGksIGlsZW4sIHRpY2ssIGxhYmVsLCB4LCB5LCB0ZXh0QWxpZ24sIHBpeGVsLCBmb250LCBsaW5lSGVpZ2h0LCBsaW5lQ291bnQsIHRleHRPZmZzZXQ7XG4gICAgbGV0IHRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgeSA9IHRoaXMudG9wICsgaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgIHggPSByZXQueDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB5ID0gKChjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmJvdHRvbSkgLyAyKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB5ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChheGlzID09PSAneScpIHtcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgeCA9ICgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMikgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgeCA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgeCA9IHBpeGVsO1xuICAgICAgICBpZiAodGV4dEFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICAgICAgaWYgKGkgPT09IGlsZW4gLSAxKSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gIXRoaXMub3B0aW9ucy5yZXZlcnNlID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrVGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxpbmVDb3VudCAqIGxpbmVIZWlnaHQgKyBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gLWxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInIHx8IHJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLyAyIC0gaGFsZkNvdW50ICogbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICB0ZXh0T2Zmc2V0ID0gKDEgLSBsaW5lQ291bnQpICogbGluZUhlaWdodCAvIDI7XG4gICAgICB9XG4gICAgICBsZXQgYmFja2Ryb3A7XG4gICAgICBpZiAob3B0c0F0SW5kZXguc2hvd0xhYmVsQmFja2Ryb3ApIHtcbiAgICAgICAgY29uc3QgbGFiZWxQYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBsYWJlbFNpemVzLndpZHRoc1tpXTtcbiAgICAgICAgbGV0IHRvcCA9IHkgKyB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgbGV0IGxlZnQgPSB4IC0gbGFiZWxQYWRkaW5nLmxlZnQ7XG4gICAgICAgIHN3aXRjaCAodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ21pZGRsZSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wIC09IGhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRleHRBbGlnbikge1xuICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBiYWNrZHJvcCA9IHtcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyBsYWJlbFBhZGRpbmcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgZm9udCxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgdGV4dE9mZnNldCxcbiAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgIHRyYW5zbGF0aW9uOiBbeCwgeV0sXG4gICAgICAgIGJhY2tkcm9wLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCByb3RhdGlvbiA9IC10b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBpZiAocm90YXRpb24pIHtcbiAgICAgIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH1cbiAgICBsZXQgYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAodGlja3MuYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgYWxpZ24gPSAnaW5uZXInO1xuICAgIH1cbiAgICByZXR1cm4gYWxpZ247XG4gIH1cbiAgX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpIHtcbiAgICBjb25zdCB7cG9zaXRpb24sIHRpY2tzOiB7Y3Jvc3NBbGlnbiwgbWlycm9yLCBwYWRkaW5nfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICBjb25zdCB3aWRlc3QgPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICBsZXQgdGV4dEFsaWduO1xuICAgIGxldCB4O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggKz0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCArPSB3aWRlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB0aGlzLnJpZ2h0IC0gdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBpZiAobWlycm9yKSB7XG4gICAgICAgIHggPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgIHggLT0gKHdpZGVzdCAvIDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICB4IC09IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgeCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgcmV0dXJuIHt0ZXh0QWxpZ24sIHh9O1xuICB9XG4gIF9jb21wdXRlTGFiZWxBcmVhKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgcmV0dXJuIHt0b3A6IDAsIGxlZnQ6IHRoaXMubGVmdCwgYm90dG9tOiBjaGFydC5oZWlnaHQsIHJpZ2h0OiB0aGlzLnJpZ2h0fTtcbiAgICB9IGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICByZXR1cm4ge3RvcDogdGhpcy50b3AsIGxlZnQ6IDAsIGJvdHRvbTogdGhpcy5ib3R0b20sIHJpZ2h0OiBjaGFydC53aWR0aH07XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtiYWNrZ3JvdW5kQ29sb3J9LCBsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHR9ID0gdGhpcztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TGluZVdpZHRoRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCAhZ3JpZC5kaXNwbGF5KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGNvbnN0IGluZGV4ID0gdGlja3MuZmluZEluZGV4KHQgPT4gdC52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBjb25zdCBvcHRzID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgcmV0dXJuIG9wdHMubGluZVdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBkcmF3R3JpZChjaGFydEFyZWEpIHtcbiAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9ncmlkTGluZUl0ZW1zIHx8ICh0aGlzLl9ncmlkTGluZUl0ZW1zID0gdGhpcy5fY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgZHJhd0xpbmUgPSAocDEsIHAyLCBzdHlsZSkgPT4ge1xuICAgICAgaWYgKCFzdHlsZS53aWR0aCB8fCAhc3R5bGUuY29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBzdHlsZS53aWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHN0eWxlLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc3R5bGUuYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8ocDEueCwgcDEueSk7XG4gICAgICBjdHgubGluZVRvKHAyLngsIHAyLnkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICBpZiAoZ3JpZC5kcmF3T25DaGFydEFyZWEpIHtcbiAgICAgICAgICBkcmF3TGluZShcbiAgICAgICAgICAgIHt4OiBpdGVtLngxLCB5OiBpdGVtLnkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLngyLCB5OiBpdGVtLnkyfSxcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRyYXdUaWNrcykge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0udHgxLCB5OiBpdGVtLnR5MX0sXG4gICAgICAgICAgICB7eDogaXRlbS50eDIsIHk6IGl0ZW0udHkyfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29sb3I6IGl0ZW0udGlja0NvbG9yLFxuICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2g6IGl0ZW0udGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IGl0ZW0udGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCb3JkZXIoKSB7XG4gICAgY29uc3Qge2NoYXJ0LCBjdHgsIG9wdGlvbnM6IHtncmlkfX0gPSB0aGlzO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGdyaWQuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhc3RMaW5lV2lkdGggPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KDApKS5saW5lV2lkdGg7XG4gICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICBsZXQgeDEsIHgyLCB5MSwgeTI7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHgxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMubGVmdCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB4MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnJpZ2h0LCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeTEgPSB5MiA9IGJvcmRlclZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aDtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJPcHRzLmJvcmRlckNvbG9yO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdMYWJlbHMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9uVGlja3MgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgaWYgKGFyZWEpIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fbGFiZWxJdGVtcyB8fCAodGhpcy5fbGFiZWxJdGVtcyA9IHRoaXMuX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgaWYgKGl0ZW0uYmFja2Ryb3ApIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGl0ZW0uYmFja2Ryb3AuY29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpdGVtLmJhY2tkcm9wLmxlZnQsIGl0ZW0uYmFja2Ryb3AudG9wLCBpdGVtLmJhY2tkcm9wLndpZHRoLCBpdGVtLmJhY2tkcm9wLmhlaWdodCk7XG4gICAgICB9XG4gICAgICBsZXQgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIGl0ZW0pO1xuICAgIH1cbiAgICBpZiAoYXJlYSkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge3Bvc2l0aW9uLCB0aXRsZSwgcmV2ZXJzZX19ID0gdGhpcztcbiAgICBpZiAoIXRpdGxlLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlLnBhZGRpbmcpO1xuICAgIGNvbnN0IGFsaWduID0gdGl0bGUuYWxpZ247XG4gICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBwb3NpdGlvbiA9PT0gJ2NlbnRlcicgfHwgaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBvZmZzZXQgKz0gcGFkZGluZy5ib3R0b207XG4gICAgICBpZiAoaXNBcnJheSh0aXRsZS50ZXh0KSkge1xuICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLnRvcDtcbiAgICB9XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGUudGV4dCwgMCwgMCwgZm9udCwge1xuICAgICAgY29sb3I6IHRpdGxlLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogdGl0bGVBbGlnbihhbGlnbiwgcG9zaXRpb24sIHJldmVyc2UpLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG4gIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgdGhpcy5kcmF3TGFiZWxzKGNoYXJ0QXJlYSk7XG4gIH1cbiAgX2xheWVycygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHR6ID0gb3B0cy50aWNrcyAmJiBvcHRzLnRpY2tzLnogfHwgMDtcbiAgICBjb25zdCBneiA9IHZhbHVlT3JEZWZhdWx0KG9wdHMuZ3JpZCAmJiBvcHRzLmdyaWQueiwgLTEpO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IHR6LFxuICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gW3tcbiAgICAgIHo6IGd6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICB6OiBneiArIDEsXG4gICAgICBkcmF3OiAoKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JvcmRlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IHR6LFxuICAgICAgZHJhdzogKGNoYXJ0QXJlYSkgPT4ge1xuICAgICAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgICAgIH1cbiAgICB9XTtcbiAgfVxuICBnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKSB7XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgICBpZiAobWV0YVtheGlzSURdID09PSB0aGlzLmlkICYmICghdHlwZSB8fCBtZXRhLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgIHJldHVybiB0b0ZvbnQob3B0cy5mb250KTtcbiAgfVxuICBfbWF4RGlnaXRzKCkge1xuICAgIGNvbnN0IGZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5saW5lSGVpZ2h0O1xuICAgIHJldHVybiAodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggOiB0aGlzLmhlaWdodCkgLyBmb250U2l6ZTtcbiAgfVxufVxuXG5jbGFzcyBUeXBlZFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgdGhpcy5vdmVycmlkZSA9IG92ZXJyaWRlO1xuICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGlzRm9yVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaXNQcm90b3R5cGVPZi5jYWxsKHRoaXMudHlwZS5wcm90b3R5cGUsIHR5cGUucHJvdG90eXBlKTtcbiAgfVxuICByZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaXRlbSk7XG4gICAgbGV0IHBhcmVudFNjb3BlO1xuICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgfVxuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlICsgJy4nICsgaWQ7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGFzcyBkb2VzIG5vdCBoYXZlIGlkOiAnICsgaXRlbSk7XG4gICAgfVxuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKTtcbiAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgZGVmYXVsdHMub3ZlcnJpZGUoaXRlbS5pZCwgaXRlbS5vdmVycmlkZXMpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGU7XG4gIH1cbiAgZ2V0KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICB9XG4gIHVucmVnaXN0ZXIoaXRlbSkge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlO1xuICAgIGlmIChpZCBpbiBpdGVtcykge1xuICAgICAgZGVsZXRlIGl0ZW1zW2lkXTtcbiAgICB9XG4gICAgaWYgKHNjb3BlICYmIGlkIGluIGRlZmF1bHRzW3Njb3BlXSkge1xuICAgICAgZGVsZXRlIGRlZmF1bHRzW3Njb3BlXVtpZF07XG4gICAgICBpZiAodGhpcy5vdmVycmlkZSkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gIGNvbnN0IGl0ZW1EZWZhdWx0cyA9IG1lcmdlKE9iamVjdC5jcmVhdGUobnVsbCksIFtcbiAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICBkZWZhdWx0cy5nZXQoc2NvcGUpLFxuICAgIGl0ZW0uZGVmYXVsdHNcbiAgXSk7XG4gIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgaWYgKGl0ZW0uZGVmYXVsdFJvdXRlcykge1xuICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gIH1cbiAgaWYgKGl0ZW0uZGVzY3JpcHRvcnMpIHtcbiAgICBkZWZhdWx0cy5kZXNjcmliZShzY29wZSwgaXRlbS5kZXNjcmlwdG9ycyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJvdXRlRGVmYXVsdHMoc2NvcGUsIHJvdXRlcykge1xuICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5UGFydHMgPSBwcm9wZXJ0eS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBwcm9wZXJ0eVBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW3Njb3BlXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgIGNvbnN0IHBhcnRzID0gcm91dGVzW3Byb3BlcnR5XS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRhcmdldE5hbWUgPSBwYXJ0cy5wb3AoKTtcbiAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICBkZWZhdWx0cy5yb3V0ZShzb3VyY2VTY29wZSwgc291cmNlTmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gIHJldHVybiAnaWQnIGluIHByb3RvICYmICdkZWZhdWx0cycgaW4gcHJvdG87XG59XG5cbmNsYXNzIFJlZ2lzdHJ5IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KERhdGFzZXRDb250cm9sbGVyLCAnZGF0YXNldHMnLCB0cnVlKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IFR5cGVkUmVnaXN0cnkoRWxlbWVudCwgJ2VsZW1lbnRzJyk7XG4gICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgIHRoaXMuc2NhbGVzID0gbmV3IFR5cGVkUmVnaXN0cnkoU2NhbGUsICdzY2FsZXMnKTtcbiAgICB0aGlzLl90eXBlZFJlZ2lzdHJpZXMgPSBbdGhpcy5jb250cm9sbGVycywgdGhpcy5zY2FsZXMsIHRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGFkZCguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICByZW1vdmUoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzKTtcbiAgfVxuICBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmNvbnRyb2xsZXJzKTtcbiAgfVxuICBhZGRFbGVtZW50cyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICBhZGRQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuc2NhbGVzKTtcbiAgfVxuICBnZXRDb250cm9sbGVyKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgfVxuICBnZXRFbGVtZW50KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5lbGVtZW50cywgJ2VsZW1lbnQnKTtcbiAgfVxuICBnZXRQbHVnaW4oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLnBsdWdpbnMsICdwbHVnaW4nKTtcbiAgfVxuICBnZXRTY2FsZShpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgfVxuICByZW1vdmVDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5lbGVtZW50cyk7XG4gIH1cbiAgcmVtb3ZlUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgcmVtb3ZlU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgIFsuLi5hcmdzXS5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBjb25zdCByZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShhcmcpO1xuICAgICAgaWYgKHR5cGVkUmVnaXN0cnkgfHwgcmVnLmlzRm9yVHlwZShhcmcpIHx8IChyZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpKSB7XG4gICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCByZWcsIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlYWNoKGFyZywgaXRlbSA9PiB7XG4gICAgICAgICAgY29uc3QgaXRlbVJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGl0ZW0pO1xuICAgICAgICAgIHRoaXMuX2V4ZWMobWV0aG9kLCBpdGVtUmVnLCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgY29uc3QgY2FtZWxNZXRob2QgPSBfY2FwaXRhbGl6ZShtZXRob2QpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYmVmb3JlJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgIGNhbGxiYWNrKGNvbXBvbmVudFsnYWZ0ZXInICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgfVxuICBfZ2V0UmVnaXN0cnlGb3JUeXBlKHR5cGUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3R5cGVkUmVnaXN0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVnID0gdGhpcy5fdHlwZWRSZWdpc3RyaWVzW2ldO1xuICAgICAgaWYgKHJlZy5pc0ZvclR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGx1Z2lucztcbiAgfVxuICBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgY29uc3QgaXRlbSA9IHR5cGVkUmVnaXN0cnkuZ2V0KGlkKTtcbiAgICBpZiAoaXRlbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGlkICsgJ1wiIGlzIG5vdCBhIHJlZ2lzdGVyZWQgJyArIHR5cGUgKyAnLicpO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gbmV3IFJlZ2lzdHJ5KCk7XG5cbmNsYXNzIFNjYXR0ZXJDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtkYXRhOiBwb2ludHMgPSBbXX0gPSBtZXRhO1xuICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCk7XG4gICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgaWYgKF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgY29uc3Qge2RhdGFzZXQ6IGxpbmUsIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICBsaW5lLl9kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5yZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpO1xuICAgICAgb3B0aW9ucy5zZWdtZW50ID0gdGhpcy5vcHRpb25zLnNlZ21lbnQ7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gIH1cbiAgYWRkRWxlbWVudHMoKSB7XG4gICAgY29uc3Qge3Nob3dMaW5lfSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHJlZ2lzdHJ5LmdldEVsZW1lbnQoJ2xpbmUnKTtcbiAgICB9XG4gICAgc3VwZXIuYWRkRWxlbWVudHMoKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIF9zdGFja2VkLCBfZGF0YXNldH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgIGNvbnN0IGluY2x1ZGVPcHRpb25zID0gdGhpcy5pbmNsdWRlT3B0aW9ucyhtb2RlLCBzaGFyZWRPcHRpb25zKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qge3NwYW5HYXBzLCBzZWdtZW50fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBjb25zdCBkaXJlY3RVcGRhdGUgPSB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQgfHwgcmVzZXQgfHwgbW9kZSA9PT0gJ25vbmUnO1xuICAgIGxldCBwcmV2UGFyc2VkID0gc3RhcnQgPiAwICYmIHRoaXMuZ2V0UGFyc2VkKHN0YXJ0IC0gMSk7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGRpcmVjdFVwZGF0ZSA/IHBvaW50IDoge307XG4gICAgICBjb25zdCBudWxsRGF0YSA9IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZBeGlzXSk7XG4gICAgICBjb25zdCBpUGl4ZWwgPSBwcm9wZXJ0aWVzW2lBeGlzXSA9IGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHBhcnNlZFtpQXhpc10sIGkpO1xuICAgICAgY29uc3QgdlBpeGVsID0gcHJvcGVydGllc1t2QXhpc10gPSByZXNldCB8fCBudWxsRGF0YSA/IHZTY2FsZS5nZXRCYXNlUGl4ZWwoKSA6IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiBwYXJzZWRbdkF4aXNdLCBpKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKSB8fCBudWxsRGF0YTtcbiAgICAgIHByb3BlcnRpZXMuc3RvcCA9IGkgPiAwICYmIChNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pKSA+IG1heEdhcExlbmd0aDtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIHByb3BlcnRpZXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICB9XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICB9XG4gICAgICBwcmV2UGFyc2VkID0gcGFyc2VkO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgfVxuICBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBsZXQgbWF4ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG4gICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxufVxuU2NhdHRlckNvbnRyb2xsZXIuaWQgPSAnc2NhdHRlcic7XG5TY2F0dGVyQ29udHJvbGxlci5kZWZhdWx0cyA9IHtcbiAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICBzaG93TGluZTogZmFsc2UsXG4gIGZpbGw6IGZhbHNlXG59O1xuU2NhdHRlckNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBpbnRlcmFjdGlvbjoge1xuICAgIG1vZGU6ICdwb2ludCdcbiAgfSxcbiAgcGx1Z2luczoge1xuICAgIHRvb2x0aXA6IHtcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICB0aXRsZSgpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGxhYmVsKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gJygnICsgaXRlbS5sYWJlbCArICcsICcgKyBpdGVtLmZvcm1hdHRlZFZhbHVlICsgJyknO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzY2FsZXM6IHtcbiAgICB4OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH0sXG4gICAgeToge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5Qb2xhckFyZWFDb250cm9sbGVyOiBQb2xhckFyZWFDb250cm9sbGVyLFxuUGllQ29udHJvbGxlcjogUGllQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuZnVuY3Rpb24gYWJzdHJhY3QoKSB7XG4gIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuY2xhc3MgRGF0ZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgfVxuICBpbml0KGNoYXJ0T3B0aW9ucykge31cbiAgZm9ybWF0cygpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBwYXJzZSh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZm9ybWF0KHRpbWVzdGFtcCwgZm9ybWF0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgYWRkKHRpbWVzdGFtcCwgYW1vdW50LCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgZGlmZihhLCBiLCB1bml0KSB7XG4gICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gIH1cbiAgc3RhcnRPZih0aW1lc3RhbXAsIHVuaXQsIHdlZWtkYXkpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBlbmRPZih0aW1lc3RhbXAsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxufVxuRGF0ZUFkYXB0ZXIub3ZlcnJpZGUgPSBmdW5jdGlvbihtZW1iZXJzKSB7XG4gIE9iamVjdC5hc3NpZ24oRGF0ZUFkYXB0ZXIucHJvdG90eXBlLCBtZW1iZXJzKTtcbn07XG52YXIgYWRhcHRlcnMgPSB7XG4gIF9kYXRlOiBEYXRlQWRhcHRlclxufTtcblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoKG1ldGFzZXQsIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpIHtcbiAgY29uc3Qge2NvbnRyb2xsZXIsIGRhdGEsIF9zb3J0ZWR9ID0gbWV0YXNldDtcbiAgY29uc3QgaVNjYWxlID0gY29udHJvbGxlci5fY2FjaGVkTWV0YS5pU2NhbGU7XG4gIGlmIChpU2NhbGUgJiYgYXhpcyA9PT0gaVNjYWxlLmF4aXMgJiYgYXhpcyAhPT0gJ3InICYmIF9zb3J0ZWQgJiYgZGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBsb29rdXBNZXRob2QgPSBpU2NhbGUuX3JldmVyc2VQaXhlbHMgPyBfcmxvb2t1cEJ5S2V5IDogX2xvb2t1cEJ5S2V5O1xuICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICByZXR1cm4gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRyb2xsZXIuX3NoYXJlZE9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGVsID0gZGF0YVswXTtcbiAgICAgIGNvbnN0IHJhbmdlID0gdHlwZW9mIGVsLmdldFJhbmdlID09PSAnZnVuY3Rpb24nICYmIGVsLmdldFJhbmdlKGF4aXMpO1xuICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICBjb25zdCBlbmQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgKyByYW5nZSk7XG4gICAgICAgIHJldHVybiB7bG86IHN0YXJ0LmxvLCBoaTogZW5kLmhpfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbzogMCwgaGk6IGRhdGEubGVuZ3RoIC0gMX07XG59XG5mdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bYXhpc107XG4gIGZvciAobGV0IGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY29uc3Qge2luZGV4LCBkYXRhfSA9IG1ldGFzZXRzW2ldO1xuICAgIGNvbnN0IHtsbywgaGl9ID0gYmluYXJ5U2VhcmNoKG1ldGFzZXRzW2ldLCBheGlzLCB2YWx1ZSwgaW50ZXJzZWN0KTtcbiAgICBmb3IgKGxldCBqID0gbG87IGogPD0gaGk7ICsraikge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRhdGFbal07XG4gICAgICBpZiAoIWVsZW1lbnQuc2tpcCkge1xuICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKSB7XG4gIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gIGNvbnN0IHVzZVkgPSBheGlzLmluZGV4T2YoJ3knKSAhPT0gLTE7XG4gIHJldHVybiBmdW5jdGlvbihwdDEsIHB0Mikge1xuICAgIGNvbnN0IGRlbHRhWCA9IHVzZVggPyBNYXRoLmFicyhwdDEueCAtIHB0Mi54KSA6IDA7XG4gICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KGRlbHRhWCwgMikgKyBNYXRoLnBvdyhkZWx0YVksIDIpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIGNvbnN0IGV2YWx1YXRpb25GdW5jID0gZnVuY3Rpb24oZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhX2lzUG9pbnRJbkFyZWEoZWxlbWVudCwgY2hhcnQuY2hhcnRBcmVhLCAwKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9O1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgbGV0IGl0ZW1zID0gW107XG4gIGZ1bmN0aW9uIGV2YWx1YXRpb25GdW5jKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICBjb25zdCB7c3RhcnRBbmdsZSwgZW5kQW5nbGV9ID0gZWxlbWVudC5nZXRQcm9wcyhbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlfSA9IGdldEFuZ2xlRnJvbVBvaW50KGVsZW1lbnQsIHt4OiBwb3NpdGlvbi54LCB5OiBwb3NpdGlvbi55fSk7XG4gICAgaWYgKF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgICAgaXRlbXMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0pO1xuICAgIH1cbiAgfVxuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgY29uc3QgZGlzdGFuY2VNZXRyaWMgPSBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcyk7XG4gIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgaWYgKGludGVyc2VjdCAmJiAhaW5SYW5nZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHBvaW50SW5BcmVhID0gISFpbmNsdWRlSW52aXNpYmxlIHx8IGNoYXJ0LmlzUG9pbnRJbkFyZWEoY2VudGVyKTtcbiAgICBpZiAoIXBvaW50SW5BcmVhICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpc3RhbmNlID0gZGlzdGFuY2VNZXRyaWMocG9zaXRpb24sIGNlbnRlcik7XG4gICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zID0gW3tlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fV07XG4gICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0XG4gICAgPyBnZXROZWFyZXN0UmFkaWFsSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uKVxuICAgIDogZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbn1cbmZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCByYW5nZU1ldGhvZCA9IGF4aXMgPT09ICd4JyA/ICdpblhSYW5nZScgOiAnaW5ZUmFuZ2UnO1xuICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpID0+IHtcbiAgICBpZiAoZWxlbWVudFtyYW5nZU1ldGhvZF0ocG9zaXRpb25bYXhpc10sIHVzZUZpbmFsUG9zaXRpb24pKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgICBpbnRlcnNlY3RzSXRlbSA9IGludGVyc2VjdHNJdGVtIHx8IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gaXRlbXM7XG59XG52YXIgSW50ZXJhY3Rpb24gPSB7XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyxcbiAgbW9kZXM6IHtcbiAgICBpbmRleChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3gnO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIGNvbnN0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpXG4gICAgICAgIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKS5mb3JFYWNoKChtZXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gaXRlbXNbMF0uaW5kZXg7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCAmJiAhZWxlbWVudC5za2lwKSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaCh7ZWxlbWVudCwgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LCBpbmRleH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9LFxuICAgIGRhdGFzZXQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3RcbiAgICAgICAgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDpcbiAgICAgICAgZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGF0YXNldEluZGV4ID0gaXRlbXNbMF0uZGF0YXNldEluZGV4O1xuICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5kYXRhO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpdGVtcy5wdXNoKHtlbGVtZW50OiBkYXRhW2ldLCBkYXRhc2V0SW5kZXgsIGluZGV4OiBpfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpdGVtcztcbiAgICB9LFxuICAgIHBvaW50KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgbmVhcmVzdChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgIH0sXG4gICAgeChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneCcsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHkoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICByZXR1cm4gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgJ3knLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBTVEFUSUNfUE9TSVRJT05TID0gWydsZWZ0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nXTtcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiB2LnBvcyA9PT0gcG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGFycmF5LCBheGlzKSB7XG4gIHJldHVybiBhcnJheS5maWx0ZXIodiA9PiBTVEFUSUNfUE9TSVRJT05TLmluZGV4T2Yodi5wb3MpID09PSAtMSAmJiB2LmJveC5heGlzID09PSBheGlzKTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVdlaWdodChhcnJheSwgcmV2ZXJzZSkge1xuICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgIGNvbnN0IHYwID0gcmV2ZXJzZSA/IGIgOiBhO1xuICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgIHJldHVybiB2MC53ZWlnaHQgPT09IHYxLndlaWdodCA/XG4gICAgICB2MC5pbmRleCAtIHYxLmluZGV4IDpcbiAgICAgIHYwLndlaWdodCAtIHYxLndlaWdodDtcbiAgfSk7XG59XG5mdW5jdGlvbiB3cmFwQm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGJveCwgcG9zLCBzdGFjaywgc3RhY2tXZWlnaHQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGJveCA9IGJveGVzW2ldO1xuICAgICh7cG9zaXRpb246IHBvcywgb3B0aW9uczoge3N0YWNrLCBzdGFja1dlaWdodCA9IDF9fSA9IGJveCk7XG4gICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICBpbmRleDogaSxcbiAgICAgIGJveCxcbiAgICAgIHBvcyxcbiAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgIHN0YWNrOiBzdGFjayAmJiAocG9zICsgc3RhY2spLFxuICAgICAgc3RhY2tXZWlnaHRcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gIGNvbnN0IHN0YWNrcyA9IHt9O1xuICBmb3IgKGNvbnN0IHdyYXAgb2YgbGF5b3V0cykge1xuICAgIGNvbnN0IHtzdGFjaywgcG9zLCBzdGFja1dlaWdodH0gPSB3cmFwO1xuICAgIGlmICghc3RhY2sgfHwgIVNUQVRJQ19QT1NJVElPTlMuaW5jbHVkZXMocG9zKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7Y291bnQ6IDAsIHBsYWNlZDogMCwgd2VpZ2h0OiAwLCBzaXplOiAwfSk7XG4gICAgX3N0YWNrLmNvdW50Kys7XG4gICAgX3N0YWNrLndlaWdodCArPSBzdGFja1dlaWdodDtcbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gc2V0TGF5b3V0RGltcyhsYXlvdXRzLCBwYXJhbXMpIHtcbiAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gIGNvbnN0IHt2Qm94TWF4V2lkdGgsIGhCb3hNYXhIZWlnaHR9ID0gcGFyYW1zO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0O1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgIGNvbnN0IHtmdWxsU2l6ZX0gPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja107XG4gICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgbGF5b3V0LndpZHRoID0gZmFjdG9yID8gZmFjdG9yICogdkJveE1heFdpZHRoIDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZVdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGhCb3hNYXhIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxheW91dC53aWR0aCA9IHZCb3hNYXhXaWR0aDtcbiAgICAgIGxheW91dC5oZWlnaHQgPSBmYWN0b3IgPyBmYWN0b3IgKiBoQm94TWF4SGVpZ2h0IDogZnVsbFNpemUgJiYgcGFyYW1zLmF2YWlsYWJsZUhlaWdodDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YWNrcztcbn1cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0Qm94ZXMoYm94ZXMpIHtcbiAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICBjb25zdCBmdWxsU2l6ZSA9IHNvcnRCeVdlaWdodChsYXlvdXRCb3hlcy5maWx0ZXIod3JhcCA9PiB3cmFwLmJveC5mdWxsU2l6ZSksIHRydWUpO1xuICBjb25zdCBsZWZ0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdsZWZ0JyksIHRydWUpO1xuICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gIGNvbnN0IHRvcCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAndG9wJyksIHRydWUpO1xuICBjb25zdCBib3R0b20gPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2JvdHRvbScpKTtcbiAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgY29uc3QgY2VudGVyVmVydGljYWwgPSBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMobGF5b3V0Qm94ZXMsICd5Jyk7XG4gIHJldHVybiB7XG4gICAgZnVsbFNpemUsXG4gICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICByaWdodEFuZEJvdHRvbTogcmlnaHQuY29uY2F0KGNlbnRlclZlcnRpY2FsKS5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbCksXG4gICAgY2hhcnRBcmVhOiBmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnY2hhcnRBcmVhJyksXG4gICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgIGhvcml6b250YWw6IHRvcC5jb25jYXQoYm90dG9tKS5jb25jYXQoY2VudGVySG9yaXpvbnRhbClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICByZXR1cm4gTWF0aC5tYXgobWF4UGFkZGluZ1thXSwgY2hhcnRBcmVhW2FdKSArIE1hdGgubWF4KG1heFBhZGRpbmdbYl0sIGNoYXJ0QXJlYVtiXSk7XG59XG5mdW5jdGlvbiB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveFBhZGRpbmcpIHtcbiAgbWF4UGFkZGluZy50b3AgPSBNYXRoLm1heChtYXhQYWRkaW5nLnRvcCwgYm94UGFkZGluZy50b3ApO1xuICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gIG1heFBhZGRpbmcuYm90dG9tID0gTWF0aC5tYXgobWF4UGFkZGluZy5ib3R0b20sIGJveFBhZGRpbmcuYm90dG9tKTtcbiAgbWF4UGFkZGluZy5yaWdodCA9IE1hdGgubWF4KG1heFBhZGRpbmcucmlnaHQsIGJveFBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpIHtcbiAgY29uc3Qge3BvcywgYm94fSA9IGxheW91dDtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBpZiAoIWlzT2JqZWN0KHBvcykpIHtcbiAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtzaXplOiAwLCBjb3VudDogMX07XG4gICAgc3RhY2suc2l6ZSA9IE1hdGgubWF4KHN0YWNrLnNpemUsIGxheW91dC5ob3Jpem9udGFsID8gYm94LmhlaWdodCA6IGJveC53aWR0aCk7XG4gICAgbGF5b3V0LnNpemUgPSBzdGFjay5zaXplIC8gc3RhY2suY291bnQ7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gIH1cbiAgaWYgKGJveC5nZXRQYWRkaW5nKSB7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCBib3guZ2V0UGFkZGluZygpKTtcbiAgfVxuICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgY29uc3QgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAndG9wJywgJ2JvdHRvbScpKTtcbiAgY29uc3Qgd2lkdGhDaGFuZ2VkID0gbmV3V2lkdGggIT09IGNoYXJ0QXJlYS53O1xuICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgY2hhcnRBcmVhLncgPSBuZXdXaWR0aDtcbiAgY2hhcnRBcmVhLmggPSBuZXdIZWlnaHQ7XG4gIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbFxuICAgID8ge3NhbWU6IHdpZHRoQ2hhbmdlZCwgb3RoZXI6IGhlaWdodENoYW5nZWR9XG4gICAgOiB7c2FtZTogaGVpZ2h0Q2hhbmdlZCwgb3RoZXI6IHdpZHRoQ2hhbmdlZH07XG59XG5mdW5jdGlvbiBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSkge1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcyhwb3MpIHtcbiAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgY2hhcnRBcmVhW3Bvc10gKz0gY2hhbmdlO1xuICAgIHJldHVybiBjaGFuZ2U7XG4gIH1cbiAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgY2hhcnRBcmVhLnggKz0gdXBkYXRlUG9zKCdsZWZ0Jyk7XG4gIHVwZGF0ZVBvcygncmlnaHQnKTtcbiAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gbWFyZ2luRm9yUG9zaXRpb25zKHBvc2l0aW9ucykge1xuICAgIGNvbnN0IG1hcmdpbiA9IHtsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiAwLCBib3R0b206IDB9O1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpID0+IHtcbiAgICAgIG1hcmdpbltwb3NdID0gTWF0aC5tYXgoY2hhcnRBcmVhW3Bvc10sIG1heFBhZGRpbmdbcG9zXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcmdpbjtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFxuICAgID8gbWFyZ2luRm9yUG9zaXRpb25zKFsnbGVmdCcsICdyaWdodCddKVxuICAgIDogbWFyZ2luRm9yUG9zaXRpb25zKFsndG9wJywgJ2JvdHRvbSddKTtcbn1cbmZ1bmN0aW9uIGZpdEJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHJlZml0Qm94ZXMgPSBbXTtcbiAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGJveGVzLmxlbmd0aCwgcmVmaXQgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgbGF5b3V0ID0gYm94ZXNbaV07XG4gICAgYm94ID0gbGF5b3V0LmJveDtcbiAgICBib3gudXBkYXRlKFxuICAgICAgbGF5b3V0LndpZHRoIHx8IGNoYXJ0QXJlYS53LFxuICAgICAgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCxcbiAgICAgIGdldE1hcmdpbnMobGF5b3V0Lmhvcml6b250YWwsIGNoYXJ0QXJlYSlcbiAgICApO1xuICAgIGNvbnN0IHtzYW1lLCBvdGhlcn0gPSB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcyk7XG4gICAgcmVmaXQgfD0gc2FtZSAmJiByZWZpdEJveGVzLmxlbmd0aDtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcbiAgICBpZiAoIWJveC5mdWxsU2l6ZSkge1xuICAgICAgcmVmaXRCb3hlcy5wdXNoKGxheW91dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICBib3gudG9wID0gdG9wO1xuICBib3gubGVmdCA9IGxlZnQ7XG4gIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgYm94LmJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgYm94LndpZHRoID0gd2lkdGg7XG4gIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gIGNvbnN0IHVzZXJQYWRkaW5nID0gcGFyYW1zLnBhZGRpbmc7XG4gIGxldCB7eCwgeX0gPSBjaGFydEFyZWE7XG4gIGZvciAoY29uc3QgbGF5b3V0IG9mIGJveGVzKSB7XG4gICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICBjb25zdCBzdGFjayA9IHN0YWNrc1tsYXlvdXQuc3RhY2tdIHx8IHtjb3VudDogMSwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDF9O1xuICAgIGNvbnN0IHdlaWdodCA9IChsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQpIHx8IDE7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGNoYXJ0QXJlYS53ICogd2VpZ2h0O1xuICAgICAgY29uc3QgaGVpZ2h0ID0gc3RhY2suc2l6ZSB8fCBib3guaGVpZ2h0O1xuICAgICAgaWYgKGRlZmluZWQoc3RhY2suc3RhcnQpKSB7XG4gICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgIH1cbiAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHVzZXJQYWRkaW5nLmxlZnQsIHksIHBhcmFtcy5vdXRlcldpZHRoIC0gdXNlclBhZGRpbmcucmlnaHQgLSB1c2VyUGFkZGluZy5sZWZ0LCBoZWlnaHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIGNoYXJ0QXJlYS5sZWZ0ICsgc3RhY2sucGxhY2VkLCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geTtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSB3aWR0aDtcbiAgICAgIHkgPSBib3guYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBjaGFydEFyZWEuaCAqIHdlaWdodDtcbiAgICAgIGNvbnN0IHdpZHRoID0gc3RhY2suc2l6ZSB8fCBib3gud2lkdGg7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeCA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCBjaGFydEFyZWEudG9wICsgc3RhY2sucGxhY2VkLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnN0YXJ0ID0geDtcbiAgICAgIHN0YWNrLnBsYWNlZCArPSBoZWlnaHQ7XG4gICAgICB4ID0gYm94LnJpZ2h0O1xuICAgIH1cbiAgfVxuICBjaGFydEFyZWEueCA9IHg7XG4gIGNoYXJ0QXJlYS55ID0geTtcbn1cbmRlZmF1bHRzLnNldCgnbGF5b3V0Jywge1xuICBhdXRvUGFkZGluZzogdHJ1ZSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9XG59KTtcbnZhciBsYXlvdXRzID0ge1xuICBhZGRCb3goY2hhcnQsIGl0ZW0pIHtcbiAgICBpZiAoIWNoYXJ0LmJveGVzKSB7XG4gICAgICBjaGFydC5ib3hlcyA9IFtdO1xuICAgIH1cbiAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gaXRlbS5wb3NpdGlvbiB8fCAndG9wJztcbiAgICBpdGVtLndlaWdodCA9IGl0ZW0ud2VpZ2h0IHx8IDA7XG4gICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIHo6IDAsXG4gICAgICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH1dO1xuICAgIH07XG4gICAgY2hhcnQuYm94ZXMucHVzaChpdGVtKTtcbiAgfSxcbiAgcmVtb3ZlQm94KGNoYXJ0LCBsYXlvdXRJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSBjaGFydC5ib3hlcyA/IGNoYXJ0LmJveGVzLmluZGV4T2YobGF5b3V0SXRlbSkgOiAtMTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcbiAgY29uZmlndXJlKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgaXRlbS5mdWxsU2l6ZSA9IG9wdGlvbnMuZnVsbFNpemU7XG4gICAgaXRlbS5wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgfSxcbiAgdXBkYXRlKGNoYXJ0LCB3aWR0aCwgaGVpZ2h0LCBtaW5QYWRkaW5nKSB7XG4gICAgaWYgKCFjaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKGNoYXJ0Lm9wdGlvbnMubGF5b3V0LnBhZGRpbmcpO1xuICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICBjb25zdCBhdmFpbGFibGVIZWlnaHQgPSBNYXRoLm1heChoZWlnaHQgLSBwYWRkaW5nLmhlaWdodCwgMCk7XG4gICAgY29uc3QgYm94ZXMgPSBidWlsZExheW91dEJveGVzKGNoYXJ0LmJveGVzKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgY29uc3QgaG9yaXpvbnRhbEJveGVzID0gYm94ZXMuaG9yaXpvbnRhbDtcbiAgICBlYWNoKGNoYXJ0LmJveGVzLCBib3ggPT4ge1xuICAgICAgaWYgKHR5cGVvZiBib3guYmVmb3JlTGF5b3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGJveC5iZWZvcmVMYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCkgPT5cbiAgICAgIHdyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgb3V0ZXJXaWR0aDogd2lkdGgsXG4gICAgICBvdXRlckhlaWdodDogaGVpZ2h0LFxuICAgICAgcGFkZGluZyxcbiAgICAgIGF2YWlsYWJsZVdpZHRoLFxuICAgICAgYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgdkJveE1heFdpZHRoOiBhdmFpbGFibGVXaWR0aCAvIDIgLyB2aXNpYmxlVmVydGljYWxCb3hDb3VudCxcbiAgICAgIGhCb3hNYXhIZWlnaHQ6IGF2YWlsYWJsZUhlaWdodCAvIDJcbiAgICB9KTtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgdXBkYXRlTWF4UGFkZGluZyhtYXhQYWRkaW5nLCB0b1BhZGRpbmcobWluUGFkZGluZykpO1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgbWF4UGFkZGluZyxcbiAgICAgIHc6IGF2YWlsYWJsZVdpZHRoLFxuICAgICAgaDogYXZhaWxhYmxlSGVpZ2h0LFxuICAgICAgeDogcGFkZGluZy5sZWZ0LFxuICAgICAgeTogcGFkZGluZy50b3BcbiAgICB9LCBwYWRkaW5nKTtcbiAgICBjb25zdCBzdGFja3MgPSBzZXRMYXlvdXREaW1zKHZlcnRpY2FsQm94ZXMuY29uY2F0KGhvcml6b250YWxCb3hlcyksIHBhcmFtcyk7XG4gICAgZml0Qm94ZXMoYm94ZXMuZnVsbFNpemUsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIGlmIChmaXRCb3hlcyhob3Jpem9udGFsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpKSB7XG4gICAgICBmaXRCb3hlcyh2ZXJ0aWNhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICB9XG4gICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuICAgIHBsYWNlQm94ZXMoYm94ZXMubGVmdEFuZFRvcCwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnRBcmVhLnggKz0gY2hhcnRBcmVhLnc7XG4gICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5yaWdodEFuZEJvdHRvbSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgY2hhcnQuY2hhcnRBcmVhID0ge1xuICAgICAgbGVmdDogY2hhcnRBcmVhLmxlZnQsXG4gICAgICB0b3A6IGNoYXJ0QXJlYS50b3AsXG4gICAgICByaWdodDogY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEudyxcbiAgICAgIGJvdHRvbTogY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5oLFxuICAgICAgaGVpZ2h0OiBjaGFydEFyZWEuaCxcbiAgICAgIHdpZHRoOiBjaGFydEFyZWEudyxcbiAgICB9O1xuICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgT2JqZWN0LmFzc2lnbihib3gsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICBib3gudXBkYXRlKGNoYXJ0QXJlYS53LCBjaGFydEFyZWEuaCwge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH0pO1xuICAgIH0pO1xuICB9XG59O1xuXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7fVxuICByZWxlYXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICByZW1vdmVFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge31cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggfHwgZWxlbWVudC53aWR0aCk7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGVsZW1lbnQuaGVpZ2h0O1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgIH07XG4gIH1cbiAgaXNBdHRhY2hlZChjYW52YXMpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gIH1cbn1cblxuY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gIH1cbiAgdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZy5vcHRpb25zLmFuaW1hdGlvbiA9IGZhbHNlO1xuICB9XG59XG5cbmNvbnN0IEVYUEFORE9fS0VZID0gJyRjaGFydGpzJztcbmNvbnN0IEVWRU5UX1RZUEVTID0ge1xuICB0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcbiAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG91Y2hlbmQ6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmVudGVyOiAnbW91c2VlbnRlcicsXG4gIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgcG9pbnRlcm1vdmU6ICdtb3VzZW1vdmUnLFxuICBwb2ludGVydXA6ICdtb3VzZXVwJyxcbiAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICBwb2ludGVyb3V0OiAnbW91c2VvdXQnXG59O1xuY29uc3QgaXNOdWxsT3JFbXB0eSA9IHZhbHVlID0+IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSAnJztcbmZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICBjb25zdCBzdHlsZSA9IGNhbnZhcy5zdHlsZTtcbiAgY29uc3QgcmVuZGVySGVpZ2h0ID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnaGVpZ2h0Jyk7XG4gIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgY2FudmFzW0VYUEFORE9fS0VZXSA9IHtcbiAgICBpbml0aWFsOiB7XG4gICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IHN0eWxlLmRpc3BsYXksXG4gICAgICAgIGhlaWdodDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0eWxlLmRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5IHx8ICdibG9jayc7XG4gIHN0eWxlLmJveFNpemluZyA9IHN0eWxlLmJveFNpemluZyB8fCAnYm9yZGVyLWJveCc7XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgIGNvbnN0IGRpc3BsYXlXaWR0aCA9IHJlYWRVc2VkU2l6ZShjYW52YXMsICd3aWR0aCcpO1xuICAgIGlmIChkaXNwbGF5V2lkdGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2FudmFzLndpZHRoID0gZGlzcGxheVdpZHRoO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdWxsT3JFbXB0eShyZW5kZXJIZWlnaHQpKSB7XG4gICAgaWYgKGNhbnZhcy5zdHlsZS5oZWlnaHQgPT09ICcnKSB7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoIC8gKGFzcGVjdFJhdGlvIHx8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGlzcGxheUhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cbmNvbnN0IGV2ZW50TGlzdGVuZXJPcHRpb25zID0gc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hhcnQuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpIHtcbiAgY29uc3QgdHlwZSA9IEVWRU5UX1RZUEVTW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gIGNvbnN0IHt4LCB5fSA9IGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoYXJ0LFxuICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgeDogeCAhPT0gdW5kZWZpbmVkID8geCA6IG51bGwsXG4gICAgeTogeSAhPT0gdW5kZWZpbmVkID8geSA6IG51bGwsXG4gIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVMaXN0KSB7XG4gICAgaWYgKG5vZGUgPT09IGNhbnZhcyB8fCBub2RlLmNvbnRhaW5zKGNhbnZhcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQXR0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURldGFjaE9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkucmVtb3ZlZE5vZGVzLCBjYW52YXMpO1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgJiYgIW5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICB9XG4gICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShkb2N1bWVudCwge2NoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0pO1xuICByZXR1cm4gb2JzZXJ2ZXI7XG59XG5jb25zdCBkcnBMaXN0ZW5pbmdDaGFydHMgPSBuZXcgTWFwKCk7XG5sZXQgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IDA7XG5mdW5jdGlvbiBvbldpbmRvd1Jlc2l6ZSgpIHtcbiAgY29uc3QgZHByID0gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb2xkRGV2aWNlUGl4ZWxSYXRpbyA9IGRwcjtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmZvckVhY2goKHJlc2l6ZSwgY2hhcnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgcmVzaXplKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLnNldChjaGFydCwgcmVzaXplKTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpIHtcbiAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIGlmICghZHJwTGlzdGVuaW5nQ2hhcnRzLnNpemUpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcmVzaXplID0gdGhyb3R0bGVkKCh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBsaXN0ZW5lcih3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAodyA8IGNvbnRhaW5lci5jbGllbnRXaWR0aCkge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0sIHdpbmRvdyk7XG4gIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1swXTtcbiAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGVudHJ5LmNvbnRlbnRSZWN0LmhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyKTtcbiAgbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9XG4gIGlmICh0eXBlID09PSAncmVzaXplJykge1xuICAgIHVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eUFuZExpc3RlbihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBwcm94eSA9IHRocm90dGxlZCgoZXZlbnQpID0+IHtcbiAgICBpZiAoY2hhcnQuY3R4ICE9PSBudWxsKSB7XG4gICAgICBsaXN0ZW5lcihmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSk7XG4gICAgfVxuICB9LCBjaGFydCwgKGFyZ3MpID0+IHtcbiAgICBjb25zdCBldmVudCA9IGFyZ3NbMF07XG4gICAgcmV0dXJuIFtldmVudCwgZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WV07XG4gIH0pO1xuICBhZGRMaXN0ZW5lcihjYW52YXMsIHR5cGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuY2xhc3MgRG9tUGxhdGZvcm0gZXh0ZW5kcyBCYXNlUGxhdGZvcm0ge1xuICBhY3F1aXJlQ29udGV4dChjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcyAmJiBjYW52YXMuZ2V0Q29udGV4dCAmJiBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICBpZiAoIWNhbnZhc1tFWFBBTkRPX0tFWV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbCA9IGNhbnZhc1tFWFBBTkRPX0tFWV0uaW5pdGlhbDtcbiAgICBbJ2hlaWdodCcsICd3aWR0aCddLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gaW5pdGlhbFtwcm9wXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShwcm9wLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBpbml0aWFsLnN0eWxlIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHN0eWxlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICB9KTtcbiAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IGNyZWF0ZUF0dGFjaE9ic2VydmVyLFxuICAgICAgZGV0YWNoOiBjcmVhdGVEZXRhY2hPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogY3JlYXRlUmVzaXplT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCBjcmVhdGVQcm94eUFuZExpc3RlbjtcbiAgICBwcm94aWVzW3R5cGVdID0gaGFuZGxlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgIGNvbnN0IHByb3h5ID0gcHJveGllc1t0eXBlXTtcbiAgICBpZiAoIXByb3h5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZXJzID0ge1xuICAgICAgYXR0YWNoOiByZWxlYXNlT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIHJlc2l6ZTogcmVsZWFzZU9ic2VydmVyXG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgcmVtb3ZlTGlzdGVuZXI7XG4gICAgaGFuZGxlcihjaGFydCwgdHlwZSwgcHJveHkpO1xuICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgIHJldHVybiBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IF9nZXRQYXJlbnROb2RlKGNhbnZhcyk7XG4gICAgcmV0dXJuICEhKGNvbnRhaW5lciAmJiBjb250YWluZXIuaXNDb25uZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZXRlY3RQbGF0Zm9ybShjYW52YXMpIHtcbiAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2FudmFzIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzKSkge1xuICAgIHJldHVybiBCYXNpY1BsYXRmb3JtO1xuICB9XG4gIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuY2xhc3MgUGx1Z2luU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2luaXQgPSBbXTtcbiAgfVxuICBub3RpZnkoY2hhcnQsIGhvb2ssIGFyZ3MsIGZpbHRlcikge1xuICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gZmlsdGVyID8gdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpLmZpbHRlcihmaWx0ZXIpIDogdGhpcy5fZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgIGlmIChob29rID09PSAnYWZ0ZXJEZXN0cm95Jykge1xuICAgICAgdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgJ3N0b3AnKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ3VuaW5zdGFsbCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIF9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgYXJncyA9IGFyZ3MgfHwge307XG4gICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgICBjb25zdCBwbHVnaW4gPSBkZXNjcmlwdG9yLnBsdWdpbjtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IHBsdWdpbltob29rXTtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IFtjaGFydCwgYXJncywgZGVzY3JpcHRvci5vcHRpb25zXTtcbiAgICAgIGlmIChjYWxsYmFjayhtZXRob2QsIHBhcmFtcywgcGx1Z2luKSA9PT0gZmFsc2UgJiYgYXJncy5jYW5jZWxhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaW52YWxpZGF0ZSgpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodGhpcy5fY2FjaGUpKSB7XG4gICAgICB0aGlzLl9vbGRDYWNoZSA9IHRoaXMuX2NhY2hlO1xuICAgICAgdGhpcy5fY2FjaGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIF9kZXNjcmlwdG9ycyhjaGFydCkge1xuICAgIGlmICh0aGlzLl9jYWNoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlID0gdGhpcy5fY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgIHRoaXMuX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCk7XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9XG4gIF9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgYWxsKSB7XG4gICAgY29uc3QgY29uZmlnID0gY2hhcnQgJiYgY2hhcnQuY29uZmlnO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgY29uc3QgcGx1Z2lucyA9IGFsbFBsdWdpbnMoY29uZmlnKTtcbiAgICByZXR1cm4gb3B0aW9ucyA9PT0gZmFsc2UgJiYgIWFsbCA/IFtdIDogY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHBsdWdpbnMsIG9wdGlvbnMsIGFsbCk7XG4gIH1cbiAgX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgIGNvbnN0IHByZXZpb3VzRGVzY3JpcHRvcnMgPSB0aGlzLl9vbGRDYWNoZSB8fCBbXTtcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHRoaXMuX2NhY2hlO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5wbHVnaW4uaWQgPT09IHkucGx1Z2luLmlkKSk7XG4gICAgdGhpcy5fbm90aWZ5KGRpZmYocHJldmlvdXNEZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpLCBjaGFydCwgJ3N0b3AnKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgY29uc3QgbG9jYWxJZHMgPSB7fTtcbiAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHBsdWdpbnMucHVzaChyZWdpc3RyeS5nZXRQbHVnaW4oa2V5c1tpXSkpO1xuICB9XG4gIGNvbnN0IGxvY2FsID0gY29uZmlnLnBsdWdpbnMgfHwgW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICBpZiAocGx1Z2lucy5pbmRleE9mKHBsdWdpbikgPT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICAgIGxvY2FsSWRzW3BsdWdpbi5pZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3BsdWdpbnMsIGxvY2FsSWRzfTtcbn1cbmZ1bmN0aW9uIGdldE9wdHMob3B0aW9ucywgYWxsKSB7XG4gIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5mdW5jdGlvbiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwge3BsdWdpbnMsIGxvY2FsSWRzfSwgb3B0aW9ucywgYWxsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgaWYgKG9wdHMgPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7XG4gICAgICBwbHVnaW4sXG4gICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge3BsdWdpbiwgbG9jYWw6IGxvY2FsSWRzW2lkXX0sIG9wdHMsIGNvbnRleHQpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7cGx1Z2luLCBsb2NhbH0sIG9wdHMsIGNvbnRleHQpIHtcbiAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3BlcyhvcHRzLCBrZXlzKTtcbiAgaWYgKGxvY2FsICYmIHBsdWdpbi5kZWZhdWx0cykge1xuICAgIHNjb3Blcy5wdXNoKHBsdWdpbi5kZWZhdWx0cyk7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFsnJ10sIHtcbiAgICBzY3JpcHRhYmxlOiBmYWxzZSxcbiAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgIGFsbEtleXM6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9O1xuICBjb25zdCBkYXRhc2V0T3B0aW9ucyA9IChvcHRpb25zLmRhdGFzZXRzIHx8IHt9KVt0eXBlXSB8fCB7fTtcbiAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICBsZXQgYXhpcyA9IGlkO1xuICBpZiAoaWQgPT09ICdfaW5kZXhfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXM7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICdfdmFsdWVfJykge1xuICAgIGF4aXMgPSBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgfVxuICByZXR1cm4gYXhpcztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gIHJldHVybiBheGlzID09PSBpbmRleEF4aXMgPyAnX2luZGV4XycgOiAnX3ZhbHVlXyc7XG59XG5mdW5jdGlvbiBheGlzRnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgcmV0dXJuICd4JztcbiAgfVxuICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHJldHVybiAneSc7XG4gIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucykge1xuICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knKSB7XG4gICAgcmV0dXJuIGlkO1xuICB9XG4gIHJldHVybiBzY2FsZU9wdGlvbnMuYXhpcyB8fCBheGlzRnJvbVBvc2l0aW9uKHNjYWxlT3B0aW9ucy5wb3NpdGlvbikgfHwgaWQuY2hhckF0KDApLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBtZXJnZVNjYWxlQ29uZmlnKGNvbmZpZywgb3B0aW9ucykge1xuICBjb25zdCBjaGFydERlZmF1bHRzID0gb3ZlcnJpZGVzW2NvbmZpZy50eXBlXSB8fCB7c2NhbGVzOiB7fX07XG4gIGNvbnN0IGNvbmZpZ1NjYWxlcyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGZpcnN0SURzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgT2JqZWN0LmtleXMoY29uZmlnU2NhbGVzKS5mb3JFYWNoKGlkID0+IHtcbiAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgIGlmICghaXNPYmplY3Qoc2NhbGVDb25mKSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgc2NhbGUgY29uZmlndXJhdGlvbiBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZUNvbmYpO1xuICAgIGNvbnN0IGRlZmF1bHRJZCA9IGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgY2hhcnRJbmRleEF4aXMpO1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBmaXJzdElEc1theGlzXSA9IGZpcnN0SURzW2F4aXNdIHx8IGlkO1xuICAgIHNjYWxlc1tpZF0gPSBtZXJnZUlmKE9iamVjdC5jcmVhdGUobnVsbCksIFt7YXhpc30sIHNjYWxlQ29uZiwgZGVmYXVsdFNjYWxlT3B0aW9uc1theGlzXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXSk7XG4gIH0pO1xuICBjb25maWcuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKGRhdGFzZXQgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgY29uc3QgaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpO1xuICAgIGNvbnN0IGRhdGFzZXREZWZhdWx0cyA9IG92ZXJyaWRlc1t0eXBlXSB8fCB7fTtcbiAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICBPYmplY3Qua2V5cyhkZWZhdWx0U2NhbGVPcHRpb25zKS5mb3JFYWNoKGRlZmF1bHRJRCA9PiB7XG4gICAgICBjb25zdCBheGlzID0gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChkZWZhdWx0SUQsIGluZGV4QXhpcyk7XG4gICAgICBjb25zdCBpZCA9IGRhdGFzZXRbYXhpcyArICdBeGlzSUQnXSB8fCBmaXJzdElEc1theGlzXSB8fCBheGlzO1xuICAgICAgc2NhbGVzW2lkXSA9IHNjYWxlc1tpZF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIG1lcmdlSWYoc2NhbGVzW2lkXSwgW3theGlzfSwgY29uZmlnU2NhbGVzW2lkXSwgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXSk7XG4gICAgfSk7XG4gIH0pO1xuICBPYmplY3Qua2V5cyhzY2FsZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBzY2FsZSA9IHNjYWxlc1trZXldO1xuICAgIG1lcmdlSWYoc2NhbGUsIFtkZWZhdWx0cy5zY2FsZXNbc2NhbGUudHlwZV0sIGRlZmF1bHRzLnNjYWxlXSk7XG4gIH0pO1xuICByZXR1cm4gc2NhbGVzO1xufVxuZnVuY3Rpb24gaW5pdE9wdGlvbnMoY29uZmlnKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBjb25maWcub3B0aW9ucyB8fCAoY29uZmlnLm9wdGlvbnMgPSB7fSk7XG4gIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICBvcHRpb25zLnNjYWxlcyA9IG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGluaXREYXRhKGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwge307XG4gIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICBkYXRhLmxhYmVscyA9IGRhdGEubGFiZWxzIHx8IFtdO1xuICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGluaXRDb25maWcoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgY29uZmlnLmRhdGEgPSBpbml0RGF0YShjb25maWcuZGF0YSk7XG4gIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIHJldHVybiBjb25maWc7XG59XG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICBsZXQga2V5cyA9IGtleUNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSBnZW5lcmF0ZSgpO1xuICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAga2V5c0NhY2hlZC5hZGQoa2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5jb25zdCBhZGRJZkZvdW5kID0gKHNldCwgb2JqLCBrZXkpID0+IHtcbiAgY29uc3Qgb3B0cyA9IHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpO1xuICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgc2V0LmFkZChvcHRzKTtcbiAgfVxufTtcbmNsYXNzIENvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICB0aGlzLl9zY29wZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUgPSBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0IHBsYXRmb3JtKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGxhdGZvcm07XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICB9XG4gIHNldCB0eXBlKHR5cGUpIHtcbiAgICB0aGlzLl9jb25maWcudHlwZSA9IHR5cGU7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5kYXRhO1xuICB9XG4gIHNldCBkYXRhKGRhdGEpIHtcbiAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcub3B0aW9ucztcbiAgfVxuICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIGdldCBwbHVnaW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgY29uc3QgY29uZmlnID0gdGhpcy5fY29uZmlnO1xuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgIGluaXRPcHRpb25zKGNvbmZpZyk7XG4gIH1cbiAgY2xlYXJDYWNoZSgpIHtcbiAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZS5jbGVhcigpO1xuICB9XG4gIGRhdGFzZXRTY29wZUtleXMoZGF0YXNldFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgZGF0YXNldEFuaW1hdGlvblNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgdHJhbnNpdGlvbikge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGAke2RhdGFzZXRUeXBlfS50cmFuc2l0aW9uLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YCxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgJydcbiAgICAgICAgXVxuICAgICAgXSk7XG4gIH1cbiAgZGF0YXNldEVsZW1lbnRTY29wZUtleXMoZGF0YXNldFR5cGUsIGVsZW1lbnRUeXBlKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICcnXG4gICAgICBdXSk7XG4gIH1cbiAgcGx1Z2luU2NvcGVLZXlzKHBsdWdpbikge1xuICAgIGNvbnN0IGlkID0gcGx1Z2luLmlkO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7dHlwZX0tcGx1Z2luLSR7aWR9YCxcbiAgICAgICgpID0+IFtbXG4gICAgICAgIGBwbHVnaW5zLiR7aWR9YCxcbiAgICAgICAgLi4ucGx1Z2luLmFkZGl0aW9uYWxPcHRpb25TY29wZXMgfHwgW10sXG4gICAgICBdXSk7XG4gIH1cbiAgX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCBfc2NvcGVDYWNoZSA9IHRoaXMuX3Njb3BlQ2FjaGU7XG4gICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgaWYgKCFjYWNoZSB8fCByZXNldENhY2hlKSB7XG4gICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgIF9zY29wZUNhY2hlLnNldChtYWluU2NvcGUsIGNhY2hlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG4gIGdldE9wdGlvblNjb3BlcyhtYWluU2NvcGUsIGtleUxpc3RzLCByZXNldENhY2hlKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2NhY2hlZFNjb3BlcyhtYWluU2NvcGUsIHJlc2V0Q2FjaGUpO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlLmdldChrZXlMaXN0cyk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gbmV3IFNldCgpO1xuICAgIGtleUxpc3RzLmZvckVhY2goa2V5cyA9PiB7XG4gICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgIHNjb3Blcy5hZGQobWFpblNjb3BlKTtcbiAgICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgbWFpblNjb3BlLCBrZXkpKTtcbiAgICAgIH1cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIG9wdGlvbnMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3ZlcnJpZGVzW3R5cGVdIHx8IHt9LCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlZmF1bHRzLCBrZXkpKTtcbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkSWZGb3VuZChzY29wZXMsIGRlc2NyaXB0b3JzLCBrZXkpKTtcbiAgICB9KTtcbiAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICBhcnJheS5wdXNoKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCB0eXBlfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSxcbiAgICAgIHt0eXBlfSxcbiAgICAgIGRlZmF1bHRzLFxuICAgICAgZGVzY3JpcHRvcnNcbiAgICBdO1xuICB9XG4gIHJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMgPSBbJyddKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyRzaGFyZWQ6IHRydWV9O1xuICAgIGNvbnN0IHtyZXNvbHZlciwgc3ViUHJlZml4ZXN9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICBpZiAobmVlZENvbnRleHQocmVzb2x2ZXIsIG5hbWVzKSkge1xuICAgICAgcmVzdWx0LiRzaGFyZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQgPSBpc0Z1bmN0aW9uKGNvbnRleHQpID8gY29udGV4dCgpIDogY29udGV4dDtcbiAgICAgIGNvbnN0IHN1YlJlc29sdmVyID0gdGhpcy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHN1YlByZWZpeGVzKTtcbiAgICAgIG9wdGlvbnMgPSBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgc3ViUmVzb2x2ZXIpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpIHtcbiAgICAgIHJlc3VsdFtwcm9wXSA9IG9wdGlvbnNbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgIGNvbnN0IHtyZXNvbHZlcn0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICByZXR1cm4gaXNPYmplY3QoY29udGV4dClcbiAgICAgID8gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHVuZGVmaW5lZCwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICAgICAgOiByZXNvbHZlcjtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UmVzb2x2ZXIocmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcykge1xuICBsZXQgY2FjaGUgPSByZXNvbHZlckNhY2hlLmdldChzY29wZXMpO1xuICBpZiAoIWNhY2hlKSB7XG4gICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmVzb2x2ZXJDYWNoZS5zZXQoc2NvcGVzLCBjYWNoZSk7XG4gIH1cbiAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gIGxldCBjYWNoZWQgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICBpZiAoIWNhY2hlZCkge1xuICAgIGNvbnN0IHJlc29sdmVyID0gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIGNhY2hlZCA9IHtcbiAgICAgIHJlc29sdmVyLFxuICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcihwID0+ICFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgfTtcbiAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGNhY2hlZCk7XG4gIH1cbiAgcmV0dXJuIGNhY2hlZDtcbn1cbmNvbnN0IGhhc0Z1bmN0aW9uID0gdmFsdWUgPT4gaXNPYmplY3QodmFsdWUpXG4gICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2MgfHwgaXNGdW5jdGlvbih2YWx1ZVtrZXldKSwgZmFsc2UpO1xuZnVuY3Rpb24gbmVlZENvbnRleHQocHJveHksIG5hbWVzKSB7XG4gIGNvbnN0IHtpc1NjcmlwdGFibGUsIGlzSW5kZXhhYmxlfSA9IF9kZXNjcmlwdG9ycyhwcm94eSk7XG4gIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgY29uc3QgaW5kZXhhYmxlID0gaXNJbmRleGFibGUocHJvcCk7XG4gICAgY29uc3QgdmFsdWUgPSAoaW5kZXhhYmxlIHx8IHNjcmlwdGFibGUpICYmIHByb3h5W3Byb3BdO1xuICAgIGlmICgoc2NyaXB0YWJsZSAmJiAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaGFzRnVuY3Rpb24odmFsdWUpKSlcbiAgICAgIHx8IChpbmRleGFibGUgJiYgaXNBcnJheSh2YWx1ZSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMy45LjFcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gWyd0b3AnLCAnYm90dG9tJywgJ2xlZnQnLCAncmlnaHQnLCAnY2hhcnRBcmVhJ107XG5mdW5jdGlvbiBwb3NpdGlvbklzSG9yaXpvbnRhbChwb3NpdGlvbiwgYXhpcykge1xuICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCAoS05PV05fUE9TSVRJT05TLmluZGV4T2YocG9zaXRpb24pID09PSAtMSAmJiBheGlzID09PSAneCcpO1xufVxuZnVuY3Rpb24gY29tcGFyZTJMZXZlbChsMSwgbDIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gYVtsMV0gPT09IGJbbDFdXG4gICAgICA/IGFbbDJdIC0gYltsMl1cbiAgICAgIDogYVtsMV0gLSBiW2wxXTtcbiAgfTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uc0NvbXBsZXRlKGNvbnRleHQpIHtcbiAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gY2hhcnQub3B0aW9ucy5hbmltYXRpb247XG4gIGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2FmdGVyUmVuZGVyJyk7XG4gIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbY29udGV4dF0sIGNoYXJ0KTtcbn1cbmZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uUHJvZ3Jlc3MsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpICYmIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJykge1xuICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgfSBlbHNlIGlmIChpdGVtICYmIGl0ZW0ubGVuZ3RoKSB7XG4gICAgaXRlbSA9IGl0ZW1bMF07XG4gIH1cbiAgaWYgKGl0ZW0gJiYgaXRlbS5jYW52YXMpIHtcbiAgICBpdGVtID0gaXRlbS5jYW52YXM7XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSkgPT4ge1xuICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5maWx0ZXIoKGMpID0+IGMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgY29uc3QgaW50S2V5ID0gK2tleTtcbiAgICBpZiAoaW50S2V5ID49IHN0YXJ0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgZGVsZXRlIG9ialtrZXldO1xuICAgICAgaWYgKG1vdmUgPiAwIHx8IGludEtleSA+IHN0YXJ0KSB7XG4gICAgICAgIG9ialtpbnRLZXkgKyBtb3ZlXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIGxhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spIHtcbiAgaWYgKCFpbkNoYXJ0QXJlYSB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoaXNDbGljaykge1xuICAgIHJldHVybiBsYXN0RXZlbnQ7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jbGFzcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKGl0ZW0sIHVzZXJDb25maWcpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZyA9IG5ldyBDb25maWcodXNlckNvbmZpZyk7XG4gICAgY29uc3QgaW5pdGlhbENhbnZhcyA9IGdldENhbnZhcyhpdGVtKTtcbiAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgaWYgKGV4aXN0aW5nQ2hhcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICtcblx0XHRcdFx0JyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG5ldyAoY29uZmlnLnBsYXRmb3JtIHx8IF9kZXRlY3RQbGF0Zm9ybShpbml0aWFsQ2FudmFzKSkoKTtcbiAgICB0aGlzLnBsYXRmb3JtLnVwZGF0ZUNvbmZpZyhjb25maWcpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQgJiYgY29udGV4dC5jYW52YXM7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2FudmFzICYmIGNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgIHRoaXMuaWQgPSB1aWQoKTtcbiAgICB0aGlzLmN0eCA9IGNvbnRleHQ7XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuX3N0YWNrcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJveGVzID0gW107XG4gICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0QXJlYSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9hY3RpdmUgPSBbXTtcbiAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IFtdO1xuICAgIHRoaXMuc2NhbGVzID0ge307XG4gICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgdGhpcy4kcHJveGllcyA9IHt9O1xuICAgIHRoaXMuX2hpZGRlbkluZGljZXMgPSB7fTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZShtb2RlID0+IHRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgaW5zdGFuY2VzW3RoaXMuaWRdID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltYXRvci5saXN0ZW4odGhpcywgJ2NvbXBsZXRlJywgb25BbmltYXRpb25zQ29tcGxldGUpO1xuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICB0aGlzLl9pbml0aWFsaXplKCk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9XG4gIGdldCBhc3BlY3RSYXRpbygpIHtcbiAgICBjb25zdCB7b3B0aW9uczoge2FzcGVjdFJhdGlvLCBtYWludGFpbkFzcGVjdFJhdGlvfSwgd2lkdGgsIGhlaWdodCwgX2FzcGVjdFJhdGlvfSA9IHRoaXM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGFzcGVjdFJhdGlvKSkge1xuICAgICAgcmV0dXJuIGFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIHJldHVybiBoZWlnaHQgPyB3aWR0aCAvIGhlaWdodCA6IG51bGw7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUluaXQnKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICB9XG4gICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcigpIHtcbiAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0ge3dpZHRoLCBoZWlnaHR9O1xuICAgIH1cbiAgfVxuICBfcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IGFzcGVjdFJhdGlvID0gb3B0aW9ucy5tYWludGFpbkFzcGVjdFJhdGlvICYmIHRoaXMuYXNwZWN0UmF0aW87XG4gICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMucGxhdGZvcm0uZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgY29uc3QgbW9kZSA9IHRoaXMud2lkdGggPyAncmVzaXplJyA6ICdhdHRhY2gnO1xuICAgIHRoaXMud2lkdGggPSBuZXdTaXplLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIGlmICghcmV0aW5hU2NhbGUodGhpcywgbmV3UmF0aW8sIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzaXplJywge3NpemU6IG5ld1NpemV9KTtcbiAgICBjYWxsYmFjayhvcHRpb25zLm9uUmVzaXplLCBbdGhpcywgbmV3U2l6ZV0sIHRoaXMpO1xuICAgIGlmICh0aGlzLmF0dGFjaGVkKSB7XG4gICAgICBpZiAodGhpcy5fZG9SZXNpemUobW9kZSkpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlU2NhbGVzSGF2ZUlEcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNjYWxlc09wdGlvbnMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBlYWNoKHNjYWxlc09wdGlvbnMsIChheGlzT3B0aW9ucywgYXhpc0lEKSA9PiB7XG4gICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlU2NhbGVzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVPcHRzID0gb3B0aW9ucy5zY2FsZXM7XG4gICAgY29uc3Qgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKSA9PiB7XG4gICAgICBvYmpbaWRdID0gZmFsc2U7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIHt9KTtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBpZiAoc2NhbGVPcHRzKSB7XG4gICAgICBpdGVtcyA9IGl0ZW1zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gc2NhbGVPcHRzW2lkXTtcbiAgICAgICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgICAgICBjb25zdCBpc1JhZGlhbCA9IGF4aXMgPT09ICdyJztcbiAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSBheGlzID09PSAneCc7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgIGRwb3NpdGlvbjogaXNSYWRpYWwgPyAnY2hhcnRBcmVhJyA6IGlzSG9yaXpvbnRhbCA/ICdib3R0b20nIDogJ2xlZnQnLFxuICAgICAgICAgICAgZHR5cGU6IGlzUmFkaWFsID8gJ3JhZGlhbExpbmVhcicgOiBpc0hvcml6b250YWwgPyAnY2F0ZWdvcnknIDogJ2xpbmVhcidcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gICAgZWFjaChpdGVtcywgKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgIHNjYWxlT3B0aW9ucy5wb3NpdGlvbiA9IGl0ZW0uZHBvc2l0aW9uO1xuICAgICAgfVxuICAgICAgdXBkYXRlZFtpZF0gPSB0cnVlO1xuICAgICAgbGV0IHNjYWxlID0gbnVsbDtcbiAgICAgIGlmIChpZCBpbiBzY2FsZXMgJiYgc2NhbGVzW2lkXS50eXBlID09PSBzY2FsZVR5cGUpIHtcbiAgICAgICAgc2NhbGUgPSBzY2FsZXNbaWRdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgIHNjYWxlID0gbmV3IHNjYWxlQ2xhc3Moe1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIHR5cGU6IHNjYWxlVHlwZSxcbiAgICAgICAgICBjdHg6IHRoaXMuY3R4LFxuICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBzY2FsZXNbc2NhbGUuaWRdID0gc2NhbGU7XG4gICAgICB9XG4gICAgICBzY2FsZS5pbml0KHNjYWxlT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpID0+IHtcbiAgICAgIGlmICghaGFzVXBkYXRlZCkge1xuICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBlYWNoKHNjYWxlcywgKHNjYWxlKSA9PiB7XG4gICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZU1ldGFzZXRzKCkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgY29uc3QgbnVtRGF0YSA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7XG4gICAgY29uc3QgbnVtTWV0YSA9IG1ldGFzZXRzLmxlbmd0aDtcbiAgICBtZXRhc2V0cy5zb3J0KChhLCBiKSA9PiBhLmluZGV4IC0gYi5pbmRleCk7XG4gICAgaWYgKG51bU1ldGEgPiBudW1EYXRhKSB7XG4gICAgICBmb3IgKGxldCBpID0gbnVtRGF0YTsgaSA8IG51bU1ldGE7ICsraSkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhc2V0cy5zcGxpY2UobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgIH1cbiAgICB0aGlzLl9zb3J0ZWRNZXRhc2V0cyA9IG1ldGFzZXRzLnNsaWNlKDApLnNvcnQoY29tcGFyZTJMZXZlbCgnb3JkZXInLCAnaW5kZXgnKSk7XG4gIH1cbiAgX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCkge1xuICAgIGNvbnN0IHtfbWV0YXNldHM6IG1ldGFzZXRzLCBkYXRhOiB7ZGF0YXNldHN9fSA9IHRoaXM7XG4gICAgaWYgKG1ldGFzZXRzLmxlbmd0aCA+IGRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIHRoaXMuX3N0YWNrcztcbiAgICB9XG4gICAgbWV0YXNldHMuZm9yRWFjaCgobWV0YSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChkYXRhc2V0cy5maWx0ZXIoeCA9PiB4ID09PSBtZXRhLl9kYXRhc2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgY29uc3QgbmV3Q29udHJvbGxlcnMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0cyA9IHRoaXMuZGF0YS5kYXRhc2V0cztcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLl9yZW1vdmVVbnJlZmVyZW5jZWRNZXRhc2V0cygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBkYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcbiAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICB9XG4gICAgICBtZXRhLnR5cGUgPSB0eXBlO1xuICAgICAgbWV0YS5pbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgdGhpcy5vcHRpb25zKTtcbiAgICAgIG1ldGEub3JkZXIgPSBkYXRhc2V0Lm9yZGVyIHx8IDA7XG4gICAgICBtZXRhLmluZGV4ID0gaTtcbiAgICAgIG1ldGEubGFiZWwgPSAnJyArIGRhdGFzZXQubGFiZWw7XG4gICAgICBtZXRhLnZpc2libGUgPSB0aGlzLmlzRGF0YXNldFZpc2libGUoaSk7XG4gICAgICBpZiAobWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLmxpbmtTY2FsZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IENvbnRyb2xsZXJDbGFzcyA9IHJlZ2lzdHJ5LmdldENvbnRyb2xsZXIodHlwZSk7XG4gICAgICAgIGNvbnN0IHtkYXRhc2V0RWxlbWVudFR5cGUsIGRhdGFFbGVtZW50VHlwZX0gPSBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBkYXRhc2V0RWxlbWVudFR5cGUgJiYgcmVnaXN0cnkuZ2V0RWxlbWVudChkYXRhc2V0RWxlbWVudFR5cGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIgPSBuZXcgQ29udHJvbGxlckNsYXNzKHRoaXMsIGkpO1xuICAgICAgICBuZXdDb250cm9sbGVycy5wdXNoKG1ldGEuY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgcmV0dXJuIG5ld0NvbnRyb2xsZXJzO1xuICB9XG4gIF9yZXNldEVsZW1lbnRzKCkge1xuICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlci5yZXNldCgpO1xuICAgIH0sIHRoaXMpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2V0Jyk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNvbmZpZztcbiAgICBjb25maWcudXBkYXRlKCk7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBjb25zdCBhbmltc0Rpc2FibGVkID0gdGhpcy5fYW5pbWF0aW9uc0Rpc2FibGVkID0gIW9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIHRoaXMuX3VwZGF0ZVNjYWxlcygpO1xuICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgIHRoaXMuX3VwZGF0ZUhpZGRlbkluZGljZXMoKTtcbiAgICB0aGlzLl9wbHVnaW5zLmludmFsaWRhdGUoKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFbGVtZW50c1VwZGF0ZScpO1xuICAgIGxldCBtaW5QYWRkaW5nID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHtjb250cm9sbGVyfSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBjb25zdCByZXNldCA9ICFhbmltc0Rpc2FibGVkICYmIG5ld0NvbnRyb2xsZXJzLmluZGV4T2YoY29udHJvbGxlcikgPT09IC0xO1xuICAgICAgY29udHJvbGxlci5idWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXQpO1xuICAgICAgbWluUGFkZGluZyA9IE1hdGgubWF4KCtjb250cm9sbGVyLmdldE1heE92ZXJmbG93KCksIG1pblBhZGRpbmcpO1xuICAgIH1cbiAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgdGhpcy5fdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpO1xuICAgIGlmICghYW5pbXNEaXNhYmxlZCkge1xuICAgICAgZWFjaChuZXdDb250cm9sbGVycywgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5yZXNldCgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZURhdGFzZXRzKG1vZGUpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJVcGRhdGUnLCB7bW9kZX0pO1xuICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcbiAgICBjb25zdCB7X2FjdGl2ZSwgX2xhc3RFdmVudH0gPSB0aGlzO1xuICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChfYWN0aXZlLmxlbmd0aCkge1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoX2FjdGl2ZSwgX2FjdGl2ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNjYWxlcygpIHtcbiAgICBlYWNoKHRoaXMuc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgICB0aGlzLmVuc3VyZVNjYWxlc0hhdmVJRHMoKTtcbiAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgfVxuICBfY2hlY2tFdmVudEJpbmRpbmdzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgIGNvbnN0IG5ld0V2ZW50cyA9IG5ldyBTZXQob3B0aW9ucy5ldmVudHMpO1xuICAgIGlmICghc2V0c0VxdWFsKGV4aXN0aW5nRXZlbnRzLCBuZXdFdmVudHMpIHx8ICEhdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyAhPT0gb3B0aW9ucy5yZXNwb25zaXZlKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgdGhpcy5iaW5kRXZlbnRzKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVIaWRkZW5JbmRpY2VzKCkge1xuICAgIGNvbnN0IHtfaGlkZGVuSW5kaWNlc30gPSB0aGlzO1xuICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHttZXRob2QsIHN0YXJ0LCBjb3VudH0gb2YgY2hhbmdlcykge1xuICAgICAgY29uc3QgbW92ZSA9IG1ldGhvZCA9PT0gJ19yZW1vdmVFbGVtZW50cycgPyAtY291bnQgOiBjb3VudDtcbiAgICAgIG1vdmVOdW1lcmljS2V5cyhfaGlkZGVuSW5kaWNlcywgc3RhcnQsIG1vdmUpO1xuICAgIH1cbiAgfVxuICBfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzKCkge1xuICAgIGNvbnN0IF9kYXRhQ2hhbmdlcyA9IHRoaXMuX2RhdGFDaGFuZ2VzO1xuICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RhdGFDaGFuZ2VzID0gW107XG4gICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBtYWtlU2V0ID0gKGlkeCkgPT4gbmV3IFNldChcbiAgICAgIF9kYXRhQ2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gY1swXSA9PT0gaWR4KVxuICAgICAgICAubWFwKChjLCBpKSA9PiBpICsgJywnICsgYy5zcGxpY2UoMSkuam9pbignLCcpKVxuICAgICk7XG4gICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKSB7XG4gICAgICBpZiAoIXNldHNFcXVhbChjaGFuZ2VTZXQsIG1ha2VTZXQoaSkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KVxuICAgICAgLm1hcChjID0+IGMuc3BsaXQoJywnKSlcbiAgICAgIC5tYXAoYSA9PiAoe21ldGhvZDogYVsxXSwgc3RhcnQ6ICthWzJdLCBjb3VudDogK2FbM119KSk7XG4gIH1cbiAgX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlTGF5b3V0Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBub0FyZWEgPSBhcmVhLndpZHRoIDw9IDAgfHwgYXJlYS5oZWlnaHQgPD0gMDtcbiAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICBlYWNoKHRoaXMuYm94ZXMsIChib3gpID0+IHtcbiAgICAgIGlmIChub0FyZWEgJiYgYm94LnBvc2l0aW9uID09PSAnY2hhcnRBcmVhJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoYm94LmNvbmZpZ3VyZSkge1xuICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICB9LCB0aGlzKTtcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJMYXlvdXQnKTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRzVXBkYXRlJywge21vZGUsIGNhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXIuY29uZmlndXJlKCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGhpcy5fdXBkYXRlRGF0YXNldChpLCBpc0Z1bmN0aW9uKG1vZGUpID8gbW9kZSh7ZGF0YXNldEluZGV4OiBpfSkgOiBtb2RlKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge21vZGV9KTtcbiAgfVxuICBfdXBkYXRlRGF0YXNldChpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBhcmdzID0ge21ldGEsIGluZGV4LCBtb2RlLCBjYW5jZWxhYmxlOiB0cnVlfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0VXBkYXRlJywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEYXRhc2V0VXBkYXRlJywgYXJncyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVJlbmRlcicsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgIGFuaW1hdG9yLnN0YXJ0KHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRyYXcoKTtcbiAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtjaGFydDogdGhpc30pO1xuICAgIH1cbiAgfVxuICBkcmF3KCkge1xuICAgIGxldCBpO1xuICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0aGlzLl9yZXNpemVCZWZvcmVEcmF3O1xuICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxheWVycyA9IHRoaXMuX2xheWVycztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXJzLmxlbmd0aCAmJiBsYXllcnNbaV0ueiA8PSAwOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG4gICAgZm9yICg7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxheWVyc1tpXS5kcmF3KHRoaXMuY2hhcnRBcmVhKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRyYXcnKTtcbiAgfVxuICBfZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc2V0c1tpXTtcbiAgICAgIGlmICghZmlsdGVyVmlzaWJsZSB8fCBtZXRhLnZpc2libGUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKHRydWUpO1xuICB9XG4gIF9kcmF3RGF0YXNldHMoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRoaXMuX2RyYXdEYXRhc2V0KG1ldGFzZXRzW2ldKTtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICB9XG4gIF9kcmF3RGF0YXNldChtZXRhKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgY29uc3QgdXNlQ2xpcCA9ICFjbGlwLmRpc2FibGVkO1xuICAgIGNvbnN0IGFyZWEgPSB0aGlzLmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgbWV0YSxcbiAgICAgIGluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgIH07XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIGNsaXBBcmVhKGN0eCwge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIGNsaXAubGVmdCxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gdGhpcy53aWR0aCA6IGFyZWEucmlnaHQgKyBjbGlwLnJpZ2h0LFxuICAgICAgICB0b3A6IGNsaXAudG9wID09PSBmYWxzZSA/IDAgOiBhcmVhLnRvcCAtIGNsaXAudG9wLFxuICAgICAgICBib3R0b206IGNsaXAuYm90dG9tID09PSBmYWxzZSA/IHRoaXMuaGVpZ2h0IDogYXJlYS5ib3R0b20gKyBjbGlwLmJvdHRvbVxuICAgICAgfSk7XG4gICAgfVxuICAgIG1ldGEuY29udHJvbGxlci5kcmF3KCk7XG4gICAgaWYgKHVzZUNsaXApIHtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXREcmF3JywgYXJncyk7XG4gIH1cbiAgaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgIHJldHVybiBfaXNQb2ludEluQXJlYShwb2ludCwgdGhpcy5jaGFydEFyZWEsIHRoaXMuX21pblBhZGRpbmcpO1xuICB9XG4gIGdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgbW9kZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgIGlmICh0eXBlb2YgbWV0aG9kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbWV0aG9kKHRoaXMsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgbGV0IG1ldGEgPSBtZXRhc2V0cy5maWx0ZXIoeCA9PiB4ICYmIHguX2RhdGFzZXQgPT09IGRhdGFzZXQpLnBvcCgpO1xuICAgIGlmICghbWV0YSkge1xuICAgICAgbWV0YSA9IHtcbiAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgZGF0YTogW10sXG4gICAgICAgIGRhdGFzZXQ6IG51bGwsXG4gICAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgeEF4aXNJRDogbnVsbCxcbiAgICAgICAgeUF4aXNJRDogbnVsbCxcbiAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICBpbmRleDogZGF0YXNldEluZGV4LFxuICAgICAgICBfZGF0YXNldDogZGF0YXNldCxcbiAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgIF9zb3J0ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgICAgbWV0YXNldHMucHVzaChtZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge2NoYXJ0OiB0aGlzLCB0eXBlOiAnY2hhcnQnfSkpO1xuICB9XG4gIGdldFZpc2libGVEYXRhc2V0Q291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgfVxuICBpc0RhdGFzZXRWaXNpYmxlKGRhdGFzZXRJbmRleCkge1xuICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gIH1cbiAgc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICB9XG4gIHRvZ2dsZURhdGFWaXNpYmlsaXR5KGluZGV4KSB7XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF0gPSAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2hpZGRlbkluZGljZXNbaW5kZXhdO1xuICB9XG4gIF91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCB2aXNpYmxlKSB7XG4gICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICBjb25zdCBhbmltcyA9IG1ldGEuY29udHJvbGxlci5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKTtcbiAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0RGF0YXNldFZpc2liaWxpdHkoZGF0YXNldEluZGV4LCB2aXNpYmxlKTtcbiAgICAgIGFuaW1zLnVwZGF0ZShtZXRhLCB7dmlzaWJsZX0pO1xuICAgICAgdGhpcy51cGRhdGUoKGN0eCkgPT4gY3R4LmRhdGFzZXRJbmRleCA9PT0gZGF0YXNldEluZGV4ID8gbW9kZSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9XG4gIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4LCBmYWxzZSk7XG4gIH1cbiAgc2hvdyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICB9XG4gIF9kZXN0cm95RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuX21ldGFzZXRzW2RhdGFzZXRJbmRleF07XG4gIH1cbiAgX3N0b3AoKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaSk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEZXN0cm95Jyk7XG4gICAgY29uc3Qge2NhbnZhcywgY3R4fSA9IHRoaXM7XG4gICAgdGhpcy5fc3RvcCgpO1xuICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICBpZiAoY2FudmFzKSB7XG4gICAgICB0aGlzLnVuYmluZEV2ZW50cygpO1xuICAgICAgY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpO1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZWxlYXNlQ29udGV4dChjdHgpO1xuICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgdGhpcy5jdHggPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2Rlc3Ryb3knKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEZXN0cm95Jyk7XG4gIH1cbiAgdG9CYXNlNjRJbWFnZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgfVxuICBiaW5kRXZlbnRzKCkge1xuICAgIHRoaXMuYmluZFVzZXJFdmVudHMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICBjb25zdCBwbGF0Zm9ybSA9IHRoaXMucGxhdGZvcm07XG4gICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgcGxhdGZvcm0uYWRkRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICBsaXN0ZW5lcnNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpID0+IHtcbiAgICAgIGUub2Zmc2V0WCA9IHg7XG4gICAgICBlLm9mZnNldFkgPSB5O1xuICAgICAgdGhpcy5fZXZlbnRIYW5kbGVyKGUpO1xuICAgIH07XG4gICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSkgPT4gX2FkZCh0eXBlLCBsaXN0ZW5lcikpO1xuICB9XG4gIGJpbmRSZXNwb25zaXZlRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZSA9ICh0eXBlLCBsaXN0ZW5lcikgPT4ge1xuICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSkge1xuICAgICAgICBwbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBjb25zdCBhdHRhY2hlZCA9ICgpID0+IHtcbiAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICB9O1xuICAgIGRldGFjaGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgIH07XG4gICAgaWYgKHBsYXRmb3JtLmlzQXR0YWNoZWQodGhpcy5jYW52YXMpKSB7XG4gICAgICBhdHRhY2hlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCgpO1xuICAgIH1cbiAgfVxuICB1bmJpbmRFdmVudHMoKSB7XG4gICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICBlYWNoKHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSkgPT4ge1xuICAgICAgdGhpcy5wbGF0Zm9ybS5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZUhvdmVyU3R5bGUoaXRlbXMsIG1vZGUsIGVuYWJsZWQpIHtcbiAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICBsZXQgbWV0YSwgaXRlbSwgaSwgaWxlbjtcbiAgICBpZiAobW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtc1swXS5kYXRhc2V0SW5kZXgpO1xuICAgICAgbWV0YS5jb250cm9sbGVyWydfJyArIHByZWZpeCArICdEYXRhc2V0SG92ZXJTdHlsZSddKCk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBpdGVtICYmIHRoaXMuZ2V0RGF0YXNldE1ldGEoaXRlbS5kYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyW3ByZWZpeCArICdIb3ZlclN0eWxlJ10oaXRlbS5lbGVtZW50LCBpdGVtLmRhdGFzZXRJbmRleCwgaXRlbS5pbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMpIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YXNldCBmb3VuZCBhdCBpbmRleCAnICsgZGF0YXNldEluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgaW5kZXgsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMubm90aWZ5KHRoaXMsIGhvb2ssIGFyZ3MsIGZpbHRlcik7XG4gIH1cbiAgX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgIGNvbnN0IGRpZmYgPSAoYSwgYikgPT4gYS5maWx0ZXIoeCA9PiAhYi5zb21lKHkgPT4geC5kYXRhc2V0SW5kZXggPT09IHkuZGF0YXNldEluZGV4ICYmIHguaW5kZXggPT09IHkuaW5kZXgpKTtcbiAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICBjb25zdCBhY3RpdmF0ZWQgPSByZXBsYXkgPyBhY3RpdmUgOiBkaWZmKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGRlYWN0aXZhdGVkLmxlbmd0aCkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGRlYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZhdGVkLmxlbmd0aCAmJiBob3Zlck9wdGlvbnMubW9kZSkge1xuICAgICAgdGhpcy51cGRhdGVIb3ZlclN0eWxlKGFjdGl2YXRlZCwgaG92ZXJPcHRpb25zLm1vZGUsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBldmVudDogZSxcbiAgICAgIHJlcGxheSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBpbkNoYXJ0QXJlYTogdGhpcy5pc1BvaW50SW5BcmVhKGUpXG4gICAgfTtcbiAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pID0+IChwbHVnaW4ub3B0aW9ucy5ldmVudHMgfHwgdGhpcy5vcHRpb25zLmV2ZW50cykuaW5jbHVkZXMoZS5uYXRpdmUudHlwZSk7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRXZlbnQnLCBhcmdzLCBldmVudEZpbHRlcikgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSB0aGlzLl9oYW5kbGVFdmVudChlLCByZXBsYXksIGFyZ3MuaW5DaGFydEFyZWEpO1xuICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICBpZiAoY2hhbmdlZCB8fCBhcmdzLmNoYW5nZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIF9oYW5kbGVFdmVudChlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qge19hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSByZXBsYXk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgIGNvbnN0IGxhc3RFdmVudCA9IGRldGVybWluZUxhc3RFdmVudChlLCB0aGlzLl9sYXN0RXZlbnQsIGluQ2hhcnRBcmVhLCBpc0NsaWNrKTtcbiAgICBpZiAoaW5DaGFydEFyZWEpIHtcbiAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICBjYWxsYmFjayhvcHRpb25zLm9uSG92ZXIsIFtlLCBhY3RpdmUsIHRoaXNdLCB0aGlzKTtcbiAgICAgIGlmIChpc0NsaWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25DbGljaywgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSk7XG4gICAgaWYgKGNoYW5nZWQgfHwgcmVwbGF5KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUsIHJlcGxheSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RFdmVudCA9IGxhc3RFdmVudDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxufVxuY29uc3QgaW52YWxpZGF0ZVBsdWdpbnMgPSAoKSA9PiBlYWNoKENoYXJ0Lmluc3RhbmNlcywgKGNoYXJ0KSA9PiBjaGFydC5fcGx1Z2lucy5pbnZhbGlkYXRlKCkpO1xuY29uc3QgZW51bWVyYWJsZSA9IHRydWU7XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFydCwge1xuICBkZWZhdWx0czoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGRlZmF1bHRzXG4gIH0sXG4gIGluc3RhbmNlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGluc3RhbmNlc1xuICB9LFxuICBvdmVycmlkZXM6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiBvdmVycmlkZXNcbiAgfSxcbiAgcmVnaXN0cnk6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiByZWdpc3RyeVxuICB9LFxuICB2ZXJzaW9uOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogdmVyc2lvblxuICB9LFxuICBnZXRDaGFydDoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IGdldENoYXJ0XG4gIH0sXG4gIHJlZ2lzdGVyOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogKC4uLml0ZW1zKSA9PiB7XG4gICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgaW52YWxpZGF0ZVBsdWdpbnMoKTtcbiAgICB9XG4gIH0sXG4gIHVucmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LnJlbW92ZSguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICBjb25zdCB7c3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIHgsIHksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1c30gPSBlbGVtZW50O1xuICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbik7XG4gIGlmIChpbm5lclJhZGl1cyA+IHBpeGVsTWFyZ2luKSB7XG4gICAgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIGlubmVyUmFkaXVzO1xuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWydvdXRlclN0YXJ0JywgJ291dGVyRW5kJywgJ2lubmVyU3RhcnQnLCAnaW5uZXJFbmQnXSk7XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyQxKGFyYywgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBhbmdsZURlbHRhKSB7XG4gIGNvbnN0IG8gPSB0b1JhZGl1c0Nvcm5lcnMoYXJjLm9wdGlvbnMuYm9yZGVyUmFkaXVzKTtcbiAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gIGNvbnN0IGlubmVyTGltaXQgPSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBhbmdsZURlbHRhICogaW5uZXJSYWRpdXMgLyAyKTtcbiAgY29uc3QgY29tcHV0ZU91dGVyTGltaXQgPSAodmFsKSA9PiB7XG4gICAgY29uc3Qgb3V0ZXJBcmNMaW1pdCA9IChvdXRlclJhZGl1cyAtIE1hdGgubWluKGhhbGZUaGlja25lc3MsIHZhbCkpICogYW5nbGVEZWx0YSAvIDI7XG4gICAgcmV0dXJuIF9saW1pdFZhbHVlKHZhbCwgMCwgTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgb3V0ZXJBcmNMaW1pdCkpO1xuICB9O1xuICByZXR1cm4ge1xuICAgIG91dGVyU3RhcnQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJTdGFydCksXG4gICAgb3V0ZXJFbmQ6IGNvbXB1dGVPdXRlckxpbWl0KG8ub3V0ZXJFbmQpLFxuICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgaW5uZXJFbmQ6IF9saW1pdFZhbHVlKG8uaW5uZXJFbmQsIDAsIGlubmVyTGltaXQpLFxuICB9O1xufVxuZnVuY3Rpb24gclRoZXRhVG9YWShyLCB0aGV0YSwgeCwgeSkge1xuICByZXR1cm4ge1xuICAgIHg6IHggKyByICogTWF0aC5jb3ModGhldGEpLFxuICAgIHk6IHkgKyByICogTWF0aC5zaW4odGhldGEpLFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aEFyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kLCBjaXJjdWxhcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZTogc3RhcnQsIHBpeGVsTWFyZ2luLCBpbm5lclJhZGl1czogaW5uZXJSfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gIGNvbnN0IGlubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiArIHNwYWNpbmcgKyBvZmZzZXQgKyBwaXhlbE1hcmdpbiA6IDA7XG4gIGxldCBzcGFjaW5nT2Zmc2V0ID0gMDtcbiAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcbiAgaWYgKHNwYWNpbmcpIHtcbiAgICBjb25zdCBub1NwYWNpbmdJbm5lclJhZGl1cyA9IGlubmVyUiA+IDAgPyBpbm5lclIgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBub1NwYWNpbmdPdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzID4gMCA/IG91dGVyUmFkaXVzIC0gc3BhY2luZyA6IDA7XG4gICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICBjb25zdCBhZGp1c3RlZEFuZ2xlID0gYXZOb2dTcGFjaW5nUmFkaXVzICE9PSAwID8gKGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzKSAvIChhdk5vZ1NwYWNpbmdSYWRpdXMgKyBzcGFjaW5nKSA6IGFscGhhO1xuICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gIH1cbiAgY29uc3QgYmV0YSA9IE1hdGgubWF4KDAuMDAxLCBhbHBoYSAqIG91dGVyUmFkaXVzIC0gb2Zmc2V0IC8gUEkpIC8gb3V0ZXJSYWRpdXM7XG4gIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICBjb25zdCBzdGFydEFuZ2xlID0gc3RhcnQgKyBhbmdsZU9mZnNldCArIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IGVuZEFuZ2xlID0gZW5kIC0gYW5nbGVPZmZzZXQgLSBzcGFjaW5nT2Zmc2V0O1xuICBjb25zdCB7b3V0ZXJTdGFydCwgb3V0ZXJFbmQsIGlubmVyU3RhcnQsIGlubmVyRW5kfSA9IHBhcnNlQm9yZGVyUmFkaXVzJDEoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyU3RhcnQ7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBvdXRlclJhZGl1cyAtIG91dGVyRW5kO1xuICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBvdXRlckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIG91dGVyRW5kIC8gb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lclN0YXJ0O1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgY29uc3QgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgPSBzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cztcbiAgY29uc3QgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlID0gZW5kQW5nbGUgLSBpbm5lckVuZCAvIGlubmVyRW5kQWRqdXN0ZWRSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgaWYgKGNpcmN1bGFyKSB7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSk7XG4gICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgfVxuICAgIGNvbnN0IHA0ID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBlbmRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcbiAgICBpZiAoaW5uZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lckVuZEFkanVzdGVkUmFkaXVzLCBpbm5lckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJFbmQsIGVuZEFuZ2xlICsgSEFMRl9QSSwgaW5uZXJFbmRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSk7XG4gICAgfVxuICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlIC0gKGlubmVyRW5kIC8gaW5uZXJSYWRpdXMpLCBzdGFydEFuZ2xlICsgKGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cyksIHRydWUpO1xuICAgIGlmIChpbm5lclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkoaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzLCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lclN0YXJ0LCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSArIE1hdGguUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgY3R4LmxpbmVUbyhwOC54LCBwOC55KTtcbiAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICBjb25zdCBvdXRlclN0YXJ0WCA9IE1hdGguY29zKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICBjdHgubGluZVRvKG91dGVyU3RhcnRYLCBvdXRlclN0YXJ0WSk7XG4gICAgY29uc3Qgb3V0ZXJFbmRYID0gTWF0aC5jb3Mob3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeDtcbiAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJFbmRYLCBvdXRlckVuZFkpO1xuICB9XG4gIGN0eC5jbG9zZVBhdGgoKTtcbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtmdWxsQ2lyY2xlcywgc3RhcnRBbmdsZSwgY2lyY3VtZmVyZW5jZX0gPSBlbGVtZW50O1xuICBsZXQgZW5kQW5nbGUgPSBlbGVtZW50LmVuZEFuZ2xlO1xuICBpZiAoZnVsbENpcmNsZXMpIHtcbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBzdGFydEFuZ2xlICsgVEFVLCBjaXJjdWxhcik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKSB7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlICUgVEFVO1xuICAgICAgaWYgKGNpcmN1bWZlcmVuY2UgJSBUQVUgPT09IDApIHtcbiAgICAgICAgZW5kQW5nbGUgKz0gVEFVO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguZmlsbCgpO1xuICByZXR1cm4gZW5kQW5nbGU7XG59XG5mdW5jdGlvbiBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcikge1xuICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgcGl4ZWxNYXJnaW4sIGZ1bGxDaXJjbGVzfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBlbGVtZW50LmlubmVyUmFkaXVzICsgcGl4ZWxNYXJnaW47XG4gIGxldCBpO1xuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgc3RhcnRBbmdsZSArIFRBVSk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBzdGFydEFuZ2xlICsgVEFVLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgZm9yIChpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdCb3JkZXIoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcikge1xuICBjb25zdCB7b3B0aW9uc30gPSBlbGVtZW50O1xuICBjb25zdCB7Ym9yZGVyV2lkdGgsIGJvcmRlckpvaW5TdHlsZX0gPSBvcHRpb25zO1xuICBjb25zdCBpbm5lciA9IG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcic7XG4gIGlmICghYm9yZGVyV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoICogMjtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ3JvdW5kJztcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gIH1cbiAgaWYgKGVsZW1lbnQuZnVsbENpcmNsZXMpIHtcbiAgICBkcmF3RnVsbENpcmNsZUJvcmRlcnMoY3R4LCBlbGVtZW50LCBpbm5lcik7XG4gIH1cbiAgaWYgKGlubmVyKSB7XG4gICAgY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKTtcbiAgfVxuICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICBjdHguc3Ryb2tlKCk7XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2lyY3VtZmVyZW5jZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IDA7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBpblJhbmdlKGNoYXJ0WCwgY2hhcnRZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHthbmdsZSwgZGlzdGFuY2V9ID0gZ2V0QW5nbGVGcm9tUG9pbnQocG9pbnQsIHt4OiBjaGFydFgsIHk6IGNoYXJ0WX0pO1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgckFkanVzdCA9IHRoaXMub3B0aW9ucy5zcGFjaW5nIC8gMjtcbiAgICBjb25zdCBfY2lyY3VtZmVyZW5jZSA9IHZhbHVlT3JEZWZhdWx0KGNpcmN1bWZlcmVuY2UsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgIHJldHVybiAoYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXMpO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1c30gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICd4JyxcbiAgICAgICd5JyxcbiAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICdlbmRBbmdsZScsXG4gICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgJ291dGVyUmFkaXVzJyxcbiAgICAgICdjaXJjdW1mZXJlbmNlJyxcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7b2Zmc2V0LCBzcGFjaW5nfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgY29uc3QgaGFsZlJhZGl1cyA9IChpbm5lclJhZGl1cyArIG91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCkgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIGhhbGZSYWRpdXNcbiAgICB9O1xuICB9XG4gIHRvb2x0aXBQb3NpdGlvbih1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY2lyY3VtZmVyZW5jZX0gPSB0aGlzO1xuICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDI7XG4gICAgY29uc3Qgc3BhY2luZyA9IChvcHRpb25zLnNwYWNpbmcgfHwgMCkgLyAyO1xuICAgIGNvbnN0IGNpcmN1bGFyID0gb3B0aW9ucy5jaXJjdWxhcjtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gKG9wdGlvbnMuYm9yZGVyQWxpZ24gPT09ICdpbm5lcicpID8gMC4zMyA6IDA7XG4gICAgdGhpcy5mdWxsQ2lyY2xlcyA9IGNpcmN1bWZlcmVuY2UgPiBUQVUgPyBNYXRoLmZsb29yKGNpcmN1bWZlcmVuY2UgLyBUQVUpIDogMDtcbiAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCByYWRpdXNPZmZzZXQgPSAwO1xuICAgIGlmIChvZmZzZXQpIHtcbiAgICAgIHJhZGl1c09mZnNldCA9IG9mZnNldCAvIDI7XG4gICAgICBjb25zdCBoYWxmQW5nbGUgPSAodGhpcy5zdGFydEFuZ2xlICsgdGhpcy5lbmRBbmdsZSkgLyAyO1xuICAgICAgY3R4LnRyYW5zbGF0ZShNYXRoLmNvcyhoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0LCBNYXRoLnNpbihoYWxmQW5nbGUpICogcmFkaXVzT2Zmc2V0KTtcbiAgICAgIGlmICh0aGlzLmNpcmN1bWZlcmVuY2UgPj0gUEkpIHtcbiAgICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IGRyYXdBcmMoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICBkcmF3Qm9yZGVyKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbkFyY0VsZW1lbnQuaWQgPSAnYXJjJztcbkFyY0VsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckFsaWduOiAnY2VudGVyJyxcbiAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgYm9yZGVySm9pblN0eWxlOiB1bmRlZmluZWQsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgYm9yZGVyV2lkdGg6IDIsXG4gIG9mZnNldDogMCxcbiAgc3BhY2luZzogMCxcbiAgYW5nbGU6IHVuZGVmaW5lZCxcbiAgY2lyY3VsYXI6IHRydWUsXG59O1xuQXJjRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InXG59O1xuXG5mdW5jdGlvbiBzZXRTdHlsZShjdHgsIG9wdGlvbnMsIHN0eWxlID0gb3B0aW9ucykge1xuICBjdHgubGluZUNhcCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckNhcFN0eWxlLCBvcHRpb25zLmJvcmRlckNhcFN0eWxlKTtcbiAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LCBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQpO1xuICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJKb2luU3R5bGUsIG9wdGlvbnMuYm9yZGVySm9pblN0eWxlKTtcbiAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ29sb3IsIG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xufVxuZnVuY3Rpb24gbGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCkge1xuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZExpbmVUbztcbiAgfVxuICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHJldHVybiBfYmV6aWVyQ3VydmVUbztcbiAgfVxuICByZXR1cm4gbGluZVRvO1xufVxuZnVuY3Rpb24gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMgPSB7fSkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtzdGFydDogcGFyYW1zU3RhcnQgPSAwLCBlbmQ6IHBhcmFtc0VuZCA9IGNvdW50IC0gMX0gPSBwYXJhbXM7XG4gIGNvbnN0IHtzdGFydDogc2VnbWVudFN0YXJ0LCBlbmQ6IHNlZ21lbnRFbmR9ID0gc2VnbWVudDtcbiAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4ocGFyYW1zRW5kLCBzZWdtZW50RW5kKTtcbiAgY29uc3Qgb3V0c2lkZSA9IHBhcmFtc1N0YXJ0IDwgc2VnbWVudFN0YXJ0ICYmIHBhcmFtc0VuZCA8IHNlZ21lbnRTdGFydCB8fCBwYXJhbXNTdGFydCA+IHNlZ21lbnRFbmQgJiYgcGFyYW1zRW5kID4gc2VnbWVudEVuZDtcbiAgcmV0dXJuIHtcbiAgICBjb3VudCxcbiAgICBzdGFydCxcbiAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgaWxlbjogZW5kIDwgc3RhcnQgJiYgIW91dHNpZGUgPyBjb3VudCArIGVuZCAtIHN0YXJ0IDogZW5kIC0gc3RhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhdGhTZWdtZW50KGN0eCwgbGluZSwgc2VnbWVudCwgcGFyYW1zKSB7XG4gIGNvbnN0IHtwb2ludHMsIG9wdGlvbnN9ID0gbGluZTtcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgbG9vcCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IGxpbmVNZXRob2QgPSBnZXRMaW5lTWV0aG9kKG9wdGlvbnMpO1xuICBsZXQge21vdmUgPSB0cnVlLCByZXZlcnNlfSA9IHBhcmFtcyB8fCB7fTtcbiAgbGV0IGksIHBvaW50LCBwcmV2O1xuICBmb3IgKGkgPSAwOyBpIDw9IGlsZW47ICsraSkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGkgOiBpKSkgJSBjb3VudF07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cbiAgICBwcmV2ID0gcG9pbnQ7XG4gIH1cbiAgaWYgKGxvb3ApIHtcbiAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gOiAwKSkgJSBjb3VudF07XG4gICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICB9XG4gIHJldHVybiAhIWxvb3A7XG59XG5mdW5jdGlvbiBmYXN0UGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHtjb3VudCwgc3RhcnQsIGlsZW59ID0gcGF0aFZhcnMocG9pbnRzLCBzZWdtZW50LCBwYXJhbXMpO1xuICBjb25zdCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHByZXZYLCBtaW5ZLCBtYXhZLCBsYXN0WTtcbiAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCkgPT4gKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaW5kZXggOiBpbmRleCkpICUgY291bnQ7XG4gIGNvbnN0IGRyYXdYID0gKCkgPT4ge1xuICAgIGlmIChtaW5ZICE9PSBtYXhZKSB7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1heFkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBtaW5ZKTtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbGFzdFkpO1xuICAgIH1cbiAgfTtcbiAgaWYgKG1vdmUpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KDApXTtcbiAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG4gICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICBjb25zdCB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgfSBlbHNlIGlmICh5ID4gbWF4WSkge1xuICAgICAgICBtYXhZID0geTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHgpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdYKCk7XG4gICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgIH1cbiAgICBsYXN0WSA9IHk7XG4gIH1cbiAgZHJhd1goKTtcbn1cbmZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgY29uc3Qgb3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgYm9yZGVyRGFzaCA9IG9wdHMuYm9yZGVyRGFzaCAmJiBvcHRzLmJvcmRlckRhc2gubGVuZ3RoO1xuICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgcmV0dXJuIHVzZUZhc3RQYXRoID8gZmFzdFBhdGhTZWdtZW50IDogcGF0aFNlZ21lbnQ7XG59XG5mdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJJbnRlcnBvbGF0aW9uO1xuICB9XG4gIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGxldCBwYXRoID0gbGluZS5fcGF0aDtcbiAgaWYgKCFwYXRoKSB7XG4gICAgcGF0aCA9IGxpbmUuX3BhdGggPSBuZXcgUGF0aDJEKCk7XG4gICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRTdHlsZShjdHgsIGxpbmUub3B0aW9ucyk7XG4gIGN0eC5zdHJva2UocGF0aCk7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoRGlyZWN0KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGNvbnN0IHtzZWdtZW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc2VnbWVudC5zdHlsZSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGlmIChzZWdtZW50TWV0aG9kKGN0eCwgbGluZSwgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSkpIHtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICBpZiAodXNlUGF0aDJEICYmICFsaW5lLm9wdGlvbnMuc2VnbWVudCkge1xuICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9IGVsc2Uge1xuICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICB9XG59XG5jbGFzcyBMaW5lRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2Z1bGxMb29wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NlZ21lbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2RlY2ltYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhc2V0SW5kZXggPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVDb250cm9sUG9pbnRzKGNoYXJ0QXJlYSwgaW5kZXhBeGlzKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgc2V0IHBvaW50cyhwb2ludHMpIHtcbiAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgZGVsZXRlIHRoaXMuX3NlZ21lbnRzO1xuICAgIGRlbGV0ZSB0aGlzLl9wYXRoO1xuICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcG9pbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHM7XG4gIH1cbiAgZ2V0IHNlZ21lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWdtZW50cyB8fCAodGhpcy5fc2VnbWVudHMgPSBfY29tcHV0ZVNlZ21lbnRzKHRoaXMsIHRoaXMub3B0aW9ucy5zZWdtZW50KSk7XG4gIH1cbiAgZmlyc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIHJldHVybiBzZWdtZW50cy5sZW5ndGggJiYgcG9pbnRzW3NlZ21lbnRzWzBdLnN0YXJ0XTtcbiAgfVxuICBsYXN0KCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gY291bnQgJiYgcG9pbnRzW3NlZ21lbnRzW2NvdW50IC0gMV0uZW5kXTtcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge3Byb3BlcnR5LCBzdGFydDogdmFsdWUsIGVuZDogdmFsdWV9KTtcbiAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50c1tpXTtcbiAgICAgIGNvbnN0IHAxID0gcG9pbnRzW3N0YXJ0XTtcbiAgICAgIGNvbnN0IHAyID0gcG9pbnRzW2VuZF07XG4gICAgICBpZiAocDEgPT09IHAyKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0ID0gTWF0aC5hYnMoKHZhbHVlIC0gcDFbcHJvcGVydHldKSAvIChwMltwcm9wZXJ0eV0gLSBwMVtwcm9wZXJ0eV0pKTtcbiAgICAgIGNvbnN0IGludGVycG9sYXRlZCA9IF9pbnRlcnBvbGF0ZShwMSwgcDIsIHQsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgICBpbnRlcnBvbGF0ZWRbcHJvcGVydHldID0gcG9pbnRbcHJvcGVydHldO1xuICAgICAgcmVzdWx0LnB1c2goaW50ZXJwb2xhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gIH1cbiAgcGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgcmV0dXJuIHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCBwYXJhbXMpO1xuICB9XG4gIHBhdGgoY3R4LCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3Qgc2VnbWVudE1ldGhvZCA9IF9nZXRTZWdtZW50TWV0aG9kKHRoaXMpO1xuICAgIGxldCBsb29wID0gdGhpcy5fbG9vcDtcbiAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgY291bnQgPSBjb3VudCB8fCAodGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQpO1xuICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgbG9vcCAmPSBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwge3N0YXJ0LCBlbmQ6IHN0YXJ0ICsgY291bnQgLSAxfSk7XG4gICAgfVxuICAgIHJldHVybiAhIWxvb3A7XG4gIH1cbiAgZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cyB8fCBbXTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbmltYXRlZCkge1xuICAgICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn1cbkxpbmVFbGVtZW50LmlkID0gJ2xpbmUnO1xuTGluZUVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlckNhcFN0eWxlOiAnYnV0dCcsXG4gIGJvcmRlckRhc2g6IFtdLFxuICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICBib3JkZXJKb2luU3R5bGU6ICdtaXRlcicsXG4gIGJvcmRlcldpZHRoOiAzLFxuICBjYXBCZXppZXJQb2ludHM6IHRydWUsXG4gIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdkZWZhdWx0JyxcbiAgZmlsbDogZmFsc2UsXG4gIHNwYW5HYXBzOiBmYWxzZSxcbiAgc3RlcHBlZDogZmFsc2UsXG4gIHRlbnNpb246IDAsXG59O1xuTGluZUVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5MaW5lRWxlbWVudC5kZXNjcmlwdG9ycyA9IHtcbiAgX3NjcmlwdGFibGU6IHRydWUsXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2ZpbGwnLFxufTtcblxuZnVuY3Rpb24gaW5SYW5nZSQxKGVsLCBwb3MsIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGVsLm9wdGlvbnM7XG4gIGNvbnN0IHtbYXhpc106IHZhbHVlfSA9IGVsLmdldFByb3BzKFtheGlzXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiAoTWF0aC5hYnMocG9zIC0gdmFsdWUpIDwgb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cyk7XG59XG5jbGFzcyBQb2ludEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXJzZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5za2lwID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuICgoTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSkgPCBNYXRoLnBvdyhvcHRpb25zLmhpdFJhZGl1cyArIG9wdGlvbnMucmFkaXVzLCAyKSk7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5ZUmFuZ2UobW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVksICd5JywgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5fSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIHt4LCB5fTtcbiAgfVxuICBzaXplKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgbGV0IHJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XG4gICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IHJhZGl1cyAmJiBvcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgcmV0dXJuIChyYWRpdXMgKyBib3JkZXJXaWR0aCkgKiAyO1xuICB9XG4gIGRyYXcoY3R4LCBhcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodGhpcy5za2lwIHx8IG9wdGlvbnMucmFkaXVzIDwgMC4xIHx8ICFfaXNQb2ludEluQXJlYSh0aGlzLCBhcmVhLCB0aGlzLnNpemUob3B0aW9ucykgLyAyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB0aGlzLngsIHRoaXMueSk7XG4gIH1cbiAgZ2V0UmFuZ2UoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgfVxufVxuUG9pbnRFbGVtZW50LmlkID0gJ3BvaW50JztcblBvaW50RWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyV2lkdGg6IDEsXG4gIGhpdFJhZGl1czogMSxcbiAgaG92ZXJCb3JkZXJXaWR0aDogMSxcbiAgaG92ZXJSYWRpdXM6IDQsXG4gIHBvaW50U3R5bGU6ICdjaXJjbGUnLFxuICByYWRpdXM6IDMsXG4gIHJvdGF0aW9uOiAwXG59O1xuUG9pbnRFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG5mdW5jdGlvbiBnZXRCYXJCb3VuZHMoYmFyLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHt4LCB5LCBiYXNlLCB3aWR0aCwgaGVpZ2h0fSA9IGJhci5nZXRQcm9wcyhbJ3gnLCAneScsICdiYXNlJywgJ3dpZHRoJywgJ2hlaWdodCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcbiAgaWYgKGJhci5ob3Jpem9udGFsKSB7XG4gICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgbGVmdCA9IE1hdGgubWluKHgsIGJhc2UpO1xuICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgYmFzZSk7XG4gICAgdG9wID0geSAtIGhhbGY7XG4gICAgYm90dG9tID0geSArIGhhbGY7XG4gIH0gZWxzZSB7XG4gICAgaGFsZiA9IHdpZHRoIC8gMjtcbiAgICBsZWZ0ID0geCAtIGhhbGY7XG4gICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICB0b3AgPSBNYXRoLm1pbih5LCBiYXNlKTtcbiAgICBib3R0b20gPSBNYXRoLm1heCh5LCBiYXNlKTtcbiAgfVxuICByZXR1cm4ge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBza2lwT3JMaW1pdChza2lwLCB2YWx1ZSwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG4gIHJldHVybiB7XG4gICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICByOiBza2lwT3JMaW1pdChza2lwLnJpZ2h0LCBvLnJpZ2h0LCAwLCBtYXhXKSxcbiAgICBiOiBza2lwT3JMaW1pdChza2lwLmJvdHRvbSwgby5ib3R0b20sIDAsIG1heEgpLFxuICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCBtYXhXLCBtYXhIKSB7XG4gIGNvbnN0IHtlbmFibGVCb3JkZXJSYWRpdXN9ID0gYmFyLmdldFByb3BzKFsnZW5hYmxlQm9yZGVyUmFkaXVzJ10pO1xuICBjb25zdCB2YWx1ZSA9IGJhci5vcHRpb25zLmJvcmRlclJhZGl1cztcbiAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICBjb25zdCBtYXhSID0gTWF0aC5taW4obWF4VywgbWF4SCk7XG4gIGNvbnN0IHNraXAgPSBiYXIuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICB0b3BSaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLnRvcCB8fCBza2lwLnJpZ2h0LCBvLnRvcFJpZ2h0LCAwLCBtYXhSKSxcbiAgICBib3R0b21MZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAubGVmdCwgby5ib3R0b21MZWZ0LCAwLCBtYXhSKSxcbiAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICB9O1xufVxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhiYXIpIHtcbiAgY29uc3QgYm91bmRzID0gZ2V0QmFyQm91bmRzKGJhcik7XG4gIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gIGNvbnN0IGhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSBib3VuZHMudG9wO1xuICBjb25zdCBib3JkZXIgPSBwYXJzZUJvcmRlcldpZHRoKGJhciwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICByZXR1cm4ge1xuICAgIG91dGVyOiB7XG4gICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICB3OiB3aWR0aCxcbiAgICAgIGg6IGhlaWdodCxcbiAgICAgIHJhZGl1c1xuICAgIH0sXG4gICAgaW5uZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0ICsgYm9yZGVyLmwsXG4gICAgICB5OiBib3VuZHMudG9wICsgYm9yZGVyLnQsXG4gICAgICB3OiB3aWR0aCAtIGJvcmRlci5sIC0gYm9yZGVyLnIsXG4gICAgICBoOiBoZWlnaHQgLSBib3JkZXIudCAtIGJvcmRlci5iLFxuICAgICAgcmFkaXVzOiB7XG4gICAgICAgIHRvcExlZnQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BMZWZ0IC0gTWF0aC5tYXgoYm9yZGVyLnQsIGJvcmRlci5sKSksXG4gICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgYm90dG9tTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbUxlZnQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLmwpKSxcbiAgICAgICAgYm90dG9tUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy5ib3R0b21SaWdodCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIucikpLFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IHNraXBYID0geCA9PT0gbnVsbDtcbiAgY29uc3Qgc2tpcFkgPSB5ID09PSBudWxsO1xuICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICBjb25zdCBib3VuZHMgPSBiYXIgJiYgIXNraXBCb3RoICYmIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pO1xuICByZXR1cm4gYm91bmRzXG5cdFx0JiYgKHNraXBYIHx8IF9pc0JldHdlZW4oeCwgYm91bmRzLmxlZnQsIGJvdW5kcy5yaWdodCkpXG5cdFx0JiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICByZXR1cm4gcmFkaXVzLnRvcExlZnQgfHwgcmFkaXVzLnRvcFJpZ2h0IHx8IHJhZGl1cy5ib3R0b21MZWZ0IHx8IHJhZGl1cy5ib3R0b21SaWdodDtcbn1cbmZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjdHgucmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53LCByZWN0LmgpO1xufVxuZnVuY3Rpb24gaW5mbGF0ZVJlY3QocmVjdCwgYW1vdW50LCByZWZSZWN0ID0ge30pIHtcbiAgY29uc3QgeCA9IHJlY3QueCAhPT0gcmVmUmVjdC54ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICBjb25zdCB3ID0gKHJlY3QueCArIHJlY3QudyAhPT0gcmVmUmVjdC54ICsgcmVmUmVjdC53ID8gYW1vdW50IDogMCkgLSB4O1xuICBjb25zdCBoID0gKHJlY3QueSArIHJlY3QuaCAhPT0gcmVmUmVjdC55ICsgcmVmUmVjdC5oID8gYW1vdW50IDogMCkgLSB5O1xuICByZXR1cm4ge1xuICAgIHg6IHJlY3QueCArIHgsXG4gICAgeTogcmVjdC55ICsgeSxcbiAgICB3OiByZWN0LncgKyB3LFxuICAgIGg6IHJlY3QuaCArIGgsXG4gICAgcmFkaXVzOiByZWN0LnJhZGl1c1xuICB9O1xufVxuY2xhc3MgQmFyRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhvcml6b250YWwgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYXNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbmZsYXRlQW1vdW50ID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCB7aW5mbGF0ZUFtb3VudCwgb3B0aW9uczoge2JvcmRlckNvbG9yLCBiYWNrZ3JvdW5kQ29sb3J9fSA9IHRoaXM7XG4gICAgY29uc3Qge2lubmVyLCBvdXRlcn0gPSBib3VuZGluZ1JlY3RzKHRoaXMpO1xuICAgIGNvbnN0IGFkZFJlY3RQYXRoID0gaGFzUmFkaXVzKG91dGVyLnJhZGl1cykgPyBhZGRSb3VuZGVkUmVjdFBhdGggOiBhZGROb3JtYWxSZWN0UGF0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGlmIChvdXRlci53ICE9PSBpbm5lci53IHx8IG91dGVyLmggIT09IGlubmVyLmgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3Qob3V0ZXIsIGluZmxhdGVBbW91bnQsIGlubmVyKSk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgLWluZmxhdGVBbW91bnQsIG91dGVyKSk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbCgnZXZlbm9kZCcpO1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChpbm5lciwgaW5mbGF0ZUFtb3VudCkpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgaW5YUmFuZ2UobW91c2VYLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbW91c2VYLCBudWxsLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBudWxsLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeSwgYmFzZSwgaG9yaXpvbnRhbH0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnaG9yaXpvbnRhbCddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/ICh4ICsgYmFzZSkgLyAyIDogeCxcbiAgICAgIHk6IGhvcml6b250YWwgPyB5IDogKHkgKyBiYXNlKSAvIDJcbiAgICB9O1xuICB9XG4gIGdldFJhbmdlKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gdGhpcy53aWR0aCAvIDIgOiB0aGlzLmhlaWdodCAvIDI7XG4gIH1cbn1cbkJhckVsZW1lbnQuaWQgPSAnYmFyJztcbkJhckVsZW1lbnQuZGVmYXVsdHMgPSB7XG4gIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG59O1xuQmFyRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcblxudmFyIGVsZW1lbnRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQXJjRWxlbWVudDogQXJjRWxlbWVudCxcbkxpbmVFbGVtZW50OiBMaW5lRWxlbWVudCxcblBvaW50RWxlbWVudDogUG9pbnRFbGVtZW50LFxuQmFyRWxlbWVudDogQmFyRWxlbWVudFxufSk7XG5cbmZ1bmN0aW9uIGx0dGJEZWNpbWF0aW9uKGRhdGEsIHN0YXJ0LCBjb3VudCwgYXZhaWxhYmxlV2lkdGgsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2FtcGxlcyA9IG9wdGlvbnMuc2FtcGxlcyB8fCBhdmFpbGFibGVXaWR0aDtcbiAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICByZXR1cm4gZGF0YS5zbGljZShzdGFydCwgc3RhcnQgKyBjb3VudCk7XG4gIH1cbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGJ1Y2tldFdpZHRoID0gKGNvdW50IC0gMikgLyAoc2FtcGxlcyAtIDIpO1xuICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGNvdW50IC0gMTtcbiAgbGV0IGEgPSBzdGFydDtcbiAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2FdO1xuICBmb3IgKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKykge1xuICAgIGxldCBhdmdYID0gMDtcbiAgICBsZXQgYXZnWSA9IDA7XG4gICAgbGV0IGo7XG4gICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICBjb25zdCBhdmdSYW5nZUVuZCA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAyKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlTGVuZ3RoID0gYXZnUmFuZ2VFbmQgLSBhdmdSYW5nZVN0YXJ0O1xuICAgIGZvciAoaiA9IGF2Z1JhbmdlU3RhcnQ7IGogPCBhdmdSYW5nZUVuZDsgaisrKSB7XG4gICAgICBhdmdYICs9IGRhdGFbal0ueDtcbiAgICAgIGF2Z1kgKz0gZGF0YVtqXS55O1xuICAgIH1cbiAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgIGF2Z1kgLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgY29uc3QgcmFuZ2VPZmZzID0gTWF0aC5mbG9vcihpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICBjb25zdCB7eDogcG9pbnRBeCwgeTogcG9pbnRBeX0gPSBkYXRhW2FdO1xuICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG4gICAgZm9yIChqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKSB7XG4gICAgICBhcmVhID0gMC41ICogTWF0aC5hYnMoXG4gICAgICAgIChwb2ludEF4IC0gYXZnWCkgKiAoZGF0YVtqXS55IC0gcG9pbnRBeSkgLVxuICAgICAgICAocG9pbnRBeCAtIGRhdGFbal0ueCkgKiAoYXZnWSAtIHBvaW50QXkpXG4gICAgICApO1xuICAgICAgaWYgKGFyZWEgPiBtYXhBcmVhKSB7XG4gICAgICAgIG1heEFyZWEgPSBhcmVhO1xuICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICBuZXh0QSA9IGo7XG4gICAgICB9XG4gICAgfVxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBtYXhBcmVhUG9pbnQ7XG4gICAgYSA9IG5leHRBO1xuICB9XG4gIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCkge1xuICBsZXQgYXZnWCA9IDA7XG4gIGxldCBjb3VudFggPSAwO1xuICBsZXQgaSwgcG9pbnQsIHgsIHksIHByZXZYLCBtaW5JbmRleCwgbWF4SW5kZXgsIHN0YXJ0SW5kZXgsIG1pblksIG1heFk7XG4gIGNvbnN0IGRlY2ltYXRlZCA9IFtdO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBjb25zdCB4TWluID0gZGF0YVtzdGFydF0ueDtcbiAgY29uc3QgeE1heCA9IGRhdGFbZW5kSW5kZXhdLng7XG4gIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG4gIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgcG9pbnQgPSBkYXRhW2ldO1xuICAgIHggPSAocG9pbnQueCAtIHhNaW4pIC8gZHggKiBhdmFpbGFibGVXaWR0aDtcbiAgICB5ID0gcG9pbnQueTtcbiAgICBjb25zdCB0cnVuY1ggPSB4IHwgMDtcbiAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgIG1pblkgPSB5O1xuICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgICBtYXhJbmRleCA9IGk7XG4gICAgICB9XG4gICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyBwb2ludC54KSAvICsrY291bnRYO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0SW5kZXggPSBpIC0gMTtcbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihtaW5JbmRleCkgJiYgIWlzTnVsbE9yVW5kZWYobWF4SW5kZXgpKSB7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MSA9IE1hdGgubWluKG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDEgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgxICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICB4OiBhdmdYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlcm1lZGlhdGVJbmRleDIgIT09IHN0YXJ0SW5kZXggJiYgaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4Ml0sXG4gICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCAmJiBsYXN0SW5kZXggIT09IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgZGVjaW1hdGVkLnB1c2goZGF0YVtsYXN0SW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIGRlY2ltYXRlZC5wdXNoKHBvaW50KTtcbiAgICAgIHByZXZYID0gdHJ1bmNYO1xuICAgICAgY291bnRYID0gMDtcbiAgICAgIG1pblkgPSBtYXhZID0geTtcbiAgICAgIG1pbkluZGV4ID0gbWF4SW5kZXggPSBzdGFydEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gIGlmIChkYXRhc2V0Ll9kZWNpbWF0ZWQpIHtcbiAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICBkZWxldGUgZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kYXRhO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHt2YWx1ZTogZGF0YX0pO1xuICB9XG59XG5mdW5jdGlvbiBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpIHtcbiAgY2hhcnQuZGF0YS5kYXRhc2V0cy5mb3JFYWNoKChkYXRhc2V0KSA9PiB7XG4gICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIHBvaW50cykge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50O1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCkge1xuICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1heCkuaGkgKyAxLCBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgfSBlbHNlIHtcbiAgICBjb3VudCA9IHBvaW50Q291bnQgLSBzdGFydDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG52YXIgcGx1Z2luX2RlY2ltYXRpb24gPSB7XG4gIGlkOiAnZGVjaW1hdGlvbicsXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gIH0sXG4gIGJlZm9yZUVsZW1lbnRzVXBkYXRlOiAoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpID0+IHtcbiAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBjaGFydC53aWR0aDtcbiAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCkgPT4ge1xuICAgICAgY29uc3Qge19kYXRhLCBpbmRleEF4aXN9ID0gZGF0YXNldDtcbiAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgY29uc3QgZGF0YSA9IF9kYXRhIHx8IGRhdGFzZXQuZGF0YTtcbiAgICAgIGlmIChyZXNvbHZlKFtpbmRleEF4aXMsIGNoYXJ0Lm9wdGlvbnMuaW5kZXhBeGlzXSkgPT09ICd5Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGEuY29udHJvbGxlci5zdXBwb3J0c0RlY2ltYXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeEF4aXMgPSBjaGFydC5zY2FsZXNbbWV0YS54QXhpc0lEXTtcbiAgICAgIGlmICh4QXhpcy50eXBlICE9PSAnbGluZWFyJyAmJiB4QXhpcy50eXBlICE9PSAndGltZScpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQge3N0YXJ0LCBjb3VudH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNOdWxsT3JVbmRlZihfZGF0YSkpIHtcbiAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgIGRlbGV0ZSBkYXRhc2V0LmRhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlY2ltYXRlZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuYWxnb3JpdGhtKSB7XG4gICAgICBjYXNlICdsdHRiJzpcbiAgICAgICAgZGVjaW1hdGVkID0gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkZWNpbWF0aW9uIGFsZ29yaXRobSAnJHtvcHRpb25zLmFsZ29yaXRobX0nYCk7XG4gICAgICB9XG4gICAgICBkYXRhc2V0Ll9kZWNpbWF0ZWQgPSBkZWNpbWF0ZWQ7XG4gICAgfSk7XG4gIH0sXG4gIGRlc3Ryb3koY2hhcnQpIHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfc2VnbWVudHMobGluZSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCB0cG9pbnRzID0gdGFyZ2V0LnBvaW50cztcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgbGV0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIHBvaW50cyk7XG4gICAgY29uc3QgYm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgcG9pbnRzW3N0YXJ0XSwgcG9pbnRzW2VuZF0sIHNlZ21lbnQubG9vcCk7XG4gICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICBzb3VyY2U6IHNlZ21lbnQsXG4gICAgICAgIHRhcmdldDogYm91bmRzLFxuICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgZW5kOiBwb2ludHNbZW5kXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0U2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0YXJnZXQsIGJvdW5kcyk7XG4gICAgZm9yIChjb25zdCB0Z3Qgb2YgdGFyZ2V0U2VnbWVudHMpIHtcbiAgICAgIGNvbnN0IHN1YkJvdW5kcyA9IF9nZXRCb3VuZHMocHJvcGVydHksIHRwb2ludHNbdGd0LnN0YXJ0XSwgdHBvaW50c1t0Z3QuZW5kXSwgdGd0Lmxvb3ApO1xuICAgICAgY29uc3QgZmlsbFNvdXJjZXMgPSBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgc3ViQm91bmRzKTtcbiAgICAgIGZvciAoY29uc3QgZmlsbFNvdXJjZSBvZiBmaWxsU291cmNlcykge1xuICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0OiB0Z3QsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnc3RhcnQnLCBNYXRoLm1heClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdlbmQnLCBNYXRoLm1pbilcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICBpZiAobG9vcCkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhcnQgPSBmaXJzdFtwcm9wZXJ0eV07XG4gIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgIGVuZCA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICB9XG4gIHJldHVybiB7cHJvcGVydHksIHN0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICBjb25zdCB7eCA9IG51bGwsIHkgPSBudWxsfSA9IGJvdW5kYXJ5IHx8IHt9O1xuICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBsaW5lLnNlZ21lbnRzLmZvckVhY2goKHtzdGFydCwgZW5kfSkgPT4ge1xuICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBsaW5lUG9pbnRzKTtcbiAgICBjb25zdCBmaXJzdCA9IGxpbmVQb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgaWYgKHkgIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBmaXJzdC54LCB5fSk7XG4gICAgICBwb2ludHMucHVzaCh7eDogbGFzdC54LCB5fSk7XG4gICAgfSBlbHNlIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogZmlyc3QueX0pO1xuICAgICAgcG9pbnRzLnB1c2goe3gsIHk6IGxhc3QueX0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBwb2ludHM7XG59XG5mdW5jdGlvbiBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKSB7XG4gIGZvciAoO2VuZCA+IHN0YXJ0OyBlbmQtLSkge1xuICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2VuZF07XG4gICAgaWYgKCFpc05hTihwb2ludC54KSAmJiAhaXNOYU4ocG9pbnQueSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gX2dldEVkZ2UoYSwgYiwgcHJvcCwgZm4pIHtcbiAgaWYgKGEgJiYgYikge1xuICAgIHJldHVybiBmbihhW3Byb3BdLCBiW3Byb3BdKTtcbiAgfVxuICByZXR1cm4gYSA/IGFbcHJvcF0gOiBiID8gYltwcm9wXSA6IDA7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpIHtcbiAgbGV0IHBvaW50cyA9IFtdO1xuICBsZXQgX2xvb3AgPSBmYWxzZTtcbiAgaWYgKGlzQXJyYXkoYm91bmRhcnkpKSB7XG4gICAgX2xvb3AgPSB0cnVlO1xuICAgIHBvaW50cyA9IGJvdW5kYXJ5O1xuICB9IGVsc2Uge1xuICAgIHBvaW50cyA9IF9wb2ludHNGcm9tU2VnbWVudHMoYm91bmRhcnksIGxpbmUpO1xuICB9XG4gIHJldHVybiBwb2ludHMubGVuZ3RoID8gbmV3IExpbmVFbGVtZW50KHtcbiAgICBwb2ludHMsXG4gICAgb3B0aW9uczoge3RlbnNpb246IDB9LFxuICAgIF9sb29wLFxuICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgfSkgOiBudWxsO1xufVxuZnVuY3Rpb24gX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuZmlsbCAhPT0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGluZGV4LCBwcm9wYWdhdGUpIHtcbiAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gIGxldCBmaWxsID0gc291cmNlLmZpbGw7XG4gIGNvbnN0IHZpc2l0ZWQgPSBbaW5kZXhdO1xuICBsZXQgdGFyZ2V0O1xuICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgIHJldHVybiBmaWxsO1xuICB9XG4gIHdoaWxlIChmaWxsICE9PSBmYWxzZSAmJiB2aXNpdGVkLmluZGV4T2YoZmlsbCkgPT09IC0xKSB7XG4gICAgaWYgKCFpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgICAgcmV0dXJuIGZpbGw7XG4gICAgfVxuICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdmlzaXRlZC5wdXNoKGZpbGwpO1xuICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfZGVjb2RlRmlsbChsaW5lLCBpbmRleCwgY291bnQpIHtcbiAgY29uc3QgZmlsbCA9IHBhcnNlRmlsbE9wdGlvbihsaW5lKTtcbiAgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcmV0dXJuIGlzTmFOKGZpbGwudmFsdWUpID8gZmFsc2UgOiBmaWxsO1xuICB9XG4gIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUodGFyZ2V0KSAmJiBNYXRoLmZsb29yKHRhcmdldCkgPT09IHRhcmdldCkge1xuICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gIH1cbiAgcmV0dXJuIFsnb3JpZ2luJywgJ3N0YXJ0JywgJ2VuZCcsICdzdGFjaycsICdzaGFwZSddLmluZGV4T2YoZmlsbCkgPj0gMCAmJiBmaWxsO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFyZ2V0SW5kZXgoZmlyc3RDaCwgaW5kZXgsIHRhcmdldCwgY291bnQpIHtcbiAgaWYgKGZpcnN0Q2ggPT09ICctJyB8fCBmaXJzdENoID09PSAnKycpIHtcbiAgICB0YXJnZXQgPSBpbmRleCArIHRhcmdldDtcbiAgfVxuICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gIGxldCBwaXhlbCA9IG51bGw7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5ib3R0b207XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLnRvcDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShmaWxsLnZhbHVlKTtcbiAgfSBlbHNlIGlmIChzY2FsZS5nZXRCYXNlUGl4ZWwpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICB9XG4gIHJldHVybiBwaXhlbDtcbn1cbmZ1bmN0aW9uIF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnRWYWx1ZSkge1xuICBsZXQgdmFsdWU7XG4gIGlmIChmaWxsID09PSAnc3RhcnQnKSB7XG4gICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZUZpbGxPcHRpb24obGluZSkge1xuICBjb25zdCBvcHRpb25zID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICBsZXQgZmlsbCA9IHZhbHVlT3JEZWZhdWx0KGZpbGxPcHRpb24gJiYgZmlsbE9wdGlvbi50YXJnZXQsIGZpbGxPcHRpb24pO1xuICBpZiAoZmlsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZmlsbCA9ICEhb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGZpbGwgPT09IHRydWUpIHtcbiAgICByZXR1cm4gJ29yaWdpbic7XG4gIH1cbiAgcmV0dXJuIGZpbGw7XG59XG5cbmZ1bmN0aW9uIF9idWlsZFN0YWNrTGluZShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlLCBpbmRleCwgbGluZX0gPSBzb3VyY2U7XG4gIGNvbnN0IHBvaW50cyA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IHNvdXJjZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBsaW5lc0JlbG93ID0gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpO1xuICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7eDogbnVsbCwgeTogc2NhbGUuYm90dG9tfSwgbGluZSkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGZvciAobGV0IGogPSBzZWdtZW50LnN0YXJ0OyBqIDw9IHNlZ21lbnQuZW5kOyBqKyspIHtcbiAgICAgIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnRzW2pdLCBsaW5lc0JlbG93KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7cG9pbnRzLCBvcHRpb25zOiB7fX0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZXNCZWxvdyhzY2FsZSwgaW5kZXgpIHtcbiAgY29uc3QgYmVsb3cgPSBbXTtcbiAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1ldGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgIGlmIChtZXRhLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghbWV0YS5oaWRkZW4pIHtcbiAgICAgIGJlbG93LnVuc2hpZnQobWV0YS5kYXRhc2V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJlbG93O1xufVxuZnVuY3Rpb24gYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludCwgbGluZXNCZWxvdykge1xuICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lc0JlbG93Lmxlbmd0aDsgaisrKSB7XG4gICAgY29uc3QgbGluZSA9IGxpbmVzQmVsb3dbal07XG4gICAgY29uc3Qge2ZpcnN0LCBsYXN0LCBwb2ludH0gPSBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsICd4Jyk7XG4gICAgaWYgKCFwb2ludCB8fCAoZmlyc3QgJiYgbGFzdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIHBvc3Rwb25lZC51bnNoaWZ0KHBvaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwb2ludHMucHVzaCguLi5wb3N0cG9uZWQpO1xufVxuZnVuY3Rpb24gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCBwb2ludCA9IGxpbmUuaW50ZXJwb2xhdGUoc291cmNlUG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKCFwb2ludCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICBjb25zdCBwb2ludFZhbHVlID0gcG9pbnRbcHJvcGVydHldO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgbGV0IGZpcnN0ID0gZmFsc2U7XG4gIGxldCBsYXN0ID0gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5lbmRdW3Byb3BlcnR5XTtcbiAgICBpZiAoX2lzQmV0d2Vlbihwb2ludFZhbHVlLCBmaXJzdFZhbHVlLCBsYXN0VmFsdWUpKSB7XG4gICAgICBmaXJzdCA9IHBvaW50VmFsdWUgPT09IGZpcnN0VmFsdWU7XG4gICAgICBsYXN0ID0gcG9pbnRWYWx1ZSA9PT0gbGFzdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7Zmlyc3QsIGxhc3QsIHBvaW50fTtcbn1cblxuY2xhc3Mgc2ltcGxlQXJjIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHRoaXMueCA9IG9wdHMueDtcbiAgICB0aGlzLnkgPSBvcHRzLnk7XG4gICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIGJvdW5kcywgb3B0cykge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBib3VuZHMgPSBib3VuZHMgfHwge3N0YXJ0OiAwLCBlbmQ6IFRBVX07XG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIGJvdW5kcy5lbmQsIGJvdW5kcy5zdGFydCwgdHJ1ZSk7XG4gICAgcmV0dXJuICFvcHRzLmJvdW5kcztcbiAgfVxuICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgIGNvbnN0IHt4LCB5LCByYWRpdXN9ID0gdGhpcztcbiAgICBjb25zdCBhbmdsZSA9IHBvaW50LmFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogeSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1cyxcbiAgICAgIGFuZ2xlXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0VGFyZ2V0KHNvdXJjZSkge1xuICBjb25zdCB7Y2hhcnQsIGZpbGwsIGxpbmV9ID0gc291cmNlO1xuICBpZiAoaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc3RhY2snKSB7XG4gICAgcmV0dXJuIF9idWlsZFN0YWNrTGluZShzb3VyY2UpO1xuICB9XG4gIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYm91bmRhcnkgPSBjb21wdXRlQm91bmRhcnkoc291cmNlKTtcbiAgaWYgKGJvdW5kYXJ5IGluc3RhbmNlb2Ygc2ltcGxlQXJjKSB7XG4gICAgcmV0dXJuIGJvdW5kYXJ5O1xuICB9XG4gIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbmZ1bmN0aW9uIGdldExpbmVCeUluZGV4KGNoYXJ0LCBpbmRleCkge1xuICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICBjb25zdCB2aXNpYmxlID0gbWV0YSAmJiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KTtcbiAgcmV0dXJuIHZpc2libGUgPyBtZXRhLmRhdGFzZXQgOiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgaWYgKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSkge1xuICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICB9XG4gIHJldHVybiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpIHtcbiAgY29uc3Qge3NjYWxlID0ge30sIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBwaXhlbCA9IF9nZXRUYXJnZXRQaXhlbChmaWxsLCBzY2FsZSk7XG4gIGlmIChpc051bWJlckZpbml0ZShwaXhlbCkpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gc2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGZpbGx9ID0gc291cmNlO1xuICBjb25zdCBvcHRpb25zID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICBjb25zdCBzdGFydCA9IG9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1heCA6IHNjYWxlLm1pbjtcbiAgY29uc3QgdmFsdWUgPSBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0KTtcbiAgY29uc3QgdGFyZ2V0ID0gW107XG4gIGlmIChvcHRpb25zLmdyaWQuY2lyY3VsYXIpIHtcbiAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgIHJldHVybiBuZXcgc2ltcGxlQXJjKHtcbiAgICAgIHg6IGNlbnRlci54LFxuICAgICAgeTogY2VudGVyLnksXG4gICAgICByYWRpdXM6IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKVxuICAgIH0pO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB0YXJnZXQucHVzaChzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdmFsdWUpKTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgY29uc3QgdGFyZ2V0ID0gX2dldFRhcmdldChzb3VyY2UpO1xuICBjb25zdCB7bGluZSwgc2NhbGUsIGF4aXN9ID0gc291cmNlO1xuICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgY29uc3QgZmlsbE9wdGlvbiA9IGxpbmVPcHRzLmZpbGw7XG4gIGNvbnN0IGNvbG9yID0gbGluZU9wdHMuYmFja2dyb3VuZENvbG9yO1xuICBjb25zdCB7YWJvdmUgPSBjb2xvciwgYmVsb3cgPSBjb2xvcn0gPSBmaWxsT3B0aW9uIHx8IHt9O1xuICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgIGNsaXBBcmVhKGN0eCwgYXJlYSk7XG4gICAgZG9GaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZSwgYXhpc30pO1xuICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIGFib3ZlLCBiZWxvdywgYXJlYSwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBwcm9wZXJ0eSA9IGxpbmUuX2xvb3AgPyAnYW5nbGUnIDogY2ZnLmF4aXM7XG4gIGN0eC5zYXZlKCk7XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnICYmIGJlbG93ICE9PSBhYm92ZSkge1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYWJvdmUsIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgfVxuICBmaWxsKGN0eCwge2xpbmUsIHRhcmdldCwgY29sb3I6IGJlbG93LCBzY2FsZSwgcHJvcGVydHl9KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgY2xpcFkpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBwb2ludHN9ID0gdGFyZ2V0O1xuICBsZXQgZmlyc3QgPSB0cnVlO1xuICBsZXQgbGluZUxvb3AgPSBmYWxzZTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBjb25zdCB7c3RhcnQsIGVuZH0gPSBzZWdtZW50O1xuICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBwb2ludHNbc3RhcnRdO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgaWYgKGZpcnN0KSB7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcbiAgICB9XG4gICAgbGluZUxvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHttb3ZlOiBsaW5lTG9vcH0pO1xuICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgfVxuICB9XG4gIGN0eC5saW5lVG8odGFyZ2V0LmZpcnN0KCkueCwgY2xpcFkpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gIGNvbnN0IHtsaW5lLCB0YXJnZXQsIHByb3BlcnR5LCBjb2xvciwgc2NhbGV9ID0gY2ZnO1xuICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgZm9yIChjb25zdCB7c291cmNlOiBzcmMsIHRhcmdldDogdGd0LCBzdGFydCwgZW5kfSBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdHlsZToge2JhY2tncm91bmRDb2xvciA9IGNvbG9yfSA9IHt9fSA9IHNyYztcbiAgICBjb25zdCBub3RTaGFwZSA9IHRhcmdldCAhPT0gdHJ1ZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBub3RTaGFwZSAmJiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBzdGFydCwgZW5kKSk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNvbnN0IGxpbmVMb29wID0gISFsaW5lLnBhdGhTZWdtZW50KGN0eCwgc3JjKTtcbiAgICBsZXQgbG9vcDtcbiAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIGVuZCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0TG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgdGd0LCB7bW92ZTogbGluZUxvb3AsIHJldmVyc2U6IHRydWV9KTtcbiAgICAgIGxvb3AgPSBsaW5lTG9vcCAmJiB0YXJnZXRMb29wO1xuICAgICAgaWYgKCFsb29wKSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgc3RhcnQsIHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKGxvb3AgPyAnZXZlbm9kZCcgOiAnbm9uemVybycpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBCb3VuZHMoY3R4LCBzY2FsZSwgYm91bmRzKSB7XG4gIGNvbnN0IHt0b3AsIGJvdHRvbX0gPSBzY2FsZS5jaGFydC5jaGFydEFyZWE7XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH0gPSBib3VuZHMgfHwge307XG4gIGlmIChwcm9wZXJ0eSA9PT0gJ3gnKSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5yZWN0KHN0YXJ0LCB0b3AsIGVuZCAtIHN0YXJ0LCBib3R0b20gLSB0b3ApO1xuICAgIGN0eC5jbGlwKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgcG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IGludGVycG9sYXRlZFBvaW50ID0gdGFyZ2V0LmludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSk7XG4gIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgIGN0eC5saW5lVG8oaW50ZXJwb2xhdGVkUG9pbnQueCwgaW50ZXJwb2xhdGVkUG9pbnQueSk7XG4gIH1cbn1cblxudmFyIGluZGV4ID0ge1xuICBpZDogJ2ZpbGxlcicsXG4gIGFmdGVyRGF0YXNldHNVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgICBsZXQgbWV0YSwgaSwgbGluZSwgc291cmNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSk7XG4gICAgICBsaW5lID0gbWV0YS5kYXRhc2V0O1xuICAgICAgc291cmNlID0gbnVsbDtcbiAgICAgIGlmIChsaW5lICYmIGxpbmUub3B0aW9ucyAmJiBsaW5lIGluc3RhbmNlb2YgTGluZUVsZW1lbnQpIHtcbiAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgIHZpc2libGU6IGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSksXG4gICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgIGF4aXM6IG1ldGEuY29udHJvbGxlci5vcHRpb25zLmluZGV4QXhpcyxcbiAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgbGluZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIG1ldGEuJGZpbGxlciA9IHNvdXJjZTtcbiAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICAgIGlmICghc291cmNlIHx8IHNvdXJjZS5maWxsID09PSBmYWxzZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5maWxsID0gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaSwgb3B0aW9ucy5wcm9wYWdhdGUpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBkcmF3ID0gb3B0aW9ucy5kcmF3VGltZSA9PT0gJ2JlZm9yZURyYXcnO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzb3VyY2UubGluZS51cGRhdGVDb250cm9sUG9pbnRzKGFyZWEsIHNvdXJjZS5heGlzKTtcbiAgICAgIGlmIChkcmF3ICYmIHNvdXJjZS5maWxsKSB7XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0c0RyYXcoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0c0RyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGF0YXNldERyYXcoY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICBpZiAoIV9zaG91bGRBcHBseUZpbGwoc291cmNlKSB8fCBvcHRpb25zLmRyYXdUaW1lICE9PSAnYmVmb3JlRGF0YXNldERyYXcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBwcm9wYWdhdGU6IHRydWUsXG4gICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgfVxufTtcblxuY29uc3QgZ2V0Qm94U2l6ZSA9IChsYWJlbE9wdHMsIGZvbnRTaXplKSA9PiB7XG4gIGxldCB7Ym94SGVpZ2h0ID0gZm9udFNpemUsIGJveFdpZHRoID0gZm9udFNpemV9ID0gbGFiZWxPcHRzO1xuICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICBib3hIZWlnaHQgPSBNYXRoLm1pbihib3hIZWlnaHQsIGZvbnRTaXplKTtcbiAgICBib3hXaWR0aCA9IGxhYmVsT3B0cy5wb2ludFN0eWxlV2lkdGggfHwgTWF0aC5taW4oYm94V2lkdGgsIGZvbnRTaXplKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJveFdpZHRoLFxuICAgIGJveEhlaWdodCxcbiAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICB9O1xufTtcbmNvbnN0IGl0ZW1zRXF1YWwgPSAoYSwgYikgPT4gYSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBudWxsO1xuICAgIHRoaXMuZG91Z2hudXRNb2RlID0gZmFsc2U7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNvbHVtblNpemVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGluZVdpZHRocyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heFdpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZnVsbFNpemUgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5idWlsZExhYmVscygpO1xuICAgIHRoaXMuZml0KCk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSB0aGlzLl9tYXJnaW5zLmxlZnQ7XG4gICAgICB0aGlzLnJpZ2h0ID0gdGhpcy53aWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgfVxuICBidWlsZExhYmVscygpIHtcbiAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgIGxldCBsZWdlbmRJdGVtcyA9IGNhbGxiYWNrKGxhYmVsT3B0cy5nZW5lcmF0ZUxhYmVscywgW3RoaXMuY2hhcnRdLCB0aGlzKSB8fCBbXTtcbiAgICBpZiAobGFiZWxPcHRzLmZpbHRlcikge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgfVxuICAgIGlmIChsYWJlbE9wdHMuc29ydCkge1xuICAgICAgbGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcy5zb3J0KChhLCBiKSA9PiBsYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICBsZWdlbmRJdGVtcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHRoaXMubGVnZW5kSXRlbXMgPSBsZWdlbmRJdGVtcztcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIGN0eH0gPSB0aGlzO1xuICAgIGlmICghb3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbE9wdHMgPSBvcHRpb25zLmxhYmVscztcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBjb25zdCB7Ym94V2lkdGgsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB3aWR0aCA9IHRoaXMuX2ZpdENvbHModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IE1hdGgubWluKHdpZHRoLCBvcHRpb25zLm1heFdpZHRoIHx8IHRoaXMubWF4V2lkdGgpO1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5taW4oaGVpZ2h0LCBvcHRpb25zLm1heEhlaWdodCB8fCB0aGlzLm1heEhlaWdodCk7XG4gIH1cbiAgX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IHtjdHgsIG1heFdpZHRoLCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgbGluZVdpZHRocyA9IHRoaXMubGluZVdpZHRocyA9IFswXTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgbGV0IHRvdGFsSGVpZ2h0ID0gdGl0bGVIZWlnaHQ7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgbGV0IHJvdyA9IC0xO1xuICAgIGxldCB0b3AgPSAtbGluZUhlaWdodDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID09PSAwIHx8IGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArIGl0ZW1XaWR0aCArIDIgKiBwYWRkaW5nID4gbWF4V2lkdGgpIHtcbiAgICAgICAgdG90YWxIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgcm93Kys7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0OiAwLCB0b3AsIHJvdywgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGxpbmVXaWR0aHNbbGluZVdpZHRocy5sZW5ndGggLSAxXSArPSBpdGVtV2lkdGggKyBwYWRkaW5nO1xuICAgIH0pO1xuICAgIHJldHVybiB0b3RhbEhlaWdodDtcbiAgfVxuICBfZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4SGVpZ2h0LCBvcHRpb25zOiB7bGFiZWxzOiB7cGFkZGluZ319fSA9IHRoaXM7XG4gICAgY29uc3QgaGl0Ym94ZXMgPSB0aGlzLmxlZ2VuZEhpdEJveGVzID0gW107XG4gICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgY29uc3QgaGVpZ2h0TGltaXQgPSBtYXhIZWlnaHQgLSB0aXRsZUhlaWdodDtcbiAgICBsZXQgdG90YWxXaWR0aCA9IHBhZGRpbmc7XG4gICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgbGV0IGN1cnJlbnRDb2xIZWlnaHQgPSAwO1xuICAgIGxldCBsZWZ0ID0gMDtcbiAgICBsZXQgY29sID0gMDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGJveFdpZHRoICsgKGZvbnRTaXplIC8gMikgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGlmIChpID4gMCAmJiBjdXJyZW50Q29sSGVpZ2h0ICsgaXRlbUhlaWdodCArIDIgKiBwYWRkaW5nID4gaGVpZ2h0TGltaXQpIHtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICAgICAgbGVmdCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICBjb2wrKztcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICBoaXRib3hlc1tpXSA9IHtsZWZ0LCB0b3A6IGN1cnJlbnRDb2xIZWlnaHQsIGNvbCwgd2lkdGg6IGl0ZW1XaWR0aCwgaGVpZ2h0OiBpdGVtSGVpZ2h0fTtcbiAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE1hdGgubWF4KGN1cnJlbnRDb2xXaWR0aCwgaXRlbVdpZHRoKTtcbiAgICAgIGN1cnJlbnRDb2xIZWlnaHQgKz0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgY29sdW1uU2l6ZXMucHVzaCh7d2lkdGg6IGN1cnJlbnRDb2xXaWR0aCwgaGVpZ2h0OiBjdXJyZW50Q29sSGVpZ2h0fSk7XG4gICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gIH1cbiAgYWRqdXN0SGl0Qm94ZXMoKSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMsIG9wdGlvbnM6IHthbGlnbiwgbGFiZWxzOiB7cGFkZGluZ30sIHJ0bH19ID0gdGhpcztcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgbGV0IHJvdyA9IDA7XG4gICAgICBsZXQgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaGl0Ym94LnJvdykge1xuICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gdGhpcy5saW5lV2lkdGhzW3Jvd10pO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgKz0gdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngobGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvbCA9IDA7XG4gICAgICBsZXQgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgZm9yIChjb25zdCBoaXRib3ggb2YgaGl0Ym94ZXMpIHtcbiAgICAgICAgaWYgKGhpdGJveC5jb2wgIT09IGNvbCkge1xuICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgdG9wID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIHRoaXMuY29sdW1uU2l6ZXNbY29sXS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGhpdGJveC50b3AgPSB0b3A7XG4gICAgICAgIGhpdGJveC5sZWZ0ICs9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICB0b3AgKz0gaGl0Ym94LmhlaWdodCArIHBhZGRpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlzSG9yaXpvbnRhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBvc2l0aW9uID09PSAndG9wJyB8fCB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICdib3R0b20nO1xuICB9XG4gIGRyYXcoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGNsaXBBcmVhKGN0eCwgdGhpcyk7XG4gICAgICB0aGlzLl9kcmF3KCk7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIF9kcmF3KCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiBvcHRzLCBjb2x1bW5TaXplcywgbGluZVdpZHRocywgY3R4fSA9IHRoaXM7XG4gICAgY29uc3Qge2FsaWduLCBsYWJlbHM6IGxhYmVsT3B0c30gPSBvcHRzO1xuICAgIGNvbnN0IGRlZmF1bHRDb2xvciA9IGRlZmF1bHRzLmNvbG9yO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICBjb25zdCB7Y29sb3I6IGZvbnRDb2xvciwgcGFkZGluZ30gPSBsYWJlbE9wdHM7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgbGV0IGN1cnNvcjtcbiAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5saW5lV2lkdGggPSAwLjU7XG4gICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0LCBpdGVtSGVpZ2h0fSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgY29uc3QgZHJhd0xlZ2VuZEJveCA9IGZ1bmN0aW9uKHgsIHksIGxlZ2VuZEl0ZW0pIHtcbiAgICAgIGlmIChpc05hTihib3hXaWR0aCkgfHwgYm94V2lkdGggPD0gMCB8fCBpc05hTihib3hIZWlnaHQpIHx8IGJveEhlaWdodCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG4gICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICBwb2ludFN0eWxlOiBsZWdlbmRJdGVtLnBvaW50U3R5bGUsXG4gICAgICAgICAgcm90YXRpb246IGxlZ2VuZEl0ZW0ucm90YXRpb24sXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLnhQbHVzKHgsIGJveFdpZHRoIC8gMik7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBkcmF3T3B0aW9ucywgY2VudGVyWCwgY2VudGVyWSwgbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCAmJiBib3hXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB5Qm94VG9wID0geSArIE1hdGgubWF4KChmb250U2l6ZSAtIGJveEhlaWdodCkgLyAyLCAwKTtcbiAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMobGVnZW5kSXRlbS5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSh2ID0+IHYgIT09IDApKSB7XG4gICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgeDogeEJveExlZnQsXG4gICAgICAgICAgICB5OiB5Qm94VG9wLFxuICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICBoOiBib3hIZWlnaHQsXG4gICAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgucmVjdCh4Qm94TGVmdCwgeUJveFRvcCwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgaWYgKGxpbmVXaWR0aCAhPT0gMCkge1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9O1xuICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIChpdGVtSGVpZ2h0IC8gMiksIGxhYmVsRm9udCwge1xuICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgdGV4dEFsaWduOiBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduKVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIGxpbmVXaWR0aHNbMF0pLFxuICAgICAgICB5OiB0aGlzLnRvcCArIHBhZGRpbmcgKyB0aXRsZUhlaWdodCxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3Vyc29yID0ge1xuICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICB5OiBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gY29sdW1uU2l6ZXNbMF0uaGVpZ2h0KSxcbiAgICAgICAgbGluZTogMFxuICAgICAgfTtcbiAgICB9XG4gICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpID0+IHtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBsZWdlbmRJdGVtLmZvbnRDb2xvciB8fCBmb250Q29sb3I7XG4gICAgICBjb25zdCB0ZXh0V2lkdGggPSBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbS50ZXh0KS53aWR0aDtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24gfHwgKGxlZ2VuZEl0ZW0udGV4dEFsaWduID0gbGFiZWxPcHRzLnRleHRBbGlnbikpO1xuICAgICAgY29uc3Qgd2lkdGggPSBib3hXaWR0aCArIGhhbGZGb250U2l6ZSArIHRleHRXaWR0aDtcbiAgICAgIGxldCB4ID0gY3Vyc29yLng7XG4gICAgICBsZXQgeSA9IGN1cnNvci55O1xuICAgICAgcnRsSGVscGVyLnNldFdpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICB5ID0gY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICBjdXJzb3IubGluZSsrO1xuICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGkgPiAwICYmIHkgKyBsaW5lSGVpZ2h0ID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgeCA9IGN1cnNvci54ID0geCArIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS53aWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgIHkgPSBjdXJzb3IueSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0uaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlYWxYID0gcnRsSGVscGVyLngoeCk7XG4gICAgICBkcmF3TGVnZW5kQm94KHJlYWxYLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIHggPSBfdGV4dFgodGV4dEFsaWduLCB4ICsgYm94V2lkdGggKyBoYWxmRm9udFNpemUsIGlzSG9yaXpvbnRhbCA/IHggKyB3aWR0aCA6IHRoaXMucmlnaHQsIG9wdHMucnRsKTtcbiAgICAgIGZpbGxUZXh0KHJ0bEhlbHBlci54KHgpLCB5LCBsZWdlbmRJdGVtKTtcbiAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgY3Vyc29yLnggKz0gd2lkdGggKyBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN0b3JlVGV4dERpcmVjdGlvbih0aGlzLmN0eCwgb3B0cy50ZXh0RGlyZWN0aW9uKTtcbiAgfVxuICBkcmF3VGl0bGUoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aXRsZU9wdHMgPSBvcHRzLnRpdGxlO1xuICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgY29uc3QgdGl0bGVQYWRkaW5nID0gdG9QYWRkaW5nKHRpdGxlT3B0cy5wYWRkaW5nKTtcbiAgICBpZiAoIXRpdGxlT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0cy5ydGwsIHRoaXMubGVmdCwgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgY29uc3QgaGFsZkZvbnRTaXplID0gdGl0bGVGb250LnNpemUgLyAyO1xuICAgIGNvbnN0IHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplID0gdGl0bGVQYWRkaW5nLnRvcCArIGhhbGZGb250U2l6ZTtcbiAgICBsZXQgeTtcbiAgICBsZXQgbGVmdCA9IHRoaXMubGVmdDtcbiAgICBsZXQgbWF4V2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLmNvbHVtblNpemVzLnJlZHVjZSgoYWNjLCBzaXplKSA9PiBNYXRoLm1heChhY2MsIHNpemUuaGVpZ2h0KSwgMCk7XG4gICAgICB5ID0gdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgKyBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCB0aGlzLnRvcCwgdGhpcy5ib3R0b20gLSBtYXhIZWlnaHQgLSBvcHRzLmxhYmVscy5wYWRkaW5nIC0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCkpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gX2FsaWduU3RhcnRFbmQocG9zaXRpb24sIGxlZnQsIGxlZnQgKyBtYXhXaWR0aCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oX3RvTGVmdFJpZ2h0Q2VudGVyKHBvc2l0aW9uKSk7XG4gICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IHRpdGxlT3B0cy5jb2xvcjtcbiAgICBjdHguZmlsbFN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICByZW5kZXJUZXh0KGN0eCwgdGl0bGVPcHRzLnRleHQsIHgsIHksIHRpdGxlRm9udCk7XG4gIH1cbiAgX2NvbXB1dGVUaXRsZUhlaWdodCgpIHtcbiAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gIH1cbiAgX2dldExlZ2VuZEl0ZW1BdCh4LCB5KSB7XG4gICAgbGV0IGksIGhpdEJveCwgbGg7XG4gICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KVxuICAgICAgJiYgX2lzQmV0d2Vlbih5LCB0aGlzLnRvcCwgdGhpcy5ib3R0b20pKSB7XG4gICAgICBsaCA9IHRoaXMubGVnZW5kSGl0Qm94ZXM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaGl0Qm94ID0gbGhbaV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHgsIGhpdEJveC5sZWZ0LCBoaXRCb3gubGVmdCArIGhpdEJveC53aWR0aClcbiAgICAgICAgICAmJiBfaXNCZXR3ZWVuKHksIGhpdEJveC50b3AsIGhpdEJveC50b3AgKyBoaXRCb3guaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhhbmRsZUV2ZW50KGUpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghaXNMaXN0ZW5lZChlLnR5cGUsIG9wdHMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2Vtb3ZlJyB8fCBlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5faG92ZXJlZEl0ZW07XG4gICAgICBjb25zdCBzYW1lSXRlbSA9IGl0ZW1zRXF1YWwocHJldmlvdXMsIGhvdmVyZWRJdGVtKTtcbiAgICAgIGlmIChwcmV2aW91cyAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbZSwgcHJldmlvdXMsIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hvdmVyZWRJdGVtID0gaG92ZXJlZEl0ZW07XG4gICAgICBpZiAoaG92ZXJlZEl0ZW0gJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW2UsIGhvdmVyZWRJdGVtLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChob3ZlcmVkSXRlbSkge1xuICAgICAgY2FsbGJhY2sob3B0cy5vbkNsaWNrLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTGlzdGVuZWQodHlwZSwgb3B0cykge1xuICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChvcHRzLm9uQ2xpY2sgJiYgKHR5cGUgPT09ICdjbGljaycgfHwgdHlwZSA9PT0gJ21vdXNldXAnKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBwbHVnaW5fbGVnZW5kID0ge1xuICBpZDogJ2xlZ2VuZCcsXG4gIF9lbGVtZW50OiBMZWdlbmQsXG4gIHN0YXJ0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe2N0eDogY2hhcnQuY3R4LCBvcHRpb25zLCBjaGFydH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCBsZWdlbmQpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIGNoYXJ0LmxlZ2VuZCk7XG4gICAgZGVsZXRlIGNoYXJ0LmxlZ2VuZDtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICBsZWdlbmQub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGFmdGVyVXBkYXRlKGNoYXJ0KSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxlZ2VuZC5idWlsZExhYmVscygpO1xuICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIHBvc2l0aW9uOiAndG9wJyxcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcmV2ZXJzZTogZmFsc2UsXG4gICAgd2VpZ2h0OiAxMDAwLFxuICAgIG9uQ2xpY2soZSwgbGVnZW5kSXRlbSwgbGVnZW5kKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4O1xuICAgICAgY29uc3QgY2kgPSBsZWdlbmQuY2hhcnQ7XG4gICAgICBpZiAoY2kuaXNEYXRhc2V0VmlzaWJsZShpbmRleCkpIHtcbiAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNpLnNob3coaW5kZXgpO1xuICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25Ib3ZlcjogbnVsbCxcbiAgICBvbkxlYXZlOiBudWxsLFxuICAgIGxhYmVsczoge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgYm94V2lkdGg6IDQwLFxuICAgICAgcGFkZGluZzogMTAsXG4gICAgICBnZW5lcmF0ZUxhYmVscyhjaGFydCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0cyA9IGNoYXJ0LmRhdGEuZGF0YXNldHM7XG4gICAgICAgIGNvbnN0IHtsYWJlbHM6IHt1c2VQb2ludFN0eWxlLCBwb2ludFN0eWxlLCB0ZXh0QWxpZ24sIGNvbG9yfX0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh1c2VQb2ludFN0eWxlID8gMCA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbCxcbiAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgIGhpZGRlbjogIW1ldGEudmlzaWJsZSxcbiAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLFxuICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsXG4gICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IChib3JkZXJXaWR0aC53aWR0aCArIGJvcmRlcldpZHRoLmhlaWdodCkgLyA0LFxuICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgcG9pbnRTdHlsZTogcG9pbnRTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLFxuICAgICAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24gfHwgc3R5bGUudGV4dEFsaWduLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0aXRsZToge1xuICAgICAgY29sb3I6IChjdHgpID0+IGN0eC5jaGFydC5vcHRpb25zLmNvbG9yLFxuICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICBwb3NpdGlvbjogJ2NlbnRlcicsXG4gICAgICB0ZXh0OiAnJyxcbiAgICB9XG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIGxhYmVsczoge1xuICAgICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhWydnZW5lcmF0ZUxhYmVscycsICdmaWx0ZXInLCAnc29ydCddLmluY2x1ZGVzKG5hbWUpLFxuICAgIH1cbiAgfSxcbn07XG5cbmNsYXNzIFRpdGxlIGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICB0aGlzLmN0eCA9IGNvbmZpZy5jdHg7XG4gICAgdGhpcy5fcGFkZGluZyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvdHRvbSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdGhpcy5sZWZ0ID0gMDtcbiAgICB0aGlzLnRvcCA9IDA7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IHRoaXMucmlnaHQgPSB0aGlzLmJvdHRvbSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IG1heEhlaWdodDtcbiAgICBjb25zdCBsaW5lQ291bnQgPSBpc0FycmF5KG9wdHMudGV4dCkgPyBvcHRzLnRleHQubGVuZ3RoIDogMTtcbiAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBsaW5lQ291bnQgKiB0b0ZvbnQob3B0cy5mb250KS5saW5lSGVpZ2h0ICsgdGhpcy5fcGFkZGluZy5oZWlnaHQ7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGV4dFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICByZXR1cm4gcG9zID09PSAndG9wJyB8fCBwb3MgPT09ICdib3R0b20nO1xuICB9XG4gIF9kcmF3QXJncyhvZmZzZXQpIHtcbiAgICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgYWxpZ24gPSBvcHRpb25zLmFsaWduO1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGl0bGVYID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGxlZnQsIHJpZ2h0KTtcbiAgICAgIHRpdGxlWSA9IHRvcCArIG9mZnNldDtcbiAgICAgIG1heFdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHRpdGxlWCA9IGxlZnQgKyBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGl0bGVYID0gcmlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0b3AsIGJvdHRvbSk7XG4gICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICB9XG4gICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZm9udE9wdHMgPSB0b0ZvbnQob3B0cy5mb250KTtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICBjb25zdCBvZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMiArIHRoaXMuX3BhZGRpbmcudG9wO1xuICAgIGNvbnN0IHt0aXRsZVgsIHRpdGxlWSwgbWF4V2lkdGgsIHJvdGF0aW9ufSA9IHRoaXMuX2RyYXdBcmdzKG9mZnNldCk7XG4gICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgbWF4V2lkdGgsXG4gICAgICByb3RhdGlvbixcbiAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgIHRyYW5zbGF0aW9uOiBbdGl0bGVYLCB0aXRsZVldLFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gIGNvbnN0IHRpdGxlID0gbmV3IFRpdGxlKHtcbiAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICBvcHRpb25zOiB0aXRsZU9wdHMsXG4gICAgY2hhcnRcbiAgfSk7XG4gIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgY2hhcnQudGl0bGVCbG9jayA9IHRpdGxlO1xufVxudmFyIHBsdWdpbl90aXRsZSA9IHtcbiAgaWQ6ICd0aXRsZScsXG4gIF9lbGVtZW50OiBUaXRsZSxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIHRpdGxlQmxvY2spO1xuICAgIGRlbGV0ZSBjaGFydC50aXRsZUJsb2NrO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBjaGFydC50aXRsZUJsb2NrO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH0sXG4gIGRlZmF1bHRzOiB7XG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMTAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMjAwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcGx1Z2luX3N1YnRpdGxlID0ge1xuICBpZDogJ3N1YnRpdGxlJyxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICBvcHRpb25zLFxuICAgICAgY2hhcnRcbiAgICB9KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgbWFwLnNldChjaGFydCwgdGl0bGUpO1xuICB9LFxuICBzdG9wKGNoYXJ0KSB7XG4gICAgbGF5b3V0cy5yZW1vdmVCb3goY2hhcnQsIG1hcC5nZXQoY2hhcnQpKTtcbiAgICBtYXAuZGVsZXRlKGNoYXJ0KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRpdGxlID0gbWFwLmdldChjaGFydCk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnbm9ybWFsJyxcbiAgICB9LFxuICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIHRleHQ6ICcnLFxuICAgIHdlaWdodDogMTUwMFxuICB9LFxuICBkZWZhdWx0Um91dGVzOiB7XG4gICAgY29sb3I6ICdjb2xvcidcbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgfSxcbn07XG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuICBhdmVyYWdlKGl0ZW1zKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IGksIGxlbjtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IGVsID0gaXRlbXNbaV0uZWxlbWVudDtcbiAgICAgIGlmIChlbCAmJiBlbC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICB4ICs9IHBvcy54O1xuICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeDogeCAvIGNvdW50LFxuICAgICAgeTogeSAvIGNvdW50XG4gICAgfTtcbiAgfSxcbiAgbmVhcmVzdChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgIGxldCB5ID0gZXZlbnRQb3NpdGlvbi55O1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gZWwuZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuICAgICAgICBpZiAoZCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgIG5lYXJlc3RFbGVtZW50ID0gZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lYXJlc3RFbGVtZW50KSB7XG4gICAgICBjb25zdCB0cCA9IG5lYXJlc3RFbGVtZW50LnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgeCA9IHRwLng7XG4gICAgICB5ID0gdHAueTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHB1c2hPckNvbmNhdChiYXNlLCB0b1B1c2gpIHtcbiAgaWYgKHRvUHVzaCkge1xuICAgIGlmIChpc0FycmF5KHRvUHVzaCkpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGJhc2UsIHRvUHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2UucHVzaCh0b1B1c2gpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmFzZTtcbn1cbmZ1bmN0aW9uIHNwbGl0TmV3bGluZXMoc3RyKSB7XG4gIGlmICgodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKSAmJiBzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgIHJldHVybiBzdHIuc3BsaXQoJ1xcbicpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwSXRlbShjaGFydCwgaXRlbSkge1xuICBjb25zdCB7ZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleH0gPSBpdGVtO1xuICBjb25zdCBjb250cm9sbGVyID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyO1xuICBjb25zdCB7bGFiZWwsIHZhbHVlfSA9IGNvbnRyb2xsZXIuZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCk7XG4gIHJldHVybiB7XG4gICAgY2hhcnQsXG4gICAgbGFiZWwsXG4gICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgcmF3OiBjaGFydC5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF0uZGF0YVtpbmRleF0sXG4gICAgZm9ybWF0dGVkVmFsdWU6IHZhbHVlLFxuICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgZGF0YXNldEluZGV4LFxuICAgIGVsZW1lbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgY29uc3QgY3R4ID0gdG9vbHRpcC5jaGFydC5jdHg7XG4gIGNvbnN0IHtib2R5LCBmb290ZXIsIHRpdGxlfSA9IHRvb2x0aXA7XG4gIGNvbnN0IHtib3hXaWR0aCwgYm94SGVpZ2h0fSA9IG9wdGlvbnM7XG4gIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQob3B0aW9ucy50aXRsZUZvbnQpO1xuICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gIGNvbnN0IHRpdGxlTGluZUNvdW50ID0gdGl0bGUubGVuZ3RoO1xuICBjb25zdCBmb290ZXJMaW5lQ291bnQgPSBmb290ZXIubGVuZ3RoO1xuICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGxldCBoZWlnaHQgPSBwYWRkaW5nLmhlaWdodDtcbiAgbGV0IHdpZHRoID0gMDtcbiAgbGV0IGNvbWJpbmVkQm9keUxlbmd0aCA9IGJvZHkucmVkdWNlKChjb3VudCwgYm9keUl0ZW0pID0+IGNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gIGNvbWJpbmVkQm9keUxlbmd0aCArPSB0b29sdGlwLmJlZm9yZUJvZHkubGVuZ3RoICsgdG9vbHRpcC5hZnRlckJvZHkubGVuZ3RoO1xuICBpZiAodGl0bGVMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gdGl0bGVMaW5lQ291bnQgKiB0aXRsZUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAodGl0bGVMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMudGl0bGVTcGFjaW5nXG5cdFx0XHQrIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gIH1cbiAgaWYgKGNvbWJpbmVkQm9keUxlbmd0aCkge1xuICAgIGNvbnN0IGJvZHlMaW5lSGVpZ2h0ID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gTWF0aC5tYXgoYm94SGVpZ2h0LCBib2R5Rm9udC5saW5lSGVpZ2h0KSA6IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIGJvZHlMaW5lSXRlbUNvdW50KSAqIGJvZHlGb250LmxpbmVIZWlnaHRcblx0XHRcdCsgKGNvbWJpbmVkQm9keUxlbmd0aCAtIDEpICogb3B0aW9ucy5ib2R5U3BhY2luZztcbiAgfVxuICBpZiAoZm9vdGVyTGluZUNvdW50KSB7XG4gICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wXG5cdFx0XHQrIGZvb3RlckxpbmVDb3VudCAqIGZvb3RlckZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoZm9vdGVyTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gIH1cbiAgbGV0IHdpZHRoUGFkZGluZyA9IDA7XG4gIGNvbnN0IG1heExpbmVXaWR0aCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjdHgubWVhc3VyZVRleHQobGluZSkud2lkdGggKyB3aWR0aFBhZGRpbmcpO1xuICB9O1xuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC50aXRsZSwgbWF4TGluZVdpZHRoKTtcbiAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5iZWZvcmVCb2R5LmNvbmNhdCh0b29sdGlwLmFmdGVyQm9keSksIG1heExpbmVXaWR0aCk7XG4gIHdpZHRoUGFkZGluZyA9IG9wdGlvbnMuZGlzcGxheUNvbG9ycyA/IChib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcpIDogMDtcbiAgZWFjaChib2R5LCAoYm9keUl0ZW0pID0+IHtcbiAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICBlYWNoKGJvZHlJdGVtLmxpbmVzLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIG1heExpbmVXaWR0aCk7XG4gIH0pO1xuICB3aWR0aFBhZGRpbmcgPSAwO1xuICBjdHguZm9udCA9IGZvb3RlckZvbnQuc3RyaW5nO1xuICBlYWNoKHRvb2x0aXAuZm9vdGVyLCBtYXhMaW5lV2lkdGgpO1xuICBjdHgucmVzdG9yZSgpO1xuICB3aWR0aCArPSBwYWRkaW5nLndpZHRoO1xuICByZXR1cm4ge3dpZHRoLCBoZWlnaHR9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKSB7XG4gIGNvbnN0IHt5LCBoZWlnaHR9ID0gc2l6ZTtcbiAgaWYgKHkgPCBoZWlnaHQgLyAyKSB7XG4gICAgcmV0dXJuICd0b3AnO1xuICB9IGVsc2UgaWYgKHkgPiAoY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikpIHtcbiAgICByZXR1cm4gJ2JvdHRvbSc7XG4gIH1cbiAgcmV0dXJuICdjZW50ZXInO1xufVxuZnVuY3Rpb24gZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gIGlmICh4QWxpZ24gPT09ICdsZWZ0JyAmJiB4ICsgd2lkdGggKyBjYXJldCA+IGNoYXJ0LndpZHRoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0JyAmJiB4IC0gd2lkdGggLSBjYXJldCA8IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IHt3aWR0aDogY2hhcnRXaWR0aCwgY2hhcnRBcmVhOiB7bGVmdCwgcmlnaHR9fSA9IGNoYXJ0O1xuICBsZXQgeEFsaWduID0gJ2NlbnRlcic7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeEFsaWduID0geCA8PSAobGVmdCArIHJpZ2h0KSAvIDIgPyAnbGVmdCcgOiAncmlnaHQnO1xuICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ2xlZnQnO1xuICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgIHhBbGlnbiA9ICdyaWdodCc7XG4gIH1cbiAgaWYgKGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkpIHtcbiAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgfVxuICByZXR1cm4geEFsaWduO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBzaXplKSB7XG4gIGNvbnN0IHlBbGlnbiA9IHNpemUueUFsaWduIHx8IG9wdGlvbnMueUFsaWduIHx8IGRldGVybWluZVlBbGlnbihjaGFydCwgc2l6ZSk7XG4gIHJldHVybiB7XG4gICAgeEFsaWduOiBzaXplLnhBbGlnbiB8fCBvcHRpb25zLnhBbGlnbiB8fCBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbiksXG4gICAgeUFsaWduXG4gIH07XG59XG5mdW5jdGlvbiBhbGlnblgoc2l6ZSwgeEFsaWduKSB7XG4gIGxldCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggLT0gd2lkdGg7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHdpZHRoIC8gMik7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICBsZXQge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSBpZiAoeUFsaWduID09PSAnYm90dG9tJykge1xuICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gIH0gZWxzZSB7XG4gICAgeSAtPSAoaGVpZ2h0IC8gMik7XG4gIH1cbiAgcmV0dXJuIHk7XG59XG5mdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICBjb25zdCB7Y2FyZXRTaXplLCBjYXJldFBhZGRpbmcsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gYWxpZ25tZW50O1xuICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gIGxldCB4ID0gYWxpZ25YKHNpemUsIHhBbGlnbik7XG4gIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG4gIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB4IC09IHBhZGRpbmdBbmRTaXplO1xuICAgIH1cbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgIHggLT0gTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCArPSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpICsgY2FyZXRTaXplO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogX2xpbWl0VmFsdWUoeCwgMCwgY2hhcnQud2lkdGggLSBzaXplLndpZHRoKSxcbiAgICB5OiBfbGltaXRWYWx1ZSh5LCAwLCBjaGFydC5oZWlnaHQgLSBzaXplLmhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEFsaWduZWRYKHRvb2x0aXAsIGFsaWduLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJ1xuICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDJcbiAgICA6IGFsaWduID09PSAncmlnaHQnXG4gICAgICA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0XG4gICAgICA6IHRvb2x0aXAueCArIHBhZGRpbmcubGVmdDtcbn1cbmZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gIHJldHVybiBwdXNoT3JDb25jYXQoW10sIHNwbGl0TmV3bGluZXMoY2FsbGJhY2spKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBDb250ZXh0KHBhcmVudCwgdG9vbHRpcCwgdG9vbHRpcEl0ZW1zKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIHRvb2x0aXAsXG4gICAgdG9vbHRpcEl0ZW1zLFxuICAgIHR5cGU6ICd0b29sdGlwJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICBjb25zdCBvdmVycmlkZSA9IGNvbnRleHQgJiYgY29udGV4dC5kYXRhc2V0ICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwICYmIGNvbnRleHQuZGF0YXNldC50b29sdGlwLmNhbGxiYWNrcztcbiAgcmV0dXJuIG92ZXJyaWRlID8gY2FsbGJhY2tzLm92ZXJyaWRlKG92ZXJyaWRlKSA6IGNhbGxiYWNrcztcbn1cbmNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wYWNpdHkgPSAwO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IFtdO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0IHx8IGNvbmZpZy5fY2hhcnQ7XG4gICAgdGhpcy5fY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpdGxlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmVmb3JlQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hZnRlckJvZHkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb290ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy54ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2FyZXRZID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRpYWxpemUob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fY2FjaGVkQW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICBjb25zdCBjYWNoZWQgPSB0aGlzLl9jYWNoZWRBbmltYXRpb25zO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBuZXcgQW5pbWF0aW9ucyh0aGlzLmNoYXJ0LCBvcHRzKTtcbiAgICBpZiAob3B0cy5fY2FjaGVhYmxlKSB7XG4gICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fFxuXHRcdFx0KHRoaXMuJGNvbnRleHQgPSBjcmVhdGVUb29sdGlwQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcywgdGhpcy5fdG9vbHRpcEl0ZW1zKSk7XG4gIH1cbiAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVUaXRsZSA9IGNhbGxiYWNrcy5iZWZvcmVUaXRsZS5hcHBseSh0aGlzLCBbY29udGV4dF0pO1xuICAgIGNvbnN0IHRpdGxlID0gY2FsbGJhY2tzLnRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgYWZ0ZXJUaXRsZSA9IGNhbGxiYWNrcy5hZnRlclRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyh0aXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGFmdGVyVGl0bGUpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYmVmb3JlQm9keS5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSkpO1xuICB9XG4gIGdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlJdGVtcyA9IFtdO1xuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgIGJlZm9yZTogW10sXG4gICAgICAgIGxpbmVzOiBbXSxcbiAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICB9O1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmJlZm9yZUxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5saW5lcywgc2NvcGVkLmxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmFmdGVyLCBzcGxpdE5ld2xpbmVzKHNjb3BlZC5hZnRlckxhYmVsLmNhbGwodGhpcywgY29udGV4dCkpKTtcbiAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm9keUl0ZW1zO1xuICB9XG4gIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMob3B0aW9ucy5jYWxsYmFja3MuYWZ0ZXJCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIGNvbnN0IHtjYWxsYmFja3N9ID0gb3B0aW9ucztcbiAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBjYWxsYmFja3MuYmVmb3JlRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBmb290ZXIgPSBjYWxsYmFja3MuZm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBjb25zdCBhZnRlckZvb3RlciA9IGNhbGxiYWNrcy5hZnRlckZvb3Rlci5hcHBseSh0aGlzLCBbdG9vbHRpcEl0ZW1zXSk7XG4gICAgbGV0IGxpbmVzID0gW107XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlRm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoZm9vdGVyKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpIHtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY2hhcnQuZGF0YTtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICBjb25zdCBsYWJlbFRleHRDb2xvcnMgPSBbXTtcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgbGV0IGksIGxlbjtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRvb2x0aXBJdGVtcy5wdXNoKGNyZWF0ZVRvb2x0aXBJdGVtKHRoaXMuY2hhcnQsIGFjdGl2ZVtpXSkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5maWx0ZXIpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5maWx0ZXIoKGVsZW1lbnQsIGluZGV4LCBhcnJheSkgPT4gb3B0aW9ucy5maWx0ZXIoZWxlbWVudCwgaW5kZXgsIGFycmF5LCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLml0ZW1Tb3J0KSB7XG4gICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuc29ydCgoYSwgYikgPT4gb3B0aW9ucy5pdGVtU29ydChhLCBiLCBkYXRhKSk7XG4gICAgfVxuICAgIGVhY2godG9vbHRpcEl0ZW1zLCAoY29udGV4dCkgPT4ge1xuICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3Mob3B0aW9ucy5jYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgbGFiZWxDb2xvcnMucHVzaChzY29wZWQubGFiZWxDb2xvci5jYWxsKHRoaXMsIGNvbnRleHQpKTtcbiAgICAgIGxhYmVsUG9pbnRTdHlsZXMucHVzaChzY29wZWQubGFiZWxQb2ludFN0eWxlLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goc2NvcGVkLmxhYmVsVGV4dENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgIH0pO1xuICAgIHRoaXMubGFiZWxDb2xvcnMgPSBsYWJlbENvbG9ycztcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSBsYWJlbFBvaW50U3R5bGVzO1xuICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgIHRoaXMuZGF0YVBvaW50cyA9IHRvb2x0aXBJdGVtcztcbiAgICByZXR1cm4gdG9vbHRpcEl0ZW1zO1xuICB9XG4gIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBsZXQgcHJvcGVydGllcztcbiAgICBsZXQgdG9vbHRpcEl0ZW1zID0gW107XG4gICAgaWYgKCFhY3RpdmUubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5vcGFjaXR5ICE9PSAwKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgb3BhY2l0eTogMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCB0aGlzLl9ldmVudFBvc2l0aW9uKTtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRoaXMuX2NyZWF0ZUl0ZW1zKG9wdGlvbnMpO1xuICAgICAgdGhpcy50aXRsZSA9IHRoaXMuZ2V0VGl0bGUodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYmVmb3JlQm9keSA9IHRoaXMuZ2V0QmVmb3JlQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5ib2R5ID0gdGhpcy5nZXRCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmFmdGVyQm9keSA9IHRoaXMuZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmZvb3RlciA9IHRoaXMuZ2V0Rm9vdGVyKHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHNpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KHRoaXMuY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBiYWNrZ3JvdW5kUG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIHRoaXMuY2hhcnQpO1xuICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgIHk6IGJhY2tncm91bmRQb2ludC55LFxuICAgICAgICB3aWR0aDogc2l6ZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgY2FyZXRYOiBwb3NpdGlvbi54LFxuICAgICAgICBjYXJldFk6IHBvc2l0aW9uLnlcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlQW5pbWF0aW9ucygpLnVwZGF0ZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGNoYW5nZWQgJiYgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgb3B0aW9ucy5leHRlcm5hbC5jYWxsKHRoaXMsIHtjaGFydDogdGhpcy5jaGFydCwgdG9vbHRpcDogdGhpcywgcmVwbGF5fSk7XG4gICAgfVxuICB9XG4gIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhcmV0UG9zaXRpb24gPSB0aGlzLmdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDEsIGNhcmV0UG9zaXRpb24ueTEpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngzLCBjYXJldFBvc2l0aW9uLnkzKTtcbiAgfVxuICBnZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSB0aGlzO1xuICAgIGNvbnN0IHtjYXJldFNpemUsIGNvcm5lclJhZGl1c30gPSBvcHRpb25zO1xuICAgIGNvbnN0IHt0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHR9ID0gdG9UUkJMQ29ybmVycyhjb3JuZXJSYWRpdXMpO1xuICAgIGNvbnN0IHt4OiBwdFgsIHk6IHB0WX0gPSB0b29sdGlwUG9pbnQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gc2l6ZTtcbiAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgeTIgPSBwdFkgKyAoaGVpZ2h0IC8gMik7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDEgPSBwdFg7XG4gICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgKyBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICB4MiA9IHgxICsgY2FyZXRTaXplO1xuICAgICAgICB5MSA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgfVxuICAgICAgeDMgPSB4MTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyAoY2FyZXRTaXplKTtcbiAgICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSB0aGlzLmNhcmV0WDtcbiAgICAgIH1cbiAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkxID0gcHRZO1xuICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICB4MSA9IHgyIC0gY2FyZXRTaXplO1xuICAgICAgICB4MyA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgIHkyID0geTEgKyBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgKyBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB5MyA9IHkxO1xuICAgIH1cbiAgICByZXR1cm4ge3gxLCB4MiwgeDMsIHkxLCB5MiwgeTN9O1xuICB9XG4gIGRyYXdUaXRsZShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRpdGxlLmxlbmd0aDtcbiAgICBsZXQgdGl0bGVGb250LCB0aXRsZVNwYWNpbmcsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgIHB0LnkgKz0gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVNwYWNpbmc7XG4gICAgICAgIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgcHQueSArPSBvcHRpb25zLnRpdGxlTWFyZ2luQm90dG9tIC0gdGl0bGVTcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGFiZWxDb2xvcnMgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZSA9IHRoaXMubGFiZWxQb2ludFN0eWxlc1tpXTtcbiAgICBjb25zdCB7Ym94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGNvbnN0IGNvbG9yWCA9IGdldEFsaWduZWRYKHRoaXMsICdsZWZ0Jywgb3B0aW9ucyk7XG4gICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICBjb25zdCB5T2ZmU2V0ID0gYm94SGVpZ2h0IDwgYm9keUZvbnQubGluZUhlaWdodCA/IChib2R5Rm9udC5saW5lSGVpZ2h0IC0gYm94SGVpZ2h0KSAvIDIgOiAwO1xuICAgIGNvbnN0IGNvbG9yWSA9IHB0LnkgKyB5T2ZmU2V0O1xuICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICByYWRpdXM6IE1hdGgubWluKGJveFdpZHRoLCBib3hIZWlnaHQpIC8gMixcbiAgICAgICAgcG9pbnRTdHlsZTogbGFiZWxQb2ludFN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgIGJvcmRlcldpZHRoOiAxXG4gICAgICB9O1xuICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bENvbG9yWCwgYm94V2lkdGgpICsgYm94V2lkdGggLyAyO1xuICAgICAgY29uc3QgY2VudGVyWSA9IGNvbG9yWSArIGJveEhlaWdodCAvIDI7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGlzT2JqZWN0KGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpKSA6IChsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxhYmVsQ29sb3JzLmJvcmRlckNvbG9yO1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxhYmVsQ29sb3JzLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvcnMuYm9yZGVyRGFzaE9mZnNldCB8fCAwO1xuICAgICAgY29uc3Qgb3V0ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCAtIGJveFBhZGRpbmcpO1xuICAgICAgY29uc3QgaW5uZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLnhQbHVzKHJ0bENvbG9yWCwgMSksIGJveFdpZHRoIC0gYm94UGFkZGluZyAtIDIpO1xuICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9ycy5ib3JkZXJSYWRpdXMpO1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgeTogY29sb3JZLFxuICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgIHk6IGNvbG9yWSArIDEsXG4gICAgICAgICAgdzogYm94V2lkdGggLSAyLFxuICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICBjdHguZmlsbFJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICBjdHguc3Ryb2tlUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9ycy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIGN0eC5maWxsUmVjdChpbm5lclgsIGNvbG9yWSArIDEsIGJveFdpZHRoIC0gMiwgYm94SGVpZ2h0IC0gMik7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgfVxuICBkcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2JvZHl9ID0gdGhpcztcbiAgICBjb25zdCB7Ym9keVNwYWNpbmcsIGJvZHlBbGlnbiwgZGlzcGxheUNvbG9ycywgYm94SGVpZ2h0LCBib3hXaWR0aCwgYm94UGFkZGluZ30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgIGxldCBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgbGV0IHhMaW5lUGFkZGluZyA9IDA7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBmaWxsTGluZU9mVGV4dCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGN0eC5maWxsVGV4dChsaW5lLCBydGxIZWxwZXIueChwdC54ICsgeExpbmVQYWRkaW5nKSwgcHQueSArIGJvZHlMaW5lSGVpZ2h0IC8gMik7XG4gICAgICBwdC55ICs9IGJvZHlMaW5lSGVpZ2h0ICsgYm9keVNwYWNpbmc7XG4gICAgfTtcbiAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICBsZXQgYm9keUl0ZW0sIHRleHRDb2xvciwgbGluZXMsIGksIGosIGlsZW4sIGpsZW47XG4gICAgY3R4LnRleHRBbGlnbiA9IGJvZHlBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uLCBvcHRpb25zKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgZWFjaCh0aGlzLmJlZm9yZUJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICB4TGluZVBhZGRpbmcgPSBkaXNwbGF5Q29sb3JzICYmIGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uICE9PSAncmlnaHQnXG4gICAgICA/IGJvZHlBbGlnbiA9PT0gJ2NlbnRlcicgPyAoYm94V2lkdGggLyAyICsgYm94UGFkZGluZykgOiAoYm94V2lkdGggKyAyICsgYm94UGFkZGluZylcbiAgICAgIDogMDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYm9keS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGJvZHlJdGVtID0gYm9keVtpXTtcbiAgICAgIHRleHRDb2xvciA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHRDb2xvcjtcbiAgICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICBsaW5lcyA9IGJvZHlJdGVtLmxpbmVzO1xuICAgICAgaWYgKGRpc3BsYXlDb2xvcnMgJiYgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IE1hdGgubWF4KGJvZHlGb250LmxpbmVIZWlnaHQsIGJveEhlaWdodCk7XG4gICAgICB9XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gbGluZXMubGVuZ3RoOyBqIDwgamxlbjsgKytqKSB7XG4gICAgICAgIGZpbGxMaW5lT2ZUZXh0KGxpbmVzW2pdKTtcbiAgICAgICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgfVxuICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgZmlsbExpbmVPZlRleHQpO1xuICAgIH1cbiAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBlYWNoKHRoaXMuYWZ0ZXJCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgcHQueSAtPSBib2R5U3BhY2luZztcbiAgfVxuICBkcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmb290ZXIgPSB0aGlzLmZvb3RlcjtcbiAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgIGxldCBmb290ZXJGb250LCBpO1xuICAgIGlmIChsZW5ndGgpIHtcbiAgICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIob3B0aW9ucy5ydGwsIHRoaXMueCwgdGhpcy53aWR0aCk7XG4gICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgb3B0aW9ucy5mb290ZXJBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBwdC55ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wO1xuICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy5mb290ZXJBbGlnbik7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5mb290ZXJDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGZvb3RlcltpXSwgcnRsSGVscGVyLngocHQueCksIHB0LnkgKyBmb290ZXJGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSBmb290ZXJGb250LmxpbmVIZWlnaHQgKyBvcHRpb25zLmZvb3RlclNwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge3gsIHl9ID0gcHQ7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gdG9vbHRpcFNpemU7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKG9wdGlvbnMuY29ybmVyUmFkaXVzKTtcbiAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gb3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyB0b3BSaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYm90dG9tUmlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYm90dG9tUmlnaHQsIHkgKyBoZWlnaHQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCArIGJvdHRvbUxlZnQsIHkgKyBoZWlnaHQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgdG9wTGVmdCwgeSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgaWYgKG9wdGlvbnMuYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgIGNvbnN0IGFuaW1ZID0gYW5pbXMgJiYgYW5pbXMueTtcbiAgICBpZiAoYW5pbVggfHwgYW5pbVkpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCB0aGlzLl9hY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5fc2l6ZSA9IGdldFRvb2x0aXBTaXplKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgY29uc3QgcG9zaXRpb25BbmRTaXplID0gT2JqZWN0LmFzc2lnbih7fSwgcG9zaXRpb24sIHRoaXMuX3NpemUpO1xuICAgICAgY29uc3QgYWxpZ25tZW50ID0gZGV0ZXJtaW5lQWxpZ25tZW50KGNoYXJ0LCBvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUpO1xuICAgICAgY29uc3QgcG9pbnQgPSBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgcG9zaXRpb25BbmRTaXplLCBhbGlnbm1lbnQsIGNoYXJ0KTtcbiAgICAgIGlmIChhbmltWC5fdG8gIT09IHBvaW50LnggfHwgYW5pbVkuX3RvICE9PSBwb2ludC55KSB7XG4gICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgdGhpcy55QWxpZ24gPSBhbGlnbm1lbnQueUFsaWduO1xuICAgICAgICB0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgdGhpcy5jYXJldFggPSBwb3NpdGlvbi54O1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3dpbGxSZW5kZXIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICB9XG4gIGRyYXcoY3R4KSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICBpZiAoIW9wYWNpdHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuICAgIGNvbnN0IHRvb2x0aXBTaXplID0ge1xuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCBwdCA9IHtcbiAgICAgIHg6IHRoaXMueCxcbiAgICAgIHk6IHRoaXMueVxuICAgIH07XG4gICAgb3BhY2l0eSA9IE1hdGguYWJzKG9wYWNpdHkpIDwgMWUtMyA/IDAgOiBvcGFjaXR5O1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBjb25zdCBoYXNUb29sdGlwQ29udGVudCA9IHRoaXMudGl0bGUubGVuZ3RoIHx8IHRoaXMuYmVmb3JlQm9keS5sZW5ndGggfHwgdGhpcy5ib2R5Lmxlbmd0aCB8fCB0aGlzLmFmdGVyQm9keS5sZW5ndGggfHwgdGhpcy5mb290ZXIubGVuZ3RoO1xuICAgIGlmIChvcHRpb25zLmVuYWJsZWQgJiYgaGFzVG9vbHRpcENvbnRlbnQpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgcHQueSArPSBwYWRkaW5nLnRvcDtcbiAgICAgIHRoaXMuZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Qm9keShwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKTtcbiAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3B0aW9ucy50ZXh0RGlyZWN0aW9uKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmUgfHwgW107XG4gIH1cbiAgc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnRzLm1hcCgoe2RhdGFzZXRJbmRleCwgaW5kZXh9KSA9PiB7XG4gICAgICBjb25zdCBtZXRhID0gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGV2ZW50UG9zaXRpb24pO1xuICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEgPSB0cnVlKSB7XG4gICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5faWdub3JlUmVwbGF5RXZlbnRzID0gZmFsc2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuICAgIGNvbnN0IGNoYW5nZWQgPSByZXBsYXkgfHwgIV9lbGVtZW50c0VxdWFsKGFjdGl2ZSwgbGFzdEFjdGl2ZSkgfHwgcG9zaXRpb25DaGFuZ2VkO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICBpZiAob3B0aW9ucy5lbmFibGVkIHx8IG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICB4OiBlLngsXG4gICAgICAgICAgeTogZS55XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKHRydWUsIHJlcGxheSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCByZXBsYXksIGluQ2hhcnRBcmVhKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgIH1cbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGFjdGl2ZS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmU7XG4gIH1cbiAgX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpIHtcbiAgICBjb25zdCB7Y2FyZXRYLCBjYXJldFksIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uZXJzW29wdGlvbnMucG9zaXRpb25dLmNhbGwodGhpcywgYWN0aXZlLCBlKTtcbiAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgfVxufVxuVG9vbHRpcC5wb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xudmFyIHBsdWdpbl90b29sdGlwID0ge1xuICBpZDogJ3Rvb2x0aXAnLFxuICBfZWxlbWVudDogVG9vbHRpcCxcbiAgcG9zaXRpb25lcnMsXG4gIGFmdGVySW5pdChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtjaGFydCwgb3B0aW9uc30pO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlVXBkYXRlKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICByZXNldChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJEcmF3KGNoYXJ0KSB7XG4gICAgY29uc3QgdG9vbHRpcCA9IGNoYXJ0LnRvb2x0aXA7XG4gICAgaWYgKHRvb2x0aXAgJiYgdG9vbHRpcC5fd2lsbFJlbmRlcigpKSB7XG4gICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICB0b29sdGlwXG4gICAgICB9O1xuICAgICAgaWYgKGNoYXJ0Lm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVRvb2x0aXBEcmF3JywgYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgIH1cbiAgfSxcbiAgYWZ0ZXJFdmVudChjaGFydCwgYXJncykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gYXJncy5yZXBsYXk7XG4gICAgICBpZiAoY2hhcnQudG9vbHRpcC5oYW5kbGVFdmVudChhcmdzLmV2ZW50LCB1c2VGaW5hbFBvc2l0aW9uLCBhcmdzLmluQ2hhcnRBcmVhKSkge1xuICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGV4dGVybmFsOiBudWxsLFxuICAgIHBvc2l0aW9uOiAnYXZlcmFnZScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICB0aXRsZUNvbG9yOiAnI2ZmZicsXG4gICAgdGl0bGVGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIHRpdGxlU3BhY2luZzogMixcbiAgICB0aXRsZU1hcmdpbkJvdHRvbTogNixcbiAgICB0aXRsZUFsaWduOiAnbGVmdCcsXG4gICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgYm9keVNwYWNpbmc6IDIsXG4gICAgYm9keUZvbnQ6IHtcbiAgICB9LFxuICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgIGZvb3RlckNvbG9yOiAnI2ZmZicsXG4gICAgZm9vdGVyU3BhY2luZzogMixcbiAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgZm9vdGVyRm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmb290ZXJBbGlnbjogJ2xlZnQnLFxuICAgIHBhZGRpbmc6IDYsXG4gICAgY2FyZXRQYWRkaW5nOiAyLFxuICAgIGNhcmV0U2l6ZTogNSxcbiAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgYm94SGVpZ2h0OiAoY3R4LCBvcHRzKSA9PiBvcHRzLmJvZHlGb250LnNpemUsXG4gICAgYm94V2lkdGg6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBtdWx0aUtleUJhY2tncm91bmQ6ICcjZmZmJyxcbiAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgIGJveFBhZGRpbmc6IDAsXG4gICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiA0MDAsXG4gICAgICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgbnVtYmVyczoge1xuICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2NhcmV0WCcsICdjYXJldFknXSxcbiAgICAgIH0sXG4gICAgICBvcGFjaXR5OiB7XG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlVGl0bGU6IG5vb3AsXG4gICAgICB0aXRsZSh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IHRvb2x0aXBJdGVtc1swXTtcbiAgICAgICAgICBjb25zdCBsYWJlbHMgPSBpdGVtLmNoYXJ0LmRhdGEubGFiZWxzO1xuICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ubGFiZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGFiZWxDb3VudCA+IDAgJiYgaXRlbS5kYXRhSW5kZXggPCBsYWJlbENvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSxcbiAgICAgIGFmdGVyVGl0bGU6IG5vb3AsXG4gICAgICBiZWZvcmVCb2R5OiBub29wLFxuICAgICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLm1vZGUgPT09ICdkYXRhc2V0Jykge1xuICAgICAgICAgIHJldHVybiB0b29sdGlwSXRlbS5sYWJlbCArICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZSB8fCB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFiZWwgPSB0b29sdGlwSXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICBsYWJlbCArPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgICB9LFxuICAgICAgbGFiZWxDb2xvcih0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGJvcmRlckNvbG9yOiBvcHRpb25zLmJvcmRlckNvbG9yLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgbGFiZWxUZXh0Q29sb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuYm9keUNvbG9yO1xuICAgICAgfSxcbiAgICAgIGxhYmVsUG9pbnRTdHlsZSh0b29sdGlwSXRlbSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdG9vbHRpcEl0ZW0uY2hhcnQuZ2V0RGF0YXNldE1ldGEodG9vbHRpcEl0ZW0uZGF0YXNldEluZGV4KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZSh0b29sdGlwSXRlbS5kYXRhSW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogb3B0aW9ucy5yb3RhdGlvbixcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBhZnRlckxhYmVsOiBub29wLFxuICAgICAgYWZ0ZXJCb2R5OiBub29wLFxuICAgICAgYmVmb3JlRm9vdGVyOiBub29wLFxuICAgICAgZm9vdGVyOiBub29wLFxuICAgICAgYWZ0ZXJGb290ZXI6IG5vb3BcbiAgICB9XG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgIGZvb3RlckZvbnQ6ICdmb250JyxcbiAgICB0aXRsZUZvbnQ6ICdmb250J1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2ZpbHRlcicgJiYgbmFtZSAhPT0gJ2l0ZW1Tb3J0JyAmJiBuYW1lICE9PSAnZXh0ZXJuYWwnLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgfSxcbiAgICBhbmltYXRpb246IHtcbiAgICAgIF9mYWxsYmFjazogZmFsc2VcbiAgICB9LFxuICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgIF9mYWxsYmFjazogJ2FuaW1hdGlvbidcbiAgICB9XG4gIH0sXG4gIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFsnaW50ZXJhY3Rpb24nXVxufTtcblxudmFyIHBsdWdpbnMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5EZWNpbWF0aW9uOiBwbHVnaW5fZGVjaW1hdGlvbixcbkZpbGxlcjogaW5kZXgsXG5MZWdlbmQ6IHBsdWdpbl9sZWdlbmQsXG5TdWJUaXRsZTogcGx1Z2luX3N1YnRpdGxlLFxuVGl0bGU6IHBsdWdpbl90aXRsZSxcblRvb2x0aXA6IHBsdWdpbl90b29sdGlwXG59KTtcblxuY29uc3QgYWRkSWZTdHJpbmcgPSAobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykgPT4ge1xuICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICBpbmRleCA9IGxhYmVscy5wdXNoKHJhdykgLSAxO1xuICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe2luZGV4LCBsYWJlbDogcmF3fSk7XG4gIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgIGluZGV4ID0gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59O1xuZnVuY3Rpb24gZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscykge1xuICBjb25zdCBmaXJzdCA9IGxhYmVscy5pbmRleE9mKHJhdyk7XG4gIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICByZXR1cm4gYWRkSWZTdHJpbmcobGFiZWxzLCByYXcsIGluZGV4LCBhZGRlZExhYmVscyk7XG4gIH1cbiAgY29uc3QgbGFzdCA9IGxhYmVscy5sYXN0SW5kZXhPZihyYXcpO1xuICByZXR1cm4gZmlyc3QgIT09IGxhc3QgPyBpbmRleCA6IGZpcnN0O1xufVxuY29uc3QgdmFsaWRJbmRleCA9IChpbmRleCwgbWF4KSA9PiBpbmRleCA9PT0gbnVsbCA/IG51bGwgOiBfbGltaXRWYWx1ZShNYXRoLnJvdW5kKGluZGV4KSwgMCwgbWF4KTtcbmNsYXNzIENhdGVnb3J5U2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICB9XG4gIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgY29uc3QgYWRkZWQgPSB0aGlzLl9hZGRlZExhYmVscztcbiAgICBpZiAoYWRkZWQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgICAgZm9yIChjb25zdCB7aW5kZXgsIGxhYmVsfSBvZiBhZGRlZCkge1xuICAgICAgICBpZiAobGFiZWxzW2luZGV4XSA9PT0gbGFiZWwpIHtcbiAgICAgICAgICBsYWJlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fYWRkZWRMYWJlbHMgPSBbXTtcbiAgICB9XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBpbmRleCA9IGlzRmluaXRlKGluZGV4KSAmJiBsYWJlbHNbaW5kZXhdID09PSByYXcgPyBpbmRleFxuICAgICAgOiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgdmFsdWVPckRlZmF1bHQoaW5kZXgsIHJhdyksIHRoaXMuX2FkZGVkTGFiZWxzKTtcbiAgICByZXR1cm4gdmFsaWRJbmRleChpbmRleCwgbGFiZWxzLmxlbmd0aCAtIDEpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub3B0aW9ucy5vZmZzZXQ7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICBsYWJlbHMgPSAobWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEpID8gbGFiZWxzIDogbGFiZWxzLnNsaWNlKG1pbiwgbWF4ICsgMSk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdGhpcy5taW4gLSAob2Zmc2V0ID8gMC41IDogMCk7XG4gICAgZm9yIChsZXQgdmFsdWUgPSBtaW47IHZhbHVlIDw9IG1heDsgdmFsdWUrKykge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWV9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGxhYmVsc1t2YWx1ZV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKCF0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gIXRoaXMuX3JldmVyc2VQaXhlbHM7XG4gICAgfVxuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRQaXhlbEZvclRpY2soaW5kZXgpIHtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICB9XG59XG5DYXRlZ29yeVNjYWxlLmlkID0gJ2NhdGVnb3J5JztcbkNhdGVnb3J5U2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IENhdGVnb3J5U2NhbGUucHJvdG90eXBlLmdldExhYmVsRm9yVmFsdWVcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgTUlOX1NQQUNJTkcgPSAxZS0xNDtcbiAgY29uc3Qge2JvdW5kcywgc3RlcCwgbWluLCBtYXgsIHByZWNpc2lvbiwgY291bnQsIG1heFRpY2tzLCBtYXhEaWdpdHMsIGluY2x1ZGVCb3VuZHN9ID0gZ2VuZXJhdGlvbk9wdGlvbnM7XG4gIGNvbnN0IHVuaXQgPSBzdGVwIHx8IDE7XG4gIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgY29uc3Qge21pbjogcm1pbiwgbWF4OiBybWF4fSA9IGRhdGFSYW5nZTtcbiAgY29uc3QgbWluRGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1pbik7XG4gIGNvbnN0IG1heERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihtYXgpO1xuICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gIGNvbnN0IG1pblNwYWNpbmcgPSAocm1heCAtIHJtaW4pIC8gKG1heERpZ2l0cyArIDEpO1xuICBsZXQgc3BhY2luZyA9IG5pY2VOdW0oKHJtYXggLSBybWluKSAvIG1heFNwYWNlcyAvIHVuaXQpICogdW5pdDtcbiAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICBpZiAoc3BhY2luZyA8IE1JTl9TUEFDSU5HICYmICFtaW5EZWZpbmVkICYmICFtYXhEZWZpbmVkKSB7XG4gICAgcmV0dXJuIFt7dmFsdWU6IHJtaW59LCB7dmFsdWU6IHJtYXh9XTtcbiAgfVxuICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gIGlmIChudW1TcGFjZXMgPiBtYXhTcGFjZXMpIHtcbiAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICB9XG4gIGlmICghaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pKSB7XG4gICAgZmFjdG9yID0gTWF0aC5wb3coMTAsIHByZWNpc2lvbik7XG4gICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgfVxuICBpZiAoYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgbmljZU1pbiA9IE1hdGguZmxvb3Iocm1pbiAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gIH0gZWxzZSB7XG4gICAgbmljZU1pbiA9IHJtaW47XG4gICAgbmljZU1heCA9IHJtYXg7XG4gIH1cbiAgaWYgKG1pbkRlZmluZWQgJiYgbWF4RGVmaW5lZCAmJiBzdGVwICYmIGFsbW9zdFdob2xlKChtYXggLSBtaW4pIC8gc3RlcCwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgc3BhY2luZyA9IChtYXggLSBtaW4pIC8gbnVtU3BhY2VzO1xuICAgIG5pY2VNaW4gPSBtaW47XG4gICAgbmljZU1heCA9IG1heDtcbiAgfSBlbHNlIGlmIChjb3VudERlZmluZWQpIHtcbiAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgbmljZU1heCA9IG1heERlZmluZWQgPyBtYXggOiBuaWNlTWF4O1xuICAgIG51bVNwYWNlcyA9IGNvdW50IC0gMTtcbiAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgfSBlbHNlIHtcbiAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICBpZiAoYWxtb3N0RXF1YWxzKG51bVNwYWNlcywgTWF0aC5yb3VuZChudW1TcGFjZXMpLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgIG51bVNwYWNlcyA9IE1hdGgucm91bmQobnVtU3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5jZWlsKG51bVNwYWNlcyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGRlY2ltYWxQbGFjZXMgPSBNYXRoLm1heChcbiAgICBfZGVjaW1hbFBsYWNlcyhzcGFjaW5nKSxcbiAgICBfZGVjaW1hbFBsYWNlcyhuaWNlTWluKVxuICApO1xuICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gIG5pY2VNaW4gPSBNYXRoLnJvdW5kKG5pY2VNaW4gKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBuaWNlTWF4ID0gTWF0aC5yb3VuZChuaWNlTWF4ICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgbGV0IGogPSAwO1xuICBpZiAobWluRGVmaW5lZCkge1xuICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgdGlja3MucHVzaCh7dmFsdWU6IG1pbn0pO1xuICAgICAgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgICAgaWYgKGFsbW9zdEVxdWFscyhNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvciwgbWluLCByZWxhdGl2ZUxhYmVsU2l6ZShtaW4sIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgICAgaisrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgaisrO1xuICAgIH1cbiAgfVxuICBmb3IgKDsgaiA8IG51bVNwYWNlczsgKytqKSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yfSk7XG4gIH1cbiAgaWYgKG1heERlZmluZWQgJiYgaW5jbHVkZUJvdW5kcyAmJiBuaWNlTWF4ICE9PSBtYXgpIHtcbiAgICBpZiAodGlja3MubGVuZ3RoICYmIGFsbW9zdEVxdWFscyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSwgbWF4LCByZWxhdGl2ZUxhYmVsU2l6ZShtYXgsIG1pblNwYWNpbmcsIGdlbmVyYXRpb25PcHRpb25zKSkpIHtcbiAgICAgIHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlID0gbWF4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWF4fSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFtYXhEZWZpbmVkIHx8IG5pY2VNYXggPT09IG1heCkge1xuICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBuaWNlTWF4fSk7XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gcmVsYXRpdmVMYWJlbFNpemUodmFsdWUsIG1pblNwYWNpbmcsIHtob3Jpem9udGFsLCBtaW5Sb3RhdGlvbn0pIHtcbiAgY29uc3QgcmFkID0gdG9SYWRpYW5zKG1pblJvdGF0aW9uKTtcbiAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgY29uc3QgbGVuZ3RoID0gMC43NSAqIG1pblNwYWNpbmcgKiAoJycgKyB2YWx1ZSkubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5taW4obWluU3BhY2luZyAvIHJhdGlvLCBsZW5ndGgpO1xufVxuY2xhc3MgTGluZWFyU2NhbGVCYXNlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcihjZmcpO1xuICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5lbmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9lbmRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYocmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICgodHlwZW9mIHJhdyA9PT0gJ251bWJlcicgfHwgcmF3IGluc3RhbmNlb2YgTnVtYmVyKSAmJiAhaXNGaW5pdGUoK3JhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gK3JhdztcbiAgfVxuICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVyb30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgaWYgKGJlZ2luQXRaZXJvKSB7XG4gICAgICBjb25zdCBtaW5TaWduID0gc2lnbihtaW4pO1xuICAgICAgY29uc3QgbWF4U2lnbiA9IHNpZ24obWF4KTtcbiAgICAgIGlmIChtaW5TaWduIDwgMCAmJiBtYXhTaWduIDwgMCkge1xuICAgICAgICBzZXRNYXgoMCk7XG4gICAgICB9IGVsc2UgaWYgKG1pblNpZ24gPiAwICYmIG1heFNpZ24gPiAwKSB7XG4gICAgICAgIHNldE1pbigwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA9PT0gbWF4KSB7XG4gICAgICBsZXQgb2Zmc2V0ID0gMTtcbiAgICAgIGlmIChtYXggPj0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbWluIDw9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguYWJzKG1heCAqIDAuMDUpO1xuICAgICAgfVxuICAgICAgc2V0TWF4KG1heCArIG9mZnNldCk7XG4gICAgICBpZiAoIWJlZ2luQXRaZXJvKSB7XG4gICAgICAgIHNldE1pbihtaW4gLSBvZmZzZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBnZXRUaWNrTGltaXQoKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IHttYXhUaWNrc0xpbWl0LCBzdGVwU2l6ZX0gPSB0aWNrT3B0cztcbiAgICBsZXQgbWF4VGlja3M7XG4gICAgaWYgKHN0ZXBTaXplKSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGguY2VpbCh0aGlzLm1heCAvIHN0ZXBTaXplKSAtIE1hdGguZmxvb3IodGhpcy5taW4gLyBzdGVwU2l6ZSkgKyAxO1xuICAgICAgaWYgKG1heFRpY2tzID4gMTAwMCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgbWF4VGlja3MgPSAxMDAwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgfVxuICAgIGlmIChtYXhUaWNrc0xpbWl0KSB7XG4gICAgICBtYXhUaWNrcyA9IE1hdGgubWluKG1heFRpY2tzTGltaXQsIG1heFRpY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heFRpY2tzO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgIGxldCBtYXhUaWNrcyA9IHRoaXMuZ2V0VGlja0xpbWl0KCk7XG4gICAgbWF4VGlja3MgPSBNYXRoLm1heCgyLCBtYXhUaWNrcyk7XG4gICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICBtYXhUaWNrcyxcbiAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICBtaW46IG9wdHMubWluLFxuICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICB9O1xuICAgIGNvbnN0IGRhdGFSYW5nZSA9IHRoaXMuX3JhbmdlIHx8IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBsZXQgZW5kID0gdGhpcy5tYXg7XG4gICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgZW5kICs9IG9mZnNldDtcbiAgICB9XG4gICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHN0YXJ0O1xuICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBlbmQgLSBzdGFydDtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gIH1cbn1cblxuY2xhc3MgTGluZWFyU2NhbGUgZXh0ZW5kcyBMaW5lYXJTY2FsZUJhc2Uge1xuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSA/IG1heCA6IDE7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCBob3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCBsZW5ndGggPSBob3Jpem9udGFsID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0O1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKG1pblJvdGF0aW9uKSA6IE1hdGguY29zKG1pblJvdGF0aW9uKSkgfHwgMC4wMDE7XG4gICAgY29uc3QgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApO1xuICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2U7XG4gIH1cbn1cbkxpbmVhclNjYWxlLmlkID0gJ2xpbmVhcic7XG5MaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICBjb25zdCByZW1haW4gPSB0aWNrVmFsIC8gKE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKSkpO1xuICByZXR1cm4gcmVtYWluID09PSAxO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgZGF0YVJhbmdlKSB7XG4gIGNvbnN0IGVuZEV4cCA9IE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1heCkpO1xuICBjb25zdCBlbmRTaWduaWZpY2FuZCA9IE1hdGguY2VpbChkYXRhUmFuZ2UubWF4IC8gTWF0aC5wb3coMTAsIGVuZEV4cCkpO1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBsZXQgdGlja1ZhbCA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5taW4sIE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKGRhdGFSYW5nZS5taW4pKSkpO1xuICBsZXQgZXhwID0gTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsKSk7XG4gIGxldCBzaWduaWZpY2FuZCA9IE1hdGguZmxvb3IodGlja1ZhbCAvIE1hdGgucG93KDEwLCBleHApKTtcbiAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICBkbyB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IHRpY2tWYWwsIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gICAgKytzaWduaWZpY2FuZDtcbiAgICBpZiAoc2lnbmlmaWNhbmQgPT09IDEwKSB7XG4gICAgICBzaWduaWZpY2FuZCA9IDE7XG4gICAgICArK2V4cDtcbiAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICB9XG4gICAgdGlja1ZhbCA9IE1hdGgucm91bmQoc2lnbmlmaWNhbmQgKiBNYXRoLnBvdygxMCwgZXhwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gIH0gd2hpbGUgKGV4cCA8IGVuZEV4cCB8fCAoZXhwID09PSBlbmRFeHAgJiYgc2lnbmlmaWNhbmQgPCBlbmRTaWduaWZpY2FuZCkpO1xuICBjb25zdCBsYXN0VGljayA9IGZpbml0ZU9yRGVmYXVsdChnZW5lcmF0aW9uT3B0aW9ucy5tYXgsIHRpY2tWYWwpO1xuICB0aWNrcy5wdXNoKHt2YWx1ZTogbGFzdFRpY2ssIG1ham9yOiBpc01ham9yKHRpY2tWYWwpfSk7XG4gIHJldHVybiB0aWNrcztcbn1cbmNsYXNzIExvZ2FyaXRobWljU2NhbGUgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBjb25zdCB2YWx1ZSA9IExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUucGFyc2UuYXBwbHkodGhpcywgW3JhdywgaW5kZXhdKTtcbiAgICBpZiAodmFsdWUgPT09IDApIHtcbiAgICAgIHRoaXMuX3plcm8gPSB0cnVlO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pID8gTWF0aC5tYXgoMCwgbWluKSA6IG51bGw7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gTWF0aC5tYXgoMCwgbWF4KSA6IG51bGw7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge21pbkRlZmluZWQsIG1heERlZmluZWR9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgbGV0IG1pbiA9IHRoaXMubWluO1xuICAgIGxldCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBzZXRNaW4gPSB2ID0+IChtaW4gPSBtaW5EZWZpbmVkID8gbWluIDogdik7XG4gICAgY29uc3Qgc2V0TWF4ID0gdiA9PiAobWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IHYpO1xuICAgIGNvbnN0IGV4cCA9ICh2LCBtKSA9PiBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh2KSkgKyBtKTtcbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICBzZXRNaW4oMSk7XG4gICAgICAgIHNldE1heCgxMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICAgICAgc2V0TWF4KGV4cChtYXgsICsxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgc2V0TWluKGV4cChtYXgsIC0xKSk7XG4gICAgfVxuICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgc2V0TWF4KGV4cChtaW4sICsxKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl96ZXJvICYmIHRoaXMubWluICE9PSB0aGlzLl9zdWdnZXN0ZWRNaW4gJiYgbWluID09PSBleHAodGhpcy5taW4sIDApKSB7XG4gICAgICBzZXRNaW4oZXhwKG1pbiwgLTEpKTtcbiAgICB9XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgfTtcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MoZ2VuZXJhdGlvbk9wdGlvbnMsIHRoaXMpO1xuICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWF4O1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1pbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnMCdcbiAgICAgIDogZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSBsb2cxMCh0aGlzLm1heCkgLSBsb2cxMChzdGFydCk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwodmFsdWUgPT09IHRoaXMubWluXG4gICAgICA/IDBcbiAgICAgIDogKGxvZzEwKHZhbHVlKSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCk7XG4gICAgcmV0dXJuIE1hdGgucG93KDEwLCB0aGlzLl9zdGFydFZhbHVlICsgZGVjaW1hbCAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG59XG5Mb2dhcml0aG1pY1NjYWxlLmlkID0gJ2xvZ2FyaXRobWljJztcbkxvZ2FyaXRobWljU2NhbGUuZGVmYXVsdHMgPSB7XG4gIHRpY2tzOiB7XG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgb3B0cy5kaXNwbGF5KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdCh0aWNrT3B0cy5mb250ICYmIHRpY2tPcHRzLmZvbnQuc2l6ZSwgZGVmYXVsdHMuZm9udC5zaXplKSArIHBhZGRpbmcuaGVpZ2h0O1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gbWVhc3VyZUxhYmVsU2l6ZShjdHgsIGZvbnQsIGxhYmVsKSB7XG4gIGxhYmVsID0gaXNBcnJheShsYWJlbCkgPyBsYWJlbCA6IFtsYWJlbF07XG4gIHJldHVybiB7XG4gICAgdzogX2xvbmdlc3RUZXh0KGN0eCwgZm9udC5zdHJpbmcsIGxhYmVsKSxcbiAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9zLCBzaXplLCBtaW4sIG1heCkge1xuICBpZiAoYW5nbGUgPT09IG1pbiB8fCBhbmdsZSA9PT0gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSAoc2l6ZSAvIDIpLFxuICAgICAgZW5kOiBwb3MgKyAoc2l6ZSAvIDIpXG4gICAgfTtcbiAgfSBlbHNlIGlmIChhbmdsZSA8IG1pbiB8fCBhbmdsZSA+IG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydDogcG9zIC0gc2l6ZSxcbiAgICAgIGVuZDogcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBwb3MsXG4gICAgZW5kOiBwb3MgKyBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgY29uc3Qgb3JpZyA9IHtcbiAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICByOiBzY2FsZS5yaWdodCAtIHNjYWxlLl9wYWRkaW5nLnJpZ2h0LFxuICAgIHQ6IHNjYWxlLnRvcCArIHNjYWxlLl9wYWRkaW5nLnRvcCxcbiAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgfTtcbiAgY29uc3QgbGltaXRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3JpZyk7XG4gIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgY29uc3QgcGFkZGluZyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBwb2ludExhYmVsT3B0cy5jZW50ZXJQb2ludExhYmVscyA/IFBJIC8gdmFsdWVDb3VudCA6IDA7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIHBhZGRpbmdbaV0gPSBvcHRzLnBhZGRpbmc7XG4gICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgc2NhbGUuZHJhd2luZ0FyZWEgKyBwYWRkaW5nW2ldLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRleHRTaXplID0gbWVhc3VyZUxhYmVsU2l6ZShzY2FsZS5jdHgsIHBsRm9udCwgc2NhbGUuX3BvaW50TGFiZWxzW2ldKTtcbiAgICBsYWJlbFNpemVzW2ldID0gdGV4dFNpemU7XG4gICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoYW5nbGVSYWRpYW5zKSk7XG4gICAgY29uc3QgaExpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi54LCB0ZXh0U2l6ZS53LCAwLCAxODApO1xuICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGVSYWRpYW5zLCBoTGltaXRzLCB2TGltaXRzKTtcbiAgfVxuICBzY2FsZS5zZXRDZW50ZXJQb2ludChcbiAgICBvcmlnLmwgLSBsaW1pdHMubCxcbiAgICBsaW1pdHMuciAtIG9yaWcucixcbiAgICBvcmlnLnQgLSBsaW1pdHMudCxcbiAgICBsaW1pdHMuYiAtIG9yaWcuYlxuICApO1xuICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgY29uc3Qgc2luID0gTWF0aC5hYnMoTWF0aC5zaW4oYW5nbGUpKTtcbiAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3MoYW5nbGUpKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGlmIChoTGltaXRzLnN0YXJ0IDwgb3JpZy5sKSB7XG4gICAgeCA9IChvcmlnLmwgLSBoTGltaXRzLnN0YXJ0KSAvIHNpbjtcbiAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgfSBlbHNlIGlmIChoTGltaXRzLmVuZCA+IG9yaWcucikge1xuICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgIGxpbWl0cy5yID0gTWF0aC5tYXgobGltaXRzLnIsIG9yaWcuciArIHgpO1xuICB9XG4gIGlmICh2TGltaXRzLnN0YXJ0IDwgb3JpZy50KSB7XG4gICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICBsaW1pdHMudCA9IE1hdGgubWluKGxpbWl0cy50LCBvcmlnLnQgLSB5KTtcbiAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgIHkgPSAodkxpbWl0cy5lbmQgLSBvcmlnLmIpIC8gY29zO1xuICAgIGxpbWl0cy5iID0gTWF0aC5tYXgobGltaXRzLmIsIG9yaWcuYiArIHkpO1xuICB9XG59XG5mdW5jdGlvbiBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZykge1xuICBjb25zdCBpdGVtcyA9IFtdO1xuICBjb25zdCB2YWx1ZUNvdW50ID0gc2NhbGUuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgY29uc3Qgb3B0cyA9IHNjYWxlLm9wdGlvbnM7XG4gIGNvbnN0IGV4dHJhID0gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIC8gMjtcbiAgY29uc3Qgb3V0ZXJEaXN0YW5jZSA9IHNjYWxlLmRyYXdpbmdBcmVhO1xuICBjb25zdCBhZGRpdGlvbmFsQW5nbGUgPSBvcHRzLnBvaW50TGFiZWxzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGksIG91dGVyRGlzdGFuY2UgKyBleHRyYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhfbm9ybWFsaXplQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLmFuZ2xlICsgSEFMRl9QSSkpKTtcbiAgICBjb25zdCBzaXplID0gbGFiZWxTaXplc1tpXTtcbiAgICBjb25zdCB5ID0geUZvckFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi55LCBzaXplLmgsIGFuZ2xlKTtcbiAgICBjb25zdCB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ25Gb3JBbmdsZShhbmdsZSk7XG4gICAgY29uc3QgbGVmdCA9IGxlZnRGb3JUZXh0QWxpZ24ocG9pbnRMYWJlbFBvc2l0aW9uLngsIHNpemUudywgdGV4dEFsaWduKTtcbiAgICBpdGVtcy5wdXNoKHtcbiAgICAgIHg6IHBvaW50TGFiZWxQb3NpdGlvbi54LFxuICAgICAgeSxcbiAgICAgIHRleHRBbGlnbixcbiAgICAgIGxlZnQsXG4gICAgICB0b3A6IHksXG4gICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgIGJvdHRvbTogeSArIHNpemUuaFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gMCB8fCBhbmdsZSA9PT0gMTgwKSB7XG4gICAgcmV0dXJuICdjZW50ZXInO1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgMTgwKSB7XG4gICAgcmV0dXJuICdsZWZ0JztcbiAgfVxuICByZXR1cm4gJ3JpZ2h0Jztcbn1cbmZ1bmN0aW9uIGxlZnRGb3JUZXh0QWxpZ24oeCwgdywgYWxpZ24pIHtcbiAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3O1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgIHggLT0gKHcgLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICBpZiAoYW5nbGUgPT09IDkwIHx8IGFuZ2xlID09PSAyNzApIHtcbiAgICB5IC09IChoIC8gMik7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgIHkgLT0gaDtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludExhYmVscyhzY2FsZSwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9pbnRMYWJlbHN9fSA9IHNjYWxlO1xuICBmb3IgKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3Qgb3B0c0F0SW5kZXggPSBwb2ludExhYmVscy5zZXRDb250ZXh0KHNjYWxlLmdldFBvaW50TGFiZWxDb250ZXh0KGkpKTtcbiAgICBjb25zdCBwbEZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgY29uc3Qge3gsIHksIHRleHRBbGlnbiwgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tfSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgY29uc3Qge2JhY2tkcm9wQ29sb3J9ID0gb3B0c0F0SW5kZXg7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKG9wdHNBdEluZGV4LmJvcmRlclJhZGl1cyk7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2Ryb3BDb2xvcjtcbiAgICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgICBjb25zdCBiYWNrZHJvcFRvcCA9IHRvcCAtIHBhZGRpbmcudG9wO1xuICAgICAgY29uc3QgYmFja2Ryb3BXaWR0aCA9IHJpZ2h0IC0gbGVmdCArIHBhZGRpbmcud2lkdGg7XG4gICAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgeDogYmFja2Ryb3BMZWZ0LFxuICAgICAgICAgIHk6IGJhY2tkcm9wVG9wLFxuICAgICAgICAgIHc6IGJhY2tkcm9wV2lkdGgsXG4gICAgICAgICAgaDogYmFja2Ryb3BIZWlnaHQsXG4gICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXMsXG4gICAgICAgIH0pO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGJhY2tkcm9wTGVmdCwgYmFja2Ryb3BUb3AsIGJhY2tkcm9wV2lkdGgsIGJhY2tkcm9wSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVGV4dChcbiAgICAgIGN0eCxcbiAgICAgIHNjYWxlLl9wb2ludExhYmVsc1tpXSxcbiAgICAgIHgsXG4gICAgICB5ICsgKHBsRm9udC5saW5lSGVpZ2h0IC8gMiksXG4gICAgICBwbEZvbnQsXG4gICAgICB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgICAgdGV4dEFsaWduOiB0ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgIH1cbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBwYXRoUmFkaXVzTGluZShzY2FsZSwgcmFkaXVzLCBjaXJjdWxhciwgbGFiZWxDb3VudCkge1xuICBjb25zdCB7Y3R4fSA9IHNjYWxlO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICBjdHgubW92ZVRvKHBvaW50UG9zaXRpb24ueCwgcG9pbnRQb3NpdGlvbi55KTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxhYmVsQ291bnQ7IGkrKykge1xuICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IGN0eCA9IHNjYWxlLmN0eDtcbiAgY29uc3QgY2lyY3VsYXIgPSBncmlkTGluZU9wdHMuY2lyY3VsYXI7XG4gIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IGdyaWRMaW5lT3B0cztcbiAgaWYgKCghY2lyY3VsYXIgJiYgIWxhYmVsQ291bnQpIHx8ICFjb2xvciB8fCAhbGluZVdpZHRoIHx8IHJhZGl1cyA8IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gIGN0eC5zZXRMaW5lRGFzaChncmlkTGluZU9wdHMuYm9yZGVyRGFzaCk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoT2Zmc2V0O1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KTtcbiAgY3R4LmNsb3NlUGF0aCgpO1xuICBjdHguc3Ryb2tlKCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQb2ludExhYmVsQ29udGV4dChwYXJlbnQsIGluZGV4LCBsYWJlbCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBsYWJlbCxcbiAgICBpbmRleCxcbiAgICB0eXBlOiAncG9pbnRMYWJlbCdcbiAgfSk7XG59XG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy54Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gW107XG4gICAgdGhpcy5fcG9pbnRMYWJlbEl0ZW1zID0gW107XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5fcGFkZGluZyA9IHRvUGFkZGluZyhnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSAvIDIpO1xuICAgIGNvbnN0IHcgPSB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aCAtIHBhZGRpbmcud2lkdGg7XG4gICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICB0aGlzLnhDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMubGVmdCArIHcgLyAyICsgcGFkZGluZy5sZWZ0KTtcbiAgICB0aGlzLnlDZW50ZXIgPSBNYXRoLmZsb29yKHRoaXMudG9wICsgaCAvIDIgKyBwYWRkaW5nLnRvcCk7XG4gICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG4gICAgdGhpcy5taW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogMDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgJiYgIWlzTmFOKG1heCkgPyBtYXggOiAwO1xuICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICB9XG4gIGNvbXB1dGVUaWNrTGltaXQoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmRyYXdpbmdBcmVhIC8gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykpO1xuICB9XG4gIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgIExpbmVhclNjYWxlQmFzZS5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrTGFiZWxzLmNhbGwodGhpcywgdGlja3MpO1xuICAgIHRoaXMuX3BvaW50TGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKVxuICAgICAgLm1hcCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gY2FsbGJhY2sodGhpcy5vcHRpb25zLnBvaW50TGFiZWxzLmNhbGxiYWNrLCBbdmFsdWUsIGluZGV4XSwgdGhpcyk7XG4gICAgICAgIHJldHVybiBsYWJlbCB8fCBsYWJlbCA9PT0gMCA/IGxhYmVsIDogJyc7XG4gICAgICB9KVxuICAgICAgLmZpbHRlcigodiwgaSkgPT4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKG9wdHMuZGlzcGxheSAmJiBvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGZpdFdpdGhQb2ludExhYmVscyh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICB9XG4gIH1cbiAgc2V0Q2VudGVyUG9pbnQobGVmdE1vdmVtZW50LCByaWdodE1vdmVtZW50LCB0b3BNb3ZlbWVudCwgYm90dG9tTW92ZW1lbnQpIHtcbiAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLnlDZW50ZXIgKz0gTWF0aC5mbG9vcigodG9wTW92ZW1lbnQgLSBib3R0b21Nb3ZlbWVudCkgLyAyKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhIC09IE1hdGgubWluKHRoaXMuZHJhd2luZ0FyZWEgLyAyLCBNYXRoLm1heChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkpO1xuICB9XG4gIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICBjb25zdCBhbmdsZU11bHRpcGxpZXIgPSBUQVUgLyAodGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoIHx8IDEpO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLm9wdGlvbnMuc3RhcnRBbmdsZSB8fCAwO1xuICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICB9XG4gIGdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsaW5nRmFjdG9yID0gdGhpcy5kcmF3aW5nQXJlYSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIHJldHVybiAodGhpcy5tYXggLSB2YWx1ZSkgKiBzY2FsaW5nRmFjdG9yO1xuICAgIH1cbiAgICByZXR1cm4gKHZhbHVlIC0gdGhpcy5taW4pICogc2NhbGluZ0ZhY3RvcjtcbiAgfVxuICBnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlcihkaXN0YW5jZSkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc2NhbGVkRGlzdGFuY2UgPSBkaXN0YW5jZSAvICh0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKTtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgfVxuICBnZXRQb2ludExhYmVsQ29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHBvaW50TGFiZWxzID0gdGhpcy5fcG9pbnRMYWJlbHMgfHwgW107XG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICB9XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgZGlzdGFuY2VGcm9tQ2VudGVyLCBhZGRpdGlvbmFsQW5nbGUgPSAwKSB7XG4gICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5jb3MoYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy54Q2VudGVyLFxuICAgICAgeTogTWF0aC5zaW4oYW5nbGUpICogZGlzdGFuY2VGcm9tQ2VudGVyICsgdGhpcy55Q2VudGVyLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG4gIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHZhbHVlKSk7XG4gIH1cbiAgZ2V0QmFzZVBvc2l0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICB9XG4gIGdldFBvaW50TGFiZWxQb3NpdGlvbihpbmRleCkge1xuICAgIGNvbnN0IHtsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gdGhpcy5fcG9pbnRMYWJlbEl0ZW1zW2luZGV4XTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdCxcbiAgICAgIHRvcCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgIH07XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2JhY2tncm91bmRDb2xvciwgZ3JpZDoge2NpcmN1bGFyfX0gPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgcGF0aFJhZGl1c0xpbmUodGhpcywgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aGlzLl9lbmRWYWx1ZSksIGNpcmN1bGFyLCB0aGlzLl9wb2ludExhYmVscy5sZW5ndGgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3R3JpZCgpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHthbmdsZUxpbmVzLCBncmlkfSA9IG9wdHM7XG4gICAgY29uc3QgbGFiZWxDb3VudCA9IHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aDtcbiAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICBpZiAob3B0cy5wb2ludExhYmVscy5kaXNwbGF5KSB7XG4gICAgICBkcmF3UG9pbnRMYWJlbHModGhpcywgbGFiZWxDb3VudCk7XG4gICAgfVxuICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAwKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh0aWNrLnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXggLSAxKSk7XG4gICAgICAgICAgZHJhd1JhZGl1c0xpbmUodGhpcywgb3B0c0F0SW5kZXgsIG9mZnNldCwgbGFiZWxDb3VudCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgZm9yIChpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBjb25zdCB7Y29sb3IsIGxpbmVXaWR0aH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgaWYgKCFsaW5lV2lkdGggfHwgIWNvbG9yKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChvcHRzQXRJbmRleC5ib3JkZXJEYXNoKTtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXguYm9yZGVyRGFzaE9mZnNldDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnRpY2tzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgcG9zaXRpb24gPSB0aGlzLmdldFBvaW50UG9zaXRpb24oaSwgb2Zmc2V0KTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbi54LCBwb3NpdGlvbi55KTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHt9XG4gIGRyYXdMYWJlbHMoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoMCk7XG4gICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGluZGV4ID09PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSB0aWNrT3B0cy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCkpO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSB0b0ZvbnQob3B0c0F0SW5kZXguZm9udCk7XG4gICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMudGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjdHguZm9udCA9IHRpY2tGb250LnN0cmluZztcbiAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzQXRJbmRleC5iYWNrZHJvcENvbG9yO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHNBdEluZGV4LmJhY2tkcm9wUGFkZGluZyk7XG4gICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LFxuICAgICAgICAgIC1vZmZzZXQgLSB0aWNrRm9udC5zaXplIC8gMiAtIHBhZGRpbmcudG9wLFxuICAgICAgICAgIHdpZHRoICsgcGFkZGluZy53aWR0aCxcbiAgICAgICAgICB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJlbmRlclRleHQoY3R4LCB0aWNrLmxhYmVsLCAwLCAtb2Zmc2V0LCB0aWNrRm9udCwge1xuICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gIGRyYXdUaXRsZSgpIHt9XG59XG5SYWRpYWxMaW5lYXJTY2FsZS5pZCA9ICdyYWRpYWxMaW5lYXInO1xuUmFkaWFsTGluZWFyU2NhbGUuZGVmYXVsdHMgPSB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIGFuaW1hdGU6IHRydWUsXG4gIHBvc2l0aW9uOiAnY2hhcnRBcmVhJyxcbiAgYW5nbGVMaW5lczoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGJvcmRlckRhc2g6IFtdLFxuICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICB9LFxuICBncmlkOiB7XG4gICAgY2lyY3VsYXI6IGZhbHNlXG4gIH0sXG4gIHN0YXJ0QW5nbGU6IDAsXG4gIHRpY2tzOiB7XG4gICAgc2hvd0xhYmVsQmFja2Ryb3A6IHRydWUsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICB9LFxuICBwb2ludExhYmVsczoge1xuICAgIGJhY2tkcm9wQ29sb3I6IHVuZGVmaW5lZCxcbiAgICBiYWNrZHJvcFBhZGRpbmc6IDIsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBmb250OiB7XG4gICAgICBzaXplOiAxMFxuICAgIH0sXG4gICAgY2FsbGJhY2sobGFiZWwpIHtcbiAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIHBhZGRpbmc6IDUsXG4gICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gIH1cbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0Um91dGVzID0ge1xuICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbn07XG5SYWRpYWxMaW5lYXJTY2FsZS5kZXNjcmlwdG9ycyA9IHtcbiAgYW5nbGVMaW5lczoge1xuICAgIF9mYWxsYmFjazogJ2dyaWQnXG4gIH1cbn07XG5cbmNvbnN0IElOVEVSVkFMUyA9IHtcbiAgbWlsbGlzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEsIHN0ZXBzOiAxMDAwfSxcbiAgc2Vjb25kOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAxMDAwLCBzdGVwczogNjB9LFxuICBtaW51dGU6IHtjb21tb246IHRydWUsIHNpemU6IDYwMDAwLCBzdGVwczogNjB9LFxuICBob3VyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzNjAwMDAwLCBzdGVwczogMjR9LFxuICBkYXk6IHtjb21tb246IHRydWUsIHNpemU6IDg2NDAwMDAwLCBzdGVwczogMzB9LFxuICB3ZWVrOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNjA0ODAwMDAwLCBzdGVwczogNH0sXG4gIG1vbnRoOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAyLjYyOGU5LCBzdGVwczogMTJ9LFxuICBxdWFydGVyOiB7Y29tbW9uOiBmYWxzZSwgc2l6ZTogNy44ODRlOSwgc3RlcHM6IDR9LFxuICB5ZWFyOiB7Y29tbW9uOiB0cnVlLCBzaXplOiAzLjE1NGUxMH1cbn07XG5jb25zdCBVTklUUyA9IChPYmplY3Qua2V5cyhJTlRFUlZBTFMpKTtcbmZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICBpZiAoaXNOdWxsT3JVbmRlZihpbnB1dCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gIGNvbnN0IHtwYXJzZXIsIHJvdW5kLCBpc29XZWVrZGF5fSA9IHNjYWxlLl9wYXJzZU9wdHM7XG4gIGxldCB2YWx1ZSA9IGlucHV0O1xuICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbHVlID0gcGFyc2VyKHZhbHVlKTtcbiAgfVxuICBpZiAoIWlzTnVtYmVyRmluaXRlKHZhbHVlKSkge1xuICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZydcbiAgICAgID8gYWRhcHRlci5wYXJzZSh2YWx1ZSwgcGFyc2VyKVxuICAgICAgOiBhZGFwdGVyLnBhcnNlKHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAocm91bmQpIHtcbiAgICB2YWx1ZSA9IHJvdW5kID09PSAnd2VlaycgJiYgKGlzTnVtYmVyKGlzb1dlZWtkYXkpIHx8IGlzb1dlZWtkYXkgPT09IHRydWUpXG4gICAgICA/IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgJ2lzb1dlZWsnLCBpc29XZWVrZGF5KVxuICAgICAgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyhtaW5Vbml0LCBtaW4sIG1heCwgY2FwYWNpdHkpIHtcbiAgY29uc3QgaWxlbiA9IFVOSVRTLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YobWluVW5pdCk7IGkgPCBpbGVuIC0gMTsgKytpKSB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBJTlRFUlZBTFNbVU5JVFNbaV1dO1xuICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICBpZiAoaW50ZXJ2YWwuY29tbW9uICYmIE1hdGguY2VpbCgobWF4IC0gbWluKSAvIChmYWN0b3IgKiBpbnRlcnZhbC5zaXplKSkgPD0gY2FwYWNpdHkpIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbmZ1bmN0aW9uIGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHNjYWxlLCBudW1UaWNrcywgbWluVW5pdCwgbWluLCBtYXgpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmxlbmd0aCAtIDE7IGkgPj0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaS0tKSB7XG4gICAgY29uc3QgdW5pdCA9IFVOSVRTW2ldO1xuICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBVTklUU1ttaW5Vbml0ID8gVU5JVFMuaW5kZXhPZihtaW5Vbml0KSA6IDBdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgZm9yIChsZXQgaSA9IFVOSVRTLmluZGV4T2YodW5pdCkgKyAxLCBpbGVuID0gVU5JVFMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaWYgKElOVEVSVkFMU1tVTklUU1tpXV0uY29tbW9uKSB7XG4gICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKSB7XG4gIGlmICghdGltZXN0YW1wcykge1xuICAgIHRpY2tzW3RpbWVdID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgIGNvbnN0IHtsbywgaGl9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lc3RhbXBzW2xvXSA+PSB0aW1lID8gdGltZXN0YW1wc1tsb10gOiB0aW1lc3RhbXBzW2hpXTtcbiAgICB0aWNrc1t0aW1lc3RhbXBdID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KSB7XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICBjb25zdCBsYXN0ID0gdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWU7XG4gIGxldCBtYWpvciwgaW5kZXg7XG4gIGZvciAobWFqb3IgPSBmaXJzdDsgbWFqb3IgPD0gbGFzdDsgbWFqb3IgPSArYWRhcHRlci5hZGQobWFqb3IsIDEsIG1ham9yVW5pdCkpIHtcbiAgICBpbmRleCA9IG1hcFttYWpvcl07XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBjb25zdCBpbGVuID0gdmFsdWVzLmxlbmd0aDtcbiAgbGV0IGksIHZhbHVlO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgbWFwW3ZhbHVlXSA9IGk7XG4gICAgdGlja3MucHVzaCh7XG4gICAgICB2YWx1ZSxcbiAgICAgIG1ham9yOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoaWxlbiA9PT0gMCB8fCAhbWFqb3JVbml0KSA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGxhYmVsczogW10sXG4gICAgICBhbGw6IFtdXG4gICAgfTtcbiAgICB0aGlzLl91bml0ID0gJ2RheSc7XG4gICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29mZnNldHMgPSB7fTtcbiAgICB0aGlzLl9ub3JtYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXQoc2NhbGVPcHRzLCBvcHRzKSB7XG4gICAgY29uc3QgdGltZSA9IHNjYWxlT3B0cy50aW1lIHx8IChzY2FsZU9wdHMudGltZSA9IHt9KTtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgYWRhcHRlci5pbml0KG9wdHMpO1xuICAgIG1lcmdlSWYodGltZS5kaXNwbGF5Rm9ybWF0cywgYWRhcHRlci5mb3JtYXRzKCkpO1xuICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgIH07XG4gICAgc3VwZXIuaW5pdChzY2FsZU9wdHMpO1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChyYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZSh0aGlzLCByYXcpO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgbGV0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBmdW5jdGlvbiBfYXBwbHlCb3VuZHMoYm91bmRzKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5taW4pKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICB9XG4gICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgYm91bmRzLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWluRGVmaW5lZCB8fCAhbWF4RGVmaW5lZCkge1xuICAgICAgX2FwcGx5Qm91bmRzKHRoaXMuX2dldExhYmVsQm91bmRzKCkpO1xuICAgICAgaWYgKG9wdGlvbnMuYm91bmRzICE9PSAndGlja3MnIHx8IG9wdGlvbnMudGlja3Muc291cmNlICE9PSAnbGFiZWxzJykge1xuICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6ICthZGFwdGVyLnN0YXJ0T2YoRGF0ZS5ub3coKSwgdW5pdCk7XG4gICAgbWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcbiAgICB0aGlzLm1pbiA9IE1hdGgubWluKG1pbiwgbWF4IC0gMSk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heChtaW4gKyAxLCBtYXgpO1xuICB9XG4gIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICBjb25zdCBhcnIgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICBpZiAoYXJyLmxlbmd0aCkge1xuICAgICAgbWluID0gYXJyWzBdO1xuICAgICAgbWF4ID0gYXJyW2Fyci5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHttaW4sIG1heH07XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgIGlmIChvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5taW4gPSB0aGlzLl91c2VyTWluIHx8IHRpbWVzdGFtcHNbMF07XG4gICAgICB0aGlzLm1heCA9IHRoaXMuX3VzZXJNYXggfHwgdGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCB0aWNrcyA9IF9maWx0ZXJCZXR3ZWVuKHRpbWVzdGFtcHMsIG1pbiwgbWF4KTtcbiAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXBcbiAgICAgID8gZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSlcbiAgICAgIDogZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcodGhpcywgdGlja3MubGVuZ3RoLCB0aW1lT3B0cy5taW5Vbml0LCB0aGlzLm1pbiwgdGhpcy5tYXgpKTtcbiAgICB0aGlzLl9tYWpvclVuaXQgPSAhdGlja09wdHMubWFqb3IuZW5hYmxlZCB8fCB0aGlzLl91bml0ID09PSAneWVhcicgPyB1bmRlZmluZWRcbiAgICAgIDogZGV0ZXJtaW5lTWFqb3JVbml0KHRoaXMuX3VuaXQpO1xuICAgIHRoaXMuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3NGcm9tVGltZXN0YW1wcyh0aGlzLCB0aWNrcywgdGhpcy5fbWFqb3JVbml0KTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0QWZ0ZXJBdXRvc2tpcCkge1xuICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aGlzLnRpY2tzLm1hcCh0aWNrID0+ICt0aWNrLnZhbHVlKSk7XG4gICAgfVxuICB9XG4gIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIGxldCBmaXJzdCwgbGFzdDtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdGFydCA9IDEgLSBmaXJzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gKHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMV0pIC0gZmlyc3QpIC8gMjtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSAobGFzdCAtIHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAyXSkpIC8gMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGltaXQgPSB0aW1lc3RhbXBzLmxlbmd0aCA8IDMgPyAwLjUgOiAwLjI1O1xuICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoc3RhcnQsIDAsIGxpbWl0KTtcbiAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICB0aGlzLl9vZmZzZXRzID0ge3N0YXJ0LCBlbmQsIGZhY3RvcjogMSAvIChzdGFydCArIDEgKyBlbmQpfTtcbiAgfVxuICBfZ2VuZXJhdGUoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICBjb25zdCBtaW5vciA9IHRpbWVPcHRzLnVuaXQgfHwgZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyh0aW1lT3B0cy5taW5Vbml0LCBtaW4sIG1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKTtcbiAgICBjb25zdCBzdGVwU2l6ZSA9IHZhbHVlT3JEZWZhdWx0KHRpbWVPcHRzLnN0ZXBTaXplLCAxKTtcbiAgICBjb25zdCB3ZWVrZGF5ID0gbWlub3IgPT09ICd3ZWVrJyA/IHRpbWVPcHRzLmlzb1dlZWtkYXkgOiBmYWxzZTtcbiAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICBjb25zdCB0aWNrcyA9IHt9O1xuICAgIGxldCBmaXJzdCA9IG1pbjtcbiAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgaWYgKGhhc1dlZWtkYXkpIHtcbiAgICAgIGZpcnN0ID0gK2FkYXB0ZXIuc3RhcnRPZihmaXJzdCwgJ2lzb1dlZWsnLCB3ZWVrZGF5KTtcbiAgICB9XG4gICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgaWYgKGFkYXB0ZXIuZGlmZihtYXgsIG1pbiwgbWlub3IpID4gMTAwMDAwICogc3RlcFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtaW4gKyAnIGFuZCAnICsgbWF4ICsgJyBhcmUgdG9vIGZhciBhcGFydCB3aXRoIHN0ZXBTaXplIG9mICcgKyBzdGVwU2l6ZSArICcgJyArIG1pbm9yKTtcbiAgICB9XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGZvciAodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKykge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIGlmICh0aW1lID09PSBtYXggfHwgb3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgfHwgY291bnQgPT09IDEpIHtcbiAgICAgIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoKGEsIGIpID0+IGEgLSBiKS5tYXAoeCA9PiAreCk7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgaWYgKHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpIHtcbiAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMudG9vbHRpcEZvcm1hdCk7XG4gICAgfVxuICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICB9XG4gIF90aWNrRm9ybWF0RnVuY3Rpb24odGltZSwgaW5kZXgsIHRpY2tzLCBmb3JtYXQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGZvcm1hdHMgPSBvcHRpb25zLnRpbWUuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgY29uc3QgbWFqb3JVbml0ID0gdGhpcy5fbWFqb3JVbml0O1xuICAgIGNvbnN0IG1pbm9yRm9ybWF0ID0gdW5pdCAmJiBmb3JtYXRzW3VuaXRdO1xuICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgIGNvbnN0IG1ham9yID0gbWFqb3JVbml0ICYmIG1ham9yRm9ybWF0ICYmIHRpY2sgJiYgdGljay5tYWpvcjtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuX2FkYXB0ZXIuZm9ybWF0KHRpbWUsIGZvcm1hdCB8fCAobWFqb3IgPyBtYWpvckZvcm1hdCA6IG1pbm9yRm9ybWF0KSk7XG4gICAgY29uc3QgZm9ybWF0dGVyID0gb3B0aW9ucy50aWNrcy5jYWxsYmFjaztcbiAgICByZXR1cm4gZm9ybWF0dGVyID8gY2FsbGJhY2soZm9ybWF0dGVyLCBbbGFiZWwsIGluZGV4LCB0aWNrc10sIHRoaXMpIDogbGFiZWw7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgfVxuICB9XG4gIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgob2Zmc2V0cy5zdGFydCArIHBvcykgKiBvZmZzZXRzLmZhY3Rvcik7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIHRoaXMubWluICsgcG9zICogKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICBjb25zdCB0aWNrc09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgY29uc3QgdGlja0xhYmVsV2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgY29uc3QgY29zUm90YXRpb24gPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgY29uc3Qgc2luUm90YXRpb24gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgIHJldHVybiB7XG4gICAgICB3OiAodGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogc2luUm90YXRpb24pLFxuICAgICAgaDogKHRpY2tMYWJlbFdpZHRoICogc2luUm90YXRpb24pICsgKHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uKVxuICAgIH07XG4gIH1cbiAgX2dldExhYmVsQ2FwYWNpdHkoZXhhbXBsZVRpbWUpIHtcbiAgICBjb25zdCB0aW1lT3B0cyA9IHRoaXMub3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgY29uc3QgZm9ybWF0ID0gZGlzcGxheUZvcm1hdHNbdGltZU9wdHMudW5pdF0gfHwgZGlzcGxheUZvcm1hdHMubWlsbGlzZWNvbmQ7XG4gICAgY29uc3QgZXhhbXBsZUxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKGV4YW1wbGVUaW1lLCAwLCB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIFtleGFtcGxlVGltZV0sIHRoaXMuX21ham9yVW5pdCksIGZvcm1hdCk7XG4gICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgIGNvbnN0IGNhcGFjaXR5ID0gTWF0aC5mbG9vcih0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCAvIHNpemUudyA6IHRoaXMuaGVpZ2h0IC8gc2l6ZS5oKSAtIDE7XG4gICAgcmV0dXJuIGNhcGFjaXR5ID4gMCA/IGNhcGFjaXR5IDogMTtcbiAgfVxuICBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmRhdGEgfHwgW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gKHRoaXMuX2NhY2hlLmRhdGEgPSBtZXRhc1swXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMgPSB0aW1lc3RhbXBzLmNvbmNhdChtZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyh0aGlzKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBnZXRMYWJlbFRpbWVzdGFtcHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBsYWJlbHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fY2FjaGUubGFiZWxzID0gdGhpcy5fbm9ybWFsaXplZCA/IHRpbWVzdGFtcHMgOiB0aGlzLm5vcm1hbGl6ZSh0aW1lc3RhbXBzKSk7XG4gIH1cbiAgbm9ybWFsaXplKHZhbHVlcykge1xuICAgIHJldHVybiBfYXJyYXlVbmlxdWUodmFsdWVzLnNvcnQoc29ydGVyKSk7XG4gIH1cbn1cblRpbWVTY2FsZS5pZCA9ICd0aW1lJztcblRpbWVTY2FsZS5kZWZhdWx0cyA9IHtcbiAgYm91bmRzOiAnZGF0YScsXG4gIGFkYXB0ZXJzOiB7fSxcbiAgdGltZToge1xuICAgIHBhcnNlcjogZmFsc2UsXG4gICAgdW5pdDogZmFsc2UsXG4gICAgcm91bmQ6IGZhbHNlLFxuICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgIG1pblVuaXQ6ICdtaWxsaXNlY29uZCcsXG4gICAgZGlzcGxheUZvcm1hdHM6IHt9XG4gIH0sXG4gIHRpY2tzOiB7XG4gICAgc291cmNlOiAnYXV0bycsXG4gICAgbWFqb3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0YWJsZSwgdmFsLCByZXZlcnNlKSB7XG4gIGxldCBsbyA9IDA7XG4gIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gIGxldCBwcmV2U291cmNlLCBuZXh0U291cmNlLCBwcmV2VGFyZ2V0LCBuZXh0VGFyZ2V0O1xuICBpZiAocmV2ZXJzZSkge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnBvcyAmJiB2YWwgPD0gdGFibGVbaGldLnBvcykge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgfVxuICAgICh7cG9zOiBwcmV2U291cmNlLCB0aW1lOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHtwb3M6IG5leHRTb3VyY2UsIHRpbWU6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodmFsID49IHRhYmxlW2xvXS50aW1lICYmIHZhbCA8PSB0YWJsZVtoaV0udGltZSkge1xuICAgICAgKHtsbywgaGl9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgIH1cbiAgICAoe3RpbWU6IHByZXZTb3VyY2UsIHBvczogcHJldlRhcmdldH0gPSB0YWJsZVtsb10pO1xuICAgICh7dGltZTogbmV4dFNvdXJjZSwgcG9zOiBuZXh0VGFyZ2V0fSA9IHRhYmxlW2hpXSk7XG4gIH1cbiAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICByZXR1cm4gc3BhbiA/IHByZXZUYXJnZXQgKyAobmV4dFRhcmdldCAtIHByZXZUYXJnZXQpICogKHZhbCAtIHByZXZTb3VyY2UpIC8gc3BhbiA6IHByZXZUYXJnZXQ7XG59XG5jbGFzcyBUaW1lU2VyaWVzU2NhbGUgZXh0ZW5kcyBUaW1lU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl90YWJsZSA9IFtdO1xuICAgIHRoaXMuX21pblBvcyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICB9XG4gIGluaXRPZmZzZXRzKCkge1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aGlzLl9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKTtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgIHRoaXMuX21pblBvcyA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1pbik7XG4gICAgdGhpcy5fdGFibGVSYW5nZSA9IGludGVycG9sYXRlKHRhYmxlLCB0aGlzLm1heCkgLSB0aGlzLl9taW5Qb3M7XG4gICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gIH1cbiAgYnVpbGRMb29rdXBUYWJsZSh0aW1lc3RhbXBzKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBjb25zdCB0YWJsZSA9IFtdO1xuICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY3VyciA9IHRpbWVzdGFtcHNbaV07XG4gICAgICBpZiAoY3VyciA+PSBtaW4gJiYgY3VyciA8PSBtYXgpIHtcbiAgICAgICAgaXRlbXMucHVzaChjdXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0aW1lOiBtaW4sIHBvczogMH0sXG4gICAgICAgIHt0aW1lOiBtYXgsIHBvczogMX1cbiAgICAgIF07XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgIHRhYmxlLnB1c2goe3RpbWU6IGN1cnIsIHBvczogaSAvIChpbGVuIC0gMSl9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIF9nZXRUaW1lc3RhbXBzRm9yVGFibGUoKSB7XG4gICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgaWYgKGRhdGEubGVuZ3RoICYmIGxhYmVsLmxlbmd0aCkge1xuICAgICAgdGltZXN0YW1wcyA9IHRoaXMubm9ybWFsaXplKGRhdGEuY29uY2F0KGxhYmVsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICB9XG4gICAgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCA9IHRpbWVzdGFtcHM7XG4gICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIChpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgdmFsdWUpIC0gdGhpcy5fbWluUG9zKSAvIHRoaXMuX3RhYmxlUmFuZ2U7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgIGNvbnN0IGRlY2ltYWwgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICB9XG59XG5UaW1lU2VyaWVzU2NhbGUuaWQgPSAndGltZXNlcmllcyc7XG5UaW1lU2VyaWVzU2NhbGUuZGVmYXVsdHMgPSBUaW1lU2NhbGUuZGVmYXVsdHM7XG5cbnZhciBzY2FsZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5DYXRlZ29yeVNjYWxlOiBDYXRlZ29yeVNjYWxlLFxuTGluZWFyU2NhbGU6IExpbmVhclNjYWxlLFxuTG9nYXJpdGhtaWNTY2FsZTogTG9nYXJpdGhtaWNTY2FsZSxcblJhZGlhbExpbmVhclNjYWxlOiBSYWRpYWxMaW5lYXJTY2FsZSxcblRpbWVTY2FsZTogVGltZVNjYWxlLFxuVGltZVNlcmllc1NjYWxlOiBUaW1lU2VyaWVzU2NhbGVcbn0pO1xuXG5jb25zdCByZWdpc3RlcmFibGVzID0gW1xuICBjb250cm9sbGVycyxcbiAgZWxlbWVudHMsXG4gIHBsdWdpbnMsXG4gIHNjYWxlcyxcbl07XG5cbmV4cG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9ucywgQXJjRWxlbWVudCwgQmFyQ29udHJvbGxlciwgQmFyRWxlbWVudCwgQmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBCdWJibGVDb250cm9sbGVyLCBDYXRlZ29yeVNjYWxlLCBDaGFydCwgRGF0YXNldENvbnRyb2xsZXIsIHBsdWdpbl9kZWNpbWF0aW9uIGFzIERlY2ltYXRpb24sIERvbVBsYXRmb3JtLCBEb3VnaG51dENvbnRyb2xsZXIsIEVsZW1lbnQsIGluZGV4IGFzIEZpbGxlciwgSW50ZXJhY3Rpb24sIHBsdWdpbl9sZWdlbmQgYXMgTGVnZW5kLCBMaW5lQ29udHJvbGxlciwgTGluZUVsZW1lbnQsIExpbmVhclNjYWxlLCBMb2dhcml0aG1pY1NjYWxlLCBQaWVDb250cm9sbGVyLCBQb2ludEVsZW1lbnQsIFBvbGFyQXJlYUNvbnRyb2xsZXIsIFJhZGFyQ29udHJvbGxlciwgUmFkaWFsTGluZWFyU2NhbGUsIFNjYWxlLCBTY2F0dGVyQ29udHJvbGxlciwgcGx1Z2luX3N1YnRpdGxlIGFzIFN1YlRpdGxlLCBUaWNrcywgVGltZVNjYWxlLCBUaW1lU2VyaWVzU2NhbGUsIHBsdWdpbl90aXRsZSBhcyBUaXRsZSwgcGx1Z2luX3Rvb2x0aXAgYXMgVG9vbHRpcCwgYWRhcHRlcnMgYXMgX2FkYXB0ZXJzLCBfZGV0ZWN0UGxhdGZvcm0sIGFuaW1hdG9yLCBjb250cm9sbGVycywgZWxlbWVudHMsIGxheW91dHMsIHBsdWdpbnMsIHJlZ2lzdGVyYWJsZXMsIHJlZ2lzdHJ5LCBzY2FsZXMgfTtcbiJdLCJuYW1lcyI6WyJyIiwicmVxdWVzdEFuaW1GcmFtZSIsImEiLCJyZXNvbHZlIiwiZSIsImVmZmVjdHMiLCJjIiwiY29sb3IiLCJkIiwiZGVmYXVsdHMiLCJpIiwiaXNPYmplY3QiLCJiIiwiaXNBcnJheSIsInYiLCJ2YWx1ZU9yRGVmYXVsdCIsInUiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwibCIsImxpc3RlbkFycmF5RXZlbnRzIiwiZiIsInJlc29sdmVPYmplY3RLZXkiLCJnIiwiaXNOdW1iZXJGaW5pdGUiLCJoIiwiY3JlYXRlQ29udGV4dCIsImoiLCJkZWZpbmVkIiwicyIsInNpZ24iLCJrIiwiaXNOdWxsT3JVbmRlZiIsIl8iLCJfYXJyYXlVbmlxdWUiLCJ0IiwidG9SYWRpYW5zIiwibSIsInRvUGVyY2VudGFnZSIsIm4iLCJ0b0RpbWVuc2lvbiIsIlQiLCJUQVUiLCJvIiwiZm9ybWF0TnVtYmVyIiwicCIsIl9hbmdsZUJldHdlZW4iLCJIIiwiSEFMRl9QSSIsIlAiLCJQSSIsInEiLCJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsInciLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwieCIsImlzTnVtYmVyIiwieSIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsInoiLCJsb2cxMCIsIkEiLCJfZmFjdG9yaXplIiwiQiIsImZpbml0ZU9yRGVmYXVsdCIsIkMiLCJjYWxsYmFjayIsIkQiLCJfYWRkR3JhY2UiLCJFIiwiX2xpbWl0VmFsdWUiLCJGIiwidG9EZWdyZWVzIiwiRyIsIl9tZWFzdXJlVGV4dCIsIkkiLCJfaW50MTZSYW5nZSIsIkoiLCJfYWxpZ25QaXhlbCIsIksiLCJ0b1BhZGRpbmciLCJMIiwiY2xpcEFyZWEiLCJNIiwicmVuZGVyVGV4dCIsIk4iLCJ1bmNsaXBBcmVhIiwiTyIsInRvRm9udCIsIlEiLCJlYWNoIiwiUiIsIl90b0xlZnRSaWdodENlbnRlciIsIlMiLCJfYWxpZ25TdGFydEVuZCIsIlUiLCJvdmVycmlkZXMiLCJWIiwibWVyZ2UiLCJXIiwiX2NhcGl0YWxpemUiLCJYIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsIlkiLCJfcmxvb2t1cEJ5S2V5IiwiWiIsIl9sb29rdXBCeUtleSIsIiQiLCJfaXNQb2ludEluQXJlYSIsImEwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJhMSIsImdldE1heGltdW1TaXplIiwiYTIiLCJfZ2V0UGFyZW50Tm9kZSIsImEzIiwicmVhZFVzZWRTaXplIiwiYTQiLCJ0aHJvdHRsZWQiLCJhNSIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJhNiIsIl9pc0RvbVN1cHBvcnRlZCIsImE3IiwiZGVzY3JpcHRvcnMiLCJhOCIsImlzRnVuY3Rpb24iLCJhOSIsIl9hdHRhY2hDb250ZXh0IiwiYWEiLCJfY3JlYXRlUmVzb2x2ZXIiLCJhYiIsIl9kZXNjcmlwdG9ycyIsImFjIiwibWVyZ2VJZiIsImFkIiwidWlkIiwiYWUiLCJkZWJvdW5jZSIsImFmIiwicmV0aW5hU2NhbGUiLCJhZyIsImNsZWFyQ2FudmFzIiwiYWgiLCJzZXRzRXF1YWwiLCJhaSIsIl9lbGVtZW50c0VxdWFsIiwiYWoiLCJfaXNDbGlja0V2ZW50IiwiYWsiLCJfaXNCZXR3ZWVuIiwiYWwiLCJfcmVhZFZhbHVlVG9Qcm9wcyIsImFtIiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJhbiIsIl9jb21wdXRlU2VnbWVudHMiLCJhbyIsIl9ib3VuZFNlZ21lbnRzIiwiYXAiLCJfc3RlcHBlZEludGVycG9sYXRpb24iLCJhcSIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiYXIiLCJfcG9pbnRJbkxpbmUiLCJhcyIsIl9zdGVwcGVkTGluZVRvIiwiYXQiLCJfYmV6aWVyQ3VydmVUbyIsImF1IiwiZHJhd1BvaW50IiwiYXYiLCJhZGRSb3VuZGVkUmVjdFBhdGgiLCJhdyIsInRvVFJCTCIsImF4IiwidG9UUkJMQ29ybmVycyIsImF5IiwiX2JvdW5kU2VnbWVudCIsImF6IiwiX25vcm1hbGl6ZUFuZ2xlIiwiYUEiLCJnZXRSdGxBZGFwdGVyIiwiYUIiLCJvdmVycmlkZVRleHREaXJlY3Rpb24iLCJhQyIsIl90ZXh0WCIsImFEIiwicmVzdG9yZVRleHREaXJlY3Rpb24iLCJhRSIsImRyYXdQb2ludExlZ2VuZCIsImFGIiwibm9vcCIsImFHIiwiZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIiwiYUgiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhSSIsIm5pY2VOdW0iLCJhSiIsImFsbW9zdFdob2xlIiwiYUsiLCJhbG1vc3RFcXVhbHMiLCJhTCIsIl9kZWNpbWFsUGxhY2VzIiwiYU0iLCJfbG9uZ2VzdFRleHQiLCJhTiIsIl9maWx0ZXJCZXR3ZWVuIiwiYU8iLCJfbG9va3VwIiwiQW5pbWF0b3IiLCJfbm90aWZ5IiwiY2hhcnQiLCJhbmltcyIsImRhdGUiLCJ0eXBlIiwiY2FsbGJhY2tzIiwibGlzdGVuZXJzIiwibnVtU3RlcHMiLCJkdXJhdGlvbiIsImZvckVhY2giLCJmbiIsImluaXRpYWwiLCJjdXJyZW50U3RlcCIsIk1hdGgiLCJtaW4iLCJzdGFydCIsIl9yZWZyZXNoIiwiX3JlcXVlc3QiLCJfcnVubmluZyIsImNhbGwiLCJ3aW5kb3ciLCJfdXBkYXRlIiwiRGF0ZSIsIm5vdyIsInJlbWFpbmluZyIsIl9jaGFydHMiLCJydW5uaW5nIiwiaXRlbXMiLCJsZW5ndGgiLCJkcmF3IiwiaXRlbSIsIl9hY3RpdmUiLCJfdG90YWwiLCJ0aWNrIiwicG9wIiwiX2xhc3REYXRlIiwiX2dldEFuaW1zIiwiY2hhcnRzIiwiZ2V0IiwiY29tcGxldGUiLCJwcm9ncmVzcyIsInNldCIsImxpc3RlbiIsImV2ZW50IiwiY2IiLCJwdXNoIiwiYWRkIiwiaGFzIiwicmVkdWNlIiwiYWNjIiwiY3VyIiwibWF4IiwiX2R1cmF0aW9uIiwic3RvcCIsImNhbmNlbCIsInJlbW92ZSIsImRlbGV0ZSIsImNvbnN0cnVjdG9yIiwiTWFwIiwidW5kZWZpbmVkIiwiYW5pbWF0b3IiLCJ0cmFuc3BhcmVudCIsImludGVycG9sYXRvcnMiLCJib29sZWFuIiwiZnJvbSIsInRvIiwiZmFjdG9yIiwiYzAiLCJjMSIsInZhbGlkIiwibWl4IiwiaGV4U3RyaW5nIiwibnVtYmVyIiwiQW5pbWF0aW9uIiwiYWN0aXZlIiwidXBkYXRlIiwiY2ZnIiwiY3VycmVudFZhbHVlIiwiX3RhcmdldCIsIl9wcm9wIiwiZWxhcHNlZCIsIl9zdGFydCIsInJlbWFpbiIsImZsb29yIiwiX2xvb3AiLCJsb29wIiwiX3RvIiwiX2Zyb20iLCJwcm9wIiwiX2Vhc2luZyIsIl9mbiIsIndhaXQiLCJwcm9taXNlcyIsIl9wcm9taXNlcyIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJyZXNvbHZlZCIsIm1ldGhvZCIsInRhcmdldCIsImVhc2luZyIsImxpbmVhciIsImRlbGF5IiwibnVtYmVycyIsImNvbG9ycyIsImFuaW1hdGlvbk9wdGlvbnMiLCJPYmplY3QiLCJrZXlzIiwiYW5pbWF0aW9uIiwiZGVzY3JpYmUiLCJfZmFsbGJhY2siLCJfaW5kZXhhYmxlIiwiX3NjcmlwdGFibGUiLCJuYW1lIiwicHJvcGVydGllcyIsInJlc2l6ZSIsInNob3ciLCJhbmltYXRpb25zIiwidmlzaWJsZSIsImhpZGUiLCJBbmltYXRpb25zIiwiY29uZmlndXJlIiwiY29uZmlnIiwiYW5pbWF0ZWRQcm9wcyIsIl9wcm9wZXJ0aWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImtleSIsIm9wdGlvbiIsIl9hbmltYXRlT3B0aW9ucyIsInZhbHVlcyIsIm5ld09wdGlvbnMiLCJvcHRpb25zIiwicmVzb2x2ZVRhcmdldE9wdGlvbnMiLCJfY3JlYXRlQW5pbWF0aW9ucyIsIiRzaGFyZWQiLCJhd2FpdEFsbCIsIiRhbmltYXRpb25zIiwidGhlbiIsInByb3BzIiwiY2hhckF0IiwidmFsdWUiLCJzaXplIiwiYXNzaWduIiwiX2NoYXJ0IiwiYW5pbSIsImFsbCIsInNjYWxlQ2xpcCIsInNjYWxlIiwiYWxsb3dlZE92ZXJmbG93Iiwib3B0cyIsInJldmVyc2UiLCJlbmQiLCJkZWZhdWx0Q2xpcCIsInhTY2FsZSIsInlTY2FsZSIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsInRvQ2xpcCIsImRpc2FibGVkIiwiZ2V0U29ydGVkRGF0YXNldEluZGljZXMiLCJmaWx0ZXJWaXNpYmxlIiwibWV0YXNldHMiLCJfZ2V0U29ydGVkRGF0YXNldE1ldGFzIiwiaWxlbiIsImluZGV4IiwiYXBwbHlTdGFjayIsInN0YWNrIiwiZHNJbmRleCIsInNpbmdsZU1vZGUiLCJtb2RlIiwiZGF0YXNldEluZGV4Iiwib3RoZXJWYWx1ZSIsImNvbnZlcnRPYmplY3REYXRhVG9BcnJheSIsImRhdGEiLCJhZGF0YSIsIkFycmF5IiwiaXNTdGFja2VkIiwibWV0YSIsInN0YWNrZWQiLCJnZXRTdGFja0tleSIsImluZGV4U2NhbGUiLCJ2YWx1ZVNjYWxlIiwiaWQiLCJnZXRVc2VyQm91bmRzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJOdW1iZXIiLCJORUdBVElWRV9JTkZJTklUWSIsIlBPU0lUSVZFX0lORklOSVRZIiwiZ2V0T3JDcmVhdGVTdGFjayIsInN0YWNrcyIsInN0YWNrS2V5IiwiaW5kZXhWYWx1ZSIsInN1YlN0YWNrIiwiZ2V0TGFzdEluZGV4SW5TdGFjayIsInZTY2FsZSIsInBvc2l0aXZlIiwiZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMiLCJ1cGRhdGVTdGFja3MiLCJjb250cm9sbGVyIiwicGFyc2VkIiwiX2NhY2hlZE1ldGEiLCJfc3RhY2tzIiwiaVNjYWxlIiwiaUF4aXMiLCJheGlzIiwidkF4aXMiLCJpdGVtU3RhY2tzIiwiX3RvcCIsIl9ib3R0b20iLCJnZXRGaXJzdFNjYWxlSWQiLCJzY2FsZXMiLCJmaWx0ZXIiLCJzaGlmdCIsImNyZWF0ZURhdGFzZXRDb250ZXh0IiwicGFyZW50IiwiZGF0YXNldCIsImNyZWF0ZURhdGFDb250ZXh0IiwiZWxlbWVudCIsImRhdGFJbmRleCIsInJhdyIsImNsZWFyU3RhY2tzIiwiX3BhcnNlZCIsImlzRGlyZWN0VXBkYXRlTW9kZSIsImNsb25lSWZOb3RTaGFyZWQiLCJjYWNoZWQiLCJzaGFyZWQiLCJjcmVhdGVTdGFjayIsImNhblN0YWNrIiwiaGlkZGVuIiwiX3N0YWNrZWQiLCJEYXRhc2V0Q29udHJvbGxlciIsImluaXRpYWxpemUiLCJsaW5rU2NhbGVzIiwiYWRkRWxlbWVudHMiLCJ1cGRhdGVJbmRleCIsImdldERhdGFzZXQiLCJjaG9vc2VJZCIsInhpZCIsInhBeGlzSUQiLCJ5aWQiLCJ5QXhpc0lEIiwicmlkIiwickF4aXNJRCIsImluZGV4QXhpcyIsImlpZCIsImlBeGlzSUQiLCJ2aWQiLCJ2QXhpc0lEIiwiZ2V0U2NhbGVGb3JJZCIsInJTY2FsZSIsImRhdGFzZXRzIiwiZ2V0TWV0YSIsImdldERhdGFzZXRNZXRhIiwic2NhbGVJRCIsIl9nZXRPdGhlclNjYWxlIiwicmVzZXQiLCJfZGVzdHJveSIsIl9kYXRhIiwiX2RhdGFDaGVjayIsImlzRXh0ZW5zaWJsZSIsIl9zeW5jTGlzdCIsImRhdGFzZXRFbGVtZW50VHlwZSIsImJ1aWxkT3JVcGRhdGVFbGVtZW50cyIsInJlc2V0TmV3RWxlbWVudHMiLCJzdGFja0NoYW5nZWQiLCJvbGRTdGFja2VkIiwiX3Jlc3luY0VsZW1lbnRzIiwic2NvcGVLZXlzIiwiZGF0YXNldFNjb3BlS2V5cyIsIl90eXBlIiwic2NvcGVzIiwiZ2V0T3B0aW9uU2NvcGVzIiwiY3JlYXRlUmVzb2x2ZXIiLCJnZXRDb250ZXh0IiwiX3BhcnNpbmciLCJwYXJzaW5nIiwiX2NhY2hlZERhdGFPcHRzIiwicGFyc2UiLCJjb3VudCIsInNvcnRlZCIsIl9zb3J0ZWQiLCJwcmV2IiwicGFyc2VBcnJheURhdGEiLCJwYXJzZU9iamVjdERhdGEiLCJwYXJzZVByaW1pdGl2ZURhdGEiLCJpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiIsImxhYmVscyIsImdldExhYmVscyIsInNpbmdsZVNjYWxlIiwieEF4aXNLZXkiLCJ5QXhpc0tleSIsImdldFBhcnNlZCIsImdldERhdGFFbGVtZW50IiwidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwicmFuZ2UiLCJwYXJzZWRWYWx1ZSIsIk5hTiIsImdldE1pbk1heCIsIm90aGVyU2NhbGUiLCJvdGhlck1pbiIsIm90aGVyTWF4IiwiX3NraXAiLCJnZXRBbGxQYXJzZWRWYWx1ZXMiLCJnZXRNYXhPdmVyZmxvdyIsImdldExhYmVsQW5kVmFsdWUiLCJsYWJlbCIsImdldExhYmVsRm9yVmFsdWUiLCJfY2xpcCIsImNsaXAiLCJjdHgiLCJfY3R4IiwiZWxlbWVudHMiLCJhcmVhIiwiY2hhcnRBcmVhIiwiX2RyYXdTdGFydCIsIl9kcmF3Q291bnQiLCJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsImdldFN0eWxlIiwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJjb250ZXh0IiwiJGNvbnRleHQiLCJfcmVzb2x2ZUVsZW1lbnRPcHRpb25zIiwiZGF0YUVsZW1lbnRUeXBlIiwiZWxlbWVudFR5cGUiLCJjYWNoZSIsImNhY2hlS2V5Iiwic2hhcmluZyIsImVuYWJsZU9wdGlvblNoYXJpbmciLCJkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyIsInByZWZpeGVzIiwibmFtZXMiLCJyZXNvbHZlTmFtZWRPcHRpb25zIiwiZnJlZXplIiwiX3Jlc29sdmVBbmltYXRpb25zIiwidHJhbnNpdGlvbiIsImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCJfY2FjaGVhYmxlIiwiZ2V0U2hhcmVkT3B0aW9ucyIsIl9zaGFyZWRPcHRpb25zIiwiaW5jbHVkZU9wdGlvbnMiLCJzaGFyZWRPcHRpb25zIiwiX2FuaW1hdGlvbnNEaXNhYmxlZCIsIl9nZXRTaGFyZWRPcHRpb25zIiwiZmlyc3RPcHRzIiwicHJldmlvdXNseVNoYXJlZE9wdGlvbnMiLCJ1cGRhdGVTaGFyZWRPcHRpb25zIiwidXBkYXRlRWxlbWVudCIsIl9zZXRTdHlsZSIsInJlbW92ZUhvdmVyU3R5bGUiLCJzZXRIb3ZlclN0eWxlIiwiX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlIiwiX3NldERhdGFzZXRIb3ZlclN0eWxlIiwiYXJnMSIsImFyZzIiLCJudW1NZXRhIiwibnVtRGF0YSIsIl9pbnNlcnRFbGVtZW50cyIsIl9yZW1vdmVFbGVtZW50cyIsIm1vdmUiLCJhcnIiLCJ1cGRhdGVFbGVtZW50cyIsInJlbW92ZWQiLCJzcGxpY2UiLCJfc3luYyIsImFyZ3MiLCJfZGF0YUNoYW5nZXMiLCJfb25EYXRhUHVzaCIsImFyZ3VtZW50cyIsIl9vbkRhdGFQb3AiLCJfb25EYXRhU2hpZnQiLCJfb25EYXRhU3BsaWNlIiwibmV3Q291bnQiLCJfb25EYXRhVW5zaGlmdCIsIl9vYmplY3REYXRhIiwic3VwcG9ydHNEZWNpbWF0aW9uIiwicHJvdG90eXBlIiwiZ2V0QWxsU2NhbGVWYWx1ZXMiLCJfY2FjaGUiLCIkYmFyIiwidmlzaWJsZU1ldGFzIiwiY29uY2F0Iiwic29ydCIsImNvbXB1dGVNaW5TYW1wbGVTaXplIiwiX2xlbmd0aCIsImN1cnIiLCJ1cGRhdGVNaW5BbmRQcmV2IiwiYWJzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsInRpY2tzIiwiZ2V0UGl4ZWxGb3JUaWNrIiwiY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzIiwicnVsZXIiLCJzdGFja0NvdW50IiwidGhpY2tuZXNzIiwiYmFyVGhpY2tuZXNzIiwicmF0aW8iLCJjYXRlZ29yeVBlcmNlbnRhZ2UiLCJiYXJQZXJjZW50YWdlIiwiY2h1bmsiLCJwaXhlbHMiLCJjb21wdXRlRmxleENhdGVnb3J5VHJhaXRzIiwibmV4dCIsInBlcmNlbnQiLCJwYXJzZUZsb2F0QmFyIiwiZW50cnkiLCJzdGFydFZhbHVlIiwiZW5kVmFsdWUiLCJiYXJTdGFydCIsImJhckVuZCIsIl9jdXN0b20iLCJwYXJzZVZhbHVlIiwicGFyc2VBcnJheU9yUHJpbWl0aXZlIiwiaXNGbG9hdEJhciIsImN1c3RvbSIsImJhclNpZ24iLCJhY3R1YWxCYXNlIiwiaXNIb3Jpem9udGFsIiwiYm9yZGVyUHJvcHMiLCJob3Jpem9udGFsIiwiYmFzZSIsInNldEJvcmRlclNraXBwZWQiLCJlZGdlIiwiYm9yZGVyU2tpcHBlZCIsImVuYWJsZUJvcmRlclJhZGl1cyIsInBhcnNlRWRnZSIsInN3YXAiLCJzdGFydEVuZCIsIm9yaWciLCJ2MSIsInYyIiwic2V0SW5mbGF0ZUFtb3VudCIsImluZmxhdGVBbW91bnQiLCJCYXJDb250cm9sbGVyIiwiaUF4aXNLZXkiLCJ2QXhpc0tleSIsIm9iaiIsImJhcnMiLCJnZXRCYXNlUGl4ZWwiLCJfZ2V0UnVsZXIiLCJ2cGl4ZWxzIiwiaGVhZCIsIl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyIsImlwaXhlbHMiLCJfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMiLCJjZW50ZXIiLCJoZWlnaHQiLCJ3aWR0aCIsIl9nZXRTdGFja3MiLCJsYXN0IiwiZ3JvdXBlZCIsInNraXBOdWxsIiwidmFsIiwiaXNOYU4iLCJpbmRleE9mIiwiX2dldFN0YWNrQ291bnQiLCJfZ2V0U3RhY2tJbmRleCIsIl9zdGFydFBpeGVsIiwiX2VuZFBpeGVsIiwiYmFzZVZhbHVlIiwibWluQmFyTGVuZ3RoIiwiZmxvYXRpbmciLCJnZXREYXRhVmlzaWJpbGl0eSIsInN0YXJ0UGl4ZWwiLCJnZXRQaXhlbEZvckRlY2ltYWwiLCJlbmRQaXhlbCIsImhhbGZHcmlkIiwiZ2V0TGluZVdpZHRoRm9yVmFsdWUiLCJtYXhCYXJUaGlja25lc3MiLCJJbmZpbml0eSIsInN0YWNrSW5kZXgiLCJyZWN0cyIsIl9pbmRleF8iLCJvZmZzZXQiLCJncmlkIiwiX3ZhbHVlXyIsImJlZ2luQXRaZXJvIiwiQnViYmxlQ29udHJvbGxlciIsInJhZGl1cyIsInBvaW50cyIsInBvaW50IiwiaVBpeGVsIiwidlBpeGVsIiwic2tpcCIsInBsdWdpbnMiLCJ0b29sdGlwIiwidGl0bGUiLCJnZXRSYXRpb0FuZE9mZnNldCIsInJvdGF0aW9uIiwiY2lyY3VtZmVyZW5jZSIsImN1dG91dCIsInJhdGlvWCIsInJhdGlvWSIsIm9mZnNldFgiLCJvZmZzZXRZIiwic3RhcnRBbmdsZSIsImVuZEFuZ2xlIiwic3RhcnRYIiwiY29zIiwic3RhcnRZIiwic2luIiwiZW5kWCIsImVuZFkiLCJjYWxjTWF4IiwiYW5nbGUiLCJjYWxjTWluIiwibWF4WCIsIm1heFkiLCJtaW5YIiwibWluWSIsIkRvdWdobnV0Q29udHJvbGxlciIsImdldHRlciIsIl9nZXRSb3RhdGlvbiIsIl9nZXRDaXJjdW1mZXJlbmNlIiwiX2dldFJvdGF0aW9uRXh0ZW50cyIsImlzRGF0YXNldFZpc2libGUiLCJhcmNzIiwic3BhY2luZyIsImdldE1heEJvcmRlcldpZHRoIiwiZ2V0TWF4T2Zmc2V0IiwibWF4U2l6ZSIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFJhZGl1cyIsIm91dGVyUmFkaXVzIiwiaW5uZXJSYWRpdXMiLCJyYWRpdXNMZW5ndGgiLCJfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCIsInRvdGFsIiwiY2FsY3VsYXRlVG90YWwiLCJfZ2V0UmluZ1dlaWdodE9mZnNldCIsIl9jaXJjdW1mZXJlbmNlIiwiYW5pbWF0ZVJvdGF0ZSIsImNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UiLCJhbmltYXRpb25PcHRzIiwiY2VudGVyWCIsImNlbnRlclkiLCJhbmltYXRlU2NhbGUiLCJhcmMiLCJtZXRhRGF0YSIsImxvY2FsZSIsImJvcmRlckFsaWduIiwiYm9yZGVyV2lkdGgiLCJob3ZlckJvcmRlcldpZHRoIiwiaG92ZXJPZmZzZXQiLCJyaW5nV2VpZ2h0T2Zmc2V0Iiwid2VpZ2h0IiwiYXNwZWN0UmF0aW8iLCJsZWdlbmQiLCJnZW5lcmF0ZUxhYmVscyIsInBvaW50U3R5bGUiLCJtYXAiLCJzdHlsZSIsInRleHQiLCJmaWxsU3R5bGUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJzdHJva2VTdHlsZSIsImJvcmRlckNvbG9yIiwibGluZVdpZHRoIiwib25DbGljayIsImxlZ2VuZEl0ZW0iLCJ0b2dnbGVEYXRhVmlzaWJpbGl0eSIsInRvb2x0aXBJdGVtIiwiZGF0YUxhYmVsIiwiZm9ybWF0dGVkVmFsdWUiLCJzbGljZSIsIkxpbmVDb250cm9sbGVyIiwibGluZSIsIl9kYXRhc2V0IiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwiX2RhdGFzZXRJbmRleCIsIl9kZWNpbWF0ZWQiLCJzaG93TGluZSIsInNlZ21lbnQiLCJhbmltYXRlZCIsInNwYW5HYXBzIiwibWF4R2FwTGVuZ3RoIiwiZGlyZWN0VXBkYXRlIiwicHJldlBhcnNlZCIsIm51bGxEYXRhIiwiYm9yZGVyIiwiZmlyc3RQb2ludCIsImxhc3RQb2ludCIsInVwZGF0ZUNvbnRyb2xQb2ludHMiLCJQb2xhckFyZWFDb250cm9sbGVyIiwiYmluZCIsIl91cGRhdGVSYWRpdXMiLCJtaW5TaXplIiwiY3V0b3V0UGVyY2VudGFnZSIsImdldFZpc2libGVEYXRhc2V0Q291bnQiLCJ4Q2VudGVyIiwieUNlbnRlciIsImRhdGFzZXRTdGFydEFuZ2xlIiwiZ2V0SW5kZXhBbmdsZSIsImRlZmF1bHRBbmdsZSIsImNvdW50VmlzaWJsZUVsZW1lbnRzIiwiX2NvbXB1dGVBbmdsZSIsImdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlIiwiYW5nbGVMaW5lcyIsImRpc3BsYXkiLCJjaXJjdWxhciIsInBvaW50TGFiZWxzIiwiUGllQ29udHJvbGxlciIsIlJhZGFyQ29udHJvbGxlciIsIl9mdWxsTG9vcCIsInBvaW50UG9zaXRpb24iLCJnZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUiLCJmaWxsIiwiRWxlbWVudCIsInRvb2x0aXBQb3NpdGlvbiIsInVzZUZpbmFsUG9zaXRpb24iLCJnZXRQcm9wcyIsImhhc1ZhbHVlIiwiZmluYWwiLCJyZXQiLCJkZWZhdWx0Um91dGVzIiwiZm9ybWF0dGVycyIsIm51bWVyaWMiLCJ0aWNrVmFsdWUiLCJub3RhdGlvbiIsImRlbHRhIiwibWF4VGljayIsImNhbGN1bGF0ZURlbHRhIiwibG9nRGVsdGEiLCJudW1EZWNpbWFsIiwibWluaW11bUZyYWN0aW9uRGlnaXRzIiwibWF4aW11bUZyYWN0aW9uRGlnaXRzIiwiZm9ybWF0IiwibG9nYXJpdGhtaWMiLCJwb3ciLCJUaWNrcyIsImJvdW5kcyIsImdyYWNlIiwiZHJhd0JvcmRlciIsImRyYXdPbkNoYXJ0QXJlYSIsImRyYXdUaWNrcyIsInRpY2tMZW5ndGgiLCJ0aWNrV2lkdGgiLCJ0aWNrQ29sb3IiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsInBhZGRpbmciLCJtaW5Sb3RhdGlvbiIsIm1heFJvdGF0aW9uIiwibWlycm9yIiwidGV4dFN0cm9rZVdpZHRoIiwidGV4dFN0cm9rZUNvbG9yIiwiYXV0b1NraXAiLCJhdXRvU2tpcFBhZGRpbmciLCJsYWJlbE9mZnNldCIsIm1pbm9yIiwibWFqb3IiLCJhbGlnbiIsImNyb3NzQWxpZ24iLCJzaG93TGFiZWxCYWNrZHJvcCIsImJhY2tkcm9wQ29sb3IiLCJiYWNrZHJvcFBhZGRpbmciLCJyb3V0ZSIsInN0YXJ0c1dpdGgiLCJ0aWNrT3B0cyIsInRpY2tzTGltaXQiLCJtYXhUaWNrc0xpbWl0IiwiZGV0ZXJtaW5lTWF4VGlja3MiLCJtYWpvckluZGljZXMiLCJlbmFibGVkIiwiZ2V0TWFqb3JJbmRpY2VzIiwibnVtTWFqb3JJbmRpY2VzIiwiZmlyc3QiLCJuZXdUaWNrcyIsInNraXBNYWpvcnMiLCJjYWxjdWxhdGVTcGFjaW5nIiwiYXZnTWFqb3JTcGFjaW5nIiwicm91bmQiLCJfdGlja1NpemUiLCJtYXhTY2FsZSIsIm1heENoYXJ0IiwiX21heExlbmd0aCIsImV2ZW5NYWpvclNwYWNpbmciLCJnZXRFdmVuU3BhY2luZyIsImZhY3RvcnMiLCJyZXN1bHQiLCJjZWlsIiwibWFqb3JTdGFydCIsIm1ham9yRW5kIiwibGVuIiwiZGlmZiIsInJldmVyc2VBbGlnbiIsIm9mZnNldEZyb21FZGdlIiwic2FtcGxlIiwibnVtSXRlbXMiLCJpbmNyZW1lbnQiLCJnZXRQaXhlbEZvckdyaWRMaW5lIiwib2Zmc2V0R3JpZExpbmVzIiwidmFsaWRJbmRleCIsImVwc2lsb24iLCJsaW5lVmFsdWUiLCJnYXJiYWdlQ29sbGVjdCIsImNhY2hlcyIsImdjIiwiZ2NMZW4iLCJnZXRUaWNrTWFya0xlbmd0aCIsImdldFRpdGxlSGVpZ2h0IiwiZmFsbGJhY2siLCJmb250IiwibGluZXMiLCJsaW5lSGVpZ2h0IiwiY3JlYXRlU2NhbGVDb250ZXh0IiwiY3JlYXRlVGlja0NvbnRleHQiLCJ0aXRsZUFsaWduIiwicG9zaXRpb24iLCJ0aXRsZUFyZ3MiLCJ0aXRsZVgiLCJ0aXRsZVkiLCJwb3NpdGlvbkF4aXNJRCIsIlNjYWxlIiwiaW5pdCIsInNldENvbnRleHQiLCJfdXNlck1pbiIsIl91c2VyTWF4IiwiX3N1Z2dlc3RlZE1pbiIsInN1Z2dlc3RlZE1pbiIsIl9zdWdnZXN0ZWRNYXgiLCJzdWdnZXN0ZWRNYXgiLCJtZXRhcyIsImdldFBhZGRpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nUmlnaHQiLCJwYWRkaW5nQm90dG9tIiwiZ2V0VGlja3MiLCJ4TGFiZWxzIiwieUxhYmVscyIsImJlZm9yZUxheW91dCIsIl9kYXRhTGltaXRzQ2FjaGVkIiwiYmVmb3JlVXBkYXRlIiwibWFyZ2lucyIsInNhbXBsZVNpemUiLCJfbWFyZ2lucyIsIl9sYWJlbFNpemVzIiwiX2dyaWRMaW5lSXRlbXMiLCJfbGFiZWxJdGVtcyIsImJlZm9yZVNldERpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwiYWZ0ZXJTZXREaW1lbnNpb25zIiwiYmVmb3JlRGF0YUxpbWl0cyIsImRldGVybWluZURhdGFMaW1pdHMiLCJhZnRlckRhdGFMaW1pdHMiLCJfcmFuZ2UiLCJiZWZvcmVCdWlsZFRpY2tzIiwiYnVpbGRUaWNrcyIsImFmdGVyQnVpbGRUaWNrcyIsInNhbXBsaW5nRW5hYmxlZCIsIl9jb252ZXJ0VGlja3NUb0xhYmVscyIsImJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24iLCJjYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwiYWZ0ZXJDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwic291cmNlIiwiYWZ0ZXJBdXRvU2tpcCIsImJlZm9yZUZpdCIsImZpdCIsImFmdGVyRml0IiwiYWZ0ZXJVcGRhdGUiLCJyZXZlcnNlUGl4ZWxzIiwiX3JldmVyc2VQaXhlbHMiLCJfYWxpZ25Ub1BpeGVscyIsImFsaWduVG9QaXhlbHMiLCJfY2FsbEhvb2tzIiwibm90aWZ5UGx1Z2lucyIsImJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbiIsImdlbmVyYXRlVGlja0xhYmVscyIsImFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uIiwibnVtVGlja3MiLCJsYWJlbFJvdGF0aW9uIiwibWF4TGFiZWxEaWFnb25hbCIsIl9pc1Zpc2libGUiLCJsYWJlbFNpemVzIiwiX2dldExhYmVsU2l6ZXMiLCJtYXhMYWJlbFdpZHRoIiwid2lkZXN0IiwibWF4TGFiZWxIZWlnaHQiLCJoaWdoZXN0Iiwic3FydCIsImFzaW4iLCJ0aXRsZU9wdHMiLCJncmlkT3B0cyIsInRpdGxlSGVpZ2h0IiwidGlja1BhZGRpbmciLCJhbmdsZVJhZGlhbnMiLCJsYWJlbEhlaWdodCIsImxhYmVsV2lkdGgiLCJfY2FsY3VsYXRlUGFkZGluZyIsIl9oYW5kbGVNYXJnaW5zIiwiaXNSb3RhdGVkIiwibGFiZWxzQmVsb3dUaWNrcyIsIm9mZnNldExlZnQiLCJvZmZzZXRSaWdodCIsImlzRnVsbFNpemUiLCJmdWxsU2l6ZSIsIl9jb21wdXRlTGFiZWxTaXplcyIsIl9sb25nZXN0VGV4dENhY2hlIiwid2lkdGhzIiwiaGVpZ2h0cyIsIndpZGVzdExhYmVsU2l6ZSIsImhpZ2hlc3RMYWJlbFNpemUiLCJqbGVuIiwidGlja0ZvbnQiLCJmb250U3RyaW5nIiwibmVzdGVkTGFiZWwiLCJfcmVzb2x2ZVRpY2tGb250T3B0aW9ucyIsInN0cmluZyIsInZhbHVlQXQiLCJpZHgiLCJnZXRWYWx1ZUZvclBpeGVsIiwicGl4ZWwiLCJkZWNpbWFsIiwiZ2V0RGVjaW1hbEZvclBpeGVsIiwiZ2V0QmFzZVZhbHVlIiwib3B0aW9uVGlja3MiLCJyb3QiLCJfY29tcHV0ZUdyaWRMaW5lSXRlbXMiLCJ0aWNrc0xlbmd0aCIsInRsIiwiYm9yZGVyT3B0cyIsImF4aXNXaWR0aCIsImF4aXNIYWxmV2lkdGgiLCJhbGlnbkJvcmRlclZhbHVlIiwiYm9yZGVyVmFsdWUiLCJhbGlnbmVkTGluZVZhbHVlIiwidHgxIiwidHkxIiwidHgyIiwidHkyIiwieDEiLCJ5MSIsIngyIiwieTIiLCJsaW1pdCIsInN0ZXAiLCJvcHRzQXRJbmRleCIsImxpbmVDb2xvciIsInRpY2tCb3JkZXJEYXNoIiwidGlja0JvcmRlckRhc2hPZmZzZXQiLCJfdGlja3NMZW5ndGgiLCJfYm9yZGVyVmFsdWUiLCJfY29tcHV0ZUxhYmVsSXRlbXMiLCJ0aWNrQW5kUGFkZGluZyIsImhUaWNrQW5kUGFkZGluZyIsInRleHRBbGlnbiIsImxpbmVDb3VudCIsInRleHRPZmZzZXQiLCJ0ZXh0QmFzZWxpbmUiLCJfZ2V0WEF4aXNMYWJlbEFsaWdubWVudCIsIl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50IiwiaGFsZkNvdW50Iiwic3Ryb2tlQ29sb3IiLCJzdHJva2VXaWR0aCIsInRpY2tUZXh0QWxpZ24iLCJiYWNrZHJvcCIsImxhYmVsUGFkZGluZyIsInRyYW5zbGF0aW9uIiwiX2NvbXB1dGVMYWJlbEFyZWEiLCJkcmF3QmFja2dyb3VuZCIsInNhdmUiLCJmaWxsUmVjdCIsInJlc3RvcmUiLCJmaW5kSW5kZXgiLCJkcmF3R3JpZCIsImRyYXdMaW5lIiwicDEiLCJwMiIsInNldExpbmVEYXNoIiwibGluZURhc2hPZmZzZXQiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJzdHJva2UiLCJsYXN0TGluZVdpZHRoIiwiZHJhd0xhYmVscyIsImRyYXdUaXRsZSIsIl9sYXllcnMiLCJ0eiIsImd6IiwiZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcyIsImF4aXNJRCIsIl9tYXhEaWdpdHMiLCJmb250U2l6ZSIsIlR5cGVkUmVnaXN0cnkiLCJpc0ZvclR5cGUiLCJpc1Byb3RvdHlwZU9mIiwicmVnaXN0ZXIiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicGFyZW50U2NvcGUiLCJpc0lDaGFydENvbXBvbmVudCIsInNjb3BlIiwiRXJyb3IiLCJyZWdpc3RlckRlZmF1bHRzIiwib3ZlcnJpZGUiLCJ1bnJlZ2lzdGVyIiwiY3JlYXRlIiwiaXRlbURlZmF1bHRzIiwicm91dGVEZWZhdWx0cyIsInJvdXRlcyIsInByb3BlcnR5IiwicHJvcGVydHlQYXJ0cyIsInNwbGl0Iiwic291cmNlTmFtZSIsInNvdXJjZVNjb3BlIiwiam9pbiIsInBhcnRzIiwidGFyZ2V0TmFtZSIsInRhcmdldFNjb3BlIiwiUmVnaXN0cnkiLCJfZWFjaCIsImFkZENvbnRyb2xsZXJzIiwiY29udHJvbGxlcnMiLCJhZGRQbHVnaW5zIiwiYWRkU2NhbGVzIiwiZ2V0Q29udHJvbGxlciIsIl9nZXQiLCJnZXRFbGVtZW50IiwiZ2V0UGx1Z2luIiwiZ2V0U2NhbGUiLCJyZW1vdmVDb250cm9sbGVycyIsInJlbW92ZUVsZW1lbnRzIiwicmVtb3ZlUGx1Z2lucyIsInJlbW92ZVNjYWxlcyIsInR5cGVkUmVnaXN0cnkiLCJhcmciLCJyZWciLCJfZ2V0UmVnaXN0cnlGb3JUeXBlIiwiX2V4ZWMiLCJpdGVtUmVnIiwicmVnaXN0cnkiLCJjb21wb25lbnQiLCJjYW1lbE1ldGhvZCIsIl90eXBlZFJlZ2lzdHJpZXMiLCJTY2F0dGVyQ29udHJvbGxlciIsImludGVyYWN0aW9uIiwiX19wcm90b19fIiwiYWJzdHJhY3QiLCJEYXRlQWRhcHRlciIsImNoYXJ0T3B0aW9ucyIsImZvcm1hdHMiLCJ0aW1lc3RhbXAiLCJhbW91bnQiLCJ1bml0Iiwic3RhcnRPZiIsIndlZWtkYXkiLCJlbmRPZiIsIm1lbWJlcnMiLCJhZGFwdGVycyIsIl9kYXRlIiwiYmluYXJ5U2VhcmNoIiwibWV0YXNldCIsImludGVyc2VjdCIsImxvb2t1cE1ldGhvZCIsImVsIiwiZ2V0UmFuZ2UiLCJsbyIsImhpIiwiZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zIiwiaGFuZGxlciIsImdldERpc3RhbmNlTWV0cmljRm9yQXhpcyIsInVzZVgiLCJ1c2VZIiwicHQxIiwicHQyIiwiZGVsdGFYIiwiZGVsdGFZIiwiZ2V0SW50ZXJzZWN0SXRlbXMiLCJpbmNsdWRlSW52aXNpYmxlIiwiaXNQb2ludEluQXJlYSIsImV2YWx1YXRpb25GdW5jIiwiaW5SYW5nZSIsImdldE5lYXJlc3RSYWRpYWxJdGVtcyIsImdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyIsImRpc3RhbmNlTWV0cmljIiwibWluRGlzdGFuY2UiLCJnZXRDZW50ZXJQb2ludCIsInBvaW50SW5BcmVhIiwiZGlzdGFuY2UiLCJnZXROZWFyZXN0SXRlbXMiLCJnZXRBeGlzSXRlbXMiLCJyYW5nZU1ldGhvZCIsImludGVyc2VjdHNJdGVtIiwiSW50ZXJhY3Rpb24iLCJtb2RlcyIsIm5lYXJlc3QiLCJTVEFUSUNfUE9TSVRJT05TIiwiZmlsdGVyQnlQb3NpdGlvbiIsImFycmF5IiwicG9zIiwiZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzIiwiYm94Iiwic29ydEJ5V2VpZ2h0IiwidjAiLCJ3cmFwQm94ZXMiLCJib3hlcyIsImxheW91dEJveGVzIiwic3RhY2tXZWlnaHQiLCJidWlsZFN0YWNrcyIsImxheW91dHMiLCJ3cmFwIiwiaW5jbHVkZXMiLCJfc3RhY2siLCJwbGFjZWQiLCJzZXRMYXlvdXREaW1zIiwicGFyYW1zIiwidkJveE1heFdpZHRoIiwiaEJveE1heEhlaWdodCIsImxheW91dCIsImF2YWlsYWJsZVdpZHRoIiwiYXZhaWxhYmxlSGVpZ2h0IiwiYnVpbGRMYXlvdXRCb3hlcyIsImNlbnRlckhvcml6b250YWwiLCJjZW50ZXJWZXJ0aWNhbCIsImxlZnRBbmRUb3AiLCJyaWdodEFuZEJvdHRvbSIsInZlcnRpY2FsIiwiZ2V0Q29tYmluZWRNYXgiLCJtYXhQYWRkaW5nIiwidXBkYXRlTWF4UGFkZGluZyIsImJveFBhZGRpbmciLCJ1cGRhdGVEaW1zIiwibmV3V2lkdGgiLCJvdXRlcldpZHRoIiwibmV3SGVpZ2h0Iiwib3V0ZXJIZWlnaHQiLCJ3aWR0aENoYW5nZWQiLCJoZWlnaHRDaGFuZ2VkIiwic2FtZSIsIm90aGVyIiwiaGFuZGxlTWF4UGFkZGluZyIsInVwZGF0ZVBvcyIsImNoYW5nZSIsImdldE1hcmdpbnMiLCJtYXJnaW5Gb3JQb3NpdGlvbnMiLCJwb3NpdGlvbnMiLCJtYXJnaW4iLCJmaXRCb3hlcyIsInJlZml0Qm94ZXMiLCJyZWZpdCIsImNoYW5nZWQiLCJzZXRCb3hEaW1zIiwicGxhY2VCb3hlcyIsInVzZXJQYWRkaW5nIiwiYXV0b1BhZGRpbmciLCJhZGRCb3giLCJyZW1vdmVCb3giLCJsYXlvdXRJdGVtIiwibWluUGFkZGluZyIsInZlcnRpY2FsQm94ZXMiLCJob3Jpem9udGFsQm94ZXMiLCJ2aXNpYmxlVmVydGljYWxCb3hDb3VudCIsIkJhc2VQbGF0Zm9ybSIsImFjcXVpcmVDb250ZXh0IiwiY2FudmFzIiwicmVsZWFzZUNvbnRleHQiLCJhZGRFdmVudExpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImlzQXR0YWNoZWQiLCJ1cGRhdGVDb25maWciLCJCYXNpY1BsYXRmb3JtIiwiRVhQQU5ET19LRVkiLCJFVkVOVF9UWVBFUyIsInRvdWNoc3RhcnQiLCJ0b3VjaG1vdmUiLCJ0b3VjaGVuZCIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVybGVhdmUiLCJwb2ludGVyb3V0IiwiaXNOdWxsT3JFbXB0eSIsImluaXRDYW52YXMiLCJyZW5kZXJIZWlnaHQiLCJnZXRBdHRyaWJ1dGUiLCJyZW5kZXJXaWR0aCIsImJveFNpemluZyIsImRpc3BsYXlXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJldmVudExpc3RlbmVyT3B0aW9ucyIsInBhc3NpdmUiLCJhZGRMaXN0ZW5lciIsIm5vZGUiLCJyZW1vdmVMaXN0ZW5lciIsImZyb21OYXRpdmVFdmVudCIsIm5hdGl2ZSIsIm5vZGVMaXN0Q29udGFpbnMiLCJub2RlTGlzdCIsImNvbnRhaW5zIiwiY3JlYXRlQXR0YWNoT2JzZXJ2ZXIiLCJvYnNlcnZlciIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwidHJpZ2dlciIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJvYnNlcnZlIiwiZG9jdW1lbnQiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiY3JlYXRlRGV0YWNoT2JzZXJ2ZXIiLCJkcnBMaXN0ZW5pbmdDaGFydHMiLCJvbGREZXZpY2VQaXhlbFJhdGlvIiwib25XaW5kb3dSZXNpemUiLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsInVubGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMiLCJjcmVhdGVSZXNpemVPYnNlcnZlciIsImNvbnRhaW5lciIsImNsaWVudFdpZHRoIiwiUmVzaXplT2JzZXJ2ZXIiLCJjb250ZW50UmVjdCIsInJlbGVhc2VPYnNlcnZlciIsImRpc2Nvbm5lY3QiLCJjcmVhdGVQcm94eUFuZExpc3RlbiIsInByb3h5IiwiRG9tUGxhdGZvcm0iLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJwcm94aWVzIiwiJHByb3hpZXMiLCJoYW5kbGVycyIsImF0dGFjaCIsImRldGFjaCIsImlzQ29ubmVjdGVkIiwiX2RldGVjdFBsYXRmb3JtIiwiT2Zmc2NyZWVuQ2FudmFzIiwiUGx1Z2luU2VydmljZSIsIm5vdGlmeSIsImhvb2siLCJfaW5pdCIsIl9jcmVhdGVEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3IiLCJwbHVnaW4iLCJjYW5jZWxhYmxlIiwiaW52YWxpZGF0ZSIsIl9vbGRDYWNoZSIsIl9ub3RpZnlTdGF0ZUNoYW5nZXMiLCJhbGxQbHVnaW5zIiwiY3JlYXRlRGVzY3JpcHRvcnMiLCJwcmV2aW91c0Rlc2NyaXB0b3JzIiwic29tZSIsImxvY2FsSWRzIiwibG9jYWwiLCJnZXRPcHRzIiwicGx1Z2luT3B0cyIsInBsdWdpblNjb3BlS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJhbGxLZXlzIiwiZ2V0SW5kZXhBeGlzIiwiZGF0YXNldERlZmF1bHRzIiwiZGF0YXNldE9wdGlvbnMiLCJnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEIiwiZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyIsImF4aXNGcm9tUG9zaXRpb24iLCJkZXRlcm1pbmVBeGlzIiwic2NhbGVPcHRpb25zIiwidG9Mb3dlckNhc2UiLCJtZXJnZVNjYWxlQ29uZmlnIiwiY2hhcnREZWZhdWx0cyIsImNvbmZpZ1NjYWxlcyIsImNoYXJ0SW5kZXhBeGlzIiwiZmlyc3RJRHMiLCJzY2FsZUNvbmYiLCJjb25zb2xlIiwiZXJyb3IiLCJfcHJveHkiLCJ3YXJuIiwiZGVmYXVsdElkIiwiZGVmYXVsdFNjYWxlT3B0aW9ucyIsImRlZmF1bHRJRCIsImluaXRPcHRpb25zIiwiaW5pdERhdGEiLCJpbml0Q29uZmlnIiwia2V5Q2FjaGUiLCJrZXlzQ2FjaGVkIiwiU2V0IiwiY2FjaGVkS2V5cyIsImdlbmVyYXRlIiwiYWRkSWZGb3VuZCIsIkNvbmZpZyIsInBsYXRmb3JtIiwiX2NvbmZpZyIsImNsZWFyQ2FjaGUiLCJfc2NvcGVDYWNoZSIsImNsZWFyIiwiX3Jlc29sdmVyQ2FjaGUiLCJkYXRhc2V0VHlwZSIsImFkZGl0aW9uYWxPcHRpb25TY29wZXMiLCJfY2FjaGVkU2NvcGVzIiwibWFpblNjb3BlIiwicmVzZXRDYWNoZSIsImtleUxpc3RzIiwiY2hhcnRPcHRpb25TY29wZXMiLCJyZXNvbHZlciIsInN1YlByZWZpeGVzIiwiZ2V0UmVzb2x2ZXIiLCJuZWVkQ29udGV4dCIsInN1YlJlc29sdmVyIiwiZGVzY3JpcHRvckRlZmF1bHRzIiwicmVzb2x2ZXJDYWNoZSIsImhhc0Z1bmN0aW9uIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJ2ZXJzaW9uIiwiS05PV05fUE9TSVRJT05TIiwicG9zaXRpb25Jc0hvcml6b250YWwiLCJjb21wYXJlMkxldmVsIiwibDEiLCJsMiIsIm9uQW5pbWF0aW9uc0NvbXBsZXRlIiwib25Db21wbGV0ZSIsIm9uQW5pbWF0aW9uUHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwiZ2V0Q2FudmFzIiwiZ2V0RWxlbWVudEJ5SWQiLCJpbnN0YW5jZXMiLCJnZXRDaGFydCIsIm1vdmVOdW1lcmljS2V5cyIsImludEtleSIsImRldGVybWluZUxhc3RFdmVudCIsImxhc3RFdmVudCIsImluQ2hhcnRBcmVhIiwiaXNDbGljayIsIkNoYXJ0IiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsIl9hc3BlY3RSYXRpbyIsIl9vcHRpb25zIiwiX2luaXRpYWxpemUiLCJyZXNwb25zaXZlIiwiYmluZEV2ZW50cyIsIl9yZXNpemUiLCJfcmVzaXplQmVmb3JlRHJhdyIsIm5ld1NpemUiLCJuZXdSYXRpbyIsIm9uUmVzaXplIiwiYXR0YWNoZWQiLCJfZG9SZXNpemUiLCJyZW5kZXIiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwic2NhbGVzT3B0aW9ucyIsImF4aXNPcHRpb25zIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsInNjYWxlT3B0cyIsInVwZGF0ZWQiLCJpc1JhZGlhbCIsImRwb3NpdGlvbiIsImR0eXBlIiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsImhhc1VwZGF0ZWQiLCJfdXBkYXRlTWV0YXNldHMiLCJfbWV0YXNldHMiLCJfZGVzdHJveURhdGFzZXRNZXRhIiwiX3NvcnRlZE1ldGFzZXRzIiwiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJvcmRlciIsIkNvbnRyb2xsZXJDbGFzcyIsIl9yZXNldEVsZW1lbnRzIiwiYW5pbXNEaXNhYmxlZCIsIl91cGRhdGVTY2FsZXMiLCJfY2hlY2tFdmVudEJpbmRpbmdzIiwiX3VwZGF0ZUhpZGRlbkluZGljZXMiLCJfcGx1Z2lucyIsIl9taW5QYWRkaW5nIiwiX3VwZGF0ZUxheW91dCIsIl91cGRhdGVEYXRhc2V0cyIsIl9sYXN0RXZlbnQiLCJfZXZlbnRIYW5kbGVyIiwiX3VwZGF0ZUhvdmVyU3R5bGVzIiwiZXhpc3RpbmdFdmVudHMiLCJfbGlzdGVuZXJzIiwibmV3RXZlbnRzIiwiZXZlbnRzIiwiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCJ1bmJpbmRFdmVudHMiLCJfaGlkZGVuSW5kaWNlcyIsImNoYW5nZXMiLCJfZ2V0VW5pZm9ybURhdGFDaGFuZ2VzIiwiZGF0YXNldENvdW50IiwibWFrZVNldCIsImNoYW5nZVNldCIsIm5vQXJlYSIsIl9pZHgiLCJfdXBkYXRlRGF0YXNldCIsImxheWVycyIsIl9kcmF3RGF0YXNldHMiLCJfZHJhd0RhdGFzZXQiLCJ1c2VDbGlwIiwiZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZSIsInNldERhdGFzZXRWaXNpYmlsaXR5IiwiX3VwZGF0ZVZpc2liaWxpdHkiLCJfc3RvcCIsImRlc3Ryb3kiLCJ0b0Jhc2U2NEltYWdlIiwidG9EYXRhVVJMIiwiYmluZFVzZXJFdmVudHMiLCJiaW5kUmVzcG9uc2l2ZUV2ZW50cyIsIl9hZGQiLCJfcmVtb3ZlIiwiZGV0YWNoZWQiLCJ1cGRhdGVIb3ZlclN0eWxlIiwicHJlZml4IiwiZ2V0QWN0aXZlRWxlbWVudHMiLCJzZXRBY3RpdmVFbGVtZW50cyIsImFjdGl2ZUVsZW1lbnRzIiwibGFzdEFjdGl2ZSIsInJlcGxheSIsImhvdmVyT3B0aW9ucyIsImhvdmVyIiwiZGVhY3RpdmF0ZWQiLCJhY3RpdmF0ZWQiLCJldmVudEZpbHRlciIsIl9oYW5kbGVFdmVudCIsIl9nZXRBY3RpdmVFbGVtZW50cyIsIm9uSG92ZXIiLCJ1c2VyQ29uZmlnIiwiaW5pdGlhbENhbnZhcyIsImV4aXN0aW5nQ2hhcnQiLCJyZXNpemVEZWxheSIsImludmFsaWRhdGVQbHVnaW5zIiwiZW51bWVyYWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJjbGlwQXJjIiwicGl4ZWxNYXJnaW4iLCJhbmdsZU1hcmdpbiIsImNsb3NlUGF0aCIsInRvUmFkaXVzQ29ybmVycyIsInBhcnNlQm9yZGVyUmFkaXVzJDEiLCJhbmdsZURlbHRhIiwiYm9yZGVyUmFkaXVzIiwiaGFsZlRoaWNrbmVzcyIsImlubmVyTGltaXQiLCJjb21wdXRlT3V0ZXJMaW1pdCIsIm91dGVyQXJjTGltaXQiLCJvdXRlclN0YXJ0Iiwib3V0ZXJFbmQiLCJpbm5lclN0YXJ0IiwiaW5uZXJFbmQiLCJyVGhldGFUb1hZIiwidGhldGEiLCJwYXRoQXJjIiwiaW5uZXJSIiwic3BhY2luZ09mZnNldCIsImFscGhhIiwibm9TcGFjaW5nSW5uZXJSYWRpdXMiLCJub1NwYWNpbmdPdXRlclJhZGl1cyIsImF2Tm9nU3BhY2luZ1JhZGl1cyIsImFkanVzdGVkQW5nbGUiLCJiZXRhIiwiYW5nbGVPZmZzZXQiLCJvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCJvdXRlckVuZEFkanVzdGVkUmFkaXVzIiwib3V0ZXJTdGFydEFkanVzdGVkQW5nbGUiLCJvdXRlckVuZEFkanVzdGVkQW5nbGUiLCJpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMiLCJpbm5lckVuZEFkanVzdGVkUmFkaXVzIiwiaW5uZXJTdGFydEFkanVzdGVkQW5nbGUiLCJpbm5lckVuZEFkanVzdGVkQW5nbGUiLCJwQ2VudGVyIiwicDQiLCJwOCIsIm91dGVyU3RhcnRYIiwib3V0ZXJTdGFydFkiLCJvdXRlckVuZFgiLCJvdXRlckVuZFkiLCJkcmF3QXJjIiwiZnVsbENpcmNsZXMiLCJkcmF3RnVsbENpcmNsZUJvcmRlcnMiLCJpbm5lciIsImJvcmRlckpvaW5TdHlsZSIsImxpbmVKb2luIiwiQXJjRWxlbWVudCIsImNoYXJ0WCIsImNoYXJ0WSIsInJBZGp1c3QiLCJiZXR3ZWVuQW5nbGVzIiwid2l0aGluUmFkaXVzIiwiaGFsZkFuZ2xlIiwiaGFsZlJhZGl1cyIsInJhZGl1c09mZnNldCIsInRyYW5zbGF0ZSIsInNldFN0eWxlIiwibGluZUNhcCIsImJvcmRlckNhcFN0eWxlIiwicHJldmlvdXMiLCJnZXRMaW5lTWV0aG9kIiwic3RlcHBlZCIsInRlbnNpb24iLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwicGF0aFZhcnMiLCJwYXJhbXNTdGFydCIsInBhcmFtc0VuZCIsInNlZ21lbnRTdGFydCIsInNlZ21lbnRFbmQiLCJvdXRzaWRlIiwicGF0aFNlZ21lbnQiLCJsaW5lTWV0aG9kIiwiZmFzdFBhdGhTZWdtZW50IiwiYXZnWCIsImNvdW50WCIsInByZXZYIiwibGFzdFkiLCJwb2ludEluZGV4IiwiZHJhd1giLCJ0cnVuY1giLCJfZ2V0U2VnbWVudE1ldGhvZCIsInVzZUZhc3RQYXRoIiwiX2dldEludGVycG9sYXRpb25NZXRob2QiLCJzdHJva2VQYXRoV2l0aENhY2hlIiwicGF0aCIsIl9wYXRoIiwiUGF0aDJEIiwic3Ryb2tlUGF0aERpcmVjdCIsInNlZ21lbnRzIiwic2VnbWVudE1ldGhvZCIsInVzZVBhdGgyRCIsIkxpbmVFbGVtZW50IiwiX3BvaW50c1VwZGF0ZWQiLCJfcG9pbnRzIiwiX3NlZ21lbnRzIiwiaW50ZXJwb2xhdGUiLCJfaW50ZXJwb2xhdGUiLCJpbnRlcnBvbGF0ZWQiLCJjYXBCZXppZXJQb2ludHMiLCJpblJhbmdlJDEiLCJoaXRSYWRpdXMiLCJQb2ludEVsZW1lbnQiLCJtb3VzZVgiLCJtb3VzZVkiLCJpblhSYW5nZSIsImluWVJhbmdlIiwiaG92ZXJSYWRpdXMiLCJnZXRCYXJCb3VuZHMiLCJiYXIiLCJoYWxmIiwic2tpcE9yTGltaXQiLCJwYXJzZUJvcmRlcldpZHRoIiwibWF4VyIsIm1heEgiLCJwYXJzZUJvcmRlclJhZGl1cyIsIm1heFIiLCJlbmFibGVCb3JkZXIiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJib3VuZGluZ1JlY3RzIiwib3V0ZXIiLCJza2lwWCIsInNraXBZIiwic2tpcEJvdGgiLCJoYXNSYWRpdXMiLCJhZGROb3JtYWxSZWN0UGF0aCIsInJlY3QiLCJpbmZsYXRlUmVjdCIsInJlZlJlY3QiLCJCYXJFbGVtZW50IiwiYWRkUmVjdFBhdGgiLCJsdHRiRGVjaW1hdGlvbiIsInNhbXBsZXMiLCJkZWNpbWF0ZWQiLCJidWNrZXRXaWR0aCIsInNhbXBsZWRJbmRleCIsImVuZEluZGV4IiwibWF4QXJlYVBvaW50IiwibWF4QXJlYSIsIm5leHRBIiwiYXZnWSIsImF2Z1JhbmdlU3RhcnQiLCJhdmdSYW5nZUVuZCIsImF2Z1JhbmdlTGVuZ3RoIiwicmFuZ2VPZmZzIiwicmFuZ2VUbyIsInBvaW50QXgiLCJwb2ludEF5IiwibWluTWF4RGVjaW1hdGlvbiIsIm1pbkluZGV4IiwibWF4SW5kZXgiLCJzdGFydEluZGV4IiwieE1pbiIsInhNYXgiLCJkeCIsImxhc3RJbmRleCIsImludGVybWVkaWF0ZUluZGV4MSIsImludGVybWVkaWF0ZUluZGV4MiIsImNsZWFuRGVjaW1hdGVkRGF0YXNldCIsImRlZmluZVByb3BlcnR5IiwiY2xlYW5EZWNpbWF0ZWREYXRhIiwiZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQiLCJwb2ludENvdW50IiwicGx1Z2luX2RlY2ltYXRpb24iLCJhbGdvcml0aG0iLCJiZWZvcmVFbGVtZW50c1VwZGF0ZSIsInhBeGlzIiwidGhyZXNob2xkIiwiY29uZmlndXJhYmxlIiwidHBvaW50cyIsIl9maW5kU2VnbWVudEVuZCIsIl9nZXRCb3VuZHMiLCJ0YXJnZXRTZWdtZW50cyIsInRndCIsInN1YkJvdW5kcyIsImZpbGxTb3VyY2VzIiwiZmlsbFNvdXJjZSIsIl9nZXRFZGdlIiwiX3BvaW50c0Zyb21TZWdtZW50cyIsImJvdW5kYXJ5IiwibGluZVBvaW50cyIsIl9jcmVhdGVCb3VuZGFyeUxpbmUiLCJfc2hvdWxkQXBwbHlGaWxsIiwiX3Jlc29sdmVUYXJnZXQiLCJzb3VyY2VzIiwicHJvcGFnYXRlIiwidmlzaXRlZCIsIl9kZWNvZGVGaWxsIiwicGFyc2VGaWxsT3B0aW9uIiwicGFyc2VGbG9hdCIsImRlY29kZVRhcmdldEluZGV4IiwiZmlyc3RDaCIsIl9nZXRUYXJnZXRQaXhlbCIsIl9nZXRUYXJnZXRWYWx1ZSIsImZpbGxPcHRpb24iLCJfYnVpbGRTdGFja0xpbmUiLCJzb3VyY2VQb2ludHMiLCJsaW5lc0JlbG93IiwiZ2V0TGluZXNCZWxvdyIsImFkZFBvaW50c0JlbG93IiwiYmVsb3ciLCJ1bnNoaWZ0Iiwic291cmNlUG9pbnQiLCJwb3N0cG9uZWQiLCJmaW5kUG9pbnQiLCJwb2ludFZhbHVlIiwiZmlyc3RWYWx1ZSIsImxhc3RWYWx1ZSIsInNpbXBsZUFyYyIsIl9nZXRUYXJnZXQiLCJnZXRMaW5lQnlJbmRleCIsImNvbXB1dGVCb3VuZGFyeSIsImNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5IiwiY29tcHV0ZUxpbmVhckJvdW5kYXJ5IiwiX2RyYXdmaWxsIiwibGluZU9wdHMiLCJhYm92ZSIsImRvRmlsbCIsImNsaXBWZXJ0aWNhbCIsImNsaXBZIiwibGluZUxvb3AiLCJzcmMiLCJub3RTaGFwZSIsImNsaXBCb3VuZHMiLCJpbnRlcnBvbGF0ZWRMaW5lVG8iLCJ0YXJnZXRMb29wIiwiaW50ZXJwb2xhdGVkUG9pbnQiLCJhZnRlckRhdGFzZXRzVXBkYXRlIiwiX2FyZ3MiLCIkZmlsbGVyIiwiYmVmb3JlRHJhdyIsImRyYXdUaW1lIiwiYmVmb3JlRGF0YXNldHNEcmF3IiwiYmVmb3JlRGF0YXNldERyYXciLCJnZXRCb3hTaXplIiwibGFiZWxPcHRzIiwiYm94SGVpZ2h0IiwiYm94V2lkdGgiLCJ1c2VQb2ludFN0eWxlIiwicG9pbnRTdHlsZVdpZHRoIiwiaXRlbUhlaWdodCIsIml0ZW1zRXF1YWwiLCJMZWdlbmQiLCJidWlsZExhYmVscyIsImxlZ2VuZEl0ZW1zIiwibGFiZWxGb250IiwiX2NvbXB1dGVUaXRsZUhlaWdodCIsIl9maXRSb3dzIiwiX2ZpdENvbHMiLCJoaXRib3hlcyIsImxlZ2VuZEhpdEJveGVzIiwibGluZVdpZHRocyIsInRvdGFsSGVpZ2h0Iiwicm93IiwiaXRlbVdpZHRoIiwibWVhc3VyZVRleHQiLCJjb2x1bW5TaXplcyIsImhlaWdodExpbWl0IiwidG90YWxXaWR0aCIsImN1cnJlbnRDb2xXaWR0aCIsImN1cnJlbnRDb2xIZWlnaHQiLCJjb2wiLCJhZGp1c3RIaXRCb3hlcyIsInJ0bCIsInJ0bEhlbHBlciIsImhpdGJveCIsImxlZnRGb3JMdHIiLCJfZHJhdyIsImRlZmF1bHRDb2xvciIsImZvbnRDb2xvciIsImhhbGZGb250U2l6ZSIsImN1cnNvciIsImRyYXdMZWdlbmRCb3giLCJsaW5lRGFzaCIsImRyYXdPcHRpb25zIiwiU1FSVDIiLCJ4UGx1cyIsInlCb3hUb3AiLCJ4Qm94TGVmdCIsImZpbGxUZXh0Iiwic3RyaWtldGhyb3VnaCIsInRleHREaXJlY3Rpb24iLCJ0ZXh0V2lkdGgiLCJzZXRXaWR0aCIsInJlYWxYIiwidGl0bGVGb250IiwidGl0bGVQYWRkaW5nIiwidG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUiLCJfZ2V0TGVnZW5kSXRlbUF0IiwiaGl0Qm94IiwibGgiLCJoYW5kbGVFdmVudCIsImlzTGlzdGVuZWQiLCJob3ZlcmVkSXRlbSIsIl9ob3ZlcmVkSXRlbSIsInNhbWVJdGVtIiwib25MZWF2ZSIsIl9hZGRlZCIsImRvdWdobnV0TW9kZSIsInBsdWdpbl9sZWdlbmQiLCJfZWxlbWVudCIsImFmdGVyRXZlbnQiLCJjaSIsIlRpdGxlIiwiX3BhZGRpbmciLCJ0ZXh0U2l6ZSIsIl9kcmF3QXJncyIsImZvbnRPcHRzIiwiY3JlYXRlVGl0bGUiLCJ0aXRsZUJsb2NrIiwicGx1Z2luX3RpdGxlIiwiV2Vha01hcCIsInBsdWdpbl9zdWJ0aXRsZSIsInBvc2l0aW9uZXJzIiwiYXZlcmFnZSIsImV2ZW50UG9zaXRpb24iLCJuZWFyZXN0RWxlbWVudCIsInRwIiwicHVzaE9yQ29uY2F0IiwidG9QdXNoIiwiYXBwbHkiLCJzcGxpdE5ld2xpbmVzIiwic3RyIiwiU3RyaW5nIiwiY3JlYXRlVG9vbHRpcEl0ZW0iLCJnZXRUb29sdGlwU2l6ZSIsImJvZHkiLCJmb290ZXIiLCJib2R5Rm9udCIsImZvb3RlckZvbnQiLCJ0aXRsZUxpbmVDb3VudCIsImZvb3RlckxpbmVDb3VudCIsImJvZHlMaW5lSXRlbUNvdW50IiwiY29tYmluZWRCb2R5TGVuZ3RoIiwiYm9keUl0ZW0iLCJiZWZvcmUiLCJhZnRlciIsImJlZm9yZUJvZHkiLCJhZnRlckJvZHkiLCJ0aXRsZVNwYWNpbmciLCJ0aXRsZU1hcmdpbkJvdHRvbSIsImJvZHlMaW5lSGVpZ2h0IiwiZGlzcGxheUNvbG9ycyIsImJvZHlTcGFjaW5nIiwiZm9vdGVyTWFyZ2luVG9wIiwiZm9vdGVyU3BhY2luZyIsIndpZHRoUGFkZGluZyIsIm1heExpbmVXaWR0aCIsImRldGVybWluZVlBbGlnbiIsImRvZXNOb3RGaXRXaXRoQWxpZ24iLCJ4QWxpZ24iLCJjYXJldCIsImNhcmV0U2l6ZSIsImNhcmV0UGFkZGluZyIsImRldGVybWluZVhBbGlnbiIsInlBbGlnbiIsImNoYXJ0V2lkdGgiLCJkZXRlcm1pbmVBbGlnbm1lbnQiLCJhbGlnblgiLCJhbGlnblkiLCJwYWRkaW5nQW5kU2l6ZSIsImdldEJhY2tncm91bmRQb2ludCIsImFsaWdubWVudCIsImNvcm5lclJhZGl1cyIsImdldEFsaWduZWRYIiwiZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMiLCJjcmVhdGVUb29sdGlwQ29udGV4dCIsInRvb2x0aXBJdGVtcyIsIm92ZXJyaWRlQ2FsbGJhY2tzIiwiVG9vbHRpcCIsIl9jYWNoZWRBbmltYXRpb25zIiwiX3Rvb2x0aXBJdGVtcyIsImdldFRpdGxlIiwiYmVmb3JlVGl0bGUiLCJhZnRlclRpdGxlIiwiZ2V0QmVmb3JlQm9keSIsImdldEJvZHkiLCJib2R5SXRlbXMiLCJzY29wZWQiLCJiZWZvcmVMYWJlbCIsImFmdGVyTGFiZWwiLCJnZXRBZnRlckJvZHkiLCJnZXRGb290ZXIiLCJiZWZvcmVGb290ZXIiLCJhZnRlckZvb3RlciIsIl9jcmVhdGVJdGVtcyIsImxhYmVsQ29sb3JzIiwibGFiZWxQb2ludFN0eWxlcyIsImxhYmVsVGV4dENvbG9ycyIsIml0ZW1Tb3J0IiwibGFiZWxDb2xvciIsImxhYmVsUG9pbnRTdHlsZSIsImxhYmVsVGV4dENvbG9yIiwiZGF0YVBvaW50cyIsIm9wYWNpdHkiLCJfZXZlbnRQb3NpdGlvbiIsIl9zaXplIiwicG9zaXRpb25BbmRTaXplIiwiYmFja2dyb3VuZFBvaW50IiwiY2FyZXRYIiwiY2FyZXRZIiwiZXh0ZXJuYWwiLCJkcmF3Q2FyZXQiLCJ0b29sdGlwUG9pbnQiLCJjYXJldFBvc2l0aW9uIiwiZ2V0Q2FyZXRQb3NpdGlvbiIsIngzIiwieTMiLCJwdFgiLCJwdFkiLCJwdCIsInRpdGxlQ29sb3IiLCJfZHJhd0NvbG9yQm94IiwiY29sb3JYIiwicnRsQ29sb3JYIiwieU9mZlNldCIsImNvbG9yWSIsIm11bHRpS2V5QmFja2dyb3VuZCIsIm91dGVyWCIsImlubmVyWCIsInN0cm9rZVJlY3QiLCJkcmF3Qm9keSIsImJvZHlBbGlnbiIsInhMaW5lUGFkZGluZyIsImZpbGxMaW5lT2ZUZXh0IiwiYm9keUFsaWduRm9yQ2FsY3VsYXRpb24iLCJ0ZXh0Q29sb3IiLCJib2R5Q29sb3IiLCJkcmF3Rm9vdGVyIiwiZm9vdGVyQWxpZ24iLCJmb290ZXJDb2xvciIsInRvb2x0aXBTaXplIiwicXVhZHJhdGljQ3VydmVUbyIsIl91cGRhdGVBbmltYXRpb25UYXJnZXQiLCJhbmltWCIsImFuaW1ZIiwiX3dpbGxSZW5kZXIiLCJoYXNUb29sdGlwQ29udGVudCIsImdsb2JhbEFscGhhIiwicG9zaXRpb25DaGFuZ2VkIiwiX3Bvc2l0aW9uQ2hhbmdlZCIsIl9pZ25vcmVSZXBsYXlFdmVudHMiLCJwbHVnaW5fdG9vbHRpcCIsImFmdGVySW5pdCIsImFmdGVyRHJhdyIsImxhYmVsQ291bnQiLCJEZWNpbWF0aW9uIiwiRmlsbGVyIiwiU3ViVGl0bGUiLCJhZGRJZlN0cmluZyIsImFkZGVkTGFiZWxzIiwiZmluZE9yQWRkTGFiZWwiLCJsYXN0SW5kZXhPZiIsIkNhdGVnb3J5U2NhbGUiLCJhZGRlZCIsIl9hZGRlZExhYmVscyIsImlzRmluaXRlIiwiX3ZhbHVlUmFuZ2UiLCJfc3RhcnRWYWx1ZSIsImdlbmVyYXRlVGlja3MkMSIsImdlbmVyYXRpb25PcHRpb25zIiwiZGF0YVJhbmdlIiwiTUlOX1NQQUNJTkciLCJwcmVjaXNpb24iLCJtYXhUaWNrcyIsIm1heERpZ2l0cyIsImluY2x1ZGVCb3VuZHMiLCJtYXhTcGFjZXMiLCJybWluIiwicm1heCIsImNvdW50RGVmaW5lZCIsIm1pblNwYWNpbmciLCJuaWNlTWluIiwibmljZU1heCIsIm51bVNwYWNlcyIsImRlY2ltYWxQbGFjZXMiLCJyZWxhdGl2ZUxhYmVsU2l6ZSIsInJhZCIsIkxpbmVhclNjYWxlQmFzZSIsImhhbmRsZVRpY2tSYW5nZU9wdGlvbnMiLCJzZXRNaW4iLCJzZXRNYXgiLCJtaW5TaWduIiwibWF4U2lnbiIsIk1BWF9TQUZFX0lOVEVHRVIiLCJNSU5fU0FGRV9JTlRFR0VSIiwiZ2V0VGlja0xpbWl0Iiwic3RlcFNpemUiLCJjb21wdXRlVGlja0xpbWl0IiwibnVtZXJpY0dlbmVyYXRvck9wdGlvbnMiLCJfZW5kVmFsdWUiLCJMaW5lYXJTY2FsZSIsImlzTWFqb3IiLCJ0aWNrVmFsIiwiZ2VuZXJhdGVUaWNrcyIsImVuZEV4cCIsImVuZFNpZ25pZmljYW5kIiwiZXhwIiwic2lnbmlmaWNhbmQiLCJsYXN0VGljayIsIkxvZ2FyaXRobWljU2NhbGUiLCJfemVybyIsImdldFRpY2tCYWNrZHJvcEhlaWdodCIsIm1lYXN1cmVMYWJlbFNpemUiLCJkZXRlcm1pbmVMaW1pdHMiLCJmaXRXaXRoUG9pbnRMYWJlbHMiLCJsaW1pdHMiLCJ2YWx1ZUNvdW50IiwiX3BvaW50TGFiZWxzIiwicG9pbnRMYWJlbE9wdHMiLCJhZGRpdGlvbmFsQW5nbGUiLCJjZW50ZXJQb2ludExhYmVscyIsImdldFBvaW50TGFiZWxDb250ZXh0IiwiZ2V0UG9pbnRQb3NpdGlvbiIsImRyYXdpbmdBcmVhIiwicGxGb250IiwiaExpbWl0cyIsInZMaW1pdHMiLCJ1cGRhdGVMaW1pdHMiLCJzZXRDZW50ZXJQb2ludCIsIl9wb2ludExhYmVsSXRlbXMiLCJidWlsZFBvaW50TGFiZWxJdGVtcyIsImV4dHJhIiwib3V0ZXJEaXN0YW5jZSIsInBvaW50TGFiZWxQb3NpdGlvbiIsInlGb3JBbmdsZSIsImdldFRleHRBbGlnbkZvckFuZ2xlIiwibGVmdEZvclRleHRBbGlnbiIsImRyYXdQb2ludExhYmVscyIsImJhY2tkcm9wTGVmdCIsImJhY2tkcm9wVG9wIiwiYmFja2Ryb3BXaWR0aCIsImJhY2tkcm9wSGVpZ2h0IiwicGF0aFJhZGl1c0xpbmUiLCJkcmF3UmFkaXVzTGluZSIsImdyaWRMaW5lT3B0cyIsImNyZWF0ZVBvaW50TGFiZWxDb250ZXh0IiwiUmFkaWFsTGluZWFyU2NhbGUiLCJsZWZ0TW92ZW1lbnQiLCJyaWdodE1vdmVtZW50IiwidG9wTW92ZW1lbnQiLCJib3R0b21Nb3ZlbWVudCIsImFuZ2xlTXVsdGlwbGllciIsInNjYWxpbmdGYWN0b3IiLCJnZXRWYWx1ZUZvckRpc3RhbmNlRnJvbUNlbnRlciIsInNjYWxlZERpc3RhbmNlIiwicG9pbnRMYWJlbCIsImRpc3RhbmNlRnJvbUNlbnRlciIsImdldEJhc2VQb3NpdGlvbiIsImdldFBvaW50TGFiZWxQb3NpdGlvbiIsInJvdGF0ZSIsImFuaW1hdGUiLCJJTlRFUlZBTFMiLCJtaWxsaXNlY29uZCIsImNvbW1vbiIsInN0ZXBzIiwic2Vjb25kIiwibWludXRlIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsInF1YXJ0ZXIiLCJ5ZWFyIiwiVU5JVFMiLCJzb3J0ZXIiLCJpbnB1dCIsImFkYXB0ZXIiLCJfYWRhcHRlciIsInBhcnNlciIsImlzb1dlZWtkYXkiLCJfcGFyc2VPcHRzIiwiZGV0ZXJtaW5lVW5pdEZvckF1dG9UaWNrcyIsIm1pblVuaXQiLCJjYXBhY2l0eSIsImludGVydmFsIiwiZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmciLCJkZXRlcm1pbmVNYWpvclVuaXQiLCJhZGRUaWNrIiwidGltZSIsInRpbWVzdGFtcHMiLCJzZXRNYWpvclRpY2tzIiwibWFqb3JVbml0IiwidGlja3NGcm9tVGltZXN0YW1wcyIsIlRpbWVTY2FsZSIsImRpc3BsYXlGb3JtYXRzIiwiX25vcm1hbGl6ZWQiLCJub3JtYWxpemVkIiwiX2FwcGx5Qm91bmRzIiwiX2dldExhYmVsQm91bmRzIiwiZ2V0TGFiZWxUaW1lc3RhbXBzIiwidGltZU9wdHMiLCJfZ2VuZXJhdGUiLCJfdW5pdCIsIl9nZXRMYWJlbENhcGFjaXR5IiwiX21ham9yVW5pdCIsImluaXRPZmZzZXRzIiwib2Zmc2V0QWZ0ZXJBdXRvc2tpcCIsImdldERlY2ltYWxGb3JWYWx1ZSIsIl9vZmZzZXRzIiwiaGFzV2Vla2RheSIsImdldERhdGFUaW1lc3RhbXBzIiwidG9vbHRpcEZvcm1hdCIsImRhdGV0aW1lIiwiX3RpY2tGb3JtYXRGdW5jdGlvbiIsIm1pbm9yRm9ybWF0IiwibWFqb3JGb3JtYXQiLCJmb3JtYXR0ZXIiLCJvZmZzZXRzIiwiX2dldExhYmVsU2l6ZSIsInRpY2tzT3B0cyIsInRpY2tMYWJlbFdpZHRoIiwiY29zUm90YXRpb24iLCJzaW5Sb3RhdGlvbiIsInRpY2tGb250U2l6ZSIsImV4YW1wbGVUaW1lIiwiZXhhbXBsZUxhYmVsIiwibm9ybWFsaXplIiwidGFibGUiLCJwcmV2U291cmNlIiwibmV4dFNvdXJjZSIsInByZXZUYXJnZXQiLCJuZXh0VGFyZ2V0Iiwic3BhbiIsIlRpbWVTZXJpZXNTY2FsZSIsIl9nZXRUaW1lc3RhbXBzRm9yVGFibGUiLCJfdGFibGUiLCJidWlsZExvb2t1cFRhYmxlIiwiX21pblBvcyIsIl90YWJsZVJhbmdlIiwicmVnaXN0ZXJhYmxlcyIsIl9hZGFwdGVycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/dist/chart.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: function() { return /* binding */ _isPointInArea; },\n/* harmony export */   A: function() { return /* binding */ _factorize; },\n/* harmony export */   B: function() { return /* binding */ finiteOrDefault; },\n/* harmony export */   C: function() { return /* binding */ callback; },\n/* harmony export */   D: function() { return /* binding */ _addGrace; },\n/* harmony export */   E: function() { return /* binding */ _limitValue; },\n/* harmony export */   F: function() { return /* binding */ toDegrees; },\n/* harmony export */   G: function() { return /* binding */ _measureText; },\n/* harmony export */   H: function() { return /* binding */ HALF_PI; },\n/* harmony export */   I: function() { return /* binding */ _int16Range; },\n/* harmony export */   J: function() { return /* binding */ _alignPixel; },\n/* harmony export */   K: function() { return /* binding */ toPadding; },\n/* harmony export */   L: function() { return /* binding */ clipArea; },\n/* harmony export */   M: function() { return /* binding */ renderText; },\n/* harmony export */   N: function() { return /* binding */ unclipArea; },\n/* harmony export */   O: function() { return /* binding */ toFont; },\n/* harmony export */   P: function() { return /* binding */ PI; },\n/* harmony export */   Q: function() { return /* binding */ each; },\n/* harmony export */   R: function() { return /* binding */ _toLeftRightCenter; },\n/* harmony export */   S: function() { return /* binding */ _alignStartEnd; },\n/* harmony export */   T: function() { return /* binding */ TAU; },\n/* harmony export */   U: function() { return /* binding */ overrides; },\n/* harmony export */   V: function() { return /* binding */ merge; },\n/* harmony export */   W: function() { return /* binding */ _capitalize; },\n/* harmony export */   X: function() { return /* binding */ getRelativePosition; },\n/* harmony export */   Y: function() { return /* binding */ _rlookupByKey; },\n/* harmony export */   Z: function() { return /* binding */ _lookupByKey; },\n/* harmony export */   _: function() { return /* binding */ _arrayUnique; },\n/* harmony export */   a: function() { return /* binding */ resolve; },\n/* harmony export */   a$: function() { return /* binding */ toLineHeight; },\n/* harmony export */   a0: function() { return /* binding */ getAngleFromPoint; },\n/* harmony export */   a1: function() { return /* binding */ getMaximumSize; },\n/* harmony export */   a2: function() { return /* binding */ _getParentNode; },\n/* harmony export */   a3: function() { return /* binding */ readUsedSize; },\n/* harmony export */   a4: function() { return /* binding */ throttled; },\n/* harmony export */   a5: function() { return /* binding */ supportsEventListenerOptions; },\n/* harmony export */   a6: function() { return /* binding */ _isDomSupported; },\n/* harmony export */   a7: function() { return /* binding */ descriptors; },\n/* harmony export */   a8: function() { return /* binding */ isFunction; },\n/* harmony export */   a9: function() { return /* binding */ _attachContext; },\n/* harmony export */   aA: function() { return /* binding */ getRtlAdapter; },\n/* harmony export */   aB: function() { return /* binding */ overrideTextDirection; },\n/* harmony export */   aC: function() { return /* binding */ _textX; },\n/* harmony export */   aD: function() { return /* binding */ restoreTextDirection; },\n/* harmony export */   aE: function() { return /* binding */ drawPointLegend; },\n/* harmony export */   aF: function() { return /* binding */ noop; },\n/* harmony export */   aG: function() { return /* binding */ distanceBetweenPoints; },\n/* harmony export */   aH: function() { return /* binding */ _setMinAndMaxByKey; },\n/* harmony export */   aI: function() { return /* binding */ niceNum; },\n/* harmony export */   aJ: function() { return /* binding */ almostWhole; },\n/* harmony export */   aK: function() { return /* binding */ almostEquals; },\n/* harmony export */   aL: function() { return /* binding */ _decimalPlaces; },\n/* harmony export */   aM: function() { return /* binding */ _longestText; },\n/* harmony export */   aN: function() { return /* binding */ _filterBetween; },\n/* harmony export */   aO: function() { return /* binding */ _lookup; },\n/* harmony export */   aP: function() { return /* binding */ isPatternOrGradient; },\n/* harmony export */   aQ: function() { return /* binding */ getHoverColor; },\n/* harmony export */   aR: function() { return /* binding */ clone$1; },\n/* harmony export */   aS: function() { return /* binding */ _merger; },\n/* harmony export */   aT: function() { return /* binding */ _mergerIf; },\n/* harmony export */   aU: function() { return /* binding */ _deprecated; },\n/* harmony export */   aV: function() { return /* binding */ _splitKey; },\n/* harmony export */   aW: function() { return /* binding */ toFontString; },\n/* harmony export */   aX: function() { return /* binding */ splineCurve; },\n/* harmony export */   aY: function() { return /* binding */ splineCurveMonotone; },\n/* harmony export */   aZ: function() { return /* binding */ getStyle; },\n/* harmony export */   a_: function() { return /* binding */ fontString; },\n/* harmony export */   aa: function() { return /* binding */ _createResolver; },\n/* harmony export */   ab: function() { return /* binding */ _descriptors; },\n/* harmony export */   ac: function() { return /* binding */ mergeIf; },\n/* harmony export */   ad: function() { return /* binding */ uid; },\n/* harmony export */   ae: function() { return /* binding */ debounce; },\n/* harmony export */   af: function() { return /* binding */ retinaScale; },\n/* harmony export */   ag: function() { return /* binding */ clearCanvas; },\n/* harmony export */   ah: function() { return /* binding */ setsEqual; },\n/* harmony export */   ai: function() { return /* binding */ _elementsEqual; },\n/* harmony export */   aj: function() { return /* binding */ _isClickEvent; },\n/* harmony export */   ak: function() { return /* binding */ _isBetween; },\n/* harmony export */   al: function() { return /* binding */ _readValueToProps; },\n/* harmony export */   am: function() { return /* binding */ _updateBezierControlPoints; },\n/* harmony export */   an: function() { return /* binding */ _computeSegments; },\n/* harmony export */   ao: function() { return /* binding */ _boundSegments; },\n/* harmony export */   ap: function() { return /* binding */ _steppedInterpolation; },\n/* harmony export */   aq: function() { return /* binding */ _bezierInterpolation; },\n/* harmony export */   ar: function() { return /* binding */ _pointInLine; },\n/* harmony export */   as: function() { return /* binding */ _steppedLineTo; },\n/* harmony export */   at: function() { return /* binding */ _bezierCurveTo; },\n/* harmony export */   au: function() { return /* binding */ drawPoint; },\n/* harmony export */   av: function() { return /* binding */ addRoundedRectPath; },\n/* harmony export */   aw: function() { return /* binding */ toTRBL; },\n/* harmony export */   ax: function() { return /* binding */ toTRBLCorners; },\n/* harmony export */   ay: function() { return /* binding */ _boundSegment; },\n/* harmony export */   az: function() { return /* binding */ _normalizeAngle; },\n/* harmony export */   b: function() { return /* binding */ isArray; },\n/* harmony export */   b0: function() { return /* binding */ PITAU; },\n/* harmony export */   b1: function() { return /* binding */ INFINITY; },\n/* harmony export */   b2: function() { return /* binding */ RAD_PER_DEG; },\n/* harmony export */   b3: function() { return /* binding */ QUARTER_PI; },\n/* harmony export */   b4: function() { return /* binding */ TWO_THIRDS_PI; },\n/* harmony export */   b5: function() { return /* binding */ _angleDiff; },\n/* harmony export */   c: function() { return /* binding */ color; },\n/* harmony export */   d: function() { return /* binding */ defaults; },\n/* harmony export */   e: function() { return /* binding */ effects; },\n/* harmony export */   f: function() { return /* binding */ resolveObjectKey; },\n/* harmony export */   g: function() { return /* binding */ isNumberFinite; },\n/* harmony export */   h: function() { return /* binding */ createContext; },\n/* harmony export */   i: function() { return /* binding */ isObject; },\n/* harmony export */   j: function() { return /* binding */ defined; },\n/* harmony export */   k: function() { return /* binding */ isNullOrUndef; },\n/* harmony export */   l: function() { return /* binding */ listenArrayEvents; },\n/* harmony export */   m: function() { return /* binding */ toPercentage; },\n/* harmony export */   n: function() { return /* binding */ toDimension; },\n/* harmony export */   o: function() { return /* binding */ formatNumber; },\n/* harmony export */   p: function() { return /* binding */ _angleBetween; },\n/* harmony export */   q: function() { return /* binding */ _getStartAndCountOfVisiblePoints; },\n/* harmony export */   r: function() { return /* binding */ requestAnimFrame; },\n/* harmony export */   s: function() { return /* binding */ sign; },\n/* harmony export */   t: function() { return /* binding */ toRadians; },\n/* harmony export */   u: function() { return /* binding */ unlistenArrayEvents; },\n/* harmony export */   v: function() { return /* binding */ valueOrDefault; },\n/* harmony export */   w: function() { return /* binding */ _scaleRangesChanged; },\n/* harmony export */   x: function() { return /* binding */ isNumber; },\n/* harmony export */   y: function() { return /* binding */ _parseObjectDataRadialScale; },\n/* harmony export */   z: function() { return /* binding */ log10; }\n/* harmony export */ });\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ var _s = $RefreshSig$();\nfunction noop() {}\nconst uid = function() {\n    let id = 0;\n    return function() {\n        return id++;\n    };\n}();\nfunction isNullOrUndef(value) {\n    return value === null || typeof value === \"undefined\";\n}\nfunction isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n        return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst isNumberFinite = (value)=>(typeof value === \"number\" || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n    return typeof value === \"undefined\" ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : value / dimension;\nconst toDimension = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\nfunction callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === \"function\") {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\nfunction _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction clone$1(source) {\n    if (isArray(source)) {\n        return source.map(clone$1);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone$1(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone$1(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    for(let i = 0; i < ilen; ++i){\n        source = sources[i];\n        if (!isObject(source)) {\n            continue;\n        }\n        const keys = Object.keys(source);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, source, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\nfunction _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone$1(sval);\n    }\n}\nfunction _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\nconst keyResolvers = {\n    \"\": (v)=>v,\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === \"\") {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction _splitKey(key) {\n    const parts = key.split(\".\");\n    const keys = [];\n    let tmp = \"\";\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith(\"\\\\\")) {\n            tmp = tmp.slice(0, -1) + \".\";\n        } else {\n            keys.push(tmp);\n            tmp = \"\";\n        }\n    }\n    return keys;\n}\nfunction _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== \"undefined\";\nconst isFunction = (value)=>typeof value === \"function\";\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _isClickEvent(e) {\n    return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU;\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\nfunction _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end) {\n    let epsilon = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1e-6;\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\nconst _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>table[index][key] <= value : (index)=>table[index][key] < value);\nconst _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"splice\",\n    \"unshift\"\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, \"_chartjs\", {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = \"_onData\" + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value () {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === \"function\") {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n    const set = new Set();\n    let i, ilen;\n    for(i = 0, ilen = items.length; i < ilen; ++i){\n        set.add(items[i]);\n    }\n    if (set.size === ilen) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + \" \" + pixelSize + \"px \" + fontFamily;\n}\nconst requestAnimFrame = function() {\n    if (false) {}\n    return window.requestAnimationFrame;\n}();\nfunction throttled(fn, thisArg, updateFn) {\n    const updateArgs = updateFn || ((args)=>Array.prototype.slice.call(args));\n    let ticking = false;\n    let args = [];\n    return function() {\n        for(var _len = arguments.length, rest = new Array(_len), _key = 0; _key < _len; _key++){\n            rest[_key] = arguments[_key];\n        }\n        args = updateArgs(rest);\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, args);\n            });\n        }\n    };\n}\nfunction debounce(fn, delay) {\n    let timeout;\n    return function() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\nconst _toLeftRightCenter = (align)=>align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\nconst _alignStartEnd = (align, start, end)=>align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl)=>{\n    const check = rtl ? \"left\" : \"right\";\n    return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, _parsed } = meta;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\nfunction _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */ function round(v) {\n    return v + 0.5 | 0;\n}\nconst lim = (v, l, h)=>Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n    return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n    return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n    return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n    return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n};\nconst hex = [\n    ...\"0123456789ABCDEF\"\n];\nconst h1 = (b)=>hex[b & 0xF];\nconst h2 = (b)=>hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b)=>(b & 0xF0) >> 4 === (b & 0xF);\nconst isShort = (v)=>eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n    var len = str.length;\n    var ret;\n    if (str[0] === \"#\") {\n        if (len === 4 || len === 5) {\n            ret = {\n                r: 255 & map$1[str[1]] * 17,\n                g: 255 & map$1[str[2]] * 17,\n                b: 255 & map$1[str[3]] * 17,\n                a: len === 5 ? map$1[str[4]] * 17 : 255\n            };\n        } else if (len === 7 || len === 9) {\n            ret = {\n                r: map$1[str[1]] << 4 | map$1[str[2]],\n                g: map$1[str[3]] << 4 | map$1[str[4]],\n                b: map$1[str[5]] << 4 | map$1[str[6]],\n                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255\n            };\n        }\n    }\n    return ret;\n}\nconst alpha = (a, f)=>a < 255 ? f(a) : \"\";\nfunction hexString(v) {\n    var f = isShort(v) ? h1 : h2;\n    return v ? \"#\" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n    const a = s * Math.min(l, 1 - l);\n    const f = function(n) {\n        let k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 30) % 12;\n        return l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    };\n    return [\n        f(0),\n        f(8),\n        f(4)\n    ];\n}\nfunction hsv2rgbn(h, s, v) {\n    const f = function(n) {\n        let k = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (n + h / 60) % 6;\n        return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n    };\n    return [\n        f(5),\n        f(3),\n        f(1)\n    ];\n}\nfunction hwb2rgbn(h, w, b) {\n    const rgb = hsl2rgbn(h, 1, 0.5);\n    let i;\n    if (w + b > 1) {\n        i = 1 / (w + b);\n        w *= i;\n        b *= i;\n    }\n    for(i = 0; i < 3; i++){\n        rgb[i] *= 1 - w - b;\n        rgb[i] += w;\n    }\n    return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n    if (r === max) {\n        return (g - b) / d + (g < b ? 6 : 0);\n    }\n    if (g === max) {\n        return (b - r) / d + 2;\n    }\n    return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n    const range = 255;\n    const r = v.r / range;\n    const g = v.g / range;\n    const b = v.b / range;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    let h, s, d;\n    if (max !== min) {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = hueValue(r, g, b, d, max);\n        h = h * 60 + 0.5;\n    }\n    return [\n        h | 0,\n        s || 0,\n        l\n    ];\n}\nfunction calln(f, a, b, c) {\n    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n    return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n    return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n    return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n    return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n    const m = HUE_RE.exec(str);\n    let a = 255;\n    let v;\n    if (!m) {\n        return;\n    }\n    if (m[5] !== v) {\n        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n    }\n    const h = hue(+m[2]);\n    const p1 = +m[3] / 100;\n    const p2 = +m[4] / 100;\n    if (m[1] === \"hwb\") {\n        v = hwb2rgb(h, p1, p2);\n    } else if (m[1] === \"hsv\") {\n        v = hsv2rgb(h, p1, p2);\n    } else {\n        v = hsl2rgb(h, p1, p2);\n    }\n    return {\n        r: v[0],\n        g: v[1],\n        b: v[2],\n        a: a\n    };\n}\nfunction rotate(v, deg) {\n    var h = rgb2hsl(v);\n    h[0] = hue(h[0] + deg);\n    h = hsl2rgb(h);\n    v.r = h[0];\n    v.g = h[1];\n    v.b = h[2];\n}\nfunction hslString(v) {\n    if (!v) {\n        return;\n    }\n    const a = rgb2hsl(v);\n    const h = a[0];\n    const s = n2p(a[1]);\n    const l = n2p(a[2]);\n    return v.a < 255 ? \"hsla(\".concat(h, \", \").concat(s, \"%, \").concat(l, \"%, \").concat(b2n(v.a), \")\") : \"hsl(\".concat(h, \", \").concat(s, \"%, \").concat(l, \"%)\");\n}\nconst map = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n};\nconst names$1 = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n};\nfunction unpack() {\n    const unpacked = {};\n    const keys = Object.keys(names$1);\n    const tkeys = Object.keys(map);\n    let i, j, k, ok, nk;\n    for(i = 0; i < keys.length; i++){\n        ok = nk = keys[i];\n        for(j = 0; j < tkeys.length; j++){\n            k = tkeys[j];\n            nk = nk.replace(k, map[k]);\n        }\n        k = parseInt(names$1[ok], 16);\n        unpacked[nk] = [\n            k >> 16 & 0xFF,\n            k >> 8 & 0xFF,\n            k & 0xFF\n        ];\n    }\n    return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n    if (!names) {\n        names = unpack();\n        names.transparent = [\n            0,\n            0,\n            0,\n            0\n        ];\n    }\n    const a = names[str.toLowerCase()];\n    return a && {\n        r: a[0],\n        g: a[1],\n        b: a[2],\n        a: a.length === 4 ? a[3] : 255\n    };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n    const m = RGB_RE.exec(str);\n    let a = 255;\n    let r, g, b;\n    if (!m) {\n        return;\n    }\n    if (m[7] !== r) {\n        const v = +m[7];\n        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n    }\n    r = +m[1];\n    g = +m[3];\n    b = +m[5];\n    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n    return {\n        r: r,\n        g: g,\n        b: b,\n        a: a\n    };\n}\nfunction rgbString(v) {\n    return v && (v.a < 255 ? \"rgba(\".concat(v.r, \", \").concat(v.g, \", \").concat(v.b, \", \").concat(b2n(v.a), \")\") : \"rgb(\".concat(v.r, \", \").concat(v.g, \", \").concat(v.b, \")\"));\n}\nconst to = (v)=>v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = (v)=>v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n    const r = from(b2n(rgb1.r));\n    const g = from(b2n(rgb1.g));\n    const b = from(b2n(rgb1.b));\n    return {\n        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n        a: rgb1.a + t * (rgb2.a - rgb1.a)\n    };\n}\nfunction modHSL(v, i, ratio) {\n    if (v) {\n        let tmp = rgb2hsl(v);\n        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n        tmp = hsl2rgb(tmp);\n        v.r = tmp[0];\n        v.g = tmp[1];\n        v.b = tmp[2];\n    }\n}\nfunction clone(v, proto) {\n    return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n    var v = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    };\n    if (Array.isArray(input)) {\n        if (input.length >= 3) {\n            v = {\n                r: input[0],\n                g: input[1],\n                b: input[2],\n                a: 255\n            };\n            if (input.length > 3) {\n                v.a = n2b(input[3]);\n            }\n        }\n    } else {\n        v = clone(input, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        });\n        v.a = n2b(v.a);\n    }\n    return v;\n}\nfunction functionParse(str) {\n    if (str.charAt(0) === \"r\") {\n        return rgbParse(str);\n    }\n    return hueParse(str);\n}\nclass Color {\n    get valid() {\n        return this._valid;\n    }\n    get rgb() {\n        var v = clone(this._rgb);\n        if (v) {\n            v.a = b2n(v.a);\n        }\n        return v;\n    }\n    set rgb(obj) {\n        this._rgb = fromObject(obj);\n    }\n    rgbString() {\n        return this._valid ? rgbString(this._rgb) : undefined;\n    }\n    hexString() {\n        return this._valid ? hexString(this._rgb) : undefined;\n    }\n    hslString() {\n        return this._valid ? hslString(this._rgb) : undefined;\n    }\n    mix(color, weight) {\n        if (color) {\n            const c1 = this.rgb;\n            const c2 = color.rgb;\n            let w2;\n            const p = weight === w2 ? 0.5 : weight;\n            const w = 2 * p - 1;\n            const a = c1.a - c2.a;\n            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            w2 = 1 - w1;\n            c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n            c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n            c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n            c1.a = p * c1.a + (1 - p) * c2.a;\n            this.rgb = c1;\n        }\n        return this;\n    }\n    interpolate(color, t) {\n        if (color) {\n            this._rgb = interpolate(this._rgb, color._rgb, t);\n        }\n        return this;\n    }\n    clone() {\n        return new Color(this.rgb);\n    }\n    alpha(a) {\n        this._rgb.a = n2b(a);\n        return this;\n    }\n    clearer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 - ratio;\n        return this;\n    }\n    greyscale() {\n        const rgb = this._rgb;\n        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n        rgb.r = rgb.g = rgb.b = val;\n        return this;\n    }\n    opaquer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 + ratio;\n        return this;\n    }\n    negate() {\n        const v = this._rgb;\n        v.r = 255 - v.r;\n        v.g = 255 - v.g;\n        v.b = 255 - v.b;\n        return this;\n    }\n    lighten(ratio) {\n        modHSL(this._rgb, 2, ratio);\n        return this;\n    }\n    darken(ratio) {\n        modHSL(this._rgb, 2, -ratio);\n        return this;\n    }\n    saturate(ratio) {\n        modHSL(this._rgb, 1, ratio);\n        return this;\n    }\n    desaturate(ratio) {\n        modHSL(this._rgb, 1, -ratio);\n        return this;\n    }\n    rotate(deg) {\n        rotate(this._rgb, deg);\n        return this;\n    }\n    constructor(input){\n        if (input instanceof Color) {\n            return input;\n        }\n        const type = typeof input;\n        let v;\n        if (type === \"object\") {\n            v = fromObject(input);\n        } else if (type === \"string\") {\n            v = hexParse(input) || nameParse(input) || functionParse(input);\n        }\n        this._rgb = v;\n        this._valid = !!v;\n    }\n}\nfunction index_esm(input) {\n    return new Color(input);\n}\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === \"object\") {\n        const type = value.toString();\n        return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split(\".\");\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === \"string\") {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, \"\"), scope);\n}\nclass Defaults {\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = \"_\" + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n    constructor(_descriptors){\n        this.animation = undefined;\n        this.backgroundColor = \"rgba(0,0,0,0.1)\";\n        this.borderColor = \"rgba(0,0,0,0.1)\";\n        this.color = \"#666\";\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            \"mousemove\",\n            \"mouseout\",\n            \"click\",\n            \"touchstart\",\n            \"touchmove\"\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: \"normal\",\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = \"x\";\n        this.interaction = {\n            mode: \"nearest\",\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n    }\n}\nvar defaults = new Defaults({\n    _scriptable: (name)=>!name.startsWith(\"on\"),\n    _indexable: (name)=>name !== \"events\",\n    hover: {\n        _fallback: \"interaction\"\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n});\nfunction toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n    ctx = ctx || canvas.getContext(\"2d\");\n    ctx.save();\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === \"object\") {\n        type = style.toString();\n        if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        case \"rectRot\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += QUARTER_PI;\n        case \"cross\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"star\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            rad += QUARTER_PI;\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\nfunction _isPointInArea(point, area, margin) {\n    margin = margin || 0.5;\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === \"middle\") {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === \"after\" !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction renderText(ctx, text, x, y, font) {\n    let opts = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += font.lineHeight;\n    }\n    ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    ctx.lineTo(x + w, y + radius.topRight);\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n    const matches = (\"\" + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === \"normal\") {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case \"px\":\n            return value;\n        case \"%\":\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\nfunction toTRBL(value) {\n    return _readValueToProps(value, {\n        top: \"y\",\n        right: \"x\",\n        bottom: \"y\",\n        left: \"x\"\n    });\n}\nfunction toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        \"topLeft\",\n        \"topRight\",\n        \"bottomLeft\",\n        \"bottomRight\"\n    ]);\n}\nfunction toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\nfunction toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === \"string\") {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !(\"\" + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = \"\";\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: \"\"\n    };\n    font.string = toFontString(font);\n    return font;\n}\nfunction resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === \"function\") {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\nfunction _createResolver(scopes) {\n    let prefixes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\n        \"\"\n    ], rootScopes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : scopes, fallback = arguments.length > 3 ? arguments[3] : void 0, getTarget = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : ()=>scopes[0];\n    if (!defined(fallback)) {\n        fallback = _resolve(\"_fallback\", scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: \"Object\",\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: rootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, rootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete target._keys;\n            delete scopes[0][prop];\n            return true;\n        },\n        get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value;\n            delete target._keys;\n            return true;\n        }\n    });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete proxy[prop];\n            return true;\n        },\n        get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        set (target, prop, value) {\n            proxy[prop] = value;\n            delete target[prop];\n            return true;\n        }\n    });\n}\nfunction _descriptors(proxy) {\n    let defaults = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n        scriptable: true,\n        indexable: true\n    };\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n        return target[prop];\n    }\n    const value = resolve();\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop];\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n    }\n    _stack.add(prop);\n    value = value(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (defined(_context.index) && isIndexable(prop)) {\n        value = value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n                return fallback;\n            }\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (defined(fallback) && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        \"\"\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        return value;\n    }\n    return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (defined(value)) {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (defined(value)) {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith(\"_\"))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = \"r\" } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01;\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK) {\n    let indexAxis = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"x\";\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[\"cp1\".concat(indexAxis)] = iPixel - delta;\n            pointCurrent[\"cp1\".concat(valueAxis)] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[\"cp2\".concat(indexAxis)] = iPixel + delta;\n            pointCurrent[\"cp2\".concat(valueAxis)] = vPixel + delta * mK[i];\n        }\n    }\n}\nfunction splineCurveMonotone(points) {\n    let indexAxis = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"x\";\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === \"monotone\") {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\nfunction _isDomSupported() {\n    return  true && typeof document !== \"undefined\";\n}\nfunction _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === \"[object ShadowRoot]\") {\n        parent = parent.host;\n    }\n    return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === \"string\") {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf(\"%\") !== -1) {\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? \"-\" + suffix : \"\";\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n    _s();\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\n_s(getCanvasPosition, \"TaN0hAexdpaD4eVsFTeI6MwcRTY=\", false, function() {\n    return [\n        useOffsetPos\n    ];\n});\nfunction getRelativePosition(evt, chart) {\n    if (\"native\" in evt) {\n        return evt;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === \"border-box\";\n    const paddings = getPositionedStyle(style, \"padding\");\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const { x, y, box } = getCanvasPosition(evt, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n            const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, \"margin\");\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === \"content-box\") {\n        const borders = getPositionedStyle(style, \"border\", \"width\");\n        const paddings = getPositionedStyle(style, \"padding\");\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        height = round1(width / 2);\n    }\n    return {\n        width,\n        height\n    };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = deviceHeight / pixelRatio;\n    chart.width = deviceWidth / pixelRatio;\n    const canvas = chart.canvas;\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = \"\".concat(chart.height, \"px\");\n        canvas.style.width = \"\".concat(chart.width, \"px\");\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\nconst supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        window.addEventListener(\"test\", null, options);\n        window.removeEventListener(\"test\", null, options);\n    } catch (e) {}\n    return passiveSupported;\n}();\nfunction readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\nfunction _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === \"center\") {\n                return align;\n            }\n            return align === \"right\" ? \"left\" : \"right\";\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === \"ltr\" || direction === \"rtl\") {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue(\"direction\"),\n            style.getPropertyPriority(\"direction\")\n        ];\n        style.setProperty(\"direction\", direction, \"important\");\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === \"angle\") {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment(param) {\n    let { start, end, count, loop, style } = param;\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: \"segment\",\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQztBQUNELFNBQVNBLFFBQVE7QUFDakIsTUFBTUMsTUFBTztJQUNYLElBQUlDLEtBQUs7SUFDVCxPQUFPO1FBQ0wsT0FBT0E7SUFDVDtBQUNGO0FBQ0EsU0FBU0MsY0FBY0MsS0FBSztJQUMxQixPQUFPQSxVQUFVLFFBQVEsT0FBT0EsVUFBVTtBQUM1QztBQUNBLFNBQVNDLFFBQVFELEtBQUs7SUFDcEIsSUFBSUUsTUFBTUQsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLENBQUNELFFBQVE7UUFDekMsT0FBTztJQUNUO0lBQ0EsTUFBTUcsT0FBT0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ1A7SUFDNUMsSUFBSUcsS0FBS0ssS0FBSyxDQUFDLEdBQUcsT0FBTyxhQUFhTCxLQUFLSyxLQUFLLENBQUMsQ0FBQyxPQUFPLFVBQVU7UUFDakUsT0FBTztJQUNUO0lBQ0EsT0FBTztBQUNUO0FBQ0EsU0FBU0MsU0FBU1QsS0FBSztJQUNyQixPQUFPQSxVQUFVLFFBQVFJLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNQLFdBQVc7QUFDckU7QUFDQSxNQUFNVSxpQkFBaUIsQ0FBQ1YsUUFBVSxDQUFDLE9BQU9BLFVBQVUsWUFBWUEsaUJBQWlCVyxNQUFLLEtBQU1DLFNBQVMsQ0FBQ1o7QUFDdEcsU0FBU2EsZ0JBQWdCYixLQUFLLEVBQUVjLFlBQVk7SUFDMUMsT0FBT0osZUFBZVYsU0FBU0EsUUFBUWM7QUFDekM7QUFDQSxTQUFT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QUFnQnY3QixRQUFRdTdCLGNBQWM7UUFDdENDLFlBQVl4N0IsUUFBUXc3QixVQUFVO1FBQzlCQyxrQkFBa0J6N0IsUUFBUXk3QixnQkFBZ0I7UUFDMUNDLGlCQUFpQjE3QixRQUFRMDdCLGVBQWU7UUFDeENwVixhQUFhdG1CLFFBQVFzbUIsV0FBVztRQUNoQ3ZGLGFBQWEvZ0IsUUFBUStnQixXQUFXO0lBQ2xDO0FBQ0Y7QUFDQSxTQUFTdWEsYUFBYTVaLEtBQUssRUFBRXFaLFNBQVM7SUFDcEMsT0FBT0EsYUFBYTdELEtBQUtDLFNBQVMsQ0FBQ3pWLFdBQVd3VixLQUFLQyxTQUFTLENBQUM0RDtBQUMvRDtBQUVxNEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuc2VnbWVudC5tanM/OWFkNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuY29uc3QgdWlkID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgaWQgPSAwO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlkKys7XG4gIH07XG59KCkpO1xuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzQXJyYXkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHR5cGUuc2xpY2UoMCwgNykgPT09ICdbb2JqZWN0JyAmJiB0eXBlLnNsaWNlKC02KSA9PT0gJ0FycmF5XScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5jb25zdCBpc051bWJlckZpbml0ZSA9ICh2YWx1ZSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpICYmIGlzRmluaXRlKCt2YWx1ZSk7XG5mdW5jdGlvbiBmaW5pdGVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpID8gdmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMFxuICAgIDogdmFsdWUgLyBkaW1lbnNpb247XG5jb25zdCB0b0RpbWVuc2lvbiA9ICh2YWx1ZSwgZGltZW5zaW9uKSA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLmVuZHNXaXRoKCclJykgP1xuICAgIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uXG4gICAgOiArdmFsdWU7XG5mdW5jdGlvbiBjYWxsYmFjayhmbiwgYXJncywgdGhpc0FyZykge1xuICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVhY2gobG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG4gIGxldCBpLCBsZW4sIGtleXM7XG4gIGlmIChpc0FycmF5KGxvb3BhYmxlKSkge1xuICAgIGxlbiA9IGxvb3BhYmxlLmxlbmd0aDtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobG9vcGFibGUpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGxvb3BhYmxlKTtcbiAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVba2V5c1tpXV0sIGtleXNbaV0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTAsIGExKSB7XG4gIGxldCBpLCBpbGVuLCB2MCwgdjE7XG4gIGlmICghYTAgfHwgIWExIHx8IGEwLmxlbmd0aCAhPT0gYTEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBhMC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2MCA9IGEwW2ldO1xuICAgIHYxID0gYTFbaV07XG4gICAgaWYgKHYwLmRhdGFzZXRJbmRleCAhPT0gdjEuZGF0YXNldEluZGV4IHx8IHYwLmluZGV4ICE9PSB2MS5pbmRleCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lJDEoc291cmNlKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gc291cmNlLm1hcChjbG9uZSQxKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgIGNvbnN0IHRhcmdldCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgIGxldCBrID0gMDtcbiAgICBmb3IgKDsgayA8IGtsZW47ICsraykge1xuICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUkMShzb3VyY2Vba2V5c1trXV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBzb3VyY2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkS2V5KGtleSkge1xuICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5kZXhPZihrZXkpID09PSAtMTtcbn1cbmZ1bmN0aW9uIF9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2UodHZhbCwgc3ZhbCwgb3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0W2tleV0gPSBjbG9uZSQxKHN2YWwpO1xuICB9XG59XG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBzb3VyY2VzID0gaXNBcnJheShzb3VyY2UpID8gc291cmNlIDogW3NvdXJjZV07XG4gIGNvbnN0IGlsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbWVyZ2VyID0gb3B0aW9ucy5tZXJnZXIgfHwgX21lcmdlcjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgIGlmICghaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGZvciAobGV0IGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIG1lcmdlcihrZXlzW2tdLCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUlmKHRhcmdldCwgc291cmNlKSB7XG4gIHJldHVybiBtZXJnZSh0YXJnZXQsIHNvdXJjZSwge21lcmdlcjogX21lcmdlcklmfSk7XG59XG5mdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuICBpZiAoIWlzVmFsaWRLZXkoa2V5KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB0dmFsID0gdGFyZ2V0W2tleV07XG4gIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgaWYgKGlzT2JqZWN0KHR2YWwpICYmIGlzT2JqZWN0KHN2YWwpKSB7XG4gICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgfSBlbHNlIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gX2RlcHJlY2F0ZWQoc2NvcGUsIHZhbHVlLCBwcmV2aW91cywgY3VycmVudCkge1xuICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybihzY29wZSArICc6IFwiJyArIHByZXZpb3VzICtcblx0XHRcdCdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICB9XG59XG5jb25zdCBrZXlSZXNvbHZlcnMgPSB7XG4gICcnOiB2ID0+IHYsXG4gIHg6IG8gPT4gby54LFxuICB5OiBvID0+IG8ueVxufTtcbmZ1bmN0aW9uIHJlc29sdmVPYmplY3RLZXkob2JqLCBrZXkpIHtcbiAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gIHJldHVybiByZXNvbHZlcihvYmopO1xufVxuZnVuY3Rpb24gX2dldEtleVJlc29sdmVyKGtleSkge1xuICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gIHJldHVybiBvYmogPT4ge1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICBpZiAoayA9PT0gJycpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvYmogPSBvYmogJiYgb2JqW2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xufVxuZnVuY3Rpb24gX3NwbGl0S2V5KGtleSkge1xuICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnLicpO1xuICBjb25zdCBrZXlzID0gW107XG4gIGxldCB0bXAgPSAnJztcbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XG4gICAgdG1wICs9IHBhcnQ7XG4gICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzLnB1c2godG1wKTtcbiAgICAgIHRtcCA9ICcnO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9jYXBpdGFsaXplKHN0cikge1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xufVxuY29uc3QgZGVmaW5lZCA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYSkge1xuICAgIGlmICghYi5oYXMoaXRlbSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gIHJldHVybiBlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT09ICdjbGljaycgfHwgZS50eXBlID09PSAnY29udGV4dG1lbnUnO1xufVxuXG5jb25zdCBQSSA9IE1hdGguUEk7XG5jb25zdCBUQVUgPSAyICogUEk7XG5jb25zdCBQSVRBVSA9IFRBVSArIFBJO1xuY29uc3QgSU5GSU5JVFkgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5jb25zdCBSQURfUEVSX0RFRyA9IFBJIC8gMTgwO1xuY29uc3QgSEFMRl9QSSA9IFBJIC8gMjtcbmNvbnN0IFFVQVJURVJfUEkgPSBQSSAvIDQ7XG5jb25zdCBUV09fVEhJUkRTX1BJID0gUEkgKiAyIC8gMztcbmNvbnN0IGxvZzEwID0gTWF0aC5sb2cxMDtcbmNvbnN0IHNpZ24gPSBNYXRoLnNpZ247XG5mdW5jdGlvbiBuaWNlTnVtKHJhbmdlKSB7XG4gIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICByYW5nZSA9IGFsbW9zdEVxdWFscyhyYW5nZSwgcm91bmRlZFJhbmdlLCByYW5nZSAvIDEwMDApID8gcm91bmRlZFJhbmdlIDogcmFuZ2U7XG4gIGNvbnN0IG5pY2VSYW5nZSA9IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHJhbmdlKSkpO1xuICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICBjb25zdCBuaWNlRnJhY3Rpb24gPSBmcmFjdGlvbiA8PSAxID8gMSA6IGZyYWN0aW9uIDw9IDIgPyAyIDogZnJhY3Rpb24gPD0gNSA/IDUgOiAxMDtcbiAgcmV0dXJuIG5pY2VGcmFjdGlvbiAqIG5pY2VSYW5nZTtcbn1cbmZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNxcnQgPSBNYXRoLnNxcnQodmFsdWUpO1xuICBsZXQgaTtcbiAgZm9yIChpID0gMTsgaSA8IHNxcnQ7IGkrKykge1xuICAgIGlmICh2YWx1ZSAlIGkgPT09IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgICAgcmVzdWx0LnB1c2godmFsdWUgLyBpKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICByZXN1bHQucHVzaChzcXJ0KTtcbiAgfVxuICByZXN1bHQuc29ydCgoYSwgYikgPT4gYSAtIGIpLnBvcCgpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuZnVuY3Rpb24gYWxtb3N0RXF1YWxzKHgsIHksIGVwc2lsb24pIHtcbiAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG5mdW5jdGlvbiBhbG1vc3RXaG9sZSh4LCBlcHNpbG9uKSB7XG4gIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKHgpO1xuICByZXR1cm4gKChyb3VuZGVkIC0gZXBzaWxvbikgPD0geCkgJiYgKChyb3VuZGVkICsgZXBzaWxvbikgPj0geCk7XG59XG5mdW5jdGlvbiBfc2V0TWluQW5kTWF4QnlLZXkoYXJyYXksIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdmFsdWUgPSBhcnJheVtpXVtwcm9wZXJ0eV07XG4gICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgKiAoUEkgLyAxODApO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gUEkpO1xufVxuZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICBpZiAoIWlzTnVtYmVyRmluaXRlKHgpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBlID0gMTtcbiAgbGV0IHAgPSAwO1xuICB3aGlsZSAoTWF0aC5yb3VuZCh4ICogZSkgLyBlICE9PSB4KSB7XG4gICAgZSAqPSAxMDtcbiAgICBwKys7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBnZXRBbmdsZUZyb21Qb2ludChjZW50cmVQb2ludCwgYW5nbGVQb2ludCkge1xuICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWUNlbnRlciA9IGFuZ2xlUG9pbnQueSAtIGNlbnRyZVBvaW50Lnk7XG4gIGNvbnN0IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGguc3FydChkaXN0YW5jZUZyb21YQ2VudGVyICogZGlzdGFuY2VGcm9tWENlbnRlciArIGRpc3RhbmNlRnJvbVlDZW50ZXIgKiBkaXN0YW5jZUZyb21ZQ2VudGVyKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgaWYgKGFuZ2xlIDwgKC0wLjUgKiBQSSkpIHtcbiAgICBhbmdsZSArPSBUQVU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmdsZSxcbiAgICBkaXN0YW5jZTogcmFkaWFsRGlzdGFuY2VGcm9tQ2VudGVyXG4gIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhwdDIueCAtIHB0MS54LCAyKSArIE1hdGgucG93KHB0Mi55IC0gcHQxLnksIDIpKTtcbn1cbmZ1bmN0aW9uIF9hbmdsZURpZmYoYSwgYikge1xuICByZXR1cm4gKGEgLSBiICsgUElUQVUpICUgVEFVIC0gUEk7XG59XG5mdW5jdGlvbiBfbm9ybWFsaXplQW5nbGUoYSkge1xuICByZXR1cm4gKGEgJSBUQVUgKyBUQVUpICUgVEFVO1xufVxuZnVuY3Rpb24gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnQsIGVuZCwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlKSB7XG4gIGNvbnN0IGEgPSBfbm9ybWFsaXplQW5nbGUoYW5nbGUpO1xuICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgY29uc3QgZSA9IF9ub3JtYWxpemVBbmdsZShlbmQpO1xuICBjb25zdCBhbmdsZVRvU3RhcnQgPSBfbm9ybWFsaXplQW5nbGUocyAtIGEpO1xuICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgY29uc3Qgc3RhcnRUb0FuZ2xlID0gX25vcm1hbGl6ZUFuZ2xlKGEgLSBzKTtcbiAgY29uc3QgZW5kVG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gZSk7XG4gIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgKHNhbWVBbmdsZUlzRnVsbENpcmNsZSAmJiBzID09PSBlKVxuICAgIHx8IChhbmdsZVRvU3RhcnQgPiBhbmdsZVRvRW5kICYmIHN0YXJ0VG9BbmdsZSA8IGVuZFRvQW5nbGUpO1xufVxuZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKG1heCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIF9pbnQxNlJhbmdlKHZhbHVlKSB7XG4gIHJldHVybiBfbGltaXRWYWx1ZSh2YWx1ZSwgLTMyNzY4LCAzMjc2Nyk7XG59XG5mdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICByZXR1cm4gdmFsdWUgPj0gTWF0aC5taW4oc3RhcnQsIGVuZCkgLSBlcHNpbG9uICYmIHZhbHVlIDw9IE1hdGgubWF4KHN0YXJ0LCBlbmQpICsgZXBzaWxvbjtcbn1cblxuZnVuY3Rpb24gX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGNtcCkge1xuICBjbXAgPSBjbXAgfHwgKChpbmRleCkgPT4gdGFibGVbaW5kZXhdIDwgdmFsdWUpO1xuICBsZXQgaGkgPSB0YWJsZS5sZW5ndGggLSAxO1xuICBsZXQgbG8gPSAwO1xuICBsZXQgbWlkO1xuICB3aGlsZSAoaGkgLSBsbyA+IDEpIHtcbiAgICBtaWQgPSAobG8gKyBoaSkgPj4gMTtcbiAgICBpZiAoY21wKG1pZCkpIHtcbiAgICAgIGxvID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaSA9IG1pZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtsbywgaGl9O1xufVxuY29uc3QgX2xvb2t1cEJ5S2V5ID0gKHRhYmxlLCBrZXksIHZhbHVlLCBsYXN0KSA9PlxuICBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdFxuICAgID8gaW5kZXggPT4gdGFibGVbaW5kZXhdW2tleV0gPD0gdmFsdWVcbiAgICA6IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuY29uc3QgX3Jsb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldID49IHZhbHVlKTtcbmZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGVuZCA9IHZhbHVlcy5sZW5ndGg7XG4gIHdoaWxlIChzdGFydCA8IGVuZCAmJiB2YWx1ZXNbc3RhcnRdIDwgbWluKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgdmFsdWVzW2VuZCAtIDFdID4gbWF4KSB7XG4gICAgZW5kLS07XG4gIH1cbiAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoXG4gICAgPyB2YWx1ZXMuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICA6IHZhbHVlcztcbn1cbmNvbnN0IGFycmF5RXZlbnRzID0gWydwdXNoJywgJ3BvcCcsICdzaGlmdCcsICdzcGxpY2UnLCAndW5zaGlmdCddO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGlmIChhcnJheS5fY2hhcnRqcykge1xuICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICByZXR1cm47XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFycmF5LCAnX2NoYXJ0anMnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiB7XG4gICAgICBsaXN0ZW5lcnM6IFtsaXN0ZW5lcl1cbiAgICB9XG4gIH0pO1xuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBtZXRob2QgPSAnX29uRGF0YScgKyBfY2FwaXRhbGl6ZShrZXkpO1xuICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYmFzZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCkgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2RdKC4uLmFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5BcnJheUV2ZW50cyhhcnJheSwgbGlzdGVuZXIpIHtcbiAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICBpZiAoIXN0dWIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbGlzdGVuZXJzID0gc3R1Yi5saXN0ZW5lcnM7XG4gIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gIH1cbiAgaWYgKGxpc3RlbmVycy5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGRlbGV0ZSBhcnJheVtrZXldO1xuICB9KTtcbiAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuZnVuY3Rpb24gX2FycmF5VW5pcXVlKGl0ZW1zKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBzZXQuYWRkKGl0ZW1zW2ldKTtcbiAgfVxuICBpZiAoc2V0LnNpemUgPT09IGlsZW4pIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cblxuZnVuY3Rpb24gZm9udFN0cmluZyhwaXhlbFNpemUsIGZvbnRTdHlsZSwgZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuY29uc3QgcmVxdWVzdEFuaW1GcmFtZSA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpKTtcbmZ1bmN0aW9uIHRocm90dGxlZChmbiwgdGhpc0FyZywgdXBkYXRlRm4pIHtcbiAgY29uc3QgdXBkYXRlQXJncyA9IHVwZGF0ZUZuIHx8ICgoYXJncykgPT4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykpO1xuICBsZXQgdGlja2luZyA9IGZhbHNlO1xuICBsZXQgYXJncyA9IFtdO1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucmVzdCkge1xuICAgIGFyZ3MgPSB1cGRhdGVBcmdzKHJlc3QpO1xuICAgIGlmICghdGlja2luZykge1xuICAgICAgdGlja2luZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICAgIHRpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChmbiwgZGVsYXksIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbGF5O1xuICB9O1xufVxuY29uc3QgX3RvTGVmdFJpZ2h0Q2VudGVyID0gKGFsaWduKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbmNvbnN0IF9hbGlnblN0YXJ0RW5kID0gKGFsaWduLCBzdGFydCwgZW5kKSA9PiBhbGlnbiA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogYWxpZ24gPT09ICdlbmQnID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG5jb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpID0+IHtcbiAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICByZXR1cm4gYWxpZ24gPT09IGNoZWNrID8gcmlnaHQgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyAobGVmdCArIHJpZ2h0KSAvIDIgOiBsZWZ0O1xufTtcbmZ1bmN0aW9uIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQgPSBwb2ludENvdW50O1xuICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgY29uc3Qge2lTY2FsZSwgX3BhcnNlZH0gPSBtZXRhO1xuICAgIGNvbnN0IGF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB7bWluLCBtYXgsIG1pbkRlZmluZWQsIG1heERlZmluZWR9ID0gaVNjYWxlLmdldFVzZXJCb3VuZHMoKTtcbiAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShNYXRoLm1pbihcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtaW4pLmxvLFxuICAgICAgICBhbmltYXRpb25zRGlzYWJsZWQgPyBwb2ludENvdW50IDogX2xvb2t1cEJ5S2V5KHBvaW50cywgYXhpcywgaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUobWluKSkubG8pLFxuICAgICAgMCwgcG9pbnRDb3VudCAtIDEpO1xuICAgIH1cbiAgICBpZiAobWF4RGVmaW5lZCkge1xuICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShNYXRoLm1heChcbiAgICAgICAgX2xvb2t1cEJ5S2V5KF9wYXJzZWQsIGlTY2FsZS5heGlzLCBtYXgsIHRydWUpLmhpICsgMSxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSksXG4gICAgICBzdGFydCwgcG9pbnRDb3VudCkgLSBzdGFydDtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbmZ1bmN0aW9uIF9zY2FsZVJhbmdlc0NoYW5nZWQobWV0YSkge1xuICBjb25zdCB7eFNjYWxlLCB5U2NhbGUsIF9zY2FsZVJhbmdlc30gPSBtZXRhO1xuICBjb25zdCBuZXdSYW5nZXMgPSB7XG4gICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICB4bWF4OiB4U2NhbGUubWF4LFxuICAgIHltaW46IHlTY2FsZS5taW4sXG4gICAgeW1heDogeVNjYWxlLm1heFxuICB9O1xuICBpZiAoIV9zY2FsZVJhbmdlcykge1xuICAgIG1ldGEuX3NjYWxlUmFuZ2VzID0gbmV3UmFuZ2VzO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGNoYW5nZWQgPSBfc2NhbGVSYW5nZXMueG1pbiAhPT0geFNjYWxlLm1pblxuXHRcdHx8IF9zY2FsZVJhbmdlcy54bWF4ICE9PSB4U2NhbGUubWF4XG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueW1heCAhPT0geVNjYWxlLm1heDtcbiAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gIHJldHVybiBjaGFuZ2VkO1xufVxuXG5jb25zdCBhdEVkZ2UgPSAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApID0+IC0oTWF0aC5wb3coMiwgMTAgKiAodCAtPSAxKSkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkpO1xuY29uc3QgZWxhc3RpY091dCA9ICh0LCBzLCBwKSA9PiBNYXRoLnBvdygyLCAtMTAgKiB0KSAqIE1hdGguc2luKCh0IC0gcykgKiBUQVUgLyBwKSArIDE7XG5jb25zdCBlZmZlY3RzID0ge1xuICBsaW5lYXI6IHQgPT4gdCxcbiAgZWFzZUluUXVhZDogdCA9PiB0ICogdCxcbiAgZWFzZU91dFF1YWQ6IHQgPT4gLXQgKiAodCAtIDIpLFxuICBlYXNlSW5PdXRRdWFkOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0XG4gICAgOiAtMC41ICogKCgtLXQpICogKHQgLSAyKSAtIDEpLFxuICBlYXNlSW5DdWJpYzogdCA9PiB0ICogdCAqIHQsXG4gIGVhc2VPdXRDdWJpYzogdCA9PiAodCAtPSAxKSAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0Q3ViaWM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICBlYXNlSW5RdWFydDogdCA9PiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVhcnQ6IHQgPT4gLSgodCAtPSAxKSAqIHQgKiB0ICogdCAtIDEpLFxuICBlYXNlSW5PdXRRdWFydDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gIGVhc2VJblF1aW50OiB0ID0+IHQgKiB0ICogdCAqIHQgKiB0LFxuICBlYXNlT3V0UXVpbnQ6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCAqIHQgKiB0ICsgMSxcbiAgZWFzZUluT3V0UXVpbnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdCAqIHRcbiAgICA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgZWFzZUluU2luZTogdCA9PiAtTWF0aC5jb3ModCAqIEhBTEZfUEkpICsgMSxcbiAgZWFzZU91dFNpbmU6IHQgPT4gTWF0aC5zaW4odCAqIEhBTEZfUEkpLFxuICBlYXNlSW5PdXRTaW5lOiB0ID0+IC0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICBlYXNlSW5FeHBvOiB0ID0+ICh0ID09PSAwKSA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICBlYXNlT3V0RXhwbzogdCA9PiAodCA9PT0gMSkgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgZWFzZUluT3V0RXhwbzogdCA9PiBhdEVkZ2UodCkgPyB0IDogdCA8IDAuNVxuICAgID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSlcbiAgICA6IDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKHQgKiAyIC0gMSkpICsgMiksXG4gIGVhc2VJbkNpcmM6IHQgPT4gKHQgPj0gMSkgPyB0IDogLShNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpLFxuICBlYXNlT3V0Q2lyYzogdCA9PiBNYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gIGVhc2VJbk91dENpcmM6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gLTAuNSAqIChNYXRoLnNxcnQoMSAtIHQgKiB0KSAtIDEpXG4gICAgOiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAodCAtPSAyKSAqIHQpICsgMSksXG4gIGVhc2VJbkVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNJbih0LCAwLjA3NSwgMC4zKSxcbiAgZWFzZU91dEVsYXN0aWM6IHQgPT4gYXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gIGVhc2VJbk91dEVsYXN0aWModCkge1xuICAgIGNvbnN0IHMgPSAwLjExMjU7XG4gICAgY29uc3QgcCA9IDAuNDU7XG4gICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOlxuICAgICAgdCA8IDAuNVxuICAgICAgICA/IDAuNSAqIGVsYXN0aWNJbih0ICogMiwgcywgcClcbiAgICAgICAgOiAwLjUgKyAwLjUgKiBlbGFzdGljT3V0KHQgKiAyIC0gMSwgcywgcCk7XG4gIH0sXG4gIGVhc2VJbkJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICB9LFxuICBlYXNlT3V0QmFjayh0KSB7XG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuICh0IC09IDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMTtcbiAgfSxcbiAgZWFzZUluT3V0QmFjayh0KSB7XG4gICAgbGV0IHMgPSAxLjcwMTU4O1xuICAgIGlmICgodCAvPSAwLjUpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqICh0ICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgfVxuICAgIHJldHVybiAwLjUgKiAoKHQgLT0gMikgKiB0ICogKCgocyAqPSAoMS41MjUpKSArIDEpICogdCArIHMpICsgMik7XG4gIH0sXG4gIGVhc2VJbkJvdW5jZTogdCA9PiAxIC0gZWZmZWN0cy5lYXNlT3V0Qm91bmNlKDEgLSB0KSxcbiAgZWFzZU91dEJvdW5jZSh0KSB7XG4gICAgY29uc3QgbSA9IDcuNTYyNTtcbiAgICBjb25zdCBkID0gMi43NTtcbiAgICBpZiAodCA8ICgxIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogdCAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgKDIgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMS41IC8gZCkpICogdCArIDAuNzU7XG4gICAgfVxuICAgIGlmICh0IDwgKDIuNSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqICh0IC09ICgyLjI1IC8gZCkpICogdCArIDAuOTM3NTtcbiAgICB9XG4gICAgcmV0dXJuIG0gKiAodCAtPSAoMi42MjUgLyBkKSkgKiB0ICsgMC45ODQzNzU7XG4gIH0sXG4gIGVhc2VJbk91dEJvdW5jZTogdCA9PiAodCA8IDAuNSlcbiAgICA/IGVmZmVjdHMuZWFzZUluQm91bmNlKHQgKiAyKSAqIDAuNVxuICAgIDogZWZmZWN0cy5lYXNlT3V0Qm91bmNlKHQgKiAyIC0gMSkgKiAwLjUgKyAwLjUsXG59O1xuXG4vKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMi4xXG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjIgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gbjJiKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIGIybih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAvIDIuNTUpIC8gMTAwLCAwLCAxKTtcbn1cbmZ1bmN0aW9uIG4ycCh2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDEwMCksIDAsIDEwMCk7XG59XG5jb25zdCBtYXAkMSA9IHswOiAwLCAxOiAxLCAyOiAyLCAzOiAzLCA0OiA0LCA1OiA1LCA2OiA2LCA3OiA3LCA4OiA4LCA5OiA5LCBBOiAxMCwgQjogMTEsIEM6IDEyLCBEOiAxMywgRTogMTQsIEY6IDE1LCBhOiAxMCwgYjogMTEsIGM6IDEyLCBkOiAxMywgZTogMTQsIGY6IDE1fTtcbmNvbnN0IGhleCA9IFsuLi4nMDEyMzQ1Njc4OUFCQ0RFRiddO1xuY29uc3QgaDEgPSBiID0+IGhleFtiICYgMHhGXTtcbmNvbnN0IGgyID0gYiA9PiBoZXhbKGIgJiAweEYwKSA+PiA0XSArIGhleFtiICYgMHhGXTtcbmNvbnN0IGVxID0gYiA9PiAoKGIgJiAweEYwKSA+PiA0KSA9PT0gKGIgJiAweEYpO1xuY29uc3QgaXNTaG9ydCA9IHYgPT4gZXEodi5yKSAmJiBlcSh2LmcpICYmIGVxKHYuYikgJiYgZXEodi5hKTtcbmZ1bmN0aW9uIGhleFBhcnNlKHN0cikge1xuICB2YXIgbGVuID0gc3RyLmxlbmd0aDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0clswXSA9PT0gJyMnKSB7XG4gICAgaWYgKGxlbiA9PT0gNCB8fCBsZW4gPT09IDUpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogMjU1ICYgbWFwJDFbc3RyWzFdXSAqIDE3LFxuICAgICAgICBnOiAyNTUgJiBtYXAkMVtzdHJbMl1dICogMTcsXG4gICAgICAgIGI6IDI1NSAmIG1hcCQxW3N0clszXV0gKiAxNyxcbiAgICAgICAgYTogbGVuID09PSA1ID8gbWFwJDFbc3RyWzRdXSAqIDE3IDogMjU1XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVuID09PSA3IHx8IGxlbiA9PT0gOSkge1xuICAgICAgcmV0ID0ge1xuICAgICAgICByOiBtYXAkMVtzdHJbMV1dIDw8IDQgfCBtYXAkMVtzdHJbMl1dLFxuICAgICAgICBnOiBtYXAkMVtzdHJbM11dIDw8IDQgfCBtYXAkMVtzdHJbNF1dLFxuICAgICAgICBiOiBtYXAkMVtzdHJbNV1dIDw8IDQgfCBtYXAkMVtzdHJbNl1dLFxuICAgICAgICBhOiBsZW4gPT09IDkgPyAobWFwJDFbc3RyWzddXSA8PCA0IHwgbWFwJDFbc3RyWzhdXSkgOiAyNTVcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXQ7XG59XG5jb25zdCBhbHBoYSA9IChhLCBmKSA9PiBhIDwgMjU1ID8gZihhKSA6ICcnO1xuZnVuY3Rpb24gaGV4U3RyaW5nKHYpIHtcbiAgdmFyIGYgPSBpc1Nob3J0KHYpID8gaDEgOiBoMjtcbiAgcmV0dXJuIHZcbiAgICA/ICcjJyArIGYodi5yKSArIGYodi5nKSArIGYodi5iKSArIGFscGhhKHYuYSwgZilcbiAgICA6IHVuZGVmaW5lZDtcbn1cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5jb25zdCBtYXAgPSB7XG4gIHg6ICdkYXJrJyxcbiAgWjogJ2xpZ2h0JyxcbiAgWTogJ3JlJyxcbiAgWDogJ2JsdScsXG4gIFc6ICdncicsXG4gIFY6ICdtZWRpdW0nLFxuICBVOiAnc2xhdGUnLFxuICBBOiAnZWUnLFxuICBUOiAnb2wnLFxuICBTOiAnb3InLFxuICBCOiAncmEnLFxuICBDOiAnbGF0ZWcnLFxuICBEOiAnaWdodHMnLFxuICBSOiAnaW4nLFxuICBROiAndHVycXVvaXMnLFxuICBFOiAnaGknLFxuICBQOiAncm8nLFxuICBPOiAnYWwnLFxuICBOOiAnbGUnLFxuICBNOiAnZGUnLFxuICBMOiAneWVsbG8nLFxuICBGOiAnZW4nLFxuICBLOiAnY2gnLFxuICBHOiAnYXJrcycsXG4gIEg6ICdlYScsXG4gIEk6ICdpZ2h0ZycsXG4gIEo6ICd3aCdcbn07XG5jb25zdCBuYW1lcyQxID0ge1xuICBPaWNlWGU6ICdmMGY4ZmYnLFxuICBhbnRpcXVld0V0ZTogJ2ZhZWJkNycsXG4gIGFxdWE6ICdmZmZmJyxcbiAgYXF1YW1hclJlOiAnN2ZmZmQ0JyxcbiAgYXp1WTogJ2YwZmZmZicsXG4gIGJlaWdlOiAnZjVmNWRjJyxcbiAgYmlzcXVlOiAnZmZlNGM0JyxcbiAgYmxhY2s6ICcwJyxcbiAgYmxhbktlZE9tb25kOiAnZmZlYmNkJyxcbiAgWGU6ICdmZicsXG4gIFhldmlUZXQ6ICc4YTJiZTInLFxuICBiUHduOiAnYTUyYTJhJyxcbiAgYnVybHl3b29kOiAnZGViODg3JyxcbiAgY2FNdFhlOiAnNWY5ZWEwJyxcbiAgS2FydFl1c2U6ICc3ZmZmMDAnLFxuICBLb2NUYXRlOiAnZDI2OTFlJyxcbiAgY1NPOiAnZmY3ZjUwJyxcbiAgY1NuZmxvd2VyWGU6ICc2NDk1ZWQnLFxuICBjU25zaWxrOiAnZmZmOGRjJyxcbiAgY3JpbXNvbjogJ2RjMTQzYycsXG4gIGN5YW46ICdmZmZmJyxcbiAgeFhlOiAnOGInLFxuICB4Y3lhbjogJzhiOGInLFxuICB4Z1RNblBkOiAnYjg4NjBiJyxcbiAgeFdheTogJ2E5YTlhOScsXG4gIHhnWUY6ICc2NDAwJyxcbiAgeGdZeTogJ2E5YTlhOScsXG4gIHhraGFraTogJ2JkYjc2YicsXG4gIHhtYWdGdGE6ICc4YjAwOGInLFxuICB4VGl2ZWdZRjogJzU1NmIyZicsXG4gIHhTYW5nZTogJ2ZmOGMwMCcsXG4gIHhTY0VkOiAnOTkzMmNjJyxcbiAgeFlkOiAnOGIwMDAwJyxcbiAgeHNPbW9uOiAnZTk5NjdhJyxcbiAgeHNIZ1lGOiAnOGZiYzhmJyxcbiAgeFVYZTogJzQ4M2Q4YicsXG4gIHhVV2F5OiAnMmY0ZjRmJyxcbiAgeFVnWXk6ICcyZjRmNGYnLFxuICB4UWU6ICdjZWQxJyxcbiAgeHZpVGV0OiAnOTQwMGQzJyxcbiAgZEFwcFJrOiAnZmYxNDkzJyxcbiAgZEFwc2t5WGU6ICdiZmZmJyxcbiAgZGltV2F5OiAnNjk2OTY5JyxcbiAgZGltZ1l5OiAnNjk2OTY5JyxcbiAgZG9kZ2VyWGU6ICcxZTkwZmYnLFxuICBmaVlicmljazogJ2IyMjIyMicsXG4gIGZsU093RXRlOiAnZmZmYWYwJyxcbiAgZm9Zc3RXQW46ICcyMjhiMjInLFxuICBmdUtzaWE6ICdmZjAwZmYnLFxuICBnYVJzYlNvOiAnZGNkY2RjJyxcbiAgZ2hvc3R3RXRlOiAnZjhmOGZmJyxcbiAgZ1RkOiAnZmZkNzAwJyxcbiAgZ1RNblBkOiAnZGFhNTIwJyxcbiAgV2F5OiAnODA4MDgwJyxcbiAgZ1lGOiAnODAwMCcsXG4gIGdZRkx3OiAnYWRmZjJmJyxcbiAgZ1l5OiAnODA4MDgwJyxcbiAgaG9uZXlNdzogJ2YwZmZmMCcsXG4gIGhvdHBSazogJ2ZmNjliNCcsXG4gIFJkaWFuWWQ6ICdjZDVjNWMnLFxuICBSZGlnbzogJzRiMDA4MicsXG4gIGl2U3k6ICdmZmZmZjAnLFxuICBraGFraTogJ2YwZTY4YycsXG4gIGxhdkZNcjogJ2U2ZTZmYScsXG4gIGxhdkZNclhzaDogJ2ZmZjBmNScsXG4gIGxhd25nWUY6ICc3Y2ZjMDAnLFxuICBObW9uY0VmZm9uOiAnZmZmYWNkJyxcbiAgWlhlOiAnYWRkOGU2JyxcbiAgWmNTTzogJ2YwODA4MCcsXG4gIFpjeWFuOiAnZTBmZmZmJyxcbiAgWmdUTW5QZEx3OiAnZmFmYWQyJyxcbiAgWldheTogJ2QzZDNkMycsXG4gIFpnWUY6ICc5MGVlOTAnLFxuICBaZ1l5OiAnZDNkM2QzJyxcbiAgWnBSazogJ2ZmYjZjMScsXG4gIFpzT21vbjogJ2ZmYTA3YScsXG4gIFpzSGdZRjogJzIwYjJhYScsXG4gIFpza3lYZTogJzg3Y2VmYScsXG4gIFpVV2F5OiAnNzc4ODk5JyxcbiAgWlVnWXk6ICc3Nzg4OTknLFxuICBac3RBbFhlOiAnYjBjNGRlJyxcbiAgWkx3OiAnZmZmZmUwJyxcbiAgbGltZTogJ2ZmMDAnLFxuICBsaW1lZ1lGOiAnMzJjZDMyJyxcbiAgbFJGOiAnZmFmMGU2JyxcbiAgbWFnRnRhOiAnZmYwMGZmJyxcbiAgbWFQb246ICc4MDAwMDAnLFxuICBWYXF1YW1hclJlOiAnNjZjZGFhJyxcbiAgVlhlOiAnY2QnLFxuICBWU2NFZDogJ2JhNTVkMycsXG4gIFZwdXJwTjogJzkzNzBkYicsXG4gIFZzSGdZRjogJzNjYjM3MScsXG4gIFZVWGU6ICc3YjY4ZWUnLFxuICBWc3ByUmdnWUY6ICdmYTlhJyxcbiAgVlFlOiAnNDhkMWNjJyxcbiAgVnZpVGV0WWQ6ICdjNzE1ODUnLFxuICBtaWRuaWdodFhlOiAnMTkxOTcwJyxcbiAgbVJ0Y1lhbTogJ2Y1ZmZmYScsXG4gIG1pc3R5UHNlOiAnZmZlNGUxJyxcbiAgbW9jY2FzUjogJ2ZmZTRiNScsXG4gIG5hdmFqb3dFdGU6ICdmZmRlYWQnLFxuICBuYXZ5OiAnODAnLFxuICBUZGxhY2U6ICdmZGY1ZTYnLFxuICBUaXZlOiAnODA4MDAwJyxcbiAgVGl2ZWRCYjogJzZiOGUyMycsXG4gIFNhbmdlOiAnZmZhNTAwJyxcbiAgU2FuZ2VZZDogJ2ZmNDUwMCcsXG4gIFNjRWQ6ICdkYTcwZDYnLFxuICBwT2VnVE1uUGQ6ICdlZWU4YWEnLFxuICBwT2VnWUY6ICc5OGZiOTgnLFxuICBwT2VRZTogJ2FmZWVlZScsXG4gIHBPZXZpVGV0WWQ6ICdkYjcwOTMnLFxuICBwYXBheWF3RXA6ICdmZmVmZDUnLFxuICBwSEtwdWZmOiAnZmZkYWI5JyxcbiAgcGVydTogJ2NkODUzZicsXG4gIHBSazogJ2ZmYzBjYicsXG4gIHBsdW06ICdkZGEwZGQnLFxuICBwb3dNclhlOiAnYjBlMGU2JyxcbiAgcHVycE46ICc4MDAwODAnLFxuICBZYmVjY2FwdXJwTjogJzY2MzM5OScsXG4gIFlkOiAnZmYwMDAwJyxcbiAgUHN5YnJvd246ICdiYzhmOGYnLFxuICBQeU9YZTogJzQxNjllMScsXG4gIHNhZGROYlB3bjogJzhiNDUxMycsXG4gIHNPbW9uOiAnZmE4MDcyJyxcbiAgc2FuZHliUHduOiAnZjRhNDYwJyxcbiAgc0hnWUY6ICcyZThiNTcnLFxuICBzSHNoZWxsOiAnZmZmNWVlJyxcbiAgc2lGbmE6ICdhMDUyMmQnLFxuICBzaWx2ZXI6ICdjMGMwYzAnLFxuICBza3lYZTogJzg3Y2VlYicsXG4gIFVYZTogJzZhNWFjZCcsXG4gIFVXYXk6ICc3MDgwOTAnLFxuICBVZ1l5OiAnNzA4MDkwJyxcbiAgc25vdzogJ2ZmZmFmYScsXG4gIHNwclJnZ1lGOiAnZmY3ZicsXG4gIHN0QWxYZTogJzQ2ODJiNCcsXG4gIHRhbjogJ2QyYjQ4YycsXG4gIHRlTzogJzgwODAnLFxuICB0RXN0TjogJ2Q4YmZkOCcsXG4gIHRvbWF0bzogJ2ZmNjM0NycsXG4gIFFlOiAnNDBlMGQwJyxcbiAgdmlUZXQ6ICdlZTgyZWUnLFxuICBKSHQ6ICdmNWRlYjMnLFxuICB3RXRlOiAnZmZmZmZmJyxcbiAgd0V0ZXNtb2tlOiAnZjVmNWY1JyxcbiAgTHc6ICdmZmZmMDAnLFxuICBMd2dZRjogJzlhY2QzMidcbn07XG5mdW5jdGlvbiB1bnBhY2soKSB7XG4gIGNvbnN0IHVucGFja2VkID0ge307XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhuYW1lcyQxKTtcbiAgY29uc3QgdGtleXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICBsZXQgaSwgaiwgaywgb2ssIG5rO1xuICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIG9rID0gbmsgPSBrZXlzW2ldO1xuICAgIGZvciAoaiA9IDA7IGogPCB0a2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgayA9IHRrZXlzW2pdO1xuICAgICAgbmsgPSBuay5yZXBsYWNlKGssIG1hcFtrXSk7XG4gICAgfVxuICAgIGsgPSBwYXJzZUludChuYW1lcyQxW29rXSwgMTYpO1xuICAgIHVucGFja2VkW25rXSA9IFtrID4+IDE2ICYgMHhGRiwgayA+PiA4ICYgMHhGRiwgayAmIDB4RkZdO1xuICB9XG4gIHJldHVybiB1bnBhY2tlZDtcbn1cbmxldCBuYW1lcztcbmZ1bmN0aW9uIG5hbWVQYXJzZShzdHIpIHtcbiAgaWYgKCFuYW1lcykge1xuICAgIG5hbWVzID0gdW5wYWNrKCk7XG4gICAgbmFtZXMudHJhbnNwYXJlbnQgPSBbMCwgMCwgMCwgMF07XG4gIH1cbiAgY29uc3QgYSA9IG5hbWVzW3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgcmV0dXJuIGEgJiYge1xuICAgIHI6IGFbMF0sXG4gICAgZzogYVsxXSxcbiAgICBiOiBhWzJdLFxuICAgIGE6IGEubGVuZ3RoID09PSA0ID8gYVszXSA6IDI1NVxuICB9O1xufVxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cbmNvbnN0IHRvID0gdiA9PiB2IDw9IDAuMDAzMTMwOCA/IHYgKiAxMi45MiA6IE1hdGgucG93KHYsIDEuMCAvIDIuNCkgKiAxLjA1NSAtIDAuMDU1O1xuY29uc3QgZnJvbSA9IHYgPT4gdiA8PSAwLjA0MDQ1ID8gdiAvIDEyLjkyIDogTWF0aC5wb3coKHYgKyAwLjA1NSkgLyAxLjA1NSwgMi40KTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKHJnYjEsIHJnYjIsIHQpIHtcbiAgY29uc3QgciA9IGZyb20oYjJuKHJnYjEucikpO1xuICBjb25zdCBnID0gZnJvbShiMm4ocmdiMS5nKSk7XG4gIGNvbnN0IGIgPSBmcm9tKGIybihyZ2IxLmIpKTtcbiAgcmV0dXJuIHtcbiAgICByOiBuMmIodG8ociArIHQgKiAoZnJvbShiMm4ocmdiMi5yKSkgLSByKSkpLFxuICAgIGc6IG4yYih0byhnICsgdCAqIChmcm9tKGIybihyZ2IyLmcpKSAtIGcpKSksXG4gICAgYjogbjJiKHRvKGIgKyB0ICogKGZyb20oYjJuKHJnYjIuYikpIC0gYikpKSxcbiAgICBhOiByZ2IxLmEgKyB0ICogKHJnYjIuYSAtIHJnYjEuYSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1vZEhTTCh2LCBpLCByYXRpbykge1xuICBpZiAodikge1xuICAgIGxldCB0bXAgPSByZ2IyaHNsKHYpO1xuICAgIHRtcFtpXSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHRtcFtpXSArIHRtcFtpXSAqIHJhdGlvLCBpID09PSAwID8gMzYwIDogMSkpO1xuICAgIHRtcCA9IGhzbDJyZ2IodG1wKTtcbiAgICB2LnIgPSB0bXBbMF07XG4gICAgdi5nID0gdG1wWzFdO1xuICAgIHYuYiA9IHRtcFsyXTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvbmUodiwgcHJvdG8pIHtcbiAgcmV0dXJuIHYgPyBPYmplY3QuYXNzaWduKHByb3RvIHx8IHt9LCB2KSA6IHY7XG59XG5mdW5jdGlvbiBmcm9tT2JqZWN0KGlucHV0KSB7XG4gIHZhciB2ID0ge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDI1NX07XG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIGlmIChpbnB1dC5sZW5ndGggPj0gMykge1xuICAgICAgdiA9IHtyOiBpbnB1dFswXSwgZzogaW5wdXRbMV0sIGI6IGlucHV0WzJdLCBhOiAyNTV9O1xuICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IDMpIHtcbiAgICAgICAgdi5hID0gbjJiKGlucHV0WzNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGNsb25lKGlucHV0LCB7cjogMCwgZzogMCwgYjogMCwgYTogMX0pO1xuICAgIHYuYSA9IG4yYih2LmEpO1xuICB9XG4gIHJldHVybiB2O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25QYXJzZShzdHIpIHtcbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICdyJykge1xuICAgIHJldHVybiByZ2JQYXJzZShzdHIpO1xuICB9XG4gIHJldHVybiBodWVQYXJzZShzdHIpO1xufVxuY2xhc3MgQ29sb3Ige1xuICBjb25zdHJ1Y3RvcihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIENvbG9yKSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgaW5wdXQ7XG4gICAgbGV0IHY7XG4gICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2ID0gZnJvbU9iamVjdChpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgdiA9IGhleFBhcnNlKGlucHV0KSB8fCBuYW1lUGFyc2UoaW5wdXQpIHx8IGZ1bmN0aW9uUGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB0aGlzLl9yZ2IgPSB2O1xuICAgIHRoaXMuX3ZhbGlkID0gISF2O1xuICB9XG4gIGdldCB2YWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQ7XG4gIH1cbiAgZ2V0IHJnYigpIHtcbiAgICB2YXIgdiA9IGNsb25lKHRoaXMuX3JnYik7XG4gICAgaWYgKHYpIHtcbiAgICAgIHYuYSA9IGIybih2LmEpO1xuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuICBzZXQgcmdiKG9iaikge1xuICAgIHRoaXMuX3JnYiA9IGZyb21PYmplY3Qob2JqKTtcbiAgfVxuICByZ2JTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gcmdiU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaGV4U3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IGhleFN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhzbFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoc2xTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBtaXgoY29sb3IsIHdlaWdodCkge1xuICAgIGlmIChjb2xvcikge1xuICAgICAgY29uc3QgYzEgPSB0aGlzLnJnYjtcbiAgICAgIGNvbnN0IGMyID0gY29sb3IucmdiO1xuICAgICAgbGV0IHcyO1xuICAgICAgY29uc3QgcCA9IHdlaWdodCA9PT0gdzIgPyAwLjUgOiB3ZWlnaHQ7XG4gICAgICBjb25zdCB3ID0gMiAqIHAgLSAxO1xuICAgICAgY29uc3QgYSA9IGMxLmEgLSBjMi5hO1xuICAgICAgY29uc3QgdzEgPSAoKHcgKiBhID09PSAtMSA/IHcgOiAodyArIGEpIC8gKDEgKyB3ICogYSkpICsgMSkgLyAyLjA7XG4gICAgICB3MiA9IDEgLSB3MTtcbiAgICAgIGMxLnIgPSAweEZGICYgdzEgKiBjMS5yICsgdzIgKiBjMi5yICsgMC41O1xuICAgICAgYzEuZyA9IDB4RkYgJiB3MSAqIGMxLmcgKyB3MiAqIGMyLmcgKyAwLjU7XG4gICAgICBjMS5iID0gMHhGRiAmIHcxICogYzEuYiArIHcyICogYzIuYiArIDAuNTtcbiAgICAgIGMxLmEgPSBwICogYzEuYSArICgxIC0gcCkgKiBjMi5hO1xuICAgICAgdGhpcy5yZ2IgPSBjMTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaW50ZXJwb2xhdGUoY29sb3IsIHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIHRoaXMuX3JnYiA9IGludGVycG9sYXRlKHRoaXMuX3JnYiwgY29sb3IuX3JnYiwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yZ2IpO1xuICB9XG4gIGFscGhhKGEpIHtcbiAgICB0aGlzLl9yZ2IuYSA9IG4yYihhKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbGVhcmVyKHJhdGlvKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIHJnYi5hICo9IDEgLSByYXRpbztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBncmV5c2NhbGUoKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5fcmdiO1xuICAgIGNvbnN0IHZhbCA9IHJvdW5kKHJnYi5yICogMC4zICsgcmdiLmcgKiAwLjU5ICsgcmdiLmIgKiAwLjExKTtcbiAgICByZ2IuciA9IHJnYi5nID0gcmdiLmIgPSB2YWw7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgb3BhcXVlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxICsgcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbmVnYXRlKCkge1xuICAgIGNvbnN0IHYgPSB0aGlzLl9yZ2I7XG4gICAgdi5yID0gMjU1IC0gdi5yO1xuICAgIHYuZyA9IDI1NSAtIHYuZztcbiAgICB2LmIgPSAyNTUgLSB2LmI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgbGlnaHRlbihyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDIsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkYXJrZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRlc2F0dXJhdGUocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAxLCAtcmF0aW8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJvdGF0ZShkZWcpIHtcbiAgICByb3RhdGUodGhpcy5fcmdiLCBkZWcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmZ1bmN0aW9uIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpIHtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCB0eXBlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBpbmRleF9lc20odmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICByZXR1cm4gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiBpbmRleF9lc20odmFsdWUpLnNhdHVyYXRlKDAuNSkuZGFya2VuKDAuMSkuaGV4U3RyaW5nKCk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBnZXRTY29wZSQxKG5vZGUsIGtleSkge1xuICBpZiAoIWtleSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgIG5vZGUgPSBub2RlW2tdIHx8IChub2RlW2tdID0gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBzZXQocm9vdCwgc2NvcGUsIHZhbHVlcykge1xuICBpZiAodHlwZW9mIHNjb3BlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBtZXJnZShnZXRTY29wZSQxKHJvb3QsIHNjb3BlKSwgdmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbmNsYXNzIERlZmF1bHRzIHtcbiAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzKSB7XG4gICAgdGhpcy5hbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICB0aGlzLmJvcmRlckNvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5jb2xvciA9ICcjNjY2JztcbiAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgdGhpcy5kZXZpY2VQaXhlbFJhdGlvID0gKGNvbnRleHQpID0+IGNvbnRleHQuY2hhcnQucGxhdGZvcm0uZ2V0RGV2aWNlUGl4ZWxSYXRpbygpO1xuICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICB0aGlzLmV2ZW50cyA9IFtcbiAgICAgICdtb3VzZW1vdmUnLFxuICAgICAgJ21vdXNlb3V0JyxcbiAgICAgICdjbGljaycsXG4gICAgICAndG91Y2hzdGFydCcsXG4gICAgICAndG91Y2htb3ZlJ1xuICAgIF07XG4gICAgdGhpcy5mb250ID0ge1xuICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICBzaXplOiAxMixcbiAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgIHdlaWdodDogbnVsbFxuICAgIH07XG4gICAgdGhpcy5ob3ZlciA9IHt9O1xuICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYmFja2dyb3VuZENvbG9yKTtcbiAgICB0aGlzLmhvdmVyQm9yZGVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgIHRoaXMuaG92ZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpID0+IGdldEhvdmVyQ29sb3Iob3B0aW9ucy5jb2xvcik7XG4gICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgdGhpcy5pbnRlcmFjdGlvbiA9IHtcbiAgICAgIG1vZGU6ICduZWFyZXN0JyxcbiAgICAgIGludGVyc2VjdDogdHJ1ZSxcbiAgICAgIGluY2x1ZGVJbnZpc2libGU6IGZhbHNlXG4gICAgfTtcbiAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgIHRoaXMub25Ib3ZlciA9IG51bGw7XG4gICAgdGhpcy5vbkNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgIHRoaXMucmVzcG9uc2l2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjYWxlcyA9IHt9O1xuICAgIHRoaXMuc2hvd0xpbmUgPSB0cnVlO1xuICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgIHRoaXMuZGVzY3JpYmUoX2Rlc2NyaXB0b3JzKTtcbiAgfVxuICBzZXQoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQodGhpcywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgZ2V0KHNjb3BlKSB7XG4gICAgcmV0dXJuIGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICB9XG4gIGRlc2NyaWJlKHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICBvdmVycmlkZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChvdmVycmlkZXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgIGNvbnN0IHNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCBzY29wZSk7XG4gICAgY29uc3QgdGFyZ2V0U2NvcGVPYmplY3QgPSBnZXRTY29wZSQxKHRoaXMsIHRhcmdldFNjb3BlKTtcbiAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2NvcGVPYmplY3QsIHtcbiAgICAgIFtwcml2YXRlTmFtZV06IHtcbiAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIFtuYW1lXToge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgY29uc3QgbG9jYWwgPSB0aGlzW3ByaXZhdGVOYW1lXTtcbiAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICBpZiAoaXNPYmplY3QobG9jYWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0LCBsb2NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG52YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoe1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gIF9pbmRleGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZXZlbnRzJyxcbiAgaG92ZXI6IHtcbiAgICBfZmFsbGJhY2s6ICdpbnRlcmFjdGlvbidcbiAgfSxcbiAgaW50ZXJhY3Rpb246IHtcbiAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICBpZiAoIWZvbnQgfHwgaXNOdWxsT3JVbmRlZihmb250LnNpemUpIHx8IGlzTnVsbE9yVW5kZWYoZm9udC5mYW1pbHkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIChmb250LnN0eWxlID8gZm9udC5zdHlsZSArICcgJyA6ICcnKVxuXHRcdCsgKGZvbnQud2VpZ2h0ID8gZm9udC53ZWlnaHQgKyAnICcgOiAnJylcblx0XHQrIGZvbnQuc2l6ZSArICdweCAnXG5cdFx0KyBmb250LmZhbWlseTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBzdHJpbmcpIHtcbiAgbGV0IHRleHRXaWR0aCA9IGRhdGFbc3RyaW5nXTtcbiAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ10gPSBjdHgubWVhc3VyZVRleHQoc3RyaW5nKS53aWR0aDtcbiAgICBnYy5wdXNoKHN0cmluZyk7XG4gIH1cbiAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICBsb25nZXN0ID0gdGV4dFdpZHRoO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2xvbmdlc3RUZXh0KGN0eCwgZm9udCwgYXJyYXlPZlRoaW5ncywgY2FjaGUpIHtcbiAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgbGV0IGRhdGEgPSBjYWNoZS5kYXRhID0gY2FjaGUuZGF0YSB8fCB7fTtcbiAgbGV0IGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCB8fCBbXTtcbiAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICBkYXRhID0gY2FjaGUuZGF0YSA9IHt9O1xuICAgIGdjID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgPSBbXTtcbiAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGZvbnQ7XG4gIGxldCBsb25nZXN0ID0gMDtcbiAgY29uc3QgaWxlbiA9IGFycmF5T2ZUaGluZ3MubGVuZ3RoO1xuICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgdGhpbmcgPSBhcnJheU9mVGhpbmdzW2ldO1xuICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmIGlzQXJyYXkodGhpbmcpICE9PSB0cnVlKSB7XG4gICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHRoaW5nKTtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkodGhpbmcpKSB7XG4gICAgICBmb3IgKGogPSAwLCBqbGVuID0gdGhpbmcubGVuZ3RoOyBqIDwgamxlbjsgaisrKSB7XG4gICAgICAgIG5lc3RlZFRoaW5nID0gdGhpbmdbal07XG4gICAgICAgIGlmIChuZXN0ZWRUaGluZyAhPT0gdW5kZWZpbmVkICYmIG5lc3RlZFRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KG5lc3RlZFRoaW5nKSkge1xuICAgICAgICAgIGxvbmdlc3QgPSBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgbmVzdGVkVGhpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG4gIGNvbnN0IGdjTGVuID0gZ2MubGVuZ3RoIC8gMjtcbiAgaWYgKGdjTGVuID4gYXJyYXlPZlRoaW5ncy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2NMZW47IGkrKykge1xuICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgIH1cbiAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICB9XG4gIHJldHVybiBsb25nZXN0O1xufVxuZnVuY3Rpb24gX2FsaWduUGl4ZWwoY2hhcnQsIHBpeGVsLCB3aWR0aCkge1xuICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW87XG4gIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgcmV0dXJuIE1hdGgucm91bmQoKHBpeGVsIC0gaGFsZldpZHRoKSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIGhhbGZXaWR0aDtcbn1cbmZ1bmN0aW9uIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KSB7XG4gIGN0eCA9IGN0eCB8fCBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHgsIHkpIHtcbiAgZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgbnVsbCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCB3KSB7XG4gIGxldCB0eXBlLCB4T2Zmc2V0LCB5T2Zmc2V0LCBzaXplLCBjb3JuZXJSYWRpdXMsIHdpZHRoO1xuICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgY29uc3Qgcm90YXRpb24gPSBvcHRpb25zLnJvdGF0aW9uO1xuICBjb25zdCByYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcbiAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICBpZiAoc3R5bGUgJiYgdHlwZW9mIHN0eWxlID09PSAnb2JqZWN0Jykge1xuICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgIGlmICh0eXBlID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHwgdHlwZSA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJykge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHgucm90YXRlKHJhZCk7XG4gICAgICBjdHguZHJhd0ltYWdlKHN0eWxlLCAtc3R5bGUud2lkdGggLyAyLCAtc3R5bGUuaGVpZ2h0IC8gMiwgc3R5bGUud2lkdGgsIHN0eWxlLmhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIHN3aXRjaCAoc3R5bGUpIHtcbiAgZGVmYXVsdDpcbiAgICBpZiAodykge1xuICAgICAgY3R4LmVsbGlwc2UoeCwgeSwgdyAvIDIsIHJhZGl1cywgMCwgMCwgVEFVKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIFRBVSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAndHJpYW5nbGUnOlxuICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICByYWQgKz0gVFdPX1RISVJEU19QSTtcbiAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgIHNpemUgPSByYWRpdXMgLSBjb3JuZXJSYWRpdXM7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiBzaXplO1xuICAgIGN0eC5hcmMoeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIFBJLCByYWQgLSBIQUxGX1BJKTtcbiAgICBjdHguYXJjKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBIQUxGX1BJLCByYWQpO1xuICAgIGN0eC5hcmMoeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCwgcmFkICsgSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkICsgSEFMRl9QSSwgcmFkICsgUEkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAncmVjdCc6XG4gICAgaWYgKCFyb3RhdGlvbikge1xuICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgIHdpZHRoID0gdyA/IHcgLyAyIDogc2l6ZTtcbiAgICAgIGN0eC5yZWN0KHggLSB3aWR0aCwgeSAtIHNpemUsIDIgKiB3aWR0aCwgMiAqIHNpemUpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdyZWN0Um90JzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjcm9zc1JvdCc6XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gIGNhc2UgJ2Nyb3NzJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3N0YXInOlxuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0KTtcbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2xpbmUnOlxuICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgIHlPZmZzZXQgPSBNYXRoLnNpbihyYWQpICogcmFkaXVzO1xuICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXQsIHkgLSB5T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2Rhc2gnOlxuICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqIHJhZGl1cywgeSArIE1hdGguc2luKHJhZCkgKiByYWRpdXMpO1xuICAgIGJyZWFrO1xuICB9XG4gIGN0eC5maWxsKCk7XG4gIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICBtYXJnaW4gPSBtYXJnaW4gfHwgMC41O1xuICByZXR1cm4gIWFyZWEgfHwgKHBvaW50ICYmIHBvaW50LnggPiBhcmVhLmxlZnQgLSBtYXJnaW4gJiYgcG9pbnQueCA8IGFyZWEucmlnaHQgKyBtYXJnaW4gJiZcblx0XHRwb2ludC55ID4gYXJlYS50b3AgLSBtYXJnaW4gJiYgcG9pbnQueSA8IGFyZWEuYm90dG9tICsgbWFyZ2luKTtcbn1cbmZ1bmN0aW9uIGNsaXBBcmVhKGN0eCwgYXJlYSkge1xuICBjdHguc2F2ZSgpO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5yZWN0KGFyZWEubGVmdCwgYXJlYS50b3AsIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgfVxuICBpZiAobW9kZSA9PT0gJ21pZGRsZScpIHtcbiAgICBjb25zdCBtaWRwb2ludCA9IChwcmV2aW91cy54ICsgdGFyZ2V0LngpIC8gMi4wO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHRhcmdldC55KTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICBjdHgubGluZVRvKHByZXZpb3VzLngsIHRhcmdldC55KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgubGluZVRvKHRhcmdldC54LCBwcmV2aW91cy55KTtcbiAgfVxuICBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgY3R4LmJlemllckN1cnZlVG8oXG4gICAgZmxpcCA/IHByZXZpb3VzLmNwMXggOiBwcmV2aW91cy5jcDJ4LFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF5IDogcHJldmlvdXMuY3AyeSxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCxcbiAgICBmbGlwID8gdGFyZ2V0LmNwMnkgOiB0YXJnZXQuY3AxeSxcbiAgICB0YXJnZXQueCxcbiAgICB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiByZW5kZXJUZXh0KGN0eCwgdGV4dCwgeCwgeSwgZm9udCwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheSh0ZXh0KSA/IHRleHQgOiBbdGV4dF07XG4gIGNvbnN0IHN0cm9rZSA9IG9wdHMuc3Ryb2tlV2lkdGggPiAwICYmIG9wdHMuc3Ryb2tlQ29sb3IgIT09ICcnO1xuICBsZXQgaSwgbGluZTtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICBmb3IgKGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICBsaW5lID0gbGluZXNbaV07XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0cy5zdHJva2VDb2xvcjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnN0cm9rZVdpZHRoKSkge1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5zdHJva2VXaWR0aDtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIH1cbiAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cyk7XG4gICAgeSArPSBmb250LmxpbmVIZWlnaHQ7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKSB7XG4gIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgY3R4LnRyYW5zbGF0ZShvcHRzLnRyYW5zbGF0aW9uWzBdLCBvcHRzLnRyYW5zbGF0aW9uWzFdKTtcbiAgfVxuICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5yb3RhdGlvbikpIHtcbiAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICB9XG4gIGlmIChvcHRzLmNvbG9yKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gIH1cbiAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdHMudGV4dEFsaWduO1xuICB9XG4gIGlmIChvcHRzLnRleHRCYXNlbGluZSkge1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVjb3JhdGVUZXh0KGN0eCwgeCwgeSwgbGluZSwgb3B0cykge1xuICBpZiAob3B0cy5zdHJpa2V0aHJvdWdoIHx8IG9wdHMudW5kZXJsaW5lKSB7XG4gICAgY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICBjb25zdCBsZWZ0ID0geCAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0O1xuICAgIGNvbnN0IHJpZ2h0ID0geCArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodDtcbiAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICBjb25zdCBib3R0b20gPSB5ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgY29uc3QgeURlY29yYXRpb24gPSBvcHRzLnN0cmlrZXRocm91Z2ggPyAodG9wICsgYm90dG9tKSAvIDIgOiBib3R0b207XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuZGVjb3JhdGlvbldpZHRoIHx8IDI7XG4gICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgY3R4LmxpbmVUbyhyaWdodCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICBjb25zdCB7eCwgeSwgdywgaCwgcmFkaXVzfSA9IHJlY3Q7XG4gIGN0eC5hcmMoeCArIHJhZGl1cy50b3BMZWZ0LCB5ICsgcmFkaXVzLnRvcExlZnQsIHJhZGl1cy50b3BMZWZ0LCAtSEFMRl9QSSwgUEksIHRydWUpO1xuICBjdHgubGluZVRvKHgsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQpO1xuICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgdywgeSArIHJhZGl1cy50b3BSaWdodCk7XG4gIGN0eC5hcmMoeCArIHcgLSByYWRpdXMudG9wUmlnaHQsIHkgKyByYWRpdXMudG9wUmlnaHQsIHJhZGl1cy50b3BSaWdodCwgMCwgLUhBTEZfUEksIHRydWUpO1xuICBjdHgubGluZVRvKHggKyByYWRpdXMudG9wTGVmdCwgeSk7XG59XG5cbmNvbnN0IExJTkVfSEVJR0hUID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8KFxcZCsoPzpcXC5cXGQrKT8pKHB4fGVtfCUpPykkLyk7XG5jb25zdCBGT05UX1NUWUxFID0gbmV3IFJlZ0V4cCgvXihub3JtYWx8aXRhbGljfGluaXRpYWx8aW5oZXJpdHx1bnNldHwob2JsaXF1ZSggLT9bMC05XT9bMC05XWRlZyk/KSkkLyk7XG5mdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgY29uc3QgbWF0Y2hlcyA9ICgnJyArIHZhbHVlKS5tYXRjaChMSU5FX0hFSUdIVCk7XG4gIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzWzFdID09PSAnbm9ybWFsJykge1xuICAgIHJldHVybiBzaXplICogMS4yO1xuICB9XG4gIHZhbHVlID0gK21hdGNoZXNbMl07XG4gIHN3aXRjaCAobWF0Y2hlc1szXSkge1xuICBjYXNlICdweCc6XG4gICAgcmV0dXJuIHZhbHVlO1xuICBjYXNlICclJzpcbiAgICB2YWx1ZSAvPSAxMDA7XG4gICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHNpemUgKiB2YWx1ZTtcbn1cbmNvbnN0IG51bWJlck9yWmVybyA9IHYgPT4gK3YgfHwgMDtcbmZ1bmN0aW9uIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBwcm9wcykge1xuICBjb25zdCByZXQgPSB7fTtcbiAgY29uc3Qgb2JqUHJvcHMgPSBpc09iamVjdChwcm9wcyk7XG4gIGNvbnN0IGtleXMgPSBvYmpQcm9wcyA/IE9iamVjdC5rZXlzKHByb3BzKSA6IHByb3BzO1xuICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpXG4gICAgPyBvYmpQcm9wc1xuICAgICAgPyBwcm9wID0+IHZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pXG4gICAgICA6IHByb3AgPT4gdmFsdWVbcHJvcF1cbiAgICA6ICgpID0+IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cykge1xuICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwge3RvcDogJ3knLCByaWdodDogJ3gnLCBib3R0b206ICd5JywgbGVmdDogJ3gnfSk7XG59XG5mdW5jdGlvbiB0b1RSQkxDb3JuZXJzKHZhbHVlKSB7XG4gIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgWyd0b3BMZWZ0JywgJ3RvcFJpZ2h0JywgJ2JvdHRvbUxlZnQnLCAnYm90dG9tUmlnaHQnXSk7XG59XG5mdW5jdGlvbiB0b1BhZGRpbmcodmFsdWUpIHtcbiAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgb2JqLndpZHRoID0gb2JqLmxlZnQgKyBvYmoucmlnaHQ7XG4gIG9iai5oZWlnaHQgPSBvYmoudG9wICsgb2JqLmJvdHRvbTtcbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgZmFsbGJhY2sgPSBmYWxsYmFjayB8fCBkZWZhdWx0cy5mb250O1xuICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICB9XG4gIGxldCBzdHlsZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc3R5bGUsIGZhbGxiYWNrLnN0eWxlKTtcbiAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgZm9udCBzdHlsZSBzcGVjaWZpZWQ6IFwiJyArIHN0eWxlICsgJ1wiJyk7XG4gICAgc3R5bGUgPSAnJztcbiAgfVxuICBjb25zdCBmb250ID0ge1xuICAgIGZhbWlseTogdmFsdWVPckRlZmF1bHQob3B0aW9ucy5mYW1pbHksIGZhbGxiYWNrLmZhbWlseSksXG4gICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgIHNpemUsXG4gICAgc3R5bGUsXG4gICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICBzdHJpbmc6ICcnXG4gIH07XG4gIGZvbnQuc3RyaW5nID0gdG9Gb250U3RyaW5nKGZvbnQpO1xuICByZXR1cm4gZm9udDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXRzLCBjb250ZXh0LCBpbmRleCwgaW5mbykge1xuICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQgJiYgaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVbaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5mbyAmJiAhY2FjaGVhYmxlKSB7XG4gICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfYWRkR3JhY2UobWlubWF4LCBncmFjZSwgYmVnaW5BdFplcm8pIHtcbiAgY29uc3Qge21pbiwgbWF4fSA9IG1pbm1heDtcbiAgY29uc3QgY2hhbmdlID0gdG9EaW1lbnNpb24oZ3JhY2UsIChtYXggLSBtaW4pIC8gMik7XG4gIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpID0+IGJlZ2luQXRaZXJvICYmIHZhbHVlID09PSAwID8gMCA6IHZhbHVlICsgYWRkO1xuICByZXR1cm4ge1xuICAgIG1pbjoga2VlcFplcm8obWluLCAtTWF0aC5hYnMoY2hhbmdlKSksXG4gICAgbWF4OiBrZWVwWmVybyhtYXgsIGNoYW5nZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocGFyZW50Q29udGV4dCwgY29udGV4dCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbJyddLCByb290U2NvcGVzID0gc2NvcGVzLCBmYWxsYmFjaywgZ2V0VGFyZ2V0ID0gKCkgPT4gc2NvcGVzWzBdKSB7XG4gIGlmICghZGVmaW5lZChmYWxsYmFjaykpIHtcbiAgICBmYWxsYmFjayA9IF9yZXNvbHZlKCdfZmFsbGJhY2snLCBzY29wZXMpO1xuICB9XG4gIGNvbnN0IGNhY2hlID0ge1xuICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICBfY2FjaGVhYmxlOiB0cnVlLFxuICAgIF9zY29wZXM6IHNjb3BlcyxcbiAgICBfcm9vdFNjb3Blczogcm9vdFNjb3BlcyxcbiAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgIF9nZXRUYXJnZXQ6IGdldFRhcmdldCxcbiAgICBvdmVycmlkZTogKHNjb3BlKSA9PiBfY3JlYXRlUmVzb2x2ZXIoW3Njb3BlLCAuLi5zY29wZXNdLCBwcmVmaXhlcywgcm9vdFNjb3BlcywgZmFsbGJhY2spLFxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIGRlbGV0ZSBzY29wZXNbMF1bcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldCh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgdGFyZ2V0KSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0Ll9zY29wZXNbMF0sIHByb3ApO1xuICAgIH0sXG4gICAgZ2V0UHJvdG90eXBlT2YoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkuaW5jbHVkZXMocHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKHRhcmdldCkge1xuICAgICAgcmV0dXJuIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRhcmdldC5fc3RvcmFnZSB8fCAodGFyZ2V0Ll9zdG9yYWdlID0gZ2V0VGFyZ2V0KCkpO1xuICAgICAgdGFyZ2V0W3Byb3BdID0gc3RvcmFnZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldC5fa2V5cztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfYXR0YWNoQ29udGV4dChwcm94eSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICBjb25zdCBjYWNoZSA9IHtcbiAgICBfY2FjaGVhYmxlOiBmYWxzZSxcbiAgICBfcHJveHk6IHByb3h5LFxuICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgIF9zdWJQcm94eTogc3ViUHJveHksXG4gICAgX3N0YWNrOiBuZXcgU2V0KCksXG4gICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgc2V0Q29udGV4dDogKGN0eCkgPT4gX2F0dGFjaENvbnRleHQocHJveHksIGN0eCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2F0dGFjaENvbnRleHQocHJveHkub3ZlcnJpZGUoc2NvcGUpLCBjb250ZXh0LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKVxuICB9O1xuICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB7XG4gICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdO1xuICAgICAgZGVsZXRlIHByb3h5W3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLFxuICAgICAgICAoKSA9PiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpKTtcbiAgICB9LFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiB0YXJnZXQuX2Rlc2NyaXB0b3JzLmFsbEtleXNcbiAgICAgICAgPyBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCkgPyB7ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlfSA6IHVuZGVmaW5lZFxuICAgICAgICA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YocHJveHkpO1xuICAgIH0sXG4gICAgaGFzKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKTtcbiAgICB9LFxuICAgIG93bktleXMoKSB7XG4gICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHByb3h5KTtcbiAgICB9LFxuICAgIHNldCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICBwcm94eVtwcm9wXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBfZGVzY3JpcHRvcnMocHJveHksIGRlZmF1bHRzID0ge3NjcmlwdGFibGU6IHRydWUsIGluZGV4YWJsZTogdHJ1ZX0pIHtcbiAgY29uc3Qge19zY3JpcHRhYmxlID0gZGVmYXVsdHMuc2NyaXB0YWJsZSwgX2luZGV4YWJsZSA9IGRlZmF1bHRzLmluZGV4YWJsZSwgX2FsbEtleXMgPSBkZWZhdWx0cy5hbGxLZXlzfSA9IHByb3h5O1xuICByZXR1cm4ge1xuICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgIHNjcmlwdGFibGU6IF9zY3JpcHRhYmxlLFxuICAgIGluZGV4YWJsZTogX2luZGV4YWJsZSxcbiAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKSA9PiBfc2NyaXB0YWJsZSxcbiAgICBpc0luZGV4YWJsZTogaXNGdW5jdGlvbihfaW5kZXhhYmxlKSA/IF9pbmRleGFibGUgOiAoKSA9PiBfaW5kZXhhYmxlXG4gIH07XG59XG5jb25zdCByZWFkS2V5ID0gKHByZWZpeCwgbmFtZSkgPT4gcHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIHByb3AgIT09ICdhZGFwdGVycycgJiZcbiAgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwgfHwgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCk7XG5mdW5jdGlvbiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgcmVzb2x2ZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkpIHtcbiAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICB9XG4gIGNvbnN0IHZhbHVlID0gcmVzb2x2ZSgpO1xuICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSAmJiBkZXNjcmlwdG9ycy5pc1NjcmlwdGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCkge1xuICAgIHZhbHVlID0gX3Jlc29sdmVBcnJheShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCBkZXNjcmlwdG9ycy5pc0luZGV4YWJsZSk7XG4gIH1cbiAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX3N0YWNrfSA9IHRhcmdldDtcbiAgaWYgKF9zdGFjay5oYXMocHJvcCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICB9XG4gIF9zdGFjay5hZGQocHJvcCk7XG4gIHZhbHVlID0gdmFsdWUoX2NvbnRleHQsIF9zdWJQcm94eSB8fCByZWNlaXZlcik7XG4gIF9zdGFjay5kZWxldGUocHJvcCk7XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgaXNJbmRleGFibGUpIHtcbiAgY29uc3Qge19wcm94eSwgX2NvbnRleHQsIF9zdWJQcm94eSwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9yc30gPSB0YXJnZXQ7XG4gIGlmIChkZWZpbmVkKF9jb250ZXh0LmluZGV4KSAmJiBpc0luZGV4YWJsZShwcm9wKSkge1xuICAgIHZhbHVlID0gdmFsdWVbX2NvbnRleHQuaW5kZXggJSB2YWx1ZS5sZW5ndGhdO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgIGNvbnN0IHNjb3BlcyA9IF9wcm94eS5fc2NvcGVzLmZpbHRlcihzID0+IHMgIT09IGFycik7XG4gICAgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICBjb25zdCByZXNvbHZlciA9IGNyZWF0ZVN1YlJlc29sdmVyKHNjb3BlcywgX3Byb3h5LCBwcm9wLCBpdGVtKTtcbiAgICAgIHZhbHVlLnB1c2goX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiByZXNvbHZlRmFsbGJhY2soZmFsbGJhY2ssIHByb3AsIHZhbHVlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpID0+IGtleSA9PT0gdHJ1ZSA/IHBhcmVudFxuICA6IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcmVzb2x2ZU9iamVjdEtleShwYXJlbnQsIGtleSkgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBhZGRTY29wZXMoc2V0LCBwYXJlbnRTY29wZXMsIGtleSwgcGFyZW50RmFsbGJhY2ssIHZhbHVlKSB7XG4gIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcykge1xuICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgIGlmIChzY29wZSkge1xuICAgICAgc2V0LmFkZChzY29wZSk7XG4gICAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhzY29wZS5fZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgICAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiBkZWZpbmVkKHBhcmVudEZhbGxiYWNrKSAmJiBrZXkgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ViUmVzb2x2ZXIocGFyZW50U2NvcGVzLCByZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3Qgcm9vdFNjb3BlcyA9IHJlc29sdmVyLl9yb290U2NvcGVzO1xuICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgY29uc3QgYWxsU2NvcGVzID0gWy4uLnBhcmVudFNjb3BlcywgLi4ucm9vdFNjb3Blc107XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGRlZmluZWQoZmFsbGJhY2spICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgZmFsbGJhY2ssIGtleSwgdmFsdWUpO1xuICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVSZXNvbHZlcihBcnJheS5mcm9tKHNldCksIFsnJ10sIHJvb3RTY29wZXMsIGZhbGxiYWNrLFxuICAgICgpID0+IHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pIHtcbiAgd2hpbGUgKGtleSkge1xuICAgIGtleSA9IGFkZFNjb3BlcyhzZXQsIGFsbFNjb3Blcywga2V5LCBmYWxsYmFjaywgaXRlbSk7XG4gIH1cbiAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgY29uc3QgcGFyZW50ID0gcmVzb2x2ZXIuX2dldFRhcmdldCgpO1xuICBpZiAoIShwcm9wIGluIHBhcmVudCkpIHtcbiAgICBwYXJlbnRbcHJvcF0gPSB7fTtcbiAgfVxuICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gIGlmIChpc0FycmF5KHRhcmdldCkgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICBsZXQgdmFsdWU7XG4gIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZShyZWFkS2V5KHByZWZpeCwgcHJvcCksIHNjb3Blcyk7XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gbmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSlcbiAgICAgICAgPyBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIHByb3h5LCBwcm9wLCB2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9yZXNvbHZlKGtleSwgc2NvcGVzKSB7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgaWYgKCFzY29wZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gc2NvcGVba2V5XTtcbiAgICBpZiAoZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEtleXNGcm9tQWxsU2NvcGVzKHRhcmdldCkge1xuICBsZXQga2V5cyA9IHRhcmdldC5fa2V5cztcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IHRhcmdldC5fa2V5cyA9IHJlc29sdmVLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQuX3Njb3Blcyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXMoc2NvcGVzKSB7XG4gIGNvbnN0IHNldCA9IG5ldyBTZXQoKTtcbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKGsgPT4gIWsuc3RhcnRzV2l0aCgnXycpKSkge1xuICAgICAgc2V0LmFkZChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpO1xufVxuZnVuY3Rpb24gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCB7aVNjYWxlfSA9IG1ldGE7XG4gIGNvbnN0IHtrZXkgPSAncid9ID0gdGhpcy5fcGFyc2luZztcbiAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgcGFyc2VkW2ldID0ge1xuICAgICAgcjogaVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwga2V5KSwgaW5kZXgpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcGFyc2VkO1xufVxuXG5jb25zdCBFUFNJTE9OID0gTnVtYmVyLkVQU0lMT04gfHwgMWUtMTQ7XG5jb25zdCBnZXRQb2ludCA9IChwb2ludHMsIGkpID0+IGkgPCBwb2ludHMubGVuZ3RoICYmICFwb2ludHNbaV0uc2tpcCAmJiBwb2ludHNbaV07XG5jb25zdCBnZXRWYWx1ZUF4aXMgPSAoaW5kZXhBeGlzKSA9PiBpbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gIGNvbnN0IHByZXZpb3VzID0gZmlyc3RQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBmaXJzdFBvaW50O1xuICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gIGNvbnN0IG5leHQgPSBhZnRlclBvaW50LnNraXAgPyBtaWRkbGVQb2ludCA6IGFmdGVyUG9pbnQ7XG4gIGNvbnN0IGQwMSA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhjdXJyZW50LCBwcmV2aW91cyk7XG4gIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgbGV0IHMwMSA9IGQwMSAvIChkMDEgKyBkMTIpO1xuICBsZXQgczEyID0gZDEyIC8gKGQwMSArIGQxMik7XG4gIHMwMSA9IGlzTmFOKHMwMSkgPyAwIDogczAxO1xuICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgY29uc3QgZmEgPSB0ICogczAxO1xuICBjb25zdCBmYiA9IHQgKiBzMTI7XG4gIHJldHVybiB7XG4gICAgcHJldmlvdXM6IHtcbiAgICAgIHg6IGN1cnJlbnQueCAtIGZhICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55IC0gZmEgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9LFxuICAgIG5leHQ6IHtcbiAgICAgIHg6IGN1cnJlbnQueCArIGZiICogKG5leHQueCAtIHByZXZpb3VzLngpLFxuICAgICAgeTogY3VycmVudC55ICsgZmIgKiAobmV4dC55IC0gcHJldmlvdXMueSlcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtb25vdG9uZUFkanVzdChwb2ludHMsIGRlbHRhSywgbUspIHtcbiAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IGFscGhhSywgYmV0YUssIHRhdUssIHNxdWFyZWRNYWduaXR1ZGUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbiAtIDE7ICsraSkge1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50IHx8ICFwb2ludEFmdGVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgYWxwaGFLID0gbUtbaV0gLyBkZWx0YUtbaV07XG4gICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgc3F1YXJlZE1hZ25pdHVkZSA9IE1hdGgucG93KGFscGhhSywgMikgKyBNYXRoLnBvdyhiZXRhSywgMik7XG4gICAgaWYgKHNxdWFyZWRNYWduaXR1ZGUgPD0gOSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRhdUsgPSAzIC8gTWF0aC5zcXJ0KHNxdWFyZWRNYWduaXR1ZGUpO1xuICAgIG1LW2ldID0gYWxwaGFLICogdGF1SyAqIGRlbHRhS1tpXTtcbiAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gIH1cbn1cbmZ1bmN0aW9uIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBkZWx0YSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpUGl4ZWwgPSBwb2ludEN1cnJlbnRbaW5kZXhBeGlzXTtcbiAgICBjb25zdCB2UGl4ZWwgPSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXTtcbiAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgZGVsdGEgPSAocG9pbnRBZnRlcltpbmRleEF4aXNdIC0gaVBpeGVsKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7aW5kZXhBeGlzfWBdID0gaVBpeGVsICsgZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMiR7dmFsdWVBeGlzfWBdID0gdlBpeGVsICsgZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMgPSAneCcpIHtcbiAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IGRlbHRhSyA9IEFycmF5KHBvaW50c0xlbikuZmlsbCgwKTtcbiAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICBsZXQgaSwgcG9pbnRCZWZvcmUsIHBvaW50Q3VycmVudDtcbiAgbGV0IHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIDApO1xuICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpIHtcbiAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICBjb25zdCBzbG9wZURlbHRhID0gcG9pbnRBZnRlcltpbmRleEF4aXNdIC0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgIH1cbiAgICBtS1tpXSA9ICFwb2ludEJlZm9yZSA/IGRlbHRhS1tpXVxuICAgICAgOiAhcG9pbnRBZnRlciA/IGRlbHRhS1tpIC0gMV1cbiAgICAgIDogKHNpZ24oZGVsdGFLW2kgLSAxXSkgIT09IHNpZ24oZGVsdGFLW2ldKSkgPyAwXG4gICAgICA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gIH1cbiAgbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKTtcbiAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChNYXRoLm1pbihwdCwgbWF4KSwgbWluKTtcbn1cbmZ1bmN0aW9uIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBpbkFyZWEsIGluQXJlYVByZXY7XG4gIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpbkFyZWFQcmV2ID0gaW5BcmVhO1xuICAgIGluQXJlYSA9IGluQXJlYU5leHQ7XG4gICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICBpZiAoIWluQXJlYSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgIGlmIChpbkFyZWFQcmV2KSB7XG4gICAgICBwb2ludC5jcDF4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXgsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDF5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMXksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyhwb2ludHMsIG9wdGlvbnMsIGFyZWEsIGxvb3AsIGluZGV4QXhpcykge1xuICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gIGlmIChvcHRpb25zLnNwYW5HYXBzKSB7XG4gICAgcG9pbnRzID0gcG9pbnRzLmZpbHRlcigocHQpID0+ICFwdC5za2lwKTtcbiAgfVxuICBpZiAob3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgc3BsaW5lQ3VydmVNb25vdG9uZShwb2ludHMsIGluZGV4QXhpcyk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IHByZXYgPSBsb29wID8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSA6IHBvaW50c1swXTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICBjb250cm9sUG9pbnRzID0gc3BsaW5lQ3VydmUoXG4gICAgICAgIHByZXYsXG4gICAgICAgIHBvaW50LFxuICAgICAgICBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSxcbiAgICAgICAgb3B0aW9ucy50ZW5zaW9uXG4gICAgICApO1xuICAgICAgcG9pbnQuY3AxeCA9IGNvbnRyb2xQb2ludHMucHJldmlvdXMueDtcbiAgICAgIHBvaW50LmNwMXkgPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLnk7XG4gICAgICBwb2ludC5jcDJ4ID0gY29udHJvbFBvaW50cy5uZXh0Lng7XG4gICAgICBwb2ludC5jcDJ5ID0gY29udHJvbFBvaW50cy5uZXh0Lnk7XG4gICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICB9XG4gIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgIGNhcEJlemllclBvaW50cyhwb2ludHMsIGFyZWEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc0RvbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBfZ2V0UGFyZW50Tm9kZShkb21Ob2RlKSB7XG4gIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJykge1xuICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICB9XG4gIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwYXJzZU1heFN0eWxlKHN0eWxlVmFsdWUsIG5vZGUsIHBhcmVudFByb3BlcnR5KSB7XG4gIGxldCB2YWx1ZUluUGl4ZWxzO1xuICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWVJblBpeGVscyA9IHBhcnNlSW50KHN0eWxlVmFsdWUsIDEwKTtcbiAgICBpZiAoc3R5bGVWYWx1ZS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICB2YWx1ZUluUGl4ZWxzID0gdmFsdWVJblBpeGVscyAvIDEwMCAqIG5vZGUucGFyZW50Tm9kZVtwYXJlbnRQcm9wZXJ0eV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBzdHlsZVZhbHVlO1xuICB9XG4gIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KSA9PiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbmZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuZnVuY3Rpb24gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlcywgc3R5bGUsIHN1ZmZpeCkge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgY29uc3QgcG9zID0gcG9zaXRpb25zW2ldO1xuICAgIHJlc3VsdFtwb3NdID0gcGFyc2VGbG9hdChzdHlsZXNbc3R5bGUgKyAnLScgKyBwb3MgKyBzdWZmaXhdKSB8fCAwO1xuICB9XG4gIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICByZXN1bHQuaGVpZ2h0ID0gcmVzdWx0LnRvcCArIHJlc3VsdC5ib3R0b207XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCB1c2VPZmZzZXRQb3MgPSAoeCwgeSwgdGFyZ2V0KSA9PiAoeCA+IDAgfHwgeSA+IDApICYmICghdGFyZ2V0IHx8ICF0YXJnZXQuc2hhZG93Um9vdCk7XG5mdW5jdGlvbiBnZXRDYW52YXNQb3NpdGlvbihlLCBjYW52YXMpIHtcbiAgY29uc3QgdG91Y2hlcyA9IGUudG91Y2hlcztcbiAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICBjb25zdCB7b2Zmc2V0WCwgb2Zmc2V0WX0gPSBzb3VyY2U7XG4gIGxldCBib3ggPSBmYWxzZTtcbiAgbGV0IHgsIHk7XG4gIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgeCA9IG9mZnNldFg7XG4gICAgeSA9IG9mZnNldFk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgeSA9IHNvdXJjZS5jbGllbnRZIC0gcmVjdC50b3A7XG4gICAgYm94ID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4ge3gsIHksIGJveH07XG59XG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2dCwgY2hhcnQpIHtcbiAgaWYgKCduYXRpdmUnIGluIGV2dCkge1xuICAgIHJldHVybiBldnQ7XG4gIH1cbiAgY29uc3Qge2NhbnZhcywgY3VycmVudERldmljZVBpeGVsUmF0aW99ID0gY2hhcnQ7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBib3JkZXJCb3ggPSBzdHlsZS5ib3hTaXppbmcgPT09ICdib3JkZXItYm94JztcbiAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgY29uc3Qge3gsIHksIGJveH0gPSBnZXRDYW52YXNQb3NpdGlvbihldnQsIGNhbnZhcyk7XG4gIGNvbnN0IHhPZmZzZXQgPSBwYWRkaW5ncy5sZWZ0ICsgKGJveCAmJiBib3JkZXJzLmxlZnQpO1xuICBjb25zdCB5T2Zmc2V0ID0gcGFkZGluZ3MudG9wICsgKGJveCAmJiBib3JkZXJzLnRvcCk7XG4gIGxldCB7d2lkdGgsIGhlaWdodH0gPSBjaGFydDtcbiAgaWYgKGJvcmRlckJveCkge1xuICAgIHdpZHRoIC09IHBhZGRpbmdzLndpZHRoICsgYm9yZGVycy53aWR0aDtcbiAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBNYXRoLnJvdW5kKCh4IC0geE9mZnNldCkgLyB3aWR0aCAqIGNhbnZhcy53aWR0aCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKSxcbiAgICB5OiBNYXRoLnJvdW5kKCh5IC0geU9mZnNldCkgLyBoZWlnaHQgKiBjYW52YXMuaGVpZ2h0IC8gY3VycmVudERldmljZVBpeGVsUmF0aW8pXG4gIH07XG59XG5mdW5jdGlvbiBnZXRDb250YWluZXJTaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCkge1xuICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQgfHwgaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgIGlmICghY29udGFpbmVyKSB7XG4gICAgICB3aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY29udGFpbmVyKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lckJvcmRlciA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgY29uc3QgY29udGFpbmVyUGFkZGluZyA9IGdldFBvc2l0aW9uZWRTdHlsZShjb250YWluZXJTdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgIHdpZHRoID0gcmVjdC53aWR0aCAtIGNvbnRhaW5lclBhZGRpbmcud2lkdGggLSBjb250YWluZXJCb3JkZXIud2lkdGg7XG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCAtIGNvbnRhaW5lclBhZGRpbmcuaGVpZ2h0IC0gY29udGFpbmVyQm9yZGVyLmhlaWdodDtcbiAgICAgIG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShjb250YWluZXJTdHlsZS5tYXhXaWR0aCwgY29udGFpbmVyLCAnY2xpZW50V2lkdGgnKTtcbiAgICAgIG1heEhlaWdodCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0LCBjb250YWluZXIsICdjbGllbnRIZWlnaHQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgIG1heEhlaWdodDogbWF4SGVpZ2h0IHx8IElORklOSVRZXG4gIH07XG59XG5jb25zdCByb3VuZDEgPSB2ID0+IE1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuZnVuY3Rpb24gZ2V0TWF4aW11bVNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCwgYXNwZWN0UmF0aW8pIHtcbiAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gIGNvbnN0IG1hcmdpbnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdtYXJnaW4nKTtcbiAgY29uc3QgbWF4V2lkdGggPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heFdpZHRoLCBjYW52YXMsICdjbGllbnRXaWR0aCcpIHx8IElORklOSVRZO1xuICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gIGNvbnN0IGNvbnRhaW5lclNpemUgPSBnZXRDb250YWluZXJTaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQpO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY29udGFpbmVyU2l6ZTtcbiAgaWYgKHN0eWxlLmJveFNpemluZyA9PT0gJ2NvbnRlbnQtYm94Jykge1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0IC0gbWFyZ2lucy5oZWlnaHQpO1xuICB3aWR0aCA9IHJvdW5kMShNYXRoLm1pbih3aWR0aCwgbWF4V2lkdGgsIGNvbnRhaW5lclNpemUubWF4V2lkdGgpKTtcbiAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICBpZiAod2lkdGggJiYgIWhlaWdodCkge1xuICAgIGhlaWdodCA9IHJvdW5kMSh3aWR0aCAvIDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiByZXRpbmFTY2FsZShjaGFydCwgZm9yY2VSYXRpbywgZm9yY2VTdHlsZSkge1xuICBjb25zdCBwaXhlbFJhdGlvID0gZm9yY2VSYXRpbyB8fCAxO1xuICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICBjb25zdCBkZXZpY2VXaWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgY2hhcnQuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgY2hhcnQud2lkdGggPSBkZXZpY2VXaWR0aCAvIHBpeGVsUmF0aW87XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAoIWNhbnZhcy5zdHlsZS5oZWlnaHQgJiYgIWNhbnZhcy5zdHlsZS53aWR0aCkpKSB7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0LmhlaWdodH1weGA7XG4gICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICB9XG4gIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gcGl4ZWxSYXRpb1xuICAgICAgfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0XG4gICAgICB8fCBjYW52YXMud2lkdGggIT09IGRldmljZVdpZHRoKSB7XG4gICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBkZXZpY2VIZWlnaHQ7XG4gICAgY2FudmFzLndpZHRoID0gZGV2aWNlV2lkdGg7XG4gICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5jb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gKGZ1bmN0aW9uKCkge1xuICBsZXQgcGFzc2l2ZVN1cHBvcnRlZCA9IGZhbHNlO1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpKTtcbmZ1bmN0aW9uIHJlYWRVc2VkU2l6ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgY29uc3QgbWF0Y2hlcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9eKFxcZCspKFxcLlxcZCspP3B4JC8pO1xuICByZXR1cm4gbWF0Y2hlcyA/ICttYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBfcG9pbnRJbkxpbmUocDEsIHAyLCB0LCBtb2RlKSB7XG4gIHJldHVybiB7XG4gICAgeDogcDEueCArIHQgKiAocDIueCAtIHAxLngpLFxuICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICB9O1xufVxuZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBtb2RlID09PSAnbWlkZGxlJyA/IHQgPCAwLjUgPyBwMS55IDogcDIueVxuICAgIDogbW9kZSA9PT0gJ2FmdGVyJyA/IHQgPCAxID8gcDEueSA6IHAyLnlcbiAgICA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICBjb25zdCBjcDEgPSB7eDogcDEuY3AyeCwgeTogcDEuY3AyeX07XG4gIGNvbnN0IGNwMiA9IHt4OiBwMi5jcDF4LCB5OiBwMi5jcDF5fTtcbiAgY29uc3QgYSA9IF9wb2ludEluTGluZShwMSwgY3AxLCB0KTtcbiAgY29uc3QgYiA9IF9wb2ludEluTGluZShjcDEsIGNwMiwgdCk7XG4gIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gIGNvbnN0IGQgPSBfcG9pbnRJbkxpbmUoYSwgYiwgdCk7XG4gIGNvbnN0IGUgPSBfcG9pbnRJbkxpbmUoYiwgYywgdCk7XG4gIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlS2V5ID0gbG9jYWxlICsgSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFmb3JtYXR0ZXIpIHtcbiAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICBpbnRsQ2FjaGUuc2V0KGNhY2hlS2V5LCBmb3JtYXR0ZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZXI7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIobnVtLCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdChudW0pO1xufVxuXG5jb25zdCBnZXRSaWdodFRvTGVmdEFkYXB0ZXIgPSBmdW5jdGlvbihyZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgICAgd2lkdGggPSB3O1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHJldHVybiBhbGlnbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggLSB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geCAtIGl0ZW1XaWR0aDtcbiAgICB9LFxuICB9O1xufTtcbmNvbnN0IGdldExlZnRUb1JpZ2h0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHgoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgICBzZXRXaWR0aCh3KSB7XG4gICAgfSxcbiAgICB0ZXh0QWxpZ24oYWxpZ24pIHtcbiAgICAgIHJldHVybiBhbGlnbjtcbiAgICB9LFxuICAgIHhQbHVzKHgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4geCArIHZhbHVlO1xuICAgIH0sXG4gICAgbGVmdEZvckx0cih4LCBfaXRlbVdpZHRoKSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9LFxuICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgcmV0dXJuIHJ0bCA/IGdldFJpZ2h0VG9MZWZ0QWRhcHRlcihyZWN0WCwgd2lkdGgpIDogZ2V0TGVmdFRvUmlnaHRBZGFwdGVyKCk7XG59XG5mdW5jdGlvbiBvdmVycmlkZVRleHREaXJlY3Rpb24oY3R4LCBkaXJlY3Rpb24pIHtcbiAgbGV0IHN0eWxlLCBvcmlnaW5hbDtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgIHN0eWxlID0gY3R4LmNhbnZhcy5zdHlsZTtcbiAgICBvcmlnaW5hbCA9IFtcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpLFxuICAgICAgc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eSgnZGlyZWN0aW9uJyksXG4gICAgXTtcbiAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgY3R4LnByZXZUZXh0RGlyZWN0aW9uID0gb3JpZ2luYWw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgaWYgKG9yaWdpbmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgIGN0eC5jYW52YXMuc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIG9yaWdpbmFsWzBdLCBvcmlnaW5hbFsxXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgYmV0d2VlbjogX2lzQmV0d2VlbixcbiAgICBjb21wYXJlOiAoYSwgYikgPT4gYSAtIGIsXG4gICAgbm9ybWFsaXplOiB4ID0+IHhcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlZ21lbnQoe3N0YXJ0LCBlbmQsIGNvdW50LCBsb29wLCBzdHlsZX0pIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgIGxvb3A6IGxvb3AgJiYgKGVuZCAtIHN0YXJ0ICsgMSkgJSBjb3VudCA9PT0gMCxcbiAgICBzdHlsZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBjb25zdCB7cHJvcGVydHksIHN0YXJ0OiBzdGFydEJvdW5kLCBlbmQ6IGVuZEJvdW5kfSA9IGJvdW5kcztcbiAgY29uc3Qge2JldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQge3N0YXJ0LCBlbmQsIGxvb3B9ID0gc2VnbWVudDtcbiAgbGV0IGksIGlsZW47XG4gIGlmIChsb29wKSB7XG4gICAgc3RhcnQgKz0gY291bnQ7XG4gICAgZW5kICs9IGNvdW50O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKCFiZXR3ZWVuKG5vcm1hbGl6ZShwb2ludHNbc3RhcnQgJSBjb3VudF1bcHJvcGVydHldKSwgc3RhcnRCb3VuZCwgZW5kQm91bmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhcnQtLTtcbiAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBlbmQgJT0gY291bnQ7XG4gIH1cbiAgaWYgKGVuZCA8IHN0YXJ0KSB7XG4gICAgZW5kICs9IGNvdW50O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGVuZCwgbG9vcCwgc3R5bGU6IHNlZ21lbnQuc3R5bGV9O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIGJvdW5kcykge1xuICBpZiAoIWJvdW5kcykge1xuICAgIHJldHVybiBbc2VnbWVudF07XG4gIH1cbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge2NvbXBhcmUsIGJldHdlZW4sIG5vcm1hbGl6ZX0gPSBwcm9wZXJ0eUZuKHByb3BlcnR5KTtcbiAgY29uc3Qge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlfSA9IGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGluc2lkZSA9IGZhbHNlO1xuICBsZXQgc3ViU3RhcnQgPSBudWxsO1xuICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gIGNvbnN0IHN0YXJ0SXNCZWZvcmUgPSAoKSA9PiBiZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgY29uc3QgZW5kSXNCZWZvcmUgPSAoKSA9PiBjb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gIGNvbnN0IHNob3VsZFN0YXJ0ID0gKCkgPT4gaW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgY29uc3Qgc2hvdWxkU3RvcCA9ICgpID0+ICFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0LCBwcmV2ID0gc3RhcnQ7IGkgPD0gZW5kOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBub3JtYWxpemUocG9pbnRbcHJvcGVydHldKTtcbiAgICBpZiAodmFsdWUgPT09IHByZXZWYWx1ZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGluc2lkZSA9IGJldHdlZW4odmFsdWUsIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKTtcbiAgICBpZiAoc3ViU3RhcnQgPT09IG51bGwgJiYgc2hvdWxkU3RhcnQoKSkge1xuICAgICAgc3ViU3RhcnQgPSBjb21wYXJlKHZhbHVlLCBzdGFydEJvdW5kKSA9PT0gMCA/IGkgOiBwcmV2O1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwgJiYgc2hvdWxkU3RvcCgpKSB7XG4gICAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZDogaSwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICAgICAgc3ViU3RhcnQgPSBudWxsO1xuICAgIH1cbiAgICBwcmV2ID0gaTtcbiAgICBwcmV2VmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICByZXN1bHQucHVzaChub3JtYWxpemVTZWdtZW50KHtzdGFydDogc3ViU3RhcnQsIGVuZCwgbG9vcCwgY291bnQsIHN0eWxlfSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfYm91bmRTZWdtZW50cyhsaW5lLCBib3VuZHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgIGlmIChzdWIubGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaCguLi5zdWIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSBjb3VudCAtIDE7XG4gIGlmIChsb29wICYmICFzcGFuR2Fwcykge1xuICAgIHdoaWxlIChzdGFydCA8IGNvdW50ICYmICFwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuICB9XG4gIHdoaWxlIChzdGFydCA8IGNvdW50ICYmIHBvaW50c1tzdGFydF0uc2tpcCkge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgc3RhcnQgJT0gY291bnQ7XG4gIGlmIChsb29wKSB7XG4gICAgZW5kICs9IHN0YXJ0O1xuICB9XG4gIHdoaWxlIChlbmQgPiBzdGFydCAmJiBwb2ludHNbZW5kICUgY291bnRdLnNraXApIHtcbiAgICBlbmQtLTtcbiAgfVxuICBlbmQgJT0gY291bnQ7XG4gIHJldHVybiB7c3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgbG9vcCkge1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgbGFzdCA9IHN0YXJ0O1xuICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gIGxldCBlbmQ7XG4gIGZvciAoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCkge1xuICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgaWYgKGN1ci5za2lwIHx8IGN1ci5zdG9wKSB7XG4gICAgICBpZiAoIXByZXYuc2tpcCkge1xuICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCwgbG9vcH0pO1xuICAgICAgICBzdGFydCA9IGxhc3QgPSBjdXIuc3RvcCA/IGVuZCA6IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2ID0gY3VyO1xuICB9XG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzdGFydCAlIGNvdW50LCBlbmQ6IGxhc3QgJSBjb3VudCwgbG9vcH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBfY29tcHV0ZVNlZ21lbnRzKGxpbmUsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBjb25zdCBzcGFuR2FwcyA9IGxpbmUub3B0aW9ucy5zcGFuR2FwcztcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBpZiAoIWNvdW50KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IGxvb3AgPSAhIWxpbmUuX2xvb3A7XG4gIGNvbnN0IHtzdGFydCwgZW5kfSA9IGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcyk7XG4gIGlmIChzcGFuR2FwcyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBzcGxpdEJ5U3R5bGVzKGxpbmUsIFt7c3RhcnQsIGVuZCwgbG9vcH1dLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbiAgfVxuICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICBjb25zdCBjb21wbGV0ZUxvb3AgPSAhIWxpbmUuX2Z1bGxMb29wICYmIHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gY291bnQgLSAxO1xuICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBzb2xpZFNlZ21lbnRzKHBvaW50cywgc3RhcnQsIG1heCwgY29tcGxldGVMb29wKSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKSB7XG4gIGlmICghc2VnbWVudE9wdGlvbnMgfHwgIXNlZ21lbnRPcHRpb25zLnNldENvbnRleHQgfHwgIXBvaW50cykge1xuICAgIHJldHVybiBzZWdtZW50cztcbiAgfVxuICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gIGNvbnN0IGJhc2VTdHlsZSA9IHJlYWRTdHlsZShsaW5lLm9wdGlvbnMpO1xuICBjb25zdCB7X2RhdGFzZXRJbmRleDogZGF0YXNldEluZGV4LCBvcHRpb25zOiB7c3BhbkdhcHN9fSA9IGxpbmU7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBwcmV2U3R5bGUgPSBiYXNlU3R5bGU7XG4gIGxldCBzdGFydCA9IHNlZ21lbnRzWzBdLnN0YXJ0O1xuICBsZXQgaSA9IHN0YXJ0O1xuICBmdW5jdGlvbiBhZGRTdHlsZShzLCBlLCBsLCBzdCkge1xuICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgIGlmIChzID09PSBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHMgKz0gY291bnQ7XG4gICAgd2hpbGUgKHBvaW50c1tzICUgY291bnRdLnNraXApIHtcbiAgICAgIHMgLT0gZGlyO1xuICAgIH1cbiAgICB3aGlsZSAocG9pbnRzW2UgJSBjb3VudF0uc2tpcCkge1xuICAgICAgZSArPSBkaXI7XG4gICAgfVxuICAgIGlmIChzICUgY291bnQgIT09IGUgJSBjb3VudCkge1xuICAgICAgcmVzdWx0LnB1c2goe3N0YXJ0OiBzICUgY291bnQsIGVuZDogZSAlIGNvdW50LCBsb29wOiBsLCBzdHlsZTogc3R9KTtcbiAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIHN0YXJ0ID0gc3BhbkdhcHMgPyBzdGFydCA6IHNlZ21lbnQuc3RhcnQ7XG4gICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgbGV0IHN0eWxlO1xuICAgIGZvciAoaSA9IHN0YXJ0ICsgMTsgaSA8PSBzZWdtZW50LmVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICB0eXBlOiAnc2VnbWVudCcsXG4gICAgICAgIHAwOiBwcmV2LFxuICAgICAgICBwMTogcHQsXG4gICAgICAgIHAwRGF0YUluZGV4OiAoaSAtIDEpICUgY291bnQsXG4gICAgICAgIHAxRGF0YUluZGV4OiBpICUgY291bnQsXG4gICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgfSkpKTtcbiAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgYWRkU3R5bGUoc3RhcnQsIGkgLSAxLCBzZWdtZW50Lmxvb3AsIHByZXZTdHlsZSk7XG4gICAgICB9XG4gICAgICBwcmV2ID0gcHQ7XG4gICAgICBwcmV2U3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgaWYgKHN0YXJ0IDwgaSAtIDEpIHtcbiAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgIGJvcmRlckNhcFN0eWxlOiBvcHRpb25zLmJvcmRlckNhcFN0eWxlLFxuICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgYm9yZGVySm9pblN0eWxlOiBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSxcbiAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICB9O1xufVxuZnVuY3Rpb24gc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpIHtcbiAgcmV0dXJuIHByZXZTdHlsZSAmJiBKU09OLnN0cmluZ2lmeShzdHlsZSkgIT09IEpTT04uc3RyaW5naWZ5KHByZXZTdHlsZSk7XG59XG5cbmV4cG9ydCB7IF9pc1BvaW50SW5BcmVhIGFzICQsIF9mYWN0b3JpemUgYXMgQSwgZmluaXRlT3JEZWZhdWx0IGFzIEIsIGNhbGxiYWNrIGFzIEMsIF9hZGRHcmFjZSBhcyBELCBfbGltaXRWYWx1ZSBhcyBFLCB0b0RlZ3JlZXMgYXMgRiwgX21lYXN1cmVUZXh0IGFzIEcsIEhBTEZfUEkgYXMgSCwgX2ludDE2UmFuZ2UgYXMgSSwgX2FsaWduUGl4ZWwgYXMgSiwgdG9QYWRkaW5nIGFzIEssIGNsaXBBcmVhIGFzIEwsIHJlbmRlclRleHQgYXMgTSwgdW5jbGlwQXJlYSBhcyBOLCB0b0ZvbnQgYXMgTywgUEkgYXMgUCwgZWFjaCBhcyBRLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgUiwgX2FsaWduU3RhcnRFbmQgYXMgUywgVEFVIGFzIFQsIG92ZXJyaWRlcyBhcyBVLCBtZXJnZSBhcyBWLCBfY2FwaXRhbGl6ZSBhcyBXLCBnZXRSZWxhdGl2ZVBvc2l0aW9uIGFzIFgsIF9ybG9va3VwQnlLZXkgYXMgWSwgX2xvb2t1cEJ5S2V5IGFzIFosIF9hcnJheVVuaXF1ZSBhcyBfLCByZXNvbHZlIGFzIGEsIHRvTGluZUhlaWdodCBhcyBhJCwgZ2V0QW5nbGVGcm9tUG9pbnQgYXMgYTAsIGdldE1heGltdW1TaXplIGFzIGExLCBfZ2V0UGFyZW50Tm9kZSBhcyBhMiwgcmVhZFVzZWRTaXplIGFzIGEzLCB0aHJvdHRsZWQgYXMgYTQsIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgYXMgYTUsIF9pc0RvbVN1cHBvcnRlZCBhcyBhNiwgZGVzY3JpcHRvcnMgYXMgYTcsIGlzRnVuY3Rpb24gYXMgYTgsIF9hdHRhY2hDb250ZXh0IGFzIGE5LCBnZXRSdGxBZGFwdGVyIGFzIGFBLCBvdmVycmlkZVRleHREaXJlY3Rpb24gYXMgYUIsIF90ZXh0WCBhcyBhQywgcmVzdG9yZVRleHREaXJlY3Rpb24gYXMgYUQsIGRyYXdQb2ludExlZ2VuZCBhcyBhRSwgbm9vcCBhcyBhRiwgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzIGFzIGFHLCBfc2V0TWluQW5kTWF4QnlLZXkgYXMgYUgsIG5pY2VOdW0gYXMgYUksIGFsbW9zdFdob2xlIGFzIGFKLCBhbG1vc3RFcXVhbHMgYXMgYUssIF9kZWNpbWFsUGxhY2VzIGFzIGFMLCBfbG9uZ2VzdFRleHQgYXMgYU0sIF9maWx0ZXJCZXR3ZWVuIGFzIGFOLCBfbG9va3VwIGFzIGFPLCBpc1BhdHRlcm5PckdyYWRpZW50IGFzIGFQLCBnZXRIb3ZlckNvbG9yIGFzIGFRLCBjbG9uZSQxIGFzIGFSLCBfbWVyZ2VyIGFzIGFTLCBfbWVyZ2VySWYgYXMgYVQsIF9kZXByZWNhdGVkIGFzIGFVLCBfc3BsaXRLZXkgYXMgYVYsIHRvRm9udFN0cmluZyBhcyBhVywgc3BsaW5lQ3VydmUgYXMgYVgsIHNwbGluZUN1cnZlTW9ub3RvbmUgYXMgYVksIGdldFN0eWxlIGFzIGFaLCBmb250U3RyaW5nIGFzIGFfLCBfY3JlYXRlUmVzb2x2ZXIgYXMgYWEsIF9kZXNjcmlwdG9ycyBhcyBhYiwgbWVyZ2VJZiBhcyBhYywgdWlkIGFzIGFkLCBkZWJvdW5jZSBhcyBhZSwgcmV0aW5hU2NhbGUgYXMgYWYsIGNsZWFyQ2FudmFzIGFzIGFnLCBzZXRzRXF1YWwgYXMgYWgsIF9lbGVtZW50c0VxdWFsIGFzIGFpLCBfaXNDbGlja0V2ZW50IGFzIGFqLCBfaXNCZXR3ZWVuIGFzIGFrLCBfcmVhZFZhbHVlVG9Qcm9wcyBhcyBhbCwgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMgYXMgYW0sIF9jb21wdXRlU2VnbWVudHMgYXMgYW4sIF9ib3VuZFNlZ21lbnRzIGFzIGFvLCBfc3RlcHBlZEludGVycG9sYXRpb24gYXMgYXAsIF9iZXppZXJJbnRlcnBvbGF0aW9uIGFzIGFxLCBfcG9pbnRJbkxpbmUgYXMgYXIsIF9zdGVwcGVkTGluZVRvIGFzIGFzLCBfYmV6aWVyQ3VydmVUbyBhcyBhdCwgZHJhd1BvaW50IGFzIGF1LCBhZGRSb3VuZGVkUmVjdFBhdGggYXMgYXYsIHRvVFJCTCBhcyBhdywgdG9UUkJMQ29ybmVycyBhcyBheCwgX2JvdW5kU2VnbWVudCBhcyBheSwgX25vcm1hbGl6ZUFuZ2xlIGFzIGF6LCBpc0FycmF5IGFzIGIsIFBJVEFVIGFzIGIwLCBJTkZJTklUWSBhcyBiMSwgUkFEX1BFUl9ERUcgYXMgYjIsIFFVQVJURVJfUEkgYXMgYjMsIFRXT19USElSRFNfUEkgYXMgYjQsIF9hbmdsZURpZmYgYXMgYjUsIGNvbG9yIGFzIGMsIGRlZmF1bHRzIGFzIGQsIGVmZmVjdHMgYXMgZSwgcmVzb2x2ZU9iamVjdEtleSBhcyBmLCBpc051bWJlckZpbml0ZSBhcyBnLCBjcmVhdGVDb250ZXh0IGFzIGgsIGlzT2JqZWN0IGFzIGksIGRlZmluZWQgYXMgaiwgaXNOdWxsT3JVbmRlZiBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b1BlcmNlbnRhZ2UgYXMgbSwgdG9EaW1lbnNpb24gYXMgbiwgZm9ybWF0TnVtYmVyIGFzIG8sIF9hbmdsZUJldHdlZW4gYXMgcCwgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9zY2FsZVJhbmdlc0NoYW5nZWQgYXMgdywgaXNOdW1iZXIgYXMgeCwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIGFzIHksIGxvZzEwIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJub29wIiwidWlkIiwiaWQiLCJpc051bGxPclVuZGVmIiwidmFsdWUiLCJpc0FycmF5IiwiQXJyYXkiLCJ0eXBlIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwic2xpY2UiLCJpc09iamVjdCIsImlzTnVtYmVyRmluaXRlIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJmaW5pdGVPckRlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJ2YWx1ZU9yRGVmYXVsdCIsInRvUGVyY2VudGFnZSIsImRpbWVuc2lvbiIsImVuZHNXaXRoIiwicGFyc2VGbG9hdCIsInRvRGltZW5zaW9uIiwiY2FsbGJhY2siLCJmbiIsImFyZ3MiLCJ0aGlzQXJnIiwiYXBwbHkiLCJlYWNoIiwibG9vcGFibGUiLCJyZXZlcnNlIiwiaSIsImxlbiIsImtleXMiLCJsZW5ndGgiLCJfZWxlbWVudHNFcXVhbCIsImEwIiwiYTEiLCJpbGVuIiwidjAiLCJ2MSIsImRhdGFzZXRJbmRleCIsImluZGV4IiwiY2xvbmUkMSIsInNvdXJjZSIsIm1hcCIsInRhcmdldCIsImNyZWF0ZSIsImtsZW4iLCJrIiwiaXNWYWxpZEtleSIsImtleSIsImluZGV4T2YiLCJfbWVyZ2VyIiwib3B0aW9ucyIsInR2YWwiLCJzdmFsIiwibWVyZ2UiLCJzb3VyY2VzIiwibWVyZ2VyIiwibWVyZ2VJZiIsIl9tZXJnZXJJZiIsImhhc093blByb3BlcnR5IiwiX2RlcHJlY2F0ZWQiLCJzY29wZSIsInByZXZpb3VzIiwiY3VycmVudCIsInVuZGVmaW5lZCIsImNvbnNvbGUiLCJ3YXJuIiwia2V5UmVzb2x2ZXJzIiwidiIsIngiLCJvIiwieSIsInJlc29sdmVPYmplY3RLZXkiLCJvYmoiLCJyZXNvbHZlciIsIl9nZXRLZXlSZXNvbHZlciIsIl9zcGxpdEtleSIsInBhcnRzIiwic3BsaXQiLCJ0bXAiLCJwYXJ0IiwicHVzaCIsIl9jYXBpdGFsaXplIiwic3RyIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJkZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNldHNFcXVhbCIsImEiLCJiIiwic2l6ZSIsIml0ZW0iLCJoYXMiLCJfaXNDbGlja0V2ZW50IiwiZSIsIlBJIiwiTWF0aCIsIlRBVSIsIlBJVEFVIiwiSU5GSU5JVFkiLCJQT1NJVElWRV9JTkZJTklUWSIsIlJBRF9QRVJfREVHIiwiSEFMRl9QSSIsIlFVQVJURVJfUEkiLCJUV09fVEhJUkRTX1BJIiwibG9nMTAiLCJzaWduIiwibmljZU51bSIsInJhbmdlIiwicm91bmRlZFJhbmdlIiwicm91bmQiLCJhbG1vc3RFcXVhbHMiLCJuaWNlUmFuZ2UiLCJwb3ciLCJmbG9vciIsImZyYWN0aW9uIiwibmljZUZyYWN0aW9uIiwiX2ZhY3Rvcml6ZSIsInJlc3VsdCIsInNxcnQiLCJzb3J0IiwicG9wIiwiaXNOdW1iZXIiLCJuIiwiaXNOYU4iLCJlcHNpbG9uIiwiYWJzIiwiYWxtb3N0V2hvbGUiLCJyb3VuZGVkIiwiX3NldE1pbkFuZE1heEJ5S2V5IiwiYXJyYXkiLCJwcm9wZXJ0eSIsIm1pbiIsIm1heCIsInRvUmFkaWFucyIsImRlZ3JlZXMiLCJ0b0RlZ3JlZXMiLCJyYWRpYW5zIiwiX2RlY2ltYWxQbGFjZXMiLCJwIiwiZ2V0QW5nbGVGcm9tUG9pbnQiLCJjZW50cmVQb2ludCIsImFuZ2xlUG9pbnQiLCJkaXN0YW5jZUZyb21YQ2VudGVyIiwiZGlzdGFuY2VGcm9tWUNlbnRlciIsInJhZGlhbERpc3RhbmNlRnJvbUNlbnRlciIsImFuZ2xlIiwiYXRhbjIiLCJkaXN0YW5jZSIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsInB0MSIsInB0MiIsIl9hbmdsZURpZmYiLCJfbm9ybWFsaXplQW5nbGUiLCJfYW5nbGVCZXR3ZWVuIiwic3RhcnQiLCJlbmQiLCJzYW1lQW5nbGVJc0Z1bGxDaXJjbGUiLCJzIiwiYW5nbGVUb1N0YXJ0IiwiYW5nbGVUb0VuZCIsInN0YXJ0VG9BbmdsZSIsImVuZFRvQW5nbGUiLCJfbGltaXRWYWx1ZSIsIl9pbnQxNlJhbmdlIiwiX2lzQmV0d2VlbiIsIl9sb29rdXAiLCJ0YWJsZSIsImNtcCIsImhpIiwibG8iLCJtaWQiLCJfbG9va3VwQnlLZXkiLCJsYXN0IiwiX3Jsb29rdXBCeUtleSIsIl9maWx0ZXJCZXR3ZWVuIiwidmFsdWVzIiwiYXJyYXlFdmVudHMiLCJsaXN0ZW5BcnJheUV2ZW50cyIsImxpc3RlbmVyIiwiX2NoYXJ0anMiLCJsaXN0ZW5lcnMiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJmb3JFYWNoIiwibWV0aG9kIiwiYmFzZSIsInJlcyIsIm9iamVjdCIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJzdHViIiwic3BsaWNlIiwiX2FycmF5VW5pcXVlIiwiaXRlbXMiLCJzZXQiLCJTZXQiLCJhZGQiLCJmcm9tIiwiZm9udFN0cmluZyIsInBpeGVsU2l6ZSIsImZvbnRTdHlsZSIsImZvbnRGYW1pbHkiLCJyZXF1ZXN0QW5pbUZyYW1lIiwid2luZG93IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGhyb3R0bGVkIiwidXBkYXRlRm4iLCJ1cGRhdGVBcmdzIiwidGlja2luZyIsInJlc3QiLCJkZWJvdW5jZSIsImRlbGF5IiwidGltZW91dCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJfdG9MZWZ0UmlnaHRDZW50ZXIiLCJhbGlnbiIsIl9hbGlnblN0YXJ0RW5kIiwiX3RleHRYIiwibGVmdCIsInJpZ2h0IiwicnRsIiwiY2hlY2siLCJfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyIsIm1ldGEiLCJwb2ludHMiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJwb2ludENvdW50IiwiY291bnQiLCJfc29ydGVkIiwiaVNjYWxlIiwiX3BhcnNlZCIsImF4aXMiLCJtaW5EZWZpbmVkIiwibWF4RGVmaW5lZCIsImdldFVzZXJCb3VuZHMiLCJnZXRQaXhlbEZvclZhbHVlIiwiX3NjYWxlUmFuZ2VzQ2hhbmdlZCIsInhTY2FsZSIsInlTY2FsZSIsIl9zY2FsZVJhbmdlcyIsIm5ld1JhbmdlcyIsInhtaW4iLCJ4bWF4IiwieW1pbiIsInltYXgiLCJjaGFuZ2VkIiwiYXNzaWduIiwiYXRFZGdlIiwidCIsImVsYXN0aWNJbiIsInNpbiIsImVsYXN0aWNPdXQiLCJlZmZlY3RzIiwibGluZWFyIiwiZWFzZUluUXVhZCIsImVhc2VPdXRRdWFkIiwiZWFzZUluT3V0UXVhZCIsImVhc2VJbkN1YmljIiwiZWFzZU91dEN1YmljIiwiZWFzZUluT3V0Q3ViaWMiLCJlYXNlSW5RdWFydCIsImVhc2VPdXRRdWFydCIsImVhc2VJbk91dFF1YXJ0IiwiZWFzZUluUXVpbnQiLCJlYXNlT3V0UXVpbnQiLCJlYXNlSW5PdXRRdWludCIsImVhc2VJblNpbmUiLCJjb3MiLCJlYXNlT3V0U2luZSIsImVhc2VJbk91dFNpbmUiLCJlYXNlSW5FeHBvIiwiZWFzZU91dEV4cG8iLCJlYXNlSW5PdXRFeHBvIiwiZWFzZUluQ2lyYyIsImVhc2VPdXRDaXJjIiwiZWFzZUluT3V0Q2lyYyIsImVhc2VJbkVsYXN0aWMiLCJlYXNlT3V0RWxhc3RpYyIsImVhc2VJbk91dEVsYXN0aWMiLCJlYXNlSW5CYWNrIiwiZWFzZU91dEJhY2siLCJlYXNlSW5PdXRCYWNrIiwiZWFzZUluQm91bmNlIiwiZWFzZU91dEJvdW5jZSIsIm0iLCJkIiwiZWFzZUluT3V0Qm91bmNlIiwibGltIiwibCIsImgiLCJwMmIiLCJuMmIiLCJiMm4iLCJuMnAiLCJtYXAkMSIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiRiIsImMiLCJmIiwiaGV4IiwiaDEiLCJoMiIsImVxIiwiaXNTaG9ydCIsInIiLCJnIiwiaGV4UGFyc2UiLCJyZXQiLCJhbHBoYSIsImhleFN0cmluZyIsIkhVRV9SRSIsImhzbDJyZ2JuIiwiaHN2MnJnYm4iLCJod2IycmdibiIsInciLCJyZ2IiLCJodWVWYWx1ZSIsInJnYjJoc2wiLCJjYWxsbiIsImhzbDJyZ2IiLCJod2IycmdiIiwiaHN2MnJnYiIsImh1ZSIsImh1ZVBhcnNlIiwiZXhlYyIsInAxIiwicDIiLCJyb3RhdGUiLCJkZWciLCJoc2xTdHJpbmciLCJaIiwiWSIsIlgiLCJXIiwiViIsIlUiLCJUIiwiUyIsIlIiLCJRIiwiUCIsIk8iLCJOIiwiTSIsIkwiLCJLIiwiRyIsIkgiLCJJIiwiSiIsIm5hbWVzJDEiLCJPaWNlWGUiLCJhbnRpcXVld0V0ZSIsImFxdWEiLCJhcXVhbWFyUmUiLCJhenVZIiwiYmVpZ2UiLCJiaXNxdWUiLCJibGFjayIsImJsYW5LZWRPbW9uZCIsIlhlIiwiWGV2aVRldCIsImJQd24iLCJidXJseXdvb2QiLCJjYU10WGUiLCJLYXJ0WXVzZSIsIktvY1RhdGUiLCJjU08iLCJjU25mbG93ZXJYZSIsImNTbnNpbGsiLCJjcmltc29uIiwiY3lhbiIsInhYZSIsInhjeWFuIiwieGdUTW5QZCIsInhXYXkiLCJ4Z1lGIiwieGdZeSIsInhraGFraSIsInhtYWdGdGEiLCJ4VGl2ZWdZRiIsInhTYW5nZSIsInhTY0VkIiwieFlkIiwieHNPbW9uIiwieHNIZ1lGIiwieFVYZSIsInhVV2F5IiwieFVnWXkiLCJ4UWUiLCJ4dmlUZXQiLCJkQXBwUmsiLCJkQXBza3lYZSIsImRpbVdheSIsImRpbWdZeSIsImRvZGdlclhlIiwiZmlZYnJpY2siLCJmbFNPd0V0ZSIsImZvWXN0V0FuIiwiZnVLc2lhIiwiZ2FSc2JTbyIsImdob3N0d0V0ZSIsImdUZCIsImdUTW5QZCIsIldheSIsImdZRiIsImdZRkx3IiwiZ1l5IiwiaG9uZXlNdyIsImhvdHBSayIsIlJkaWFuWWQiLCJSZGlnbyIsIml2U3kiLCJraGFraSIsImxhdkZNciIsImxhdkZNclhzaCIsImxhd25nWUYiLCJObW9uY0VmZm9uIiwiWlhlIiwiWmNTTyIsIlpjeWFuIiwiWmdUTW5QZEx3IiwiWldheSIsIlpnWUYiLCJaZ1l5IiwiWnBSayIsIlpzT21vbiIsIlpzSGdZRiIsIlpza3lYZSIsIlpVV2F5IiwiWlVnWXkiLCJac3RBbFhlIiwiWkx3IiwibGltZSIsImxpbWVnWUYiLCJsUkYiLCJtYWdGdGEiLCJtYVBvbiIsIlZhcXVhbWFyUmUiLCJWWGUiLCJWU2NFZCIsIlZwdXJwTiIsIlZzSGdZRiIsIlZVWGUiLCJWc3ByUmdnWUYiLCJWUWUiLCJWdmlUZXRZZCIsIm1pZG5pZ2h0WGUiLCJtUnRjWWFtIiwibWlzdHlQc2UiLCJtb2NjYXNSIiwibmF2YWpvd0V0ZSIsIm5hdnkiLCJUZGxhY2UiLCJUaXZlIiwiVGl2ZWRCYiIsIlNhbmdlIiwiU2FuZ2VZZCIsIlNjRWQiLCJwT2VnVE1uUGQiLCJwT2VnWUYiLCJwT2VRZSIsInBPZXZpVGV0WWQiLCJwYXBheWF3RXAiLCJwSEtwdWZmIiwicGVydSIsInBSayIsInBsdW0iLCJwb3dNclhlIiwicHVycE4iLCJZYmVjY2FwdXJwTiIsIllkIiwiUHN5YnJvd24iLCJQeU9YZSIsInNhZGROYlB3biIsInNPbW9uIiwic2FuZHliUHduIiwic0hnWUYiLCJzSHNoZWxsIiwic2lGbmEiLCJzaWx2ZXIiLCJza3lYZSIsIlVYZSIsIlVXYXkiLCJVZ1l5Iiwic25vdyIsInNwclJnZ1lGIiwic3RBbFhlIiwidGFuIiwidGVPIiwidEVzdE4iLCJ0b21hdG8iLCJRZSIsInZpVGV0IiwiSkh0Iiwid0V0ZSIsIndFdGVzbW9rZSIsIkx3IiwiTHdnWUYiLCJ1bnBhY2siLCJ1bnBhY2tlZCIsInRrZXlzIiwiaiIsIm9rIiwibmsiLCJyZXBsYWNlIiwicGFyc2VJbnQiLCJuYW1lcyIsIm5hbWVQYXJzZSIsInRyYW5zcGFyZW50IiwidG9Mb3dlckNhc2UiLCJSR0JfUkUiLCJyZ2JQYXJzZSIsInJnYlN0cmluZyIsInRvIiwiaW50ZXJwb2xhdGUiLCJyZ2IxIiwicmdiMiIsIm1vZEhTTCIsInJhdGlvIiwiY2xvbmUiLCJwcm90byIsImZyb21PYmplY3QiLCJpbnB1dCIsImZ1bmN0aW9uUGFyc2UiLCJDb2xvciIsInZhbGlkIiwiX3ZhbGlkIiwiX3JnYiIsIm1peCIsImNvbG9yIiwid2VpZ2h0IiwiYzEiLCJjMiIsIncyIiwidzEiLCJjbGVhcmVyIiwiZ3JleXNjYWxlIiwidmFsIiwib3BhcXVlciIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJjb25zdHJ1Y3RvciIsImluZGV4X2VzbSIsImlzUGF0dGVybk9yR3JhZGllbnQiLCJnZXRIb3ZlckNvbG9yIiwib3ZlcnJpZGVzIiwiZGVzY3JpcHRvcnMiLCJnZXRTY29wZSQxIiwibm9kZSIsInJvb3QiLCJEZWZhdWx0cyIsImdldCIsImRlc2NyaWJlIiwib3ZlcnJpZGUiLCJyb3V0ZSIsIm5hbWUiLCJ0YXJnZXRTY29wZSIsInRhcmdldE5hbWUiLCJzY29wZU9iamVjdCIsInRhcmdldFNjb3BlT2JqZWN0IiwicHJpdmF0ZU5hbWUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwid3JpdGFibGUiLCJsb2NhbCIsIl9kZXNjcmlwdG9ycyIsImFuaW1hdGlvbiIsImJhY2tncm91bmRDb2xvciIsImJvcmRlckNvbG9yIiwiZGF0YXNldHMiLCJkZXZpY2VQaXhlbFJhdGlvIiwiY29udGV4dCIsImNoYXJ0IiwicGxhdGZvcm0iLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiZWxlbWVudHMiLCJldmVudHMiLCJmb250IiwiZmFtaWx5Iiwic3R5bGUiLCJsaW5lSGVpZ2h0IiwiaG92ZXIiLCJob3ZlckJhY2tncm91bmRDb2xvciIsImN0eCIsImhvdmVyQm9yZGVyQ29sb3IiLCJob3ZlckNvbG9yIiwiaW5kZXhBeGlzIiwiaW50ZXJhY3Rpb24iLCJtb2RlIiwiaW50ZXJzZWN0IiwiaW5jbHVkZUludmlzaWJsZSIsIm1haW50YWluQXNwZWN0UmF0aW8iLCJvbkhvdmVyIiwib25DbGljayIsInBhcnNpbmciLCJwbHVnaW5zIiwicmVzcG9uc2l2ZSIsInNjYWxlIiwic2NhbGVzIiwic2hvd0xpbmUiLCJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsImRlZmF1bHRzIiwiX3NjcmlwdGFibGUiLCJzdGFydHNXaXRoIiwiX2luZGV4YWJsZSIsIl9mYWxsYmFjayIsInRvRm9udFN0cmluZyIsIl9tZWFzdXJlVGV4dCIsImRhdGEiLCJnYyIsImxvbmdlc3QiLCJzdHJpbmciLCJ0ZXh0V2lkdGgiLCJtZWFzdXJlVGV4dCIsIndpZHRoIiwiX2xvbmdlc3RUZXh0IiwiYXJyYXlPZlRoaW5ncyIsImNhY2hlIiwiZ2FyYmFnZUNvbGxlY3QiLCJzYXZlIiwiamxlbiIsInRoaW5nIiwibmVzdGVkVGhpbmciLCJyZXN0b3JlIiwiZ2NMZW4iLCJfYWxpZ25QaXhlbCIsInBpeGVsIiwiY3VycmVudERldmljZVBpeGVsUmF0aW8iLCJoYWxmV2lkdGgiLCJjbGVhckNhbnZhcyIsImNhbnZhcyIsImdldENvbnRleHQiLCJyZXNldFRyYW5zZm9ybSIsImNsZWFyUmVjdCIsImhlaWdodCIsImRyYXdQb2ludCIsImRyYXdQb2ludExlZ2VuZCIsInhPZmZzZXQiLCJ5T2Zmc2V0IiwiY29ybmVyUmFkaXVzIiwicG9pbnRTdHlsZSIsInJvdGF0aW9uIiwicmFkaXVzIiwicmFkIiwidHJhbnNsYXRlIiwiZHJhd0ltYWdlIiwiYmVnaW5QYXRoIiwiZWxsaXBzZSIsImFyYyIsImNsb3NlUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsIlNRUlQxXzIiLCJyZWN0IiwiZmlsbCIsImJvcmRlcldpZHRoIiwic3Ryb2tlIiwiX2lzUG9pbnRJbkFyZWEiLCJwb2ludCIsImFyZWEiLCJtYXJnaW4iLCJ0b3AiLCJib3R0b20iLCJjbGlwQXJlYSIsImNsaXAiLCJ1bmNsaXBBcmVhIiwiX3N0ZXBwZWRMaW5lVG8iLCJmbGlwIiwibWlkcG9pbnQiLCJfYmV6aWVyQ3VydmVUbyIsImJlemllckN1cnZlVG8iLCJjcDF4IiwiY3AyeCIsImNwMXkiLCJjcDJ5IiwicmVuZGVyVGV4dCIsInRleHQiLCJvcHRzIiwibGluZXMiLCJzdHJva2VXaWR0aCIsInN0cm9rZUNvbG9yIiwibGluZSIsInNldFJlbmRlck9wdHMiLCJzdHJva2VTdHlsZSIsImxpbmVXaWR0aCIsInN0cm9rZVRleHQiLCJtYXhXaWR0aCIsImZpbGxUZXh0IiwiZGVjb3JhdGVUZXh0IiwidHJhbnNsYXRpb24iLCJmaWxsU3R5bGUiLCJ0ZXh0QWxpZ24iLCJ0ZXh0QmFzZWxpbmUiLCJzdHJpa2V0aHJvdWdoIiwidW5kZXJsaW5lIiwibWV0cmljcyIsImFjdHVhbEJvdW5kaW5nQm94TGVmdCIsImFjdHVhbEJvdW5kaW5nQm94UmlnaHQiLCJhY3R1YWxCb3VuZGluZ0JveEFzY2VudCIsImFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCIsInlEZWNvcmF0aW9uIiwiZGVjb3JhdGlvbldpZHRoIiwiYWRkUm91bmRlZFJlY3RQYXRoIiwidG9wTGVmdCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsInRvcFJpZ2h0IiwiTElORV9IRUlHSFQiLCJSZWdFeHAiLCJGT05UX1NUWUxFIiwidG9MaW5lSGVpZ2h0IiwibWF0Y2hlcyIsIm1hdGNoIiwibnVtYmVyT3JaZXJvIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJwcm9wcyIsIm9ialByb3BzIiwicmVhZCIsInByb3AiLCJ0b1RSQkwiLCJ0b1RSQkxDb3JuZXJzIiwidG9QYWRkaW5nIiwidG9Gb250IiwiZmFsbGJhY2siLCJyZXNvbHZlIiwiaW5wdXRzIiwiaW5mbyIsImNhY2hlYWJsZSIsIl9hZGRHcmFjZSIsIm1pbm1heCIsImdyYWNlIiwiYmVnaW5BdFplcm8iLCJjaGFuZ2UiLCJrZWVwWmVybyIsImNyZWF0ZUNvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiX2NyZWF0ZVJlc29sdmVyIiwic2NvcGVzIiwicHJlZml4ZXMiLCJyb290U2NvcGVzIiwiZ2V0VGFyZ2V0IiwiX3Jlc29sdmUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIl9jYWNoZWFibGUiLCJfc2NvcGVzIiwiX3Jvb3RTY29wZXMiLCJfZ2V0VGFyZ2V0IiwiUHJveHkiLCJkZWxldGVQcm9wZXJ0eSIsIl9rZXlzIiwiX2NhY2hlZCIsIl9yZXNvbHZlV2l0aFByZWZpeGVzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiUmVmbGVjdCIsImdldFByb3RvdHlwZU9mIiwiZ2V0S2V5c0Zyb21BbGxTY29wZXMiLCJpbmNsdWRlcyIsIm93bktleXMiLCJzdG9yYWdlIiwiX3N0b3JhZ2UiLCJfYXR0YWNoQ29udGV4dCIsInByb3h5Iiwic3ViUHJveHkiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJfcHJveHkiLCJfY29udGV4dCIsIl9zdWJQcm94eSIsIl9zdGFjayIsInNldENvbnRleHQiLCJyZWNlaXZlciIsIl9yZXNvbHZlV2l0aENvbnRleHQiLCJhbGxLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsIl9hbGxLZXlzIiwiaXNTY3JpcHRhYmxlIiwiaXNJbmRleGFibGUiLCJyZWFkS2V5IiwicHJlZml4IiwibmVlZHNTdWJSZXNvbHZlciIsIl9yZXNvbHZlU2NyaXB0YWJsZSIsIl9yZXNvbHZlQXJyYXkiLCJFcnJvciIsImpvaW4iLCJkZWxldGUiLCJjcmVhdGVTdWJSZXNvbHZlciIsImFyciIsImZpbHRlciIsInJlc29sdmVGYWxsYmFjayIsImdldFNjb3BlIiwicGFyZW50IiwiYWRkU2NvcGVzIiwicGFyZW50U2NvcGVzIiwicGFyZW50RmFsbGJhY2siLCJhbGxTY29wZXMiLCJhZGRTY29wZXNGcm9tS2V5Iiwic3ViR2V0VGFyZ2V0IiwicmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzIiwiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwiX3BhcnNpbmciLCJwYXJzZWQiLCJwYXJzZSIsIkVQU0lMT04iLCJnZXRQb2ludCIsInNraXAiLCJnZXRWYWx1ZUF4aXMiLCJzcGxpbmVDdXJ2ZSIsImZpcnN0UG9pbnQiLCJtaWRkbGVQb2ludCIsImFmdGVyUG9pbnQiLCJuZXh0IiwiZDAxIiwiZDEyIiwiczAxIiwiczEyIiwiZmEiLCJmYiIsIm1vbm90b25lQWRqdXN0IiwiZGVsdGFLIiwibUsiLCJwb2ludHNMZW4iLCJhbHBoYUsiLCJiZXRhSyIsInRhdUsiLCJzcXVhcmVkTWFnbml0dWRlIiwicG9pbnRDdXJyZW50IiwicG9pbnRBZnRlciIsIm1vbm90b25lQ29tcHV0ZSIsInZhbHVlQXhpcyIsImRlbHRhIiwicG9pbnRCZWZvcmUiLCJpUGl4ZWwiLCJ2UGl4ZWwiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwic2xvcGVEZWx0YSIsImNhcENvbnRyb2xQb2ludCIsInB0IiwiY2FwQmV6aWVyUG9pbnRzIiwiaW5BcmVhIiwiaW5BcmVhUHJldiIsImluQXJlYU5leHQiLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImxvb3AiLCJjb250cm9sUG9pbnRzIiwic3BhbkdhcHMiLCJjdWJpY0ludGVycG9sYXRpb25Nb2RlIiwicHJldiIsInRlbnNpb24iLCJfaXNEb21TdXBwb3J0ZWQiLCJkb2N1bWVudCIsIl9nZXRQYXJlbnROb2RlIiwiZG9tTm9kZSIsInBhcmVudE5vZGUiLCJob3N0IiwicGFyc2VNYXhTdHlsZSIsInN0eWxlVmFsdWUiLCJwYXJlbnRQcm9wZXJ0eSIsInZhbHVlSW5QaXhlbHMiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWxlbWVudCIsImdldFN0eWxlIiwiZWwiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicG9zaXRpb25zIiwiZ2V0UG9zaXRpb25lZFN0eWxlIiwic3R5bGVzIiwic3VmZml4IiwicG9zIiwidXNlT2Zmc2V0UG9zIiwic2hhZG93Um9vdCIsImdldENhbnZhc1Bvc2l0aW9uIiwidG91Y2hlcyIsIm9mZnNldFgiLCJvZmZzZXRZIiwiYm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiZXZ0IiwiYm9yZGVyQm94IiwiYm94U2l6aW5nIiwicGFkZGluZ3MiLCJib3JkZXJzIiwiZ2V0Q29udGFpbmVyU2l6ZSIsIm1heEhlaWdodCIsImNvbnRhaW5lciIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiY29udGFpbmVyU3R5bGUiLCJjb250YWluZXJCb3JkZXIiLCJjb250YWluZXJQYWRkaW5nIiwicm91bmQxIiwiZ2V0TWF4aW11bVNpemUiLCJiYldpZHRoIiwiYmJIZWlnaHQiLCJhc3BlY3RSYXRpbyIsIm1hcmdpbnMiLCJjb250YWluZXJTaXplIiwicmV0aW5hU2NhbGUiLCJmb3JjZVJhdGlvIiwiZm9yY2VTdHlsZSIsInBpeGVsUmF0aW8iLCJkZXZpY2VIZWlnaHQiLCJkZXZpY2VXaWR0aCIsInNldFRyYW5zZm9ybSIsInN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlU3VwcG9ydGVkIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVhZFVzZWRTaXplIiwiX3BvaW50SW5MaW5lIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiX2JlemllckludGVycG9sYXRpb24iLCJjcDEiLCJjcDIiLCJpbnRsQ2FjaGUiLCJNYXAiLCJnZXROdW1iZXJGb3JtYXQiLCJsb2NhbGUiLCJjYWNoZUtleSIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtYXR0ZXIiLCJJbnRsIiwiTnVtYmVyRm9ybWF0IiwiZm9ybWF0TnVtYmVyIiwibnVtIiwiZm9ybWF0IiwiZ2V0UmlnaHRUb0xlZnRBZGFwdGVyIiwicmVjdFgiLCJzZXRXaWR0aCIsInhQbHVzIiwibGVmdEZvckx0ciIsIml0ZW1XaWR0aCIsImdldExlZnRUb1JpZ2h0QWRhcHRlciIsIl9pdGVtV2lkdGgiLCJnZXRSdGxBZGFwdGVyIiwib3ZlcnJpZGVUZXh0RGlyZWN0aW9uIiwiZGlyZWN0aW9uIiwib3JpZ2luYWwiLCJnZXRQcm9wZXJ0eVByaW9yaXR5Iiwic2V0UHJvcGVydHkiLCJwcmV2VGV4dERpcmVjdGlvbiIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwicHJvcGVydHlGbiIsImJldHdlZW4iLCJjb21wYXJlIiwibm9ybWFsaXplIiwibm9ybWFsaXplU2VnbWVudCIsImdldFNlZ21lbnQiLCJzZWdtZW50IiwiYm91bmRzIiwic3RhcnRCb3VuZCIsImVuZEJvdW5kIiwiX2JvdW5kU2VnbWVudCIsImluc2lkZSIsInN1YlN0YXJ0IiwicHJldlZhbHVlIiwic3RhcnRJc0JlZm9yZSIsImVuZElzQmVmb3JlIiwic2hvdWxkU3RhcnQiLCJzaG91bGRTdG9wIiwiX2JvdW5kU2VnbWVudHMiLCJzZWdtZW50cyIsInN1YiIsImZpbmRTdGFydEFuZEVuZCIsInNvbGlkU2VnbWVudHMiLCJjdXIiLCJzdG9wIiwiX2NvbXB1dGVTZWdtZW50cyIsInNlZ21lbnRPcHRpb25zIiwiX2xvb3AiLCJzcGxpdEJ5U3R5bGVzIiwiY29tcGxldGVMb29wIiwiX2Z1bGxMb29wIiwiZG9TcGxpdEJ5U3R5bGVzIiwiY2hhcnRDb250ZXh0IiwiX2NoYXJ0IiwiYmFzZVN0eWxlIiwicmVhZFN0eWxlIiwiX2RhdGFzZXRJbmRleCIsInByZXZTdHlsZSIsImFkZFN0eWxlIiwic3QiLCJkaXIiLCJwMCIsInAwRGF0YUluZGV4IiwicDFEYXRhSW5kZXgiLCJzdHlsZUNoYW5nZWQiLCJib3JkZXJDYXBTdHlsZSIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwiYm9yZGVySm9pblN0eWxlIiwiJCIsIl8iLCJhJCIsImEyIiwiYTMiLCJhNCIsImE1IiwiYTYiLCJhNyIsImE4IiwiYTkiLCJhQSIsImFCIiwiYUMiLCJhRCIsImFFIiwiYUYiLCJhRyIsImFIIiwiYUkiLCJhSiIsImFLIiwiYUwiLCJhTSIsImFOIiwiYU8iLCJhUCIsImFRIiwiYVIiLCJhUyIsImFUIiwiYVUiLCJhViIsImFXIiwiYVgiLCJhWSIsImFaIiwiYV8iLCJhYSIsImFiIiwiYWMiLCJhZCIsImFlIiwiYWYiLCJhZyIsImFoIiwiYWkiLCJhaiIsImFrIiwiYWwiLCJhbSIsImFuIiwiYW8iLCJhcCIsImFxIiwiYXIiLCJhcyIsImF0IiwiYXUiLCJhdiIsImF3IiwiYXgiLCJheSIsImF6IiwiYjAiLCJiMSIsImIyIiwiYjMiLCJiNCIsImI1IiwicSIsInUiLCJ6Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/dist/helpers.mjs":
/*!************************************************!*\
  !*** ./node_modules/chart.js/dist/helpers.mjs ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H; },\n/* harmony export */   INFINITY: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b1; },\n/* harmony export */   PI: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P; },\n/* harmony export */   PITAU: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b0; },\n/* harmony export */   QUARTER_PI: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b3; },\n/* harmony export */   RAD_PER_DEG: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b2; },\n/* harmony export */   TAU: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T; },\n/* harmony export */   TWO_THIRDS_PI: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b4; },\n/* harmony export */   _addGrace: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D; },\n/* harmony export */   _alignPixel: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J; },\n/* harmony export */   _alignStartEnd: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S; },\n/* harmony export */   _angleBetween: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p; },\n/* harmony export */   _angleDiff: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b5; },\n/* harmony export */   _arrayUnique: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._; },\n/* harmony export */   _attachContext: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9; },\n/* harmony export */   _bezierCurveTo: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at; },\n/* harmony export */   _bezierInterpolation: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq; },\n/* harmony export */   _boundSegment: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay; },\n/* harmony export */   _boundSegments: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao; },\n/* harmony export */   _capitalize: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W; },\n/* harmony export */   _computeSegments: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an; },\n/* harmony export */   _createResolver: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa; },\n/* harmony export */   _decimalPlaces: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL; },\n/* harmony export */   _deprecated: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aU; },\n/* harmony export */   _descriptors: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab; },\n/* harmony export */   _elementsEqual: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai; },\n/* harmony export */   _factorize: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A; },\n/* harmony export */   _filterBetween: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN; },\n/* harmony export */   _getParentNode: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2; },\n/* harmony export */   _getStartAndCountOfVisiblePoints: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q; },\n/* harmony export */   _int16Range: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I; },\n/* harmony export */   _isBetween: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak; },\n/* harmony export */   _isClickEvent: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj; },\n/* harmony export */   _isDomSupported: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6; },\n/* harmony export */   _isPointInArea: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$; },\n/* harmony export */   _limitValue: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E; },\n/* harmony export */   _longestText: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM; },\n/* harmony export */   _lookup: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO; },\n/* harmony export */   _lookupByKey: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z; },\n/* harmony export */   _measureText: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G; },\n/* harmony export */   _merger: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aS; },\n/* harmony export */   _mergerIf: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aT; },\n/* harmony export */   _normalizeAngle: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az; },\n/* harmony export */   _parseObjectDataRadialScale: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y; },\n/* harmony export */   _pointInLine: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar; },\n/* harmony export */   _readValueToProps: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al; },\n/* harmony export */   _rlookupByKey: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y; },\n/* harmony export */   _scaleRangesChanged: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w; },\n/* harmony export */   _setMinAndMaxByKey: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH; },\n/* harmony export */   _splitKey: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aV; },\n/* harmony export */   _steppedInterpolation: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap; },\n/* harmony export */   _steppedLineTo: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as; },\n/* harmony export */   _textX: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC; },\n/* harmony export */   _toLeftRightCenter: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R; },\n/* harmony export */   _updateBezierControlPoints: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am; },\n/* harmony export */   addRoundedRectPath: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av; },\n/* harmony export */   almostEquals: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK; },\n/* harmony export */   almostWhole: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ; },\n/* harmony export */   callback: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C; },\n/* harmony export */   clearCanvas: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag; },\n/* harmony export */   clipArea: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L; },\n/* harmony export */   clone: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aR; },\n/* harmony export */   color: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c; },\n/* harmony export */   createContext: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h; },\n/* harmony export */   debounce: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae; },\n/* harmony export */   defined: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j; },\n/* harmony export */   distanceBetweenPoints: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG; },\n/* harmony export */   drawPoint: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au; },\n/* harmony export */   drawPointLegend: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE; },\n/* harmony export */   each: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q; },\n/* harmony export */   easingEffects: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e; },\n/* harmony export */   finiteOrDefault: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B; },\n/* harmony export */   fontString: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a_; },\n/* harmony export */   formatNumber: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o; },\n/* harmony export */   getAngleFromPoint: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0; },\n/* harmony export */   getHoverColor: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aQ; },\n/* harmony export */   getMaximumSize: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1; },\n/* harmony export */   getRelativePosition: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X; },\n/* harmony export */   getRtlAdapter: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA; },\n/* harmony export */   getStyle: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aZ; },\n/* harmony export */   isArray: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b; },\n/* harmony export */   isFinite: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g; },\n/* harmony export */   isFunction: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8; },\n/* harmony export */   isNullOrUndef: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x; },\n/* harmony export */   isObject: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i; },\n/* harmony export */   isPatternOrGradient: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aP; },\n/* harmony export */   listenArrayEvents: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l; },\n/* harmony export */   log10: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z; },\n/* harmony export */   merge: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V; },\n/* harmony export */   mergeIf: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac; },\n/* harmony export */   niceNum: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI; },\n/* harmony export */   noop: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF; },\n/* harmony export */   overrideTextDirection: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB; },\n/* harmony export */   readUsedSize: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3; },\n/* harmony export */   renderText: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M; },\n/* harmony export */   requestAnimFrame: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r; },\n/* harmony export */   resolve: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a; },\n/* harmony export */   resolveObjectKey: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f; },\n/* harmony export */   restoreTextDirection: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD; },\n/* harmony export */   retinaScale: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af; },\n/* harmony export */   setsEqual: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah; },\n/* harmony export */   sign: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s; },\n/* harmony export */   splineCurve: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aX; },\n/* harmony export */   splineCurveMonotone: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aY; },\n/* harmony export */   supportsEventListenerOptions: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5; },\n/* harmony export */   throttled: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4; },\n/* harmony export */   toDegrees: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F; },\n/* harmony export */   toDimension: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n; },\n/* harmony export */   toFont: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O; },\n/* harmony export */   toFontString: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aW; },\n/* harmony export */   toLineHeight: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a$; },\n/* harmony export */   toPadding: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K; },\n/* harmony export */   toPercentage: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m; },\n/* harmony export */   toRadians: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t; },\n/* harmony export */   toTRBL: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw; },\n/* harmony export */   toTRBLCorners: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax; },\n/* harmony export */   uid: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad; },\n/* harmony export */   unclipArea: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N; },\n/* harmony export */   unlistenArrayEvents: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u; },\n/* harmony export */   valueOrDefault: function() { return /* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v; }\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(app-pages-browser)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2hlbHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDbzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2hlbHBlcnMubWpzPzFmZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5leHBvcnQgeyBIIGFzIEhBTEZfUEksIGIxIGFzIElORklOSVRZLCBQIGFzIFBJLCBiMCBhcyBQSVRBVSwgYjMgYXMgUVVBUlRFUl9QSSwgYjIgYXMgUkFEX1BFUl9ERUcsIFQgYXMgVEFVLCBiNCBhcyBUV09fVEhJUkRTX1BJLCBEIGFzIF9hZGRHcmFjZSwgSiBhcyBfYWxpZ25QaXhlbCwgUyBhcyBfYWxpZ25TdGFydEVuZCwgcCBhcyBfYW5nbGVCZXR3ZWVuLCBiNSBhcyBfYW5nbGVEaWZmLCBfIGFzIF9hcnJheVVuaXF1ZSwgYTkgYXMgX2F0dGFjaENvbnRleHQsIGF0IGFzIF9iZXppZXJDdXJ2ZVRvLCBhcSBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYXkgYXMgX2JvdW5kU2VnbWVudCwgYW8gYXMgX2JvdW5kU2VnbWVudHMsIFcgYXMgX2NhcGl0YWxpemUsIGFuIGFzIF9jb21wdXRlU2VnbWVudHMsIGFhIGFzIF9jcmVhdGVSZXNvbHZlciwgYUwgYXMgX2RlY2ltYWxQbGFjZXMsIGFVIGFzIF9kZXByZWNhdGVkLCBhYiBhcyBfZGVzY3JpcHRvcnMsIGFpIGFzIF9lbGVtZW50c0VxdWFsLCBBIGFzIF9mYWN0b3JpemUsIGFOIGFzIF9maWx0ZXJCZXR3ZWVuLCBhMiBhcyBfZ2V0UGFyZW50Tm9kZSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgSSBhcyBfaW50MTZSYW5nZSwgYWsgYXMgX2lzQmV0d2VlbiwgYWogYXMgX2lzQ2xpY2tFdmVudCwgYTYgYXMgX2lzRG9tU3VwcG9ydGVkLCAkIGFzIF9pc1BvaW50SW5BcmVhLCBFIGFzIF9saW1pdFZhbHVlLCBhTSBhcyBfbG9uZ2VzdFRleHQsIGFPIGFzIF9sb29rdXAsIFogYXMgX2xvb2t1cEJ5S2V5LCBHIGFzIF9tZWFzdXJlVGV4dCwgYVMgYXMgX21lcmdlciwgYVQgYXMgX21lcmdlcklmLCBheiBhcyBfbm9ybWFsaXplQW5nbGUsIHkgYXMgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLCBhciBhcyBfcG9pbnRJbkxpbmUsIGFsIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBZIGFzIF9ybG9va3VwQnlLZXksIHcgYXMgX3NjYWxlUmFuZ2VzQ2hhbmdlZCwgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhViBhcyBfc3BsaXRLZXksIGFwIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXMgYXMgX3N0ZXBwZWRMaW5lVG8sIGFDIGFzIF90ZXh0WCwgUiBhcyBfdG9MZWZ0UmlnaHRDZW50ZXIsIGFtIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhdiBhcyBhZGRSb3VuZGVkUmVjdFBhdGgsIGFLIGFzIGFsbW9zdEVxdWFscywgYUogYXMgYWxtb3N0V2hvbGUsIEMgYXMgY2FsbGJhY2ssIGFnIGFzIGNsZWFyQ2FudmFzLCBMIGFzIGNsaXBBcmVhLCBhUiBhcyBjbG9uZSwgYyBhcyBjb2xvciwgaCBhcyBjcmVhdGVDb250ZXh0LCBhZSBhcyBkZWJvdW5jZSwgaiBhcyBkZWZpbmVkLCBhRyBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGF1IGFzIGRyYXdQb2ludCwgYUUgYXMgZHJhd1BvaW50TGVnZW5kLCBRIGFzIGVhY2gsIGUgYXMgZWFzaW5nRWZmZWN0cywgQiBhcyBmaW5pdGVPckRlZmF1bHQsIGFfIGFzIGZvbnRTdHJpbmcsIG8gYXMgZm9ybWF0TnVtYmVyLCBhMCBhcyBnZXRBbmdsZUZyb21Qb2ludCwgYVEgYXMgZ2V0SG92ZXJDb2xvciwgYTEgYXMgZ2V0TWF4aW11bVNpemUsIFggYXMgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgYUEgYXMgZ2V0UnRsQWRhcHRlciwgYVogYXMgZ2V0U3R5bGUsIGIgYXMgaXNBcnJheSwgZyBhcyBpc0Zpbml0ZSwgYTggYXMgaXNGdW5jdGlvbiwgayBhcyBpc051bGxPclVuZGVmLCB4IGFzIGlzTnVtYmVyLCBpIGFzIGlzT2JqZWN0LCBhUCBhcyBpc1BhdHRlcm5PckdyYWRpZW50LCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCB6IGFzIGxvZzEwLCBWIGFzIG1lcmdlLCBhYyBhcyBtZXJnZUlmLCBhSSBhcyBuaWNlTnVtLCBhRiBhcyBub29wLCBhQiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIGEzIGFzIHJlYWRVc2VkU2l6ZSwgTSBhcyByZW5kZXJUZXh0LCByIGFzIHJlcXVlc3RBbmltRnJhbWUsIGEgYXMgcmVzb2x2ZSwgZiBhcyByZXNvbHZlT2JqZWN0S2V5LCBhRCBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYWYgYXMgcmV0aW5hU2NhbGUsIGFoIGFzIHNldHNFcXVhbCwgcyBhcyBzaWduLCBhWCBhcyBzcGxpbmVDdXJ2ZSwgYVkgYXMgc3BsaW5lQ3VydmVNb25vdG9uZSwgYTUgYXMgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgYTQgYXMgdGhyb3R0bGVkLCBGIGFzIHRvRGVncmVlcywgbiBhcyB0b0RpbWVuc2lvbiwgTyBhcyB0b0ZvbnQsIGFXIGFzIHRvRm9udFN0cmluZywgYSQgYXMgdG9MaW5lSGVpZ2h0LCBLIGFzIHRvUGFkZGluZywgbSBhcyB0b1BlcmNlbnRhZ2UsIHQgYXMgdG9SYWRpYW5zLCBhdyBhcyB0b1RSQkwsIGF4IGFzIHRvVFJCTENvcm5lcnMsIGFkIGFzIHVpZCwgTiBhcyB1bmNsaXBBcmVhLCB1IGFzIHVubGlzdGVuQXJyYXlFdmVudHMsIHYgYXMgdmFsdWVPckRlZmF1bHQgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcbiJdLCJuYW1lcyI6WyJIIiwiSEFMRl9QSSIsImIxIiwiSU5GSU5JVFkiLCJQIiwiUEkiLCJiMCIsIlBJVEFVIiwiYjMiLCJRVUFSVEVSX1BJIiwiYjIiLCJSQURfUEVSX0RFRyIsIlQiLCJUQVUiLCJiNCIsIlRXT19USElSRFNfUEkiLCJEIiwiX2FkZEdyYWNlIiwiSiIsIl9hbGlnblBpeGVsIiwiUyIsIl9hbGlnblN0YXJ0RW5kIiwicCIsIl9hbmdsZUJldHdlZW4iLCJiNSIsIl9hbmdsZURpZmYiLCJfIiwiX2FycmF5VW5pcXVlIiwiYTkiLCJfYXR0YWNoQ29udGV4dCIsImF0IiwiX2JlemllckN1cnZlVG8iLCJhcSIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiYXkiLCJfYm91bmRTZWdtZW50IiwiYW8iLCJfYm91bmRTZWdtZW50cyIsIlciLCJfY2FwaXRhbGl6ZSIsImFuIiwiX2NvbXB1dGVTZWdtZW50cyIsImFhIiwiX2NyZWF0ZVJlc29sdmVyIiwiYUwiLCJfZGVjaW1hbFBsYWNlcyIsImFVIiwiX2RlcHJlY2F0ZWQiLCJhYiIsIl9kZXNjcmlwdG9ycyIsImFpIiwiX2VsZW1lbnRzRXF1YWwiLCJBIiwiX2ZhY3Rvcml6ZSIsImFOIiwiX2ZpbHRlckJldHdlZW4iLCJhMiIsIl9nZXRQYXJlbnROb2RlIiwicSIsIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwiSSIsIl9pbnQxNlJhbmdlIiwiYWsiLCJfaXNCZXR3ZWVuIiwiYWoiLCJfaXNDbGlja0V2ZW50IiwiYTYiLCJfaXNEb21TdXBwb3J0ZWQiLCIkIiwiX2lzUG9pbnRJbkFyZWEiLCJFIiwiX2xpbWl0VmFsdWUiLCJhTSIsIl9sb25nZXN0VGV4dCIsImFPIiwiX2xvb2t1cCIsIloiLCJfbG9va3VwQnlLZXkiLCJHIiwiX21lYXN1cmVUZXh0IiwiYVMiLCJfbWVyZ2VyIiwiYVQiLCJfbWVyZ2VySWYiLCJheiIsIl9ub3JtYWxpemVBbmdsZSIsInkiLCJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCJhciIsIl9wb2ludEluTGluZSIsImFsIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJZIiwiX3Jsb29rdXBCeUtleSIsInciLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwiYUgiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhViIsIl9zcGxpdEtleSIsImFwIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiYXMiLCJfc3RlcHBlZExpbmVUbyIsImFDIiwiX3RleHRYIiwiUiIsIl90b0xlZnRSaWdodENlbnRlciIsImFtIiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJhdiIsImFkZFJvdW5kZWRSZWN0UGF0aCIsImFLIiwiYWxtb3N0RXF1YWxzIiwiYUoiLCJhbG1vc3RXaG9sZSIsIkMiLCJjYWxsYmFjayIsImFnIiwiY2xlYXJDYW52YXMiLCJMIiwiY2xpcEFyZWEiLCJhUiIsImNsb25lIiwiYyIsImNvbG9yIiwiaCIsImNyZWF0ZUNvbnRleHQiLCJhZSIsImRlYm91bmNlIiwiaiIsImRlZmluZWQiLCJhRyIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsImF1IiwiZHJhd1BvaW50IiwiYUUiLCJkcmF3UG9pbnRMZWdlbmQiLCJRIiwiZWFjaCIsImUiLCJlYXNpbmdFZmZlY3RzIiwiQiIsImZpbml0ZU9yRGVmYXVsdCIsImFfIiwiZm9udFN0cmluZyIsIm8iLCJmb3JtYXROdW1iZXIiLCJhMCIsImdldEFuZ2xlRnJvbVBvaW50IiwiYVEiLCJnZXRIb3ZlckNvbG9yIiwiYTEiLCJnZXRNYXhpbXVtU2l6ZSIsIlgiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiYUEiLCJnZXRSdGxBZGFwdGVyIiwiYVoiLCJnZXRTdHlsZSIsImIiLCJpc0FycmF5IiwiZyIsImlzRmluaXRlIiwiYTgiLCJpc0Z1bmN0aW9uIiwiayIsImlzTnVsbE9yVW5kZWYiLCJ4IiwiaXNOdW1iZXIiLCJpIiwiaXNPYmplY3QiLCJhUCIsImlzUGF0dGVybk9yR3JhZGllbnQiLCJsIiwibGlzdGVuQXJyYXlFdmVudHMiLCJ6IiwibG9nMTAiLCJWIiwibWVyZ2UiLCJhYyIsIm1lcmdlSWYiLCJhSSIsIm5pY2VOdW0iLCJhRiIsIm5vb3AiLCJhQiIsIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsImEzIiwicmVhZFVzZWRTaXplIiwiTSIsInJlbmRlclRleHQiLCJyIiwicmVxdWVzdEFuaW1GcmFtZSIsImEiLCJyZXNvbHZlIiwiZiIsInJlc29sdmVPYmplY3RLZXkiLCJhRCIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwiYWYiLCJyZXRpbmFTY2FsZSIsImFoIiwic2V0c0VxdWFsIiwicyIsInNpZ24iLCJhWCIsInNwbGluZUN1cnZlIiwiYVkiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwiYTUiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwiYTQiLCJ0aHJvdHRsZWQiLCJGIiwidG9EZWdyZWVzIiwibiIsInRvRGltZW5zaW9uIiwiTyIsInRvRm9udCIsImFXIiwidG9Gb250U3RyaW5nIiwiYSQiLCJ0b0xpbmVIZWlnaHQiLCJLIiwidG9QYWRkaW5nIiwibSIsInRvUGVyY2VudGFnZSIsInQiLCJ0b1JhZGlhbnMiLCJhdyIsInRvVFJCTCIsImF4IiwidG9UUkJMQ29ybmVycyIsImFkIiwidWlkIiwiTiIsInVuY2xpcEFyZWEiLCJ1IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInYiLCJ2YWx1ZU9yRGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/dist/helpers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/chart.js/helpers/helpers.mjs":
/*!***************************************************!*\
  !*** ./node_modules/chart.js/helpers/helpers.mjs ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.HALF_PI; },\n/* harmony export */   INFINITY: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.INFINITY; },\n/* harmony export */   PI: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PI; },\n/* harmony export */   PITAU: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PITAU; },\n/* harmony export */   QUARTER_PI: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI; },\n/* harmony export */   RAD_PER_DEG: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG; },\n/* harmony export */   TAU: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TAU; },\n/* harmony export */   TWO_THIRDS_PI: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI; },\n/* harmony export */   _addGrace: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._addGrace; },\n/* harmony export */   _alignPixel: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignPixel; },\n/* harmony export */   _alignStartEnd: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignStartEnd; },\n/* harmony export */   _angleBetween: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleBetween; },\n/* harmony export */   _angleDiff: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleDiff; },\n/* harmony export */   _arrayUnique: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._arrayUnique; },\n/* harmony export */   _attachContext: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._attachContext; },\n/* harmony export */   _bezierCurveTo: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierCurveTo; },\n/* harmony export */   _bezierInterpolation: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierInterpolation; },\n/* harmony export */   _boundSegment: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegment; },\n/* harmony export */   _boundSegments: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegments; },\n/* harmony export */   _capitalize: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._capitalize; },\n/* harmony export */   _computeSegments: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._computeSegments; },\n/* harmony export */   _createResolver: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._createResolver; },\n/* harmony export */   _decimalPlaces: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._decimalPlaces; },\n/* harmony export */   _deprecated: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deprecated; },\n/* harmony export */   _descriptors: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._descriptors; },\n/* harmony export */   _elementsEqual: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._elementsEqual; },\n/* harmony export */   _factorize: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._factorize; },\n/* harmony export */   _filterBetween: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._filterBetween; },\n/* harmony export */   _getParentNode: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getParentNode; },\n/* harmony export */   _getStartAndCountOfVisiblePoints: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getStartAndCountOfVisiblePoints; },\n/* harmony export */   _int16Range: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._int16Range; },\n/* harmony export */   _isBetween: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isBetween; },\n/* harmony export */   _isClickEvent: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isClickEvent; },\n/* harmony export */   _isDomSupported: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isDomSupported; },\n/* harmony export */   _isPointInArea: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isPointInArea; },\n/* harmony export */   _limitValue: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._limitValue; },\n/* harmony export */   _longestText: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._longestText; },\n/* harmony export */   _lookup: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookup; },\n/* harmony export */   _lookupByKey: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookupByKey; },\n/* harmony export */   _measureText: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._measureText; },\n/* harmony export */   _merger: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._merger; },\n/* harmony export */   _mergerIf: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._mergerIf; },\n/* harmony export */   _normalizeAngle: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._normalizeAngle; },\n/* harmony export */   _parseObjectDataRadialScale: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._parseObjectDataRadialScale; },\n/* harmony export */   _pointInLine: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._pointInLine; },\n/* harmony export */   _readValueToProps: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._readValueToProps; },\n/* harmony export */   _rlookupByKey: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._rlookupByKey; },\n/* harmony export */   _scaleRangesChanged: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._scaleRangesChanged; },\n/* harmony export */   _setMinAndMaxByKey: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._setMinAndMaxByKey; },\n/* harmony export */   _splitKey: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._splitKey; },\n/* harmony export */   _steppedInterpolation: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedInterpolation; },\n/* harmony export */   _steppedLineTo: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedLineTo; },\n/* harmony export */   _textX: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._textX; },\n/* harmony export */   _toLeftRightCenter: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._toLeftRightCenter; },\n/* harmony export */   _updateBezierControlPoints: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._updateBezierControlPoints; },\n/* harmony export */   addRoundedRectPath: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addRoundedRectPath; },\n/* harmony export */   almostEquals: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostEquals; },\n/* harmony export */   almostWhole: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostWhole; },\n/* harmony export */   callback: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.callback; },\n/* harmony export */   clearCanvas: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clearCanvas; },\n/* harmony export */   clipArea: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clipArea; },\n/* harmony export */   clone: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clone; },\n/* harmony export */   color: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.color; },\n/* harmony export */   createContext: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.createContext; },\n/* harmony export */   debounce: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce; },\n/* harmony export */   defined: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.defined; },\n/* harmony export */   distanceBetweenPoints: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints; },\n/* harmony export */   drawPoint: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPoint; },\n/* harmony export */   drawPointLegend: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPointLegend; },\n/* harmony export */   each: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.each; },\n/* harmony export */   easingEffects: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.easingEffects; },\n/* harmony export */   finiteOrDefault: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.finiteOrDefault; },\n/* harmony export */   fontString: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.fontString; },\n/* harmony export */   formatNumber: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.formatNumber; },\n/* harmony export */   getAngleFromPoint: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint; },\n/* harmony export */   getHoverColor: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getHoverColor; },\n/* harmony export */   getMaximumSize: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getMaximumSize; },\n/* harmony export */   getRelativePosition: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRelativePosition; },\n/* harmony export */   getRtlAdapter: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRtlAdapter; },\n/* harmony export */   getStyle: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getStyle; },\n/* harmony export */   isArray: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isArray; },\n/* harmony export */   isFinite: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFinite; },\n/* harmony export */   isFunction: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction; },\n/* harmony export */   isNullOrUndef: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber; },\n/* harmony export */   isObject: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject; },\n/* harmony export */   isPatternOrGradient: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isPatternOrGradient; },\n/* harmony export */   listenArrayEvents: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.listenArrayEvents; },\n/* harmony export */   log10: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.log10; },\n/* harmony export */   merge: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.merge; },\n/* harmony export */   mergeIf: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeIf; },\n/* harmony export */   niceNum: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.niceNum; },\n/* harmony export */   noop: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.noop; },\n/* harmony export */   overrideTextDirection: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.overrideTextDirection; },\n/* harmony export */   readUsedSize: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.readUsedSize; },\n/* harmony export */   renderText: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.renderText; },\n/* harmony export */   requestAnimFrame: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.requestAnimFrame; },\n/* harmony export */   resolve: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolve; },\n/* harmony export */   resolveObjectKey: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveObjectKey; },\n/* harmony export */   restoreTextDirection: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.restoreTextDirection; },\n/* harmony export */   retinaScale: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.retinaScale; },\n/* harmony export */   setsEqual: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setsEqual; },\n/* harmony export */   sign: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.sign; },\n/* harmony export */   splineCurve: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurve; },\n/* harmony export */   splineCurveMonotone: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurveMonotone; },\n/* harmony export */   supportsEventListenerOptions: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.supportsEventListenerOptions; },\n/* harmony export */   throttled: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.throttled; },\n/* harmony export */   toDegrees: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDegrees; },\n/* harmony export */   toDimension: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDimension; },\n/* harmony export */   toFont: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFont; },\n/* harmony export */   toFontString: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFontString; },\n/* harmony export */   toLineHeight: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toLineHeight; },\n/* harmony export */   toPadding: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPadding; },\n/* harmony export */   toPercentage: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPercentage; },\n/* harmony export */   toRadians: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRadians; },\n/* harmony export */   toTRBL: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBL; },\n/* harmony export */   toTRBLCorners: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBLCorners; },\n/* harmony export */   uid: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.uid; },\n/* harmony export */   unclipArea: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unclipArea; },\n/* harmony export */   unlistenArrayEvents: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unlistenArrayEvents; },\n/* harmony export */   valueOrDefault: function() { return /* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault; }\n/* harmony export */ });\n/* harmony import */ var _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/helpers.mjs */ \"(app-pages-browser)/./node_modules/chart.js/dist/helpers.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9oZWxwZXJzL2hlbHBlcnMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9oZWxwZXJzL2hlbHBlcnMubWpzPzZhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9oZWxwZXJzLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/chart.js/helpers/helpers.mjs\n"));

/***/ })

}]);