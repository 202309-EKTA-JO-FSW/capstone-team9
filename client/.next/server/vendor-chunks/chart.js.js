"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/chart.js";
exports.ids = ["vendor-chunks/chart.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/chart.js/dist/chart.mjs":
/*!**********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animation: () => (/* binding */ Animation),\n/* harmony export */   Animations: () => (/* binding */ Animations),\n/* harmony export */   ArcElement: () => (/* binding */ ArcElement),\n/* harmony export */   BarController: () => (/* binding */ BarController),\n/* harmony export */   BarElement: () => (/* binding */ BarElement),\n/* harmony export */   BasePlatform: () => (/* binding */ BasePlatform),\n/* harmony export */   BasicPlatform: () => (/* binding */ BasicPlatform),\n/* harmony export */   BubbleController: () => (/* binding */ BubbleController),\n/* harmony export */   CategoryScale: () => (/* binding */ CategoryScale),\n/* harmony export */   Chart: () => (/* binding */ Chart),\n/* harmony export */   DatasetController: () => (/* binding */ DatasetController),\n/* harmony export */   Decimation: () => (/* binding */ plugin_decimation),\n/* harmony export */   DomPlatform: () => (/* binding */ DomPlatform),\n/* harmony export */   DoughnutController: () => (/* binding */ DoughnutController),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Filler: () => (/* binding */ index),\n/* harmony export */   Interaction: () => (/* binding */ Interaction),\n/* harmony export */   Legend: () => (/* binding */ plugin_legend),\n/* harmony export */   LineController: () => (/* binding */ LineController),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearScale: () => (/* binding */ LinearScale),\n/* harmony export */   LogarithmicScale: () => (/* binding */ LogarithmicScale),\n/* harmony export */   PieController: () => (/* binding */ PieController),\n/* harmony export */   PointElement: () => (/* binding */ PointElement),\n/* harmony export */   PolarAreaController: () => (/* binding */ PolarAreaController),\n/* harmony export */   RadarController: () => (/* binding */ RadarController),\n/* harmony export */   RadialLinearScale: () => (/* binding */ RadialLinearScale),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   ScatterController: () => (/* binding */ ScatterController),\n/* harmony export */   SubTitle: () => (/* binding */ plugin_subtitle),\n/* harmony export */   Ticks: () => (/* binding */ Ticks),\n/* harmony export */   TimeScale: () => (/* binding */ TimeScale),\n/* harmony export */   TimeSeriesScale: () => (/* binding */ TimeSeriesScale),\n/* harmony export */   Title: () => (/* binding */ plugin_title),\n/* harmony export */   Tooltip: () => (/* binding */ plugin_tooltip),\n/* harmony export */   _adapters: () => (/* binding */ adapters),\n/* harmony export */   _detectPlatform: () => (/* binding */ _detectPlatform),\n/* harmony export */   animator: () => (/* binding */ animator),\n/* harmony export */   controllers: () => (/* binding */ controllers),\n/* harmony export */   defaults: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   elements: () => (/* binding */ elements),\n/* harmony export */   layouts: () => (/* binding */ layouts),\n/* harmony export */   plugins: () => (/* binding */ plugins),\n/* harmony export */   registerables: () => (/* binding */ registerables),\n/* harmony export */   registry: () => (/* binding */ registry),\n/* harmony export */   scales: () => (/* binding */ scales)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n\nclass Animator {\n    constructor(){\n        this._request = null;\n        this._charts = new Map();\n        this._running = false;\n        this._lastDate = undefined;\n    }\n    _notify(chart, anims, date, type) {\n        const callbacks = anims.listeners[type];\n        const numSteps = anims.duration;\n        callbacks.forEach((fn)=>fn({\n                chart,\n                initial: anims.initial,\n                numSteps,\n                currentStep: Math.min(date - anims.start, numSteps)\n            }));\n    }\n    _refresh() {\n        if (this._request) {\n            return;\n        }\n        this._running = true;\n        this._request = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r.call(window, ()=>{\n            this._update();\n            this._request = null;\n            if (this._running) {\n                this._refresh();\n            }\n        });\n    }\n    _update(date = Date.now()) {\n        let remaining = 0;\n        this._charts.forEach((anims, chart)=>{\n            if (!anims.running || !anims.items.length) {\n                return;\n            }\n            const items = anims.items;\n            let i = items.length - 1;\n            let draw = false;\n            let item;\n            for(; i >= 0; --i){\n                item = items[i];\n                if (item._active) {\n                    if (item._total > anims.duration) {\n                        anims.duration = item._total;\n                    }\n                    item.tick(date);\n                    draw = true;\n                } else {\n                    items[i] = items[items.length - 1];\n                    items.pop();\n                }\n            }\n            if (draw) {\n                chart.draw();\n                this._notify(chart, anims, date, \"progress\");\n            }\n            if (!items.length) {\n                anims.running = false;\n                this._notify(chart, anims, date, \"complete\");\n                anims.initial = false;\n            }\n            remaining += items.length;\n        });\n        this._lastDate = date;\n        if (remaining === 0) {\n            this._running = false;\n        }\n    }\n    _getAnims(chart) {\n        const charts = this._charts;\n        let anims = charts.get(chart);\n        if (!anims) {\n            anims = {\n                running: false,\n                initial: true,\n                items: [],\n                listeners: {\n                    complete: [],\n                    progress: []\n                }\n            };\n            charts.set(chart, anims);\n        }\n        return anims;\n    }\n    listen(chart, event, cb) {\n        this._getAnims(chart).listeners[event].push(cb);\n    }\n    add(chart, items) {\n        if (!items || !items.length) {\n            return;\n        }\n        this._getAnims(chart).items.push(...items);\n    }\n    has(chart) {\n        return this._getAnims(chart).items.length > 0;\n    }\n    start(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims) {\n            return;\n        }\n        anims.running = true;\n        anims.start = Date.now();\n        anims.duration = anims.items.reduce((acc, cur)=>Math.max(acc, cur._duration), 0);\n        this._refresh();\n    }\n    running(chart) {\n        if (!this._running) {\n            return false;\n        }\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.running || !anims.items.length) {\n            return false;\n        }\n        return true;\n    }\n    stop(chart) {\n        const anims = this._charts.get(chart);\n        if (!anims || !anims.items.length) {\n            return;\n        }\n        const items = anims.items;\n        let i = items.length - 1;\n        for(; i >= 0; --i){\n            items[i].cancel();\n        }\n        anims.items = [];\n        this._notify(chart, anims, Date.now(), \"complete\");\n    }\n    remove(chart) {\n        return this._charts.delete(chart);\n    }\n}\nvar animator = new Animator();\nconst transparent = \"transparent\";\nconst interpolators = {\n    boolean (from, to, factor) {\n        return factor > 0.5 ? to : from;\n    },\n    color (from, to, factor) {\n        const c0 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(from || transparent);\n        const c1 = c0.valid && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c)(to || transparent);\n        return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;\n    },\n    number (from, to, factor) {\n        return from + (to - from) * factor;\n    }\n};\nclass Animation {\n    constructor(cfg, target, prop, to){\n        const currentValue = target[prop];\n        to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.to,\n            to,\n            currentValue,\n            cfg.from\n        ]);\n        const from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n            cfg.from,\n            currentValue,\n            to\n        ]);\n        this._active = true;\n        this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n        this._easing = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e[cfg.easing] || _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e.linear;\n        this._start = Math.floor(Date.now() + (cfg.delay || 0));\n        this._duration = this._total = Math.floor(cfg.duration);\n        this._loop = !!cfg.loop;\n        this._target = target;\n        this._prop = prop;\n        this._from = from;\n        this._to = to;\n        this._promises = undefined;\n    }\n    active() {\n        return this._active;\n    }\n    update(cfg, to, date) {\n        if (this._active) {\n            this._notify(false);\n            const currentValue = this._target[this._prop];\n            const elapsed = date - this._start;\n            const remain = this._duration - elapsed;\n            this._start = date;\n            this._duration = Math.floor(Math.max(remain, cfg.duration));\n            this._total += elapsed;\n            this._loop = !!cfg.loop;\n            this._to = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.to,\n                to,\n                currentValue,\n                cfg.from\n            ]);\n            this._from = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                cfg.from,\n                currentValue,\n                to\n            ]);\n        }\n    }\n    cancel() {\n        if (this._active) {\n            this.tick(Date.now());\n            this._active = false;\n            this._notify(false);\n        }\n    }\n    tick(date) {\n        const elapsed = date - this._start;\n        const duration = this._duration;\n        const prop = this._prop;\n        const from = this._from;\n        const loop = this._loop;\n        const to = this._to;\n        let factor;\n        this._active = from !== to && (loop || elapsed < duration);\n        if (!this._active) {\n            this._target[prop] = to;\n            this._notify(true);\n            return;\n        }\n        if (elapsed < 0) {\n            this._target[prop] = from;\n            return;\n        }\n        factor = elapsed / duration % 2;\n        factor = loop && factor > 1 ? 2 - factor : factor;\n        factor = this._easing(Math.min(1, Math.max(0, factor)));\n        this._target[prop] = this._fn(from, to, factor);\n    }\n    wait() {\n        const promises = this._promises || (this._promises = []);\n        return new Promise((res, rej)=>{\n            promises.push({\n                res,\n                rej\n            });\n        });\n    }\n    _notify(resolved) {\n        const method = resolved ? \"res\" : \"rej\";\n        const promises = this._promises || [];\n        for(let i = 0; i < promises.length; i++){\n            promises[i][method]();\n        }\n    }\n}\nconst numbers = [\n    \"x\",\n    \"y\",\n    \"borderWidth\",\n    \"radius\",\n    \"tension\"\n];\nconst colors = [\n    \"color\",\n    \"borderColor\",\n    \"backgroundColor\"\n];\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animation\", {\n    delay: undefined,\n    duration: 1000,\n    easing: \"easeOutQuart\",\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined\n});\nconst animationOptions = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.animation);\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animation\", {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name)=>name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"animations\", {\n    colors: {\n        type: \"color\",\n        properties: colors\n    },\n    numbers: {\n        type: \"number\",\n        properties: numbers\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"animations\", {\n    _fallback: \"animation\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"transitions\", {\n    active: {\n        animation: {\n            duration: 400\n        }\n    },\n    resize: {\n        animation: {\n            duration: 0\n        }\n    },\n    show: {\n        animations: {\n            colors: {\n                from: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                duration: 0\n            }\n        }\n    },\n    hide: {\n        animations: {\n            colors: {\n                to: \"transparent\"\n            },\n            visible: {\n                type: \"boolean\",\n                easing: \"linear\",\n                fn: (v)=>v | 0\n            }\n        }\n    }\n});\nclass Animations {\n    constructor(chart, config){\n        this._chart = chart;\n        this._properties = new Map();\n        this.configure(config);\n    }\n    configure(config) {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(config)) {\n            return;\n        }\n        const animatedProps = this._properties;\n        Object.getOwnPropertyNames(config).forEach((key)=>{\n            const cfg = config[key];\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(cfg)) {\n                return;\n            }\n            const resolved = {};\n            for (const option of animationOptions){\n                resolved[option] = cfg[option];\n            }\n            ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(cfg.properties) && cfg.properties || [\n                key\n            ]).forEach((prop)=>{\n                if (prop === key || !animatedProps.has(prop)) {\n                    animatedProps.set(prop, resolved);\n                }\n            });\n        });\n    }\n    _animateOptions(target, values) {\n        const newOptions = values.options;\n        const options = resolveTargetOptions(target, newOptions);\n        if (!options) {\n            return [];\n        }\n        const animations = this._createAnimations(options, newOptions);\n        if (newOptions.$shared) {\n            awaitAll(target.options.$animations, newOptions).then(()=>{\n                target.options = newOptions;\n            }, ()=>{});\n        }\n        return animations;\n    }\n    _createAnimations(target, values) {\n        const animatedProps = this._properties;\n        const animations = [];\n        const running = target.$animations || (target.$animations = {});\n        const props = Object.keys(values);\n        const date = Date.now();\n        let i;\n        for(i = props.length - 1; i >= 0; --i){\n            const prop = props[i];\n            if (prop.charAt(0) === \"$\") {\n                continue;\n            }\n            if (prop === \"options\") {\n                animations.push(...this._animateOptions(target, values));\n                continue;\n            }\n            const value = values[prop];\n            let animation = running[prop];\n            const cfg = animatedProps.get(prop);\n            if (animation) {\n                if (cfg && animation.active()) {\n                    animation.update(cfg, value, date);\n                    continue;\n                } else {\n                    animation.cancel();\n                }\n            }\n            if (!cfg || !cfg.duration) {\n                target[prop] = value;\n                continue;\n            }\n            running[prop] = animation = new Animation(cfg, target, prop, value);\n            animations.push(animation);\n        }\n        return animations;\n    }\n    update(target, values) {\n        if (this._properties.size === 0) {\n            Object.assign(target, values);\n            return;\n        }\n        const animations = this._createAnimations(target, values);\n        if (animations.length) {\n            animator.add(this._chart, animations);\n            return true;\n        }\n    }\n}\nfunction awaitAll(animations, properties) {\n    const running = [];\n    const keys = Object.keys(properties);\n    for(let i = 0; i < keys.length; i++){\n        const anim = animations[keys[i]];\n        if (anim && anim.active()) {\n            running.push(anim.wait());\n        }\n    }\n    return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n    if (!newOptions) {\n        return;\n    }\n    let options = target.options;\n    if (!options) {\n        target.options = newOptions;\n        return;\n    }\n    if (options.$shared) {\n        target.options = options = Object.assign({}, options, {\n            $shared: false,\n            $animations: {}\n        });\n    }\n    return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n    const opts = scale && scale.options || {};\n    const reverse = opts.reverse;\n    const min = opts.min === undefined ? allowedOverflow : 0;\n    const max = opts.max === undefined ? allowedOverflow : 0;\n    return {\n        start: reverse ? max : min,\n        end: reverse ? min : max\n    };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n    if (allowedOverflow === false) {\n        return false;\n    }\n    const x = scaleClip(xScale, allowedOverflow);\n    const y = scaleClip(yScale, allowedOverflow);\n    return {\n        top: y.end,\n        right: x.end,\n        bottom: y.start,\n        left: x.start\n    };\n}\nfunction toClip(value) {\n    let t, r, b, l;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {\n        t = value.top;\n        r = value.right;\n        b = value.bottom;\n        l = value.left;\n    } else {\n        t = r = b = l = value;\n    }\n    return {\n        top: t,\n        right: r,\n        bottom: b,\n        left: l,\n        disabled: value === false\n    };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n    const keys = [];\n    const metasets = chart._getSortedDatasetMetas(filterVisible);\n    let i, ilen;\n    for(i = 0, ilen = metasets.length; i < ilen; ++i){\n        keys.push(metasets[i].index);\n    }\n    return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n    const keys = stack.keys;\n    const singleMode = options.mode === \"single\";\n    let i, ilen, datasetIndex, otherValue;\n    if (value === null) {\n        return;\n    }\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        datasetIndex = +keys[i];\n        if (datasetIndex === dsIndex) {\n            if (options.all) {\n                continue;\n            }\n            break;\n        }\n        otherValue = stack.values[datasetIndex];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(otherValue) && (singleMode || value === 0 || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) === (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(otherValue))) {\n            value += otherValue;\n        }\n    }\n    return value;\n}\nfunction convertObjectDataToArray(data) {\n    const keys = Object.keys(data);\n    const adata = new Array(keys.length);\n    let i, ilen, key;\n    for(i = 0, ilen = keys.length; i < ilen; ++i){\n        key = keys[i];\n        adata[i] = {\n            x: key,\n            y: data[key]\n        };\n    }\n    return adata;\n}\nfunction isStacked(scale, meta) {\n    const stacked = scale && scale.options.stacked;\n    return stacked || stacked === undefined && meta.stack !== undefined;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n    return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n    const { min, max, minDefined, maxDefined } = scale.getUserBounds();\n    return {\n        min: minDefined ? min : Number.NEGATIVE_INFINITY,\n        max: maxDefined ? max : Number.POSITIVE_INFINITY\n    };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n    const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n    return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n    for (const meta of vScale.getMatchingVisibleMetas(type).reverse()){\n        const value = stack[meta.index];\n        if (positive && value > 0 || !positive && value < 0) {\n            return meta.index;\n        }\n    }\n    return null;\n}\nfunction updateStacks(controller, parsed) {\n    const { chart, _cachedMeta: meta } = controller;\n    const stacks = chart._stacks || (chart._stacks = {});\n    const { iScale, vScale, index: datasetIndex } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const key = getStackKey(iScale, vScale, meta);\n    const ilen = parsed.length;\n    let stack;\n    for(let i = 0; i < ilen; ++i){\n        const item = parsed[i];\n        const { [iAxis]: index, [vAxis]: value } = item;\n        const itemStacks = item._stacks || (item._stacks = {});\n        stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n        stack[datasetIndex] = value;\n        stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n        stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n    }\n}\nfunction getFirstScaleId(chart, axis) {\n    const scales = chart.scales;\n    return Object.keys(scales).filter((key)=>scales[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataset: undefined,\n        datasetIndex: index,\n        index,\n        mode: \"default\",\n        type: \"dataset\"\n    });\n}\nfunction createDataContext(parent, index, element) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        active: false,\n        dataIndex: index,\n        parsed: undefined,\n        raw: undefined,\n        element,\n        index,\n        mode: \"default\",\n        type: \"data\"\n    });\n}\nfunction clearStacks(meta, items) {\n    const datasetIndex = meta.controller.index;\n    const axis = meta.vScale && meta.vScale.axis;\n    if (!axis) {\n        return;\n    }\n    items = items || meta._parsed;\n    for (const parsed of items){\n        const stacks = parsed._stacks;\n        if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n            return;\n        }\n        delete stacks[axis][datasetIndex];\n    }\n}\nconst isDirectUpdateMode = (mode)=>mode === \"reset\" || mode === \"none\";\nconst cloneIfNotShared = (cached, shared)=>shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart)=>canStack && !meta.hidden && meta._stacked && {\n        keys: getSortedDatasetIndices(chart, true),\n        values: null\n    };\nclass DatasetController {\n    constructor(chart, datasetIndex){\n        this.chart = chart;\n        this._ctx = chart.ctx;\n        this.index = datasetIndex;\n        this._cachedDataOpts = {};\n        this._cachedMeta = this.getMeta();\n        this._type = this._cachedMeta.type;\n        this.options = undefined;\n        this._parsing = false;\n        this._data = undefined;\n        this._objectData = undefined;\n        this._sharedOptions = undefined;\n        this._drawStart = undefined;\n        this._drawCount = undefined;\n        this.enableOptionSharing = false;\n        this.supportsDecimation = false;\n        this.$context = undefined;\n        this._syncList = [];\n        this.initialize();\n    }\n    initialize() {\n        const meta = this._cachedMeta;\n        this.configure();\n        this.linkScales();\n        meta._stacked = isStacked(meta.vScale, meta);\n        this.addElements();\n    }\n    updateIndex(datasetIndex) {\n        if (this.index !== datasetIndex) {\n            clearStacks(this._cachedMeta);\n        }\n        this.index = datasetIndex;\n    }\n    linkScales() {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        const chooseId = (axis, x, y, r)=>axis === \"x\" ? x : axis === \"r\" ? r : y;\n        const xid = meta.xAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n        const yid = meta.yAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n        const rid = meta.rAxisID = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n        const indexAxis = meta.indexAxis;\n        const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n        const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n        meta.xScale = this.getScaleForId(xid);\n        meta.yScale = this.getScaleForId(yid);\n        meta.rScale = this.getScaleForId(rid);\n        meta.iScale = this.getScaleForId(iid);\n        meta.vScale = this.getScaleForId(vid);\n    }\n    getDataset() {\n        return this.chart.data.datasets[this.index];\n    }\n    getMeta() {\n        return this.chart.getDatasetMeta(this.index);\n    }\n    getScaleForId(scaleID) {\n        return this.chart.scales[scaleID];\n    }\n    _getOtherScale(scale) {\n        const meta = this._cachedMeta;\n        return scale === meta.iScale ? meta.vScale : meta.iScale;\n    }\n    reset() {\n        this._update(\"reset\");\n    }\n    _destroy() {\n        const meta = this._cachedMeta;\n        if (this._data) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(this._data, this);\n        }\n        if (meta._stacked) {\n            clearStacks(meta);\n        }\n    }\n    _dataCheck() {\n        const dataset = this.getDataset();\n        const data = dataset.data || (dataset.data = []);\n        const _data = this._data;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data)) {\n            this._data = convertObjectDataToArray(data);\n        } else if (_data !== data) {\n            if (_data) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u)(_data, this);\n                const meta = this._cachedMeta;\n                clearStacks(meta);\n                meta._parsed = [];\n            }\n            if (data && Object.isExtensible(data)) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l)(data, this);\n            }\n            this._syncList = [];\n            this._data = data;\n        }\n    }\n    addElements() {\n        const meta = this._cachedMeta;\n        this._dataCheck();\n        if (this.datasetElementType) {\n            meta.dataset = new this.datasetElementType();\n        }\n    }\n    buildOrUpdateElements(resetNewElements) {\n        const meta = this._cachedMeta;\n        const dataset = this.getDataset();\n        let stackChanged = false;\n        this._dataCheck();\n        const oldStacked = meta._stacked;\n        meta._stacked = isStacked(meta.vScale, meta);\n        if (meta.stack !== dataset.stack) {\n            stackChanged = true;\n            clearStacks(meta);\n            meta.stack = dataset.stack;\n        }\n        this._resyncElements(resetNewElements);\n        if (stackChanged || oldStacked !== meta._stacked) {\n            updateStacks(this, meta._parsed);\n        }\n    }\n    configure() {\n        const config = this.chart.config;\n        const scopeKeys = config.datasetScopeKeys(this._type);\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n        this.options = config.createResolver(scopes, this.getContext());\n        this._parsing = this.options.parsing;\n        this._cachedDataOpts = {};\n    }\n    parse(start, count) {\n        const { _cachedMeta: meta, _data: data } = this;\n        const { iScale, _stacked } = meta;\n        const iAxis = iScale.axis;\n        let sorted = start === 0 && count === data.length ? true : meta._sorted;\n        let prev = start > 0 && meta._parsed[start - 1];\n        let i, cur, parsed;\n        if (this._parsing === false) {\n            meta._parsed = data;\n            meta._sorted = true;\n            parsed = data;\n        } else {\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(data[start])) {\n                parsed = this.parseArrayData(meta, data, start, count);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                parsed = this.parseObjectData(meta, data, start, count);\n            } else {\n                parsed = this.parsePrimitiveData(meta, data, start, count);\n            }\n            const isNotInOrderComparedToPrev = ()=>cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n            for(i = 0; i < count; ++i){\n                meta._parsed[i + start] = cur = parsed[i];\n                if (sorted) {\n                    if (isNotInOrderComparedToPrev()) {\n                        sorted = false;\n                    }\n                    prev = cur;\n                }\n            }\n            meta._sorted = sorted;\n        }\n        if (_stacked) {\n            updateStacks(this, parsed);\n        }\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const labels = iScale.getLabels();\n        const singleScale = iScale === vScale;\n        const parsed = new Array(count);\n        let i, ilen, index;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            parsed[i] = {\n                [iAxis]: singleScale || iScale.parse(labels[index], index),\n                [vAxis]: vScale.parse(data[index], index)\n            };\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse(item[0], index),\n                y: yScale.parse(item[1], index)\n            };\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const { xScale, yScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const parsed = new Array(count);\n        let i, ilen, index, item;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            index = i + start;\n            item = data[index];\n            parsed[i] = {\n                x: xScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, xAxisKey), index),\n                y: yScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(item, yAxisKey), index)\n            };\n        }\n        return parsed;\n    }\n    getParsed(index) {\n        return this._cachedMeta._parsed[index];\n    }\n    getDataElement(index) {\n        return this._cachedMeta.data[index];\n    }\n    applyStack(scale, parsed, mode) {\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const value = parsed[scale.axis];\n        const stack = {\n            keys: getSortedDatasetIndices(chart, true),\n            values: parsed._stacks[scale.axis]\n        };\n        return applyStack(stack, value, meta.index, {\n            mode\n        });\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        const parsedValue = parsed[scale.axis];\n        let value = parsedValue === null ? NaN : parsedValue;\n        const values = stack && parsed._stacks[scale.axis];\n        if (stack && values) {\n            stack.values = values;\n            value = applyStack(stack, parsedValue, this._cachedMeta.index);\n        }\n        range.min = Math.min(range.min, value);\n        range.max = Math.max(range.max, value);\n    }\n    getMinMax(scale, canStack) {\n        const meta = this._cachedMeta;\n        const _parsed = meta._parsed;\n        const sorted = meta._sorted && scale === meta.iScale;\n        const ilen = _parsed.length;\n        const otherScale = this._getOtherScale(scale);\n        const stack = createStack(canStack, meta, this.chart);\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        const { min: otherMin, max: otherMax } = getUserBounds(otherScale);\n        let i, parsed;\n        function _skip() {\n            parsed = _parsed[i];\n            const otherValue = parsed[otherScale.axis];\n            return !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n        }\n        for(i = 0; i < ilen; ++i){\n            if (_skip()) {\n                continue;\n            }\n            this.updateRangeFromParsed(range, scale, parsed, stack);\n            if (sorted) {\n                break;\n            }\n        }\n        if (sorted) {\n            for(i = ilen - 1; i >= 0; --i){\n                if (_skip()) {\n                    continue;\n                }\n                this.updateRangeFromParsed(range, scale, parsed, stack);\n                break;\n            }\n        }\n        return range;\n    }\n    getAllParsedValues(scale) {\n        const parsed = this._cachedMeta._parsed;\n        const values = [];\n        let i, ilen, value;\n        for(i = 0, ilen = parsed.length; i < ilen; ++i){\n            value = parsed[i][scale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n                values.push(value);\n            }\n        }\n        return values;\n    }\n    getMaxOverflow() {\n        return false;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const vScale = meta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n            value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n        };\n    }\n    _update(mode) {\n        const meta = this._cachedMeta;\n        this.update(mode || \"default\");\n        meta._clip = toClip((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n    }\n    update(mode) {}\n    draw() {\n        const ctx = this._ctx;\n        const chart = this.chart;\n        const meta = this._cachedMeta;\n        const elements = meta.data || [];\n        const area = chart.chartArea;\n        const active = [];\n        const start = this._drawStart || 0;\n        const count = this._drawCount || elements.length - start;\n        const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n        let i;\n        if (meta.dataset) {\n            meta.dataset.draw(ctx, area, start, count);\n        }\n        for(i = start; i < start + count; ++i){\n            const element = elements[i];\n            if (element.hidden) {\n                continue;\n            }\n            if (element.active && drawActiveElementsOnTop) {\n                active.push(element);\n            } else {\n                element.draw(ctx, area);\n            }\n        }\n        for(i = 0; i < active.length; ++i){\n            active[i].draw(ctx, area);\n        }\n    }\n    getStyle(index, active) {\n        const mode = active ? \"active\" : \"default\";\n        return index === undefined && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);\n    }\n    getContext(index, active, mode) {\n        const dataset = this.getDataset();\n        let context;\n        if (index >= 0 && index < this._cachedMeta.data.length) {\n            const element = this._cachedMeta.data[index];\n            context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));\n            context.parsed = this.getParsed(index);\n            context.raw = dataset.data[index];\n            context.index = context.dataIndex = index;\n        } else {\n            context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n            context.dataset = dataset;\n            context.index = context.datasetIndex = this.index;\n        }\n        context.active = !!active;\n        context.mode = mode;\n        return context;\n    }\n    resolveDatasetElementOptions(mode) {\n        return this._resolveElementOptions(this.datasetElementType.id, mode);\n    }\n    resolveDataElementOptions(index, mode) {\n        return this._resolveElementOptions(this.dataElementType.id, mode, index);\n    }\n    _resolveElementOptions(elementType, mode = \"default\", index) {\n        const active = mode === \"active\";\n        const cache = this._cachedDataOpts;\n        const cacheKey = elementType + \"-\" + mode;\n        const cached = cache[cacheKey];\n        const sharing = this.enableOptionSharing && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(index);\n        if (cached) {\n            return cloneIfNotShared(cached, sharing);\n        }\n        const config = this.chart.config;\n        const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n        const prefixes = active ? [\n            `${elementType}Hover`,\n            \"hover\",\n            elementType,\n            \"\"\n        ] : [\n            elementType,\n            \"\"\n        ];\n        const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n        const names = Object.keys(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.elements[elementType]);\n        const context = ()=>this.getContext(index, active);\n        const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n        if (values.$shared) {\n            values.$shared = sharing;\n            cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n        }\n        return values;\n    }\n    _resolveAnimations(index, transition, active) {\n        const chart = this.chart;\n        const cache = this._cachedDataOpts;\n        const cacheKey = `animation-${transition}`;\n        const cached = cache[cacheKey];\n        if (cached) {\n            return cached;\n        }\n        let options;\n        if (chart.options.animation !== false) {\n            const config = this.chart.config;\n            const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n            options = config.createResolver(scopes, this.getContext(index, active, transition));\n        }\n        const animations = new Animations(chart, options && options.animations);\n        if (options && options._cacheable) {\n            cache[cacheKey] = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getSharedOptions(options) {\n        if (!options.$shared) {\n            return;\n        }\n        return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n    }\n    includeOptions(mode, sharedOptions) {\n        return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n    }\n    _getSharedOptions(start, mode) {\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const previouslySharedOptions = this._sharedOptions;\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n        return {\n            sharedOptions,\n            includeOptions\n        };\n    }\n    updateElement(element, index, properties, mode) {\n        if (isDirectUpdateMode(mode)) {\n            Object.assign(element, properties);\n        } else {\n            this._resolveAnimations(index, mode).update(element, properties);\n        }\n    }\n    updateSharedOptions(sharedOptions, mode, newOptions) {\n        if (sharedOptions && !isDirectUpdateMode(mode)) {\n            this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n        }\n    }\n    _setStyle(element, index, mode, active) {\n        element.active = active;\n        const options = this.getStyle(index, active);\n        this._resolveAnimations(index, mode, active).update(element, {\n            options: !active && this.getSharedOptions(options) || options\n        });\n    }\n    removeHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", false);\n    }\n    setHoverStyle(element, datasetIndex, index) {\n        this._setStyle(element, index, \"active\", true);\n    }\n    _removeDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", false);\n        }\n    }\n    _setDatasetHoverStyle() {\n        const element = this._cachedMeta.dataset;\n        if (element) {\n            this._setStyle(element, undefined, \"active\", true);\n        }\n    }\n    _resyncElements(resetNewElements) {\n        const data = this._data;\n        const elements = this._cachedMeta.data;\n        for (const [method, arg1, arg2] of this._syncList){\n            this[method](arg1, arg2);\n        }\n        this._syncList = [];\n        const numMeta = elements.length;\n        const numData = data.length;\n        const count = Math.min(numData, numMeta);\n        if (count) {\n            this.parse(0, count);\n        }\n        if (numData > numMeta) {\n            this._insertElements(numMeta, numData - numMeta, resetNewElements);\n        } else if (numData < numMeta) {\n            this._removeElements(numData, numMeta - numData);\n        }\n    }\n    _insertElements(start, count, resetNewElements = true) {\n        const meta = this._cachedMeta;\n        const data = meta.data;\n        const end = start + count;\n        let i;\n        const move = (arr)=>{\n            arr.length += count;\n            for(i = arr.length - 1; i >= end; i--){\n                arr[i] = arr[i - count];\n            }\n        };\n        move(data);\n        for(i = start; i < end; ++i){\n            data[i] = new this.dataElementType();\n        }\n        if (this._parsing) {\n            move(meta._parsed);\n        }\n        this.parse(start, count);\n        if (resetNewElements) {\n            this.updateElements(data, start, count, \"reset\");\n        }\n    }\n    updateElements(element, start, count, mode) {}\n    _removeElements(start, count) {\n        const meta = this._cachedMeta;\n        if (this._parsing) {\n            const removed = meta._parsed.splice(start, count);\n            if (meta._stacked) {\n                clearStacks(meta, removed);\n            }\n        }\n        meta.data.splice(start, count);\n    }\n    _sync(args) {\n        if (this._parsing) {\n            this._syncList.push(args);\n        } else {\n            const [method, arg1, arg2] = args;\n            this[method](arg1, arg2);\n        }\n        this.chart._dataChanges.push([\n            this.index,\n            ...args\n        ]);\n    }\n    _onDataPush() {\n        const count = arguments.length;\n        this._sync([\n            \"_insertElements\",\n            this.getDataset().data.length - count,\n            count\n        ]);\n    }\n    _onDataPop() {\n        this._sync([\n            \"_removeElements\",\n            this._cachedMeta.data.length - 1,\n            1\n        ]);\n    }\n    _onDataShift() {\n        this._sync([\n            \"_removeElements\",\n            0,\n            1\n        ]);\n    }\n    _onDataSplice(start, count) {\n        if (count) {\n            this._sync([\n                \"_removeElements\",\n                start,\n                count\n            ]);\n        }\n        const newCount = arguments.length - 2;\n        if (newCount) {\n            this._sync([\n                \"_insertElements\",\n                start,\n                newCount\n            ]);\n        }\n    }\n    _onDataUnshift() {\n        this._sync([\n            \"_insertElements\",\n            0,\n            arguments.length\n        ]);\n    }\n}\nDatasetController.defaults = {};\nDatasetController.prototype.datasetElementType = null;\nDatasetController.prototype.dataElementType = null;\nfunction getAllScaleValues(scale, type) {\n    if (!scale._cache.$bar) {\n        const visibleMetas = scale.getMatchingVisibleMetas(type);\n        let values = [];\n        for(let i = 0, ilen = visibleMetas.length; i < ilen; i++){\n            values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n        }\n        scale._cache.$bar = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort((a, b)=>a - b));\n    }\n    return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n    const scale = meta.iScale;\n    const values = getAllScaleValues(scale, meta.type);\n    let min = scale._length;\n    let i, ilen, curr, prev;\n    const updateMinAndPrev = ()=>{\n        if (curr === 32767 || curr === -32768) {\n            return;\n        }\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(prev)) {\n            min = Math.min(min, Math.abs(curr - prev) || min);\n        }\n        prev = curr;\n    };\n    for(i = 0, ilen = values.length; i < ilen; ++i){\n        curr = scale.getPixelForValue(values[i]);\n        updateMinAndPrev();\n    }\n    prev = undefined;\n    for(i = 0, ilen = scale.ticks.length; i < ilen; ++i){\n        curr = scale.getPixelForTick(i);\n        updateMinAndPrev();\n    }\n    return min;\n}\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n    const thickness = options.barThickness;\n    let size, ratio;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(thickness)) {\n        size = ruler.min * options.categoryPercentage;\n        ratio = options.barPercentage;\n    } else {\n        size = thickness * stackCount;\n        ratio = 1;\n    }\n    return {\n        chunk: size / stackCount,\n        ratio,\n        start: ruler.pixels[index] - size / 2\n    };\n}\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n    const pixels = ruler.pixels;\n    const curr = pixels[index];\n    let prev = index > 0 ? pixels[index - 1] : null;\n    let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n    const percent = options.categoryPercentage;\n    if (prev === null) {\n        prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n    }\n    if (next === null) {\n        next = curr + curr - prev;\n    }\n    const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n    const size = Math.abs(next - prev) / 2 * percent;\n    return {\n        chunk: size / stackCount,\n        ratio: options.barPercentage,\n        start\n    };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n    const startValue = vScale.parse(entry[0], i);\n    const endValue = vScale.parse(entry[1], i);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    let barStart = min;\n    let barEnd = max;\n    if (Math.abs(min) > Math.abs(max)) {\n        barStart = max;\n        barEnd = min;\n    }\n    item[vScale.axis] = barEnd;\n    item._custom = {\n        barStart,\n        barEnd,\n        start: startValue,\n        end: endValue,\n        min,\n        max\n    };\n}\nfunction parseValue(entry, item, vScale, i) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(entry)) {\n        parseFloatBar(entry, item, vScale, i);\n    } else {\n        item[vScale.axis] = vScale.parse(entry, i);\n    }\n    return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = [];\n    let i, ilen, item, entry;\n    for(i = start, ilen = start + count; i < ilen; ++i){\n        entry = data[i];\n        item = {};\n        item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n        parsed.push(parseValue(entry, item, vScale, i));\n    }\n    return parsed;\n}\nfunction isFloatBar(custom) {\n    return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\nfunction barSign(size, vScale, actualBase) {\n    if (size !== 0) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size);\n    }\n    return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n    let reverse, start, end, top, bottom;\n    if (properties.horizontal) {\n        reverse = properties.base > properties.x;\n        start = \"left\";\n        end = \"right\";\n    } else {\n        reverse = properties.base < properties.y;\n        start = \"bottom\";\n        end = \"top\";\n    }\n    if (reverse) {\n        top = \"end\";\n        bottom = \"start\";\n    } else {\n        top = \"start\";\n        bottom = \"end\";\n    }\n    return {\n        start,\n        end,\n        reverse,\n        top,\n        bottom\n    };\n}\nfunction setBorderSkipped(properties, options, stack, index) {\n    let edge = options.borderSkipped;\n    const res = {};\n    if (!edge) {\n        properties.borderSkipped = res;\n        return;\n    }\n    if (edge === true) {\n        properties.borderSkipped = {\n            top: true,\n            right: true,\n            bottom: true,\n            left: true\n        };\n        return;\n    }\n    const { start, end, reverse, top, bottom } = borderProps(properties);\n    if (edge === \"middle\" && stack) {\n        properties.enableBorderRadius = true;\n        if ((stack._top || 0) === index) {\n            edge = top;\n        } else if ((stack._bottom || 0) === index) {\n            edge = bottom;\n        } else {\n            res[parseEdge(bottom, start, end, reverse)] = true;\n            edge = top;\n        }\n    }\n    res[parseEdge(edge, start, end, reverse)] = true;\n    properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n    if (reverse) {\n        edge = swap(edge, a, b);\n        edge = startEnd(edge, b, a);\n    } else {\n        edge = startEnd(edge, a, b);\n    }\n    return edge;\n}\nfunction swap(orig, v1, v2) {\n    return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n    return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, { inflateAmount }, ratio) {\n    properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nclass BarController extends DatasetController {\n    parsePrimitiveData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseArrayData(meta, data, start, count) {\n        return parseArrayOrPrimitive(meta, data, start, count);\n    }\n    parseObjectData(meta, data, start, count) {\n        const { iScale, vScale } = meta;\n        const { xAxisKey = \"x\", yAxisKey = \"y\" } = this._parsing;\n        const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n        const parsed = [];\n        let i, ilen, item, obj;\n        for(i = start, ilen = start + count; i < ilen; ++i){\n            obj = data[i];\n            item = {};\n            item[iScale.axis] = iScale.parse((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, iAxisKey), i);\n            parsed.push(parseValue((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, vAxisKey), item, vScale, i));\n        }\n        return parsed;\n    }\n    updateRangeFromParsed(range, scale, parsed, stack) {\n        super.updateRangeFromParsed(range, scale, parsed, stack);\n        const custom = parsed._custom;\n        if (custom && scale === this._cachedMeta.vScale) {\n            range.min = Math.min(range.min, custom.min);\n            range.max = Math.max(range.max, custom.max);\n        }\n    }\n    getMaxOverflow() {\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { iScale, vScale } = meta;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n        return {\n            label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n            value\n        };\n    }\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n        const meta = this._cachedMeta;\n        meta.stack = this.getDataset().stack;\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        this.updateElements(meta.data, 0, meta.data.length, mode);\n    }\n    updateElements(bars, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { index, _cachedMeta: { vScale } } = this;\n        const base = vScale.getBasePixel();\n        const horizontal = vScale.isHorizontal();\n        const ruler = this._getRuler();\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        for(let i = start; i < start + count; i++){\n            const parsed = this.getParsed(i);\n            const vpixels = reset || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vScale.axis]) ? {\n                base,\n                head: base\n            } : this._calculateBarValuePixels(i);\n            const ipixels = this._calculateBarIndexPixels(i, ruler);\n            const stack = (parsed._stacks || {})[vScale.axis];\n            const properties = {\n                horizontal,\n                base: vpixels.base,\n                enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,\n                x: horizontal ? vpixels.head : ipixels.center,\n                y: horizontal ? ipixels.center : vpixels.head,\n                height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n                width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n            }\n            const options = properties.options || bars[i].options;\n            setBorderSkipped(properties, options, stack, index);\n            setInflateAmount(properties, options, ruler.ratio);\n            this.updateElement(bars[i], i, properties, mode);\n        }\n    }\n    _getStacks(last, dataIndex) {\n        const { iScale } = this._cachedMeta;\n        const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta)=>meta.controller.options.grouped);\n        const stacked = iScale.options.stacked;\n        const stacks = [];\n        const skipNull = (meta)=>{\n            const parsed = meta.controller.getParsed(dataIndex);\n            const val = parsed && parsed[meta.vScale.axis];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(val) || isNaN(val)) {\n                return true;\n            }\n        };\n        for (const meta of metasets){\n            if (dataIndex !== undefined && skipNull(meta)) {\n                continue;\n            }\n            if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === undefined && meta.stack === undefined) {\n                stacks.push(meta.stack);\n            }\n            if (meta.index === last) {\n                break;\n            }\n        }\n        if (!stacks.length) {\n            stacks.push(undefined);\n        }\n        return stacks;\n    }\n    _getStackCount(index) {\n        return this._getStacks(undefined, index).length;\n    }\n    _getStackIndex(datasetIndex, name, dataIndex) {\n        const stacks = this._getStacks(datasetIndex, dataIndex);\n        const index = name !== undefined ? stacks.indexOf(name) : -1;\n        return index === -1 ? stacks.length - 1 : index;\n    }\n    _getRuler() {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const iScale = meta.iScale;\n        const pixels = [];\n        let i, ilen;\n        for(i = 0, ilen = meta.data.length; i < ilen; ++i){\n            pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n        }\n        const barThickness = opts.barThickness;\n        const min = barThickness || computeMinSampleSize(meta);\n        return {\n            min,\n            pixels,\n            start: iScale._startPixel,\n            end: iScale._endPixel,\n            stackCount: this._getStackCount(),\n            scale: iScale,\n            grouped: opts.grouped,\n            ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n        };\n    }\n    _calculateBarValuePixels(index) {\n        const { _cachedMeta: { vScale, _stacked }, options: { base: baseValue, minBarLength } } = this;\n        const actualBase = baseValue || 0;\n        const parsed = this.getParsed(index);\n        const custom = parsed._custom;\n        const floating = isFloatBar(custom);\n        let value = parsed[vScale.axis];\n        let start = 0;\n        let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n        let head, size;\n        if (length !== value) {\n            start = length - value;\n            length = value;\n        }\n        if (floating) {\n            value = custom.barStart;\n            length = custom.barEnd - custom.barStart;\n            if (value !== 0 && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(value) !== (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(custom.barEnd)) {\n                start = 0;\n            }\n            start += value;\n        }\n        const startValue = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(baseValue) && !floating ? baseValue : start;\n        let base = vScale.getPixelForValue(startValue);\n        if (this.chart.getDataVisibility(index)) {\n            head = vScale.getPixelForValue(start + length);\n        } else {\n            head = base;\n        }\n        size = head - base;\n        if (Math.abs(size) < minBarLength) {\n            size = barSign(size, vScale, actualBase) * minBarLength;\n            if (value === actualBase) {\n                base -= size / 2;\n            }\n            const startPixel = vScale.getPixelForDecimal(0);\n            const endPixel = vScale.getPixelForDecimal(1);\n            const min = Math.min(startPixel, endPixel);\n            const max = Math.max(startPixel, endPixel);\n            base = Math.max(Math.min(base, max), min);\n            head = base + size;\n        }\n        if (base === vScale.getPixelForValue(actualBase)) {\n            const halfGrid = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(size) * vScale.getLineWidthForValue(actualBase) / 2;\n            base += halfGrid;\n            size -= halfGrid;\n        }\n        return {\n            size,\n            base,\n            head,\n            center: head + size / 2\n        };\n    }\n    _calculateBarIndexPixels(index, ruler) {\n        const scale = ruler.scale;\n        const options = this.options;\n        const skipNull = options.skipNull;\n        const maxBarThickness = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.maxBarThickness, Infinity);\n        let center, size;\n        if (ruler.grouped) {\n            const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n            const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);\n            const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n            center = range.start + range.chunk * stackIndex + range.chunk / 2;\n            size = Math.min(maxBarThickness, range.chunk * range.ratio);\n        } else {\n            center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n            size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n        }\n        return {\n            base: center - size / 2,\n            head: center + size / 2,\n            center,\n            size\n        };\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        const vScale = meta.vScale;\n        const rects = meta.data;\n        const ilen = rects.length;\n        let i = 0;\n        for(; i < ilen; ++i){\n            if (this.getParsed(i)[vScale.axis] !== null) {\n                rects[i].draw(this._ctx);\n            }\n        }\n    }\n}\nBarController.id = \"bar\";\nBarController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"base\",\n                \"width\",\n                \"height\"\n            ]\n        }\n    }\n};\nBarController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\",\n            offset: true,\n            grid: {\n                offset: true\n            }\n        },\n        _value_: {\n            type: \"linear\",\n            beginAtZero: true\n        }\n    }\n};\nclass BubbleController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        super.initialize();\n    }\n    parsePrimitiveData(meta, data, start, count) {\n        const parsed = super.parsePrimitiveData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n        }\n        return parsed;\n    }\n    parseArrayData(meta, data, start, count) {\n        const parsed = super.parseArrayData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item[2], this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    parseObjectData(meta, data, start, count) {\n        const parsed = super.parseObjectData(meta, data, start, count);\n        for(let i = 0; i < parsed.length; i++){\n            const item = data[start + i];\n            parsed[i]._custom = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n        }\n        return parsed;\n    }\n    getMaxOverflow() {\n        const data = this._cachedMeta.data;\n        let max = 0;\n        for(let i = data.length - 1; i >= 0; --i){\n            max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n        }\n        return max > 0 && max;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const { xScale, yScale } = meta;\n        const parsed = this.getParsed(index);\n        const x = xScale.getLabelForValue(parsed.x);\n        const y = yScale.getLabelForValue(parsed.y);\n        const r = parsed._custom;\n        return {\n            label: meta.label,\n            value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n        };\n    }\n    update(mode) {\n        const points = this._cachedMeta.data;\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const parsed = !reset && this.getParsed(i);\n            const properties = {};\n            const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n            const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel);\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n                if (reset) {\n                    properties.options.radius = 0;\n                }\n            }\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n    resolveDataElementOptions(index, mode) {\n        const parsed = this.getParsed(index);\n        let values = super.resolveDataElementOptions(index, mode);\n        if (values.$shared) {\n            values = Object.assign({}, values, {\n                $shared: false\n            });\n        }\n        const radius = values.radius;\n        if (mode !== \"active\") {\n            values.radius = 0;\n        }\n        values.radius += (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(parsed && parsed._custom, radius);\n        return values;\n    }\n}\nBubbleController.id = \"bubble\";\nBubbleController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"borderWidth\",\n                \"radius\"\n            ]\n        }\n    }\n};\nBubbleController.overrides = {\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                }\n            }\n        }\n    }\n};\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n    let ratioX = 1;\n    let ratioY = 1;\n    let offsetX = 0;\n    let offsetY = 0;\n    if (circumference < _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) {\n        const startAngle = rotation;\n        const endAngle = startAngle + circumference;\n        const startX = Math.cos(startAngle);\n        const startY = Math.sin(startAngle);\n        const endX = Math.cos(endAngle);\n        const endY = Math.sin(endAngle);\n        const calcMax = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n        const calcMin = (angle, a, b)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n        const maxX = calcMax(0, startX, endX);\n        const maxY = calcMax(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        const minX = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P, startX, endX);\n        const minY = calcMin(_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startY, endY);\n        ratioX = (maxX - minX) / 2;\n        ratioY = (maxY - minY) / 2;\n        offsetX = -(maxX + minX) / 2;\n        offsetY = -(maxY + minY) / 2;\n    }\n    return {\n        ratioX,\n        ratioY,\n        offsetX,\n        offsetY\n    };\n}\nclass DoughnutController extends DatasetController {\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.enableOptionSharing = true;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.offsetX = undefined;\n        this.offsetY = undefined;\n    }\n    linkScales() {}\n    parse(start, count) {\n        const data = this.getDataset().data;\n        const meta = this._cachedMeta;\n        if (this._parsing === false) {\n            meta._parsed = data;\n        } else {\n            let getter = (i)=>+data[i];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(data[start])) {\n                const { key = \"value\" } = this._parsing;\n                getter = (i)=>+(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(data[i], key);\n            }\n            let i, ilen;\n            for(i = start, ilen = start + count; i < ilen; ++i){\n                meta._parsed[i] = getter(i);\n            }\n        }\n    }\n    _getRotation() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.rotation - 90);\n    }\n    _getCircumference() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.circumference);\n    }\n    _getRotationExtents() {\n        let min = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        let max = -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n        for(let i = 0; i < this.chart.data.datasets.length; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                const controller = this.chart.getDatasetMeta(i).controller;\n                const rotation = controller._getRotation();\n                const circumference = controller._getCircumference();\n                min = Math.min(min, rotation);\n                max = Math.max(max, rotation + circumference);\n            }\n        }\n        return {\n            rotation: min,\n            circumference: max - min\n        };\n    }\n    update(mode) {\n        const chart = this.chart;\n        const { chartArea } = chart;\n        const meta = this._cachedMeta;\n        const arcs = meta.data;\n        const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n        const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n        const cutout = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m)(this.options.cutout, maxSize), 1);\n        const chartWeight = this._getRingWeight(this.index);\n        const { circumference, rotation } = this._getRotationExtents();\n        const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(rotation, circumference, cutout);\n        const maxWidth = (chartArea.width - spacing) / ratioX;\n        const maxHeight = (chartArea.height - spacing) / ratioY;\n        const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n        const outerRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n)(this.options.radius, maxRadius);\n        const innerRadius = Math.max(outerRadius * cutout, 0);\n        const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n        this.offsetX = offsetX * outerRadius;\n        this.offsetY = offsetY * outerRadius;\n        meta.total = this.calculateTotal();\n        this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n        this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    _circumference(i, reset) {\n        const opts = this.options;\n        const meta = this._cachedMeta;\n        const circumference = this._getCircumference();\n        if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n            return 0;\n        }\n        return this.calculateCircumference(meta._parsed[i] * circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const centerX = (chartArea.left + chartArea.right) / 2;\n        const centerY = (chartArea.top + chartArea.bottom) / 2;\n        const animateScale = reset && animationOpts.animateScale;\n        const innerRadius = animateScale ? 0 : this.innerRadius;\n        const outerRadius = animateScale ? 0 : this.outerRadius;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        let startAngle = this._getRotation();\n        let i;\n        for(i = 0; i < start; ++i){\n            startAngle += this._circumference(i, reset);\n        }\n        for(i = start; i < start + count; ++i){\n            const circumference = this._circumference(i, reset);\n            const arc = arcs[i];\n            const properties = {\n                x: centerX + this.offsetX,\n                y: centerY + this.offsetY,\n                startAngle,\n                endAngle: startAngle + circumference,\n                circumference,\n                outerRadius,\n                innerRadius\n            };\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n            }\n            startAngle += circumference;\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    calculateTotal() {\n        const meta = this._cachedMeta;\n        const metaData = meta.data;\n        let total = 0;\n        let i;\n        for(i = 0; i < metaData.length; i++){\n            const value = meta._parsed[i];\n            if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n                total += Math.abs(value);\n            }\n        }\n        return total;\n    }\n    calculateCircumference(value) {\n        const total = this._cachedMeta.total;\n        if (total > 0 && !isNaN(value)) {\n            return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T * (Math.abs(value) / total);\n        }\n        return 0;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index], chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    getMaxBorderWidth(arcs) {\n        let max = 0;\n        const chart = this.chart;\n        let i, ilen, meta, controller, options;\n        if (!arcs) {\n            for(i = 0, ilen = chart.data.datasets.length; i < ilen; ++i){\n                if (chart.isDatasetVisible(i)) {\n                    meta = chart.getDatasetMeta(i);\n                    arcs = meta.data;\n                    controller = meta.controller;\n                    break;\n                }\n            }\n        }\n        if (!arcs) {\n            return 0;\n        }\n        for(i = 0, ilen = arcs.length; i < ilen; ++i){\n            options = controller.resolveDataElementOptions(i);\n            if (options.borderAlign !== \"inner\") {\n                max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n            }\n        }\n        return max;\n    }\n    getMaxOffset(arcs) {\n        let max = 0;\n        for(let i = 0, ilen = arcs.length; i < ilen; ++i){\n            const options = this.resolveDataElementOptions(i);\n            max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n        }\n        return max;\n    }\n    _getRingWeightOffset(datasetIndex) {\n        let ringWeightOffset = 0;\n        for(let i = 0; i < datasetIndex; ++i){\n            if (this.chart.isDatasetVisible(i)) {\n                ringWeightOffset += this._getRingWeight(i);\n            }\n        }\n        return ringWeightOffset;\n    }\n    _getRingWeight(datasetIndex) {\n        return Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n    }\n    _getVisibleDatasetWeightTotal() {\n        return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n    }\n}\nDoughnutController.id = \"doughnut\";\nDoughnutController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: false\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"circumference\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\",\n                \"startAngle\",\n                \"x\",\n                \"y\",\n                \"offset\",\n                \"borderWidth\",\n                \"spacing\"\n            ]\n        }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n};\nDoughnutController.descriptors = {\n    _scriptable: (name)=>name !== \"spacing\",\n    _indexable: (name)=>name !== \"spacing\"\n};\nDoughnutController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (tooltipItem) {\n                    let dataLabel = tooltipItem.label;\n                    const value = \": \" + tooltipItem.formattedValue;\n                    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(dataLabel)) {\n                        dataLabel = dataLabel.slice();\n                        dataLabel[0] += value;\n                    } else {\n                        dataLabel += value;\n                    }\n                    return dataLabel;\n                }\n            }\n        }\n    }\n};\nclass LineController extends DatasetController {\n    initialize() {\n        this.enableOptionSharing = true;\n        this.supportsDecimation = true;\n        super.initialize();\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { dataset: line, data: points = [], _dataset } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        line._chart = this.chart;\n        line._datasetIndex = this.index;\n        line._decimated = !!_dataset._decimated;\n        line.points = points;\n        const options = this.resolveDatasetElementOptions(mode);\n        if (!this.options.showLine) {\n            options.borderWidth = 0;\n        }\n        options.segment = this.options.segment;\n        this.updateElement(line, undefined, {\n            animated: !animationsDisabled,\n            options\n        }, mode);\n        this.updateElements(points, start, count, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const { sharedOptions, includeOptions } = this._getSharedOptions(start, mode);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        const data = meta.data || [];\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n    draw() {\n        const meta = this._cachedMeta;\n        meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n        super.draw();\n    }\n}\nLineController.id = \"line\";\nLineController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n};\nLineController.overrides = {\n    scales: {\n        _index_: {\n            type: \"category\"\n        },\n        _value_: {\n            type: \"linear\"\n        }\n    }\n};\nclass PolarAreaController extends DatasetController {\n    constructor(chart, datasetIndex){\n        super(chart, datasetIndex);\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n    }\n    getLabelAndValue(index) {\n        const meta = this._cachedMeta;\n        const chart = this.chart;\n        const labels = chart.data.labels || [];\n        const value = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(meta._parsed[index].r, chart.options.locale);\n        return {\n            label: labels[index] || \"\",\n            value\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const arcs = this._cachedMeta.data;\n        this._updateRadius();\n        this.updateElements(arcs, 0, arcs.length, mode);\n    }\n    getMinMax() {\n        const meta = this._cachedMeta;\n        const range = {\n            min: Number.POSITIVE_INFINITY,\n            max: Number.NEGATIVE_INFINITY\n        };\n        meta.data.forEach((element, index)=>{\n            const parsed = this.getParsed(index).r;\n            if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n                if (parsed < range.min) {\n                    range.min = parsed;\n                }\n                if (parsed > range.max) {\n                    range.max = parsed;\n                }\n            }\n        });\n        return range;\n    }\n    _updateRadius() {\n        const chart = this.chart;\n        const chartArea = chart.chartArea;\n        const opts = chart.options;\n        const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n        const outerRadius = Math.max(minSize / 2, 0);\n        const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n        const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n        this.outerRadius = outerRadius - radiusLength * this.index;\n        this.innerRadius = this.outerRadius - radiusLength;\n    }\n    updateElements(arcs, start, count, mode) {\n        const reset = mode === \"reset\";\n        const chart = this.chart;\n        const opts = chart.options;\n        const animationOpts = opts.animation;\n        const scale = this._cachedMeta.rScale;\n        const centerX = scale.xCenter;\n        const centerY = scale.yCenter;\n        const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P;\n        let angle = datasetStartAngle;\n        let i;\n        const defaultAngle = 360 / this.countVisibleElements();\n        for(i = 0; i < start; ++i){\n            angle += this._computeAngle(i, mode, defaultAngle);\n        }\n        for(i = start; i < start + count; i++){\n            const arc = arcs[i];\n            let startAngle = angle;\n            let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n            let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n            angle = endAngle;\n            if (reset) {\n                if (animationOpts.animateScale) {\n                    outerRadius = 0;\n                }\n                if (animationOpts.animateRotate) {\n                    startAngle = endAngle = datasetStartAngle;\n                }\n            }\n            const properties = {\n                x: centerX,\n                y: centerY,\n                innerRadius: 0,\n                outerRadius,\n                startAngle,\n                endAngle,\n                options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n            };\n            this.updateElement(arc, i, properties, mode);\n        }\n    }\n    countVisibleElements() {\n        const meta = this._cachedMeta;\n        let count = 0;\n        meta.data.forEach((element, index)=>{\n            if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n                count++;\n            }\n        });\n        return count;\n    }\n    _computeAngle(index, mode, defaultAngle) {\n        return this.chart.getDataVisibility(index) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;\n    }\n}\nPolarAreaController.id = \"polarArea\";\nPolarAreaController.defaults = {\n    dataElementType: \"arc\",\n    animation: {\n        animateRotate: true,\n        animateScale: true\n    },\n    animations: {\n        numbers: {\n            type: \"number\",\n            properties: [\n                \"x\",\n                \"y\",\n                \"startAngle\",\n                \"endAngle\",\n                \"innerRadius\",\n                \"outerRadius\"\n            ]\n        }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n};\nPolarAreaController.overrides = {\n    aspectRatio: 1,\n    plugins: {\n        legend: {\n            labels: {\n                generateLabels (chart) {\n                    const data = chart.data;\n                    if (data.labels.length && data.datasets.length) {\n                        const { labels: { pointStyle } } = chart.legend.options;\n                        return data.labels.map((label, i)=>{\n                            const meta = chart.getDatasetMeta(0);\n                            const style = meta.controller.getStyle(i);\n                            return {\n                                text: label,\n                                fillStyle: style.backgroundColor,\n                                strokeStyle: style.borderColor,\n                                lineWidth: style.borderWidth,\n                                pointStyle: pointStyle,\n                                hidden: !chart.getDataVisibility(i),\n                                index: i\n                            };\n                        });\n                    }\n                    return [];\n                }\n            },\n            onClick (e, legendItem, legend) {\n                legend.chart.toggleDataVisibility(legendItem.index);\n                legend.chart.update();\n            }\n        },\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (context) {\n                    return context.chart.data.labels[context.dataIndex] + \": \" + context.formattedValue;\n                }\n            }\n        }\n    },\n    scales: {\n        r: {\n            type: \"radialLinear\",\n            angleLines: {\n                display: false\n            },\n            beginAtZero: true,\n            grid: {\n                circular: true\n            },\n            pointLabels: {\n                display: false\n            },\n            startAngle: 0\n        }\n    }\n};\nclass PieController extends DoughnutController {\n}\nPieController.id = \"pie\";\nPieController.defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n};\nclass RadarController extends DatasetController {\n    getLabelAndValue(index) {\n        const vScale = this._cachedMeta.vScale;\n        const parsed = this.getParsed(index);\n        return {\n            label: vScale.getLabels()[index],\n            value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n        };\n    }\n    parseObjectData(meta, data, start, count) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y.bind(this)(meta, data, start, count);\n    }\n    update(mode) {\n        const meta = this._cachedMeta;\n        const line = meta.dataset;\n        const points = meta.data || [];\n        const labels = meta.iScale.getLabels();\n        line.points = points;\n        if (mode !== \"resize\") {\n            const options = this.resolveDatasetElementOptions(mode);\n            if (!this.options.showLine) {\n                options.borderWidth = 0;\n            }\n            const properties = {\n                _loop: true,\n                _fullLoop: labels.length === points.length,\n                options\n            };\n            this.updateElement(line, undefined, properties, mode);\n        }\n        this.updateElements(points, 0, points.length, mode);\n    }\n    updateElements(points, start, count, mode) {\n        const scale = this._cachedMeta.rScale;\n        const reset = mode === \"reset\";\n        for(let i = start; i < start + count; i++){\n            const point = points[i];\n            const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n            const x = reset ? scale.xCenter : pointPosition.x;\n            const y = reset ? scale.yCenter : pointPosition.y;\n            const properties = {\n                x,\n                y,\n                angle: pointPosition.angle,\n                skip: isNaN(x) || isNaN(y),\n                options\n            };\n            this.updateElement(point, i, properties, mode);\n        }\n    }\n}\nRadarController.id = \"radar\";\nRadarController.defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n        line: {\n            fill: \"start\"\n        }\n    }\n};\nRadarController.overrides = {\n    aspectRatio: 1,\n    scales: {\n        r: {\n            type: \"radialLinear\"\n        }\n    }\n};\nclass Element {\n    constructor(){\n        this.x = undefined;\n        this.y = undefined;\n        this.active = false;\n        this.options = undefined;\n        this.$animations = undefined;\n    }\n    tooltipPosition(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    hasValue() {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.x) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(this.y);\n    }\n    getProps(props, final) {\n        const anims = this.$animations;\n        if (!final || !anims) {\n            return this;\n        }\n        const ret = {};\n        props.forEach((prop)=>{\n            ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n        });\n        return ret;\n    }\n}\nElement.defaults = {};\nElement.defaultRoutes = undefined;\nconst formatters = {\n    values (value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value) ? value : \"\" + value;\n    },\n    numeric (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const locale = this.chart.options.locale;\n        let notation;\n        let delta = tickValue;\n        if (ticks.length > 1) {\n            const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n            if (maxTick < 1e-4 || maxTick > 1e+15) {\n                notation = \"scientific\";\n            }\n            delta = calculateDelta(tickValue, ticks);\n        }\n        const logDelta = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(Math.abs(delta));\n        const numDecimal = Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n        const options = {\n            notation,\n            minimumFractionDigits: numDecimal,\n            maximumFractionDigits: numDecimal\n        };\n        Object.assign(options, this.options.ticks.format);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(tickValue, locale, options);\n    },\n    logarithmic (tickValue, index, ticks) {\n        if (tickValue === 0) {\n            return \"0\";\n        }\n        const remain = tickValue / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickValue)));\n        if (remain === 1 || remain === 2 || remain === 5) {\n            return formatters.numeric.call(this, tickValue, index, ticks);\n        }\n        return \"\";\n    }\n};\nfunction calculateDelta(tickValue, ticks) {\n    let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n    if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n        delta = tickValue - Math.floor(tickValue);\n    }\n    return delta;\n}\nvar Ticks = {\n    formatters\n};\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"scale\", {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: \"ticks\",\n    grace: 0,\n    grid: {\n        display: true,\n        lineWidth: 1,\n        drawBorder: true,\n        drawOnChartArea: true,\n        drawTicks: true,\n        tickLength: 8,\n        tickWidth: (_ctx, options)=>options.lineWidth,\n        tickColor: (_ctx, options)=>options.color,\n        offset: false,\n        borderDash: [],\n        borderDashOffset: 0.0,\n        borderWidth: 1\n    },\n    title: {\n        display: false,\n        text: \"\",\n        padding: {\n            top: 4,\n            bottom: 4\n        }\n    },\n    ticks: {\n        minRotation: 0,\n        maxRotation: 50,\n        mirror: false,\n        textStrokeWidth: 0,\n        textStrokeColor: \"\",\n        padding: 3,\n        display: true,\n        autoSkip: true,\n        autoSkipPadding: 3,\n        labelOffset: 0,\n        callback: Ticks.formatters.values,\n        minor: {},\n        major: {},\n        align: \"center\",\n        crossAlign: \"near\",\n        showLabelBackdrop: false,\n        backdropColor: \"rgba(255, 255, 255, 0.75)\",\n        backdropPadding: 2\n    }\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.ticks\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.grid\", \"borderColor\", \"\", \"borderColor\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(\"scale.title\", \"color\", \"\", \"color\");\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale\", {\n    _fallback: false,\n    _scriptable: (name)=>!name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"tickBorderDash\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scales\", {\n    _fallback: \"scale\"\n});\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(\"scale.ticks\", {\n    _scriptable: (name)=>name !== \"backdropPadding\" && name !== \"callback\",\n    _indexable: (name)=>name !== \"backdropPadding\"\n});\nfunction autoSkip(scale, ticks) {\n    const tickOpts = scale.options.ticks;\n    const ticksLimit = tickOpts.maxTicksLimit || determineMaxTicks(scale);\n    const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n    const numMajorIndices = majorIndices.length;\n    const first = majorIndices[0];\n    const last = majorIndices[numMajorIndices - 1];\n    const newTicks = [];\n    if (numMajorIndices > ticksLimit) {\n        skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n        return newTicks;\n    }\n    const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n    if (numMajorIndices > 0) {\n        let i, ilen;\n        const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n        skip(ticks, newTicks, spacing, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n        for(i = 0, ilen = numMajorIndices - 1; i < ilen; i++){\n            skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n        }\n        skip(ticks, newTicks, spacing, last, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n        return newTicks;\n    }\n    skip(ticks, newTicks, spacing);\n    return newTicks;\n}\nfunction determineMaxTicks(scale) {\n    const offset = scale.options.offset;\n    const tickLength = scale._tickSize();\n    const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n    const maxChart = scale._maxLength / tickLength;\n    return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n    const evenMajorSpacing = getEvenSpacing(majorIndices);\n    const spacing = ticks.length / ticksLimit;\n    if (!evenMajorSpacing) {\n        return Math.max(spacing, 1);\n    }\n    const factors = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A)(evenMajorSpacing);\n    for(let i = 0, ilen = factors.length - 1; i < ilen; i++){\n        const factor = factors[i];\n        if (factor > spacing) {\n            return factor;\n        }\n    }\n    return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n    const result = [];\n    let i, ilen;\n    for(i = 0, ilen = ticks.length; i < ilen; i++){\n        if (ticks[i].major) {\n            result.push(i);\n        }\n    }\n    return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n    let count = 0;\n    let next = majorIndices[0];\n    let i;\n    spacing = Math.ceil(spacing);\n    for(i = 0; i < ticks.length; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = majorIndices[count * spacing];\n        }\n    }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n    const start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorStart, 0);\n    const end = Math.min((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(majorEnd, ticks.length), ticks.length);\n    let count = 0;\n    let length, i, next;\n    spacing = Math.ceil(spacing);\n    if (majorEnd) {\n        length = majorEnd - majorStart;\n        spacing = length / Math.floor(length / spacing);\n    }\n    next = start;\n    while(next < 0){\n        count++;\n        next = Math.round(start + count * spacing);\n    }\n    for(i = Math.max(start, 0); i < end; i++){\n        if (i === next) {\n            newTicks.push(ticks[i]);\n            count++;\n            next = Math.round(start + count * spacing);\n        }\n    }\n}\nfunction getEvenSpacing(arr) {\n    const len = arr.length;\n    let i, diff;\n    if (len < 2) {\n        return false;\n    }\n    for(diff = arr[0], i = 1; i < len; ++i){\n        if (arr[i] - arr[i - 1] !== diff) {\n            return false;\n        }\n    }\n    return diff;\n}\nconst reverseAlign = (align)=>align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nconst offsetFromEdge = (scale, edge, offset)=>edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nfunction sample(arr, numItems) {\n    const result = [];\n    const increment = arr.length / numItems;\n    const len = arr.length;\n    let i = 0;\n    for(; i < len; i += increment){\n        result.push(arr[Math.floor(i)]);\n    }\n    return result;\n}\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n    const length = scale.ticks.length;\n    const validIndex = Math.min(index, length - 1);\n    const start = scale._startPixel;\n    const end = scale._endPixel;\n    const epsilon = 1e-6;\n    let lineValue = scale.getPixelForTick(validIndex);\n    let offset;\n    if (offsetGridLines) {\n        if (length === 1) {\n            offset = Math.max(lineValue - start, end - lineValue);\n        } else if (index === 0) {\n            offset = (scale.getPixelForTick(1) - lineValue) / 2;\n        } else {\n            offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n        }\n        lineValue += validIndex < index ? offset : -offset;\n        if (lineValue < start - epsilon || lineValue > end + epsilon) {\n            return;\n        }\n    }\n    return lineValue;\n}\nfunction garbageCollect(caches, length) {\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(caches, (cache)=>{\n        const gc = cache.gc;\n        const gcLen = gc.length / 2;\n        let i;\n        if (gcLen > length) {\n            for(i = 0; i < gcLen; ++i){\n                delete cache.data[gc[i]];\n            }\n            gc.splice(0, gcLen);\n        }\n    });\n}\nfunction getTickMarkLength(options) {\n    return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n    if (!options.display) {\n        return 0;\n    }\n    const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.font, fallback);\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    const lines = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(options.text) ? options.text.length : 1;\n    return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        scale,\n        type: \"scale\"\n    });\n}\nfunction createTickContext(parent, index, tick) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tick,\n        index,\n        type: \"tick\"\n    });\n}\nfunction titleAlign(align, position, reverse) {\n    let ret = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(align);\n    if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n        ret = reverseAlign(ret);\n    }\n    return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n    const { top, left, bottom, right, chart } = scale;\n    const { chartArea, scales } = chart;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    const height = bottom - top;\n    const width = right - left;\n    if (scale.isHorizontal()) {\n        titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n        } else if (position === \"center\") {\n            titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n        } else {\n            titleY = offsetFromEdge(scale, position, offset);\n        }\n        maxWidth = right - left;\n    } else {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            const positionAxisID = Object.keys(position)[0];\n            const value = position[positionAxisID];\n            titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n        } else if (position === \"center\") {\n            titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n        } else {\n            titleX = offsetFromEdge(scale, position, offset);\n        }\n        titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n        rotation = position === \"left\" ? -_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H;\n    }\n    return {\n        titleX,\n        titleY,\n        maxWidth,\n        rotation\n    };\n}\nclass Scale extends Element {\n    constructor(cfg){\n        super();\n        this.id = cfg.id;\n        this.type = cfg.type;\n        this.options = undefined;\n        this.ctx = cfg.ctx;\n        this.chart = cfg.chart;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this._margins = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        };\n        this.maxWidth = undefined;\n        this.maxHeight = undefined;\n        this.paddingTop = undefined;\n        this.paddingBottom = undefined;\n        this.paddingLeft = undefined;\n        this.paddingRight = undefined;\n        this.axis = undefined;\n        this.labelRotation = undefined;\n        this.min = undefined;\n        this.max = undefined;\n        this._range = undefined;\n        this.ticks = [];\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this._labelSizes = null;\n        this._length = 0;\n        this._maxLength = 0;\n        this._longestTextCache = {};\n        this._startPixel = undefined;\n        this._endPixel = undefined;\n        this._reversePixels = false;\n        this._userMax = undefined;\n        this._userMin = undefined;\n        this._suggestedMax = undefined;\n        this._suggestedMin = undefined;\n        this._ticksLength = 0;\n        this._borderValue = 0;\n        this._cache = {};\n        this._dataLimitsCached = false;\n        this.$context = undefined;\n    }\n    init(options) {\n        this.options = options.setContext(this.getContext());\n        this.axis = options.axis;\n        this._userMin = this.parse(options.min);\n        this._userMax = this.parse(options.max);\n        this._suggestedMin = this.parse(options.suggestedMin);\n        this._suggestedMax = this.parse(options.suggestedMax);\n    }\n    parse(raw, index) {\n        return raw;\n    }\n    getUserBounds() {\n        let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;\n        _userMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, Number.POSITIVE_INFINITY);\n        _userMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, Number.NEGATIVE_INFINITY);\n        _suggestedMin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMin, Number.POSITIVE_INFINITY);\n        _suggestedMax = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_suggestedMax, Number.NEGATIVE_INFINITY);\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMin, _suggestedMin),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(_userMax, _suggestedMax),\n            minDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMin),\n            maxDefined: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(_userMax)\n        };\n    }\n    getMinMax(canStack) {\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        let range;\n        if (minDefined && maxDefined) {\n            return {\n                min,\n                max\n            };\n        }\n        const metas = this.getMatchingVisibleMetas();\n        for(let i = 0, ilen = metas.length; i < ilen; ++i){\n            range = metas[i].controller.getMinMax(this, canStack);\n            if (!minDefined) {\n                min = Math.min(min, range.min);\n            }\n            if (!maxDefined) {\n                max = Math.max(max, range.max);\n            }\n        }\n        min = maxDefined && min > max ? max : min;\n        max = minDefined && min > max ? min : max;\n        return {\n            min: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, min)),\n            max: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(max, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(min, max))\n        };\n    }\n    getPadding() {\n        return {\n            left: this.paddingLeft || 0,\n            top: this.paddingTop || 0,\n            right: this.paddingRight || 0,\n            bottom: this.paddingBottom || 0\n        };\n    }\n    getTicks() {\n        return this.ticks;\n    }\n    getLabels() {\n        const data = this.chart.data;\n        return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n    }\n    beforeLayout() {\n        this._cache = {};\n        this._dataLimitsCached = false;\n    }\n    beforeUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeUpdate, [\n            this\n        ]);\n    }\n    update(maxWidth, maxHeight, margins) {\n        const { beginAtZero, grace, ticks: tickOpts } = this.options;\n        const sampleSize = tickOpts.sampleSize;\n        this.beforeUpdate();\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins = Object.assign({\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n        }, margins);\n        this.ticks = null;\n        this._labelSizes = null;\n        this._gridLineItems = null;\n        this._labelItems = null;\n        this.beforeSetDimensions();\n        this.setDimensions();\n        this.afterSetDimensions();\n        this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n        if (!this._dataLimitsCached) {\n            this.beforeDataLimits();\n            this.determineDataLimits();\n            this.afterDataLimits();\n            this._range = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D)(this, grace, beginAtZero);\n            this._dataLimitsCached = true;\n        }\n        this.beforeBuildTicks();\n        this.ticks = this.buildTicks() || [];\n        this.afterBuildTicks();\n        const samplingEnabled = sampleSize < this.ticks.length;\n        this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n        this.configure();\n        this.beforeCalculateLabelRotation();\n        this.calculateLabelRotation();\n        this.afterCalculateLabelRotation();\n        if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n            this.ticks = autoSkip(this, this.ticks);\n            this._labelSizes = null;\n            this.afterAutoSkip();\n        }\n        if (samplingEnabled) {\n            this._convertTicksToLabels(this.ticks);\n        }\n        this.beforeFit();\n        this.fit();\n        this.afterFit();\n        this.afterUpdate();\n    }\n    configure() {\n        let reversePixels = this.options.reverse;\n        let startPixel, endPixel;\n        if (this.isHorizontal()) {\n            startPixel = this.left;\n            endPixel = this.right;\n        } else {\n            startPixel = this.top;\n            endPixel = this.bottom;\n            reversePixels = !reversePixels;\n        }\n        this._startPixel = startPixel;\n        this._endPixel = endPixel;\n        this._reversePixels = reversePixels;\n        this._length = endPixel - startPixel;\n        this._alignToPixels = this.options.alignToPixels;\n    }\n    afterUpdate() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterUpdate, [\n            this\n        ]);\n    }\n    beforeSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeSetDimensions, [\n            this\n        ]);\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = 0;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = 0;\n            this.bottom = this.height;\n        }\n        this.paddingLeft = 0;\n        this.paddingTop = 0;\n        this.paddingRight = 0;\n        this.paddingBottom = 0;\n    }\n    afterSetDimensions() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterSetDimensions, [\n            this\n        ]);\n    }\n    _callHooks(name) {\n        this.chart.notifyPlugins(name, this.getContext());\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options[name], [\n            this\n        ]);\n    }\n    beforeDataLimits() {\n        this._callHooks(\"beforeDataLimits\");\n    }\n    determineDataLimits() {}\n    afterDataLimits() {\n        this._callHooks(\"afterDataLimits\");\n    }\n    beforeBuildTicks() {\n        this._callHooks(\"beforeBuildTicks\");\n    }\n    buildTicks() {\n        return [];\n    }\n    afterBuildTicks() {\n        this._callHooks(\"afterBuildTicks\");\n    }\n    beforeTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeTickToLabelConversion, [\n            this\n        ]);\n    }\n    generateTickLabels(ticks) {\n        const tickOpts = this.options.ticks;\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            tick = ticks[i];\n            tick.label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(tickOpts.callback, [\n                tick.value,\n                i,\n                ticks\n            ], this);\n        }\n    }\n    afterTickToLabelConversion() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterTickToLabelConversion, [\n            this\n        ]);\n    }\n    beforeCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeCalculateLabelRotation, [\n            this\n        ]);\n    }\n    calculateLabelRotation() {\n        const options = this.options;\n        const tickOpts = options.ticks;\n        const numTicks = this.ticks.length;\n        const minRotation = tickOpts.minRotation || 0;\n        const maxRotation = tickOpts.maxRotation;\n        let labelRotation = minRotation;\n        let tickWidth, maxHeight, maxLabelDiagonal;\n        if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n            this.labelRotation = minRotation;\n            return;\n        }\n        const labelSizes = this._getLabelSizes();\n        const maxLabelWidth = labelSizes.widest.width;\n        const maxLabelHeight = labelSizes.highest.height;\n        const maxWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n        tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n        if (maxLabelWidth + 6 > tickWidth) {\n            tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n            maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n            maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n            labelRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(Math.min(Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n            labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n        }\n        this.labelRotation = labelRotation;\n    }\n    afterCalculateLabelRotation() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterCalculateLabelRotation, [\n            this\n        ]);\n    }\n    afterAutoSkip() {}\n    beforeFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.beforeFit, [\n            this\n        ]);\n    }\n    fit() {\n        const minSize = {\n            width: 0,\n            height: 0\n        };\n        const { chart, options: { ticks: tickOpts, title: titleOpts, grid: gridOpts } } = this;\n        const display = this._isVisible();\n        const isHorizontal = this.isHorizontal();\n        if (display) {\n            const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n            if (isHorizontal) {\n                minSize.width = this.maxWidth;\n                minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n            } else {\n                minSize.height = this.maxHeight;\n                minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n            }\n            if (tickOpts.display && this.ticks.length) {\n                const { first, last, widest, highest } = this._getLabelSizes();\n                const tickPadding = tickOpts.padding * 2;\n                const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n                const cos = Math.cos(angleRadians);\n                const sin = Math.sin(angleRadians);\n                if (isHorizontal) {\n                    const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n                    minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n                } else {\n                    const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n                    minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n                }\n                this._calculatePadding(first, last, sin, cos);\n            }\n        }\n        this._handleMargins();\n        if (isHorizontal) {\n            this.width = this._length = chart.width - this._margins.left - this._margins.right;\n            this.height = minSize.height;\n        } else {\n            this.width = minSize.width;\n            this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n        }\n    }\n    _calculatePadding(first, last, sin, cos) {\n        const { ticks: { align, padding }, position } = this.options;\n        const isRotated = this.labelRotation !== 0;\n        const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n        if (this.isHorizontal()) {\n            const offsetLeft = this.getPixelForTick(0) - this.left;\n            const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n            let paddingLeft = 0;\n            let paddingRight = 0;\n            if (isRotated) {\n                if (labelsBelowTicks) {\n                    paddingLeft = cos * first.width;\n                    paddingRight = sin * last.height;\n                } else {\n                    paddingLeft = sin * first.height;\n                    paddingRight = cos * last.width;\n                }\n            } else if (align === \"start\") {\n                paddingRight = last.width;\n            } else if (align === \"end\") {\n                paddingLeft = first.width;\n            } else if (align !== \"inner\") {\n                paddingLeft = first.width / 2;\n                paddingRight = last.width / 2;\n            }\n            this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n            this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n        } else {\n            let paddingTop = last.height / 2;\n            let paddingBottom = first.height / 2;\n            if (align === \"start\") {\n                paddingTop = 0;\n                paddingBottom = first.height;\n            } else if (align === \"end\") {\n                paddingTop = last.height;\n                paddingBottom = 0;\n            }\n            this.paddingTop = paddingTop + padding;\n            this.paddingBottom = paddingBottom + padding;\n        }\n    }\n    _handleMargins() {\n        if (this._margins) {\n            this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n            this._margins.top = Math.max(this.paddingTop, this._margins.top);\n            this._margins.right = Math.max(this.paddingRight, this._margins.right);\n            this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n        }\n    }\n    afterFit() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.afterFit, [\n            this\n        ]);\n    }\n    isHorizontal() {\n        const { axis, position } = this.options;\n        return position === \"top\" || position === \"bottom\" || axis === \"x\";\n    }\n    isFullSize() {\n        return this.options.fullSize;\n    }\n    _convertTicksToLabels(ticks) {\n        this.beforeTickToLabelConversion();\n        this.generateTickLabels(ticks);\n        let i, ilen;\n        for(i = 0, ilen = ticks.length; i < ilen; i++){\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(ticks[i].label)) {\n                ticks.splice(i, 1);\n                ilen--;\n                i--;\n            }\n        }\n        this.afterTickToLabelConversion();\n    }\n    _getLabelSizes() {\n        let labelSizes = this._labelSizes;\n        if (!labelSizes) {\n            const sampleSize = this.options.ticks.sampleSize;\n            let ticks = this.ticks;\n            if (sampleSize < ticks.length) {\n                ticks = sample(ticks, sampleSize);\n            }\n            this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length);\n        }\n        return labelSizes;\n    }\n    _computeLabelSizes(ticks, length) {\n        const { ctx, _longestTextCache: caches } = this;\n        const widths = [];\n        const heights = [];\n        let widestLabelSize = 0;\n        let highestLabelSize = 0;\n        let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n        for(i = 0; i < length; ++i){\n            label = ticks[i].label;\n            tickFont = this._resolveTickFontOptions(i);\n            ctx.font = fontString = tickFont.string;\n            cache = caches[fontString] = caches[fontString] || {\n                data: {},\n                gc: []\n            };\n            lineHeight = tickFont.lineHeight;\n            width = height = 0;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(label) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, label);\n                height = lineHeight;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label)) {\n                for(j = 0, jlen = label.length; j < jlen; ++j){\n                    nestedLabel = label[j];\n                    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(nestedLabel) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(nestedLabel)) {\n                        width = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G)(ctx, cache.data, cache.gc, width, nestedLabel);\n                        height += lineHeight;\n                    }\n                }\n            }\n            widths.push(width);\n            heights.push(height);\n            widestLabelSize = Math.max(width, widestLabelSize);\n            highestLabelSize = Math.max(height, highestLabelSize);\n        }\n        garbageCollect(caches, length);\n        const widest = widths.indexOf(widestLabelSize);\n        const highest = heights.indexOf(highestLabelSize);\n        const valueAt = (idx)=>({\n                width: widths[idx] || 0,\n                height: heights[idx] || 0\n            });\n        return {\n            first: valueAt(0),\n            last: valueAt(length - 1),\n            widest: valueAt(widest),\n            highest: valueAt(highest),\n            widths,\n            heights\n        };\n    }\n    getLabelForValue(value) {\n        return value;\n    }\n    getPixelForValue(value, index) {\n        return NaN;\n    }\n    getValueForPixel(pixel) {}\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getPixelForDecimal(decimal) {\n        if (this._reversePixels) {\n            decimal = 1 - decimal;\n        }\n        const pixel = this._startPixel + decimal * this._length;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I)(this._alignToPixels ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(this.chart, pixel, 0) : pixel);\n    }\n    getDecimalForPixel(pixel) {\n        const decimal = (pixel - this._startPixel) / this._length;\n        return this._reversePixels ? 1 - decimal : decimal;\n    }\n    getBasePixel() {\n        return this.getPixelForValue(this.getBaseValue());\n    }\n    getBaseValue() {\n        const { min, max } = this;\n        return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    }\n    getContext(index) {\n        const ticks = this.ticks || [];\n        if (index >= 0 && index < ticks.length) {\n            const tick = ticks[index];\n            return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));\n        }\n        return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n    }\n    _tickSize() {\n        const optionTicks = this.options.ticks;\n        const rot = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const cos = Math.abs(Math.cos(rot));\n        const sin = Math.abs(Math.sin(rot));\n        const labelSizes = this._getLabelSizes();\n        const padding = optionTicks.autoSkipPadding || 0;\n        const w = labelSizes ? labelSizes.widest.width + padding : 0;\n        const h = labelSizes ? labelSizes.highest.height + padding : 0;\n        return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n    }\n    _isVisible() {\n        const display = this.options.display;\n        if (display !== \"auto\") {\n            return !!display;\n        }\n        return this.getMatchingVisibleMetas().length > 0;\n    }\n    _computeGridLineItems(chartArea) {\n        const axis = this.axis;\n        const chart = this.chart;\n        const options = this.options;\n        const { grid, position } = options;\n        const offset = grid.offset;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const ticksLength = ticks.length + (offset ? 1 : 0);\n        const tl = getTickMarkLength(grid);\n        const items = [];\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = borderOpts.drawBorder ? borderOpts.borderWidth : 0;\n        const axisHalfWidth = axisWidth / 2;\n        const alignBorderValue = function(pixel) {\n            return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, pixel, axisWidth);\n        };\n        let borderValue, i, lineValue, alignedLineValue;\n        let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n        if (position === \"top\") {\n            borderValue = alignBorderValue(this.bottom);\n            ty1 = this.bottom - tl;\n            ty2 = borderValue - axisHalfWidth;\n            y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n            y2 = chartArea.bottom;\n        } else if (position === \"bottom\") {\n            borderValue = alignBorderValue(this.top);\n            y1 = chartArea.top;\n            y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = this.top + tl;\n        } else if (position === \"left\") {\n            borderValue = alignBorderValue(this.right);\n            tx1 = this.right - tl;\n            tx2 = borderValue - axisHalfWidth;\n            x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n            x2 = chartArea.right;\n        } else if (position === \"right\") {\n            borderValue = alignBorderValue(this.left);\n            x1 = chartArea.left;\n            x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n            tx1 = borderValue + axisHalfWidth;\n            tx2 = this.left + tl;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            y1 = chartArea.top;\n            y2 = chartArea.bottom;\n            ty1 = borderValue + axisHalfWidth;\n            ty2 = ty1 + tl;\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n            }\n            tx1 = borderValue - axisHalfWidth;\n            tx2 = tx1 - tl;\n            x1 = chartArea.left;\n            x2 = chartArea.right;\n        }\n        const limit = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.ticks.maxTicksLimit, ticksLength);\n        const step = Math.max(1, Math.ceil(ticksLength / limit));\n        for(i = 0; i < ticksLength; i += step){\n            const optsAtIndex = grid.setContext(this.getContext(i));\n            const lineWidth = optsAtIndex.lineWidth;\n            const lineColor = optsAtIndex.color;\n            const borderDash = optsAtIndex.borderDash || [];\n            const borderDashOffset = optsAtIndex.borderDashOffset;\n            const tickWidth = optsAtIndex.tickWidth;\n            const tickColor = optsAtIndex.tickColor;\n            const tickBorderDash = optsAtIndex.tickBorderDash || [];\n            const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n            lineValue = getPixelForGridLine(this, i, offset);\n            if (lineValue === undefined) {\n                continue;\n            }\n            alignedLineValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, lineValue, lineWidth);\n            if (isHorizontal) {\n                tx1 = tx2 = x1 = x2 = alignedLineValue;\n            } else {\n                ty1 = ty2 = y1 = y2 = alignedLineValue;\n            }\n            items.push({\n                tx1,\n                ty1,\n                tx2,\n                ty2,\n                x1,\n                y1,\n                x2,\n                y2,\n                width: lineWidth,\n                color: lineColor,\n                borderDash,\n                borderDashOffset,\n                tickWidth,\n                tickColor,\n                tickBorderDash,\n                tickBorderDashOffset\n            });\n        }\n        this._ticksLength = ticksLength;\n        this._borderValue = borderValue;\n        return items;\n    }\n    _computeLabelItems(chartArea) {\n        const axis = this.axis;\n        const options = this.options;\n        const { position, ticks: optionTicks } = options;\n        const isHorizontal = this.isHorizontal();\n        const ticks = this.ticks;\n        const { align, crossAlign, padding, mirror } = optionTicks;\n        const tl = getTickMarkLength(options.grid);\n        const tickAndPadding = tl + padding;\n        const hTickAndPadding = mirror ? -padding : tickAndPadding;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        const items = [];\n        let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n        let textBaseline = \"middle\";\n        if (position === \"top\") {\n            y = this.bottom - hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"bottom\") {\n            y = this.top + hTickAndPadding;\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (position === \"left\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (position === \"right\") {\n            const ret = this._getYAxisLabelAlignment(tl);\n            textAlign = ret.textAlign;\n            x = ret.x;\n        } else if (axis === \"x\") {\n            if (position === \"center\") {\n                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n            }\n            textAlign = this._getXAxisLabelAlignment();\n        } else if (axis === \"y\") {\n            if (position === \"center\") {\n                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n            } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n                const positionAxisID = Object.keys(position)[0];\n                const value = position[positionAxisID];\n                x = this.chart.scales[positionAxisID].getPixelForValue(value);\n            }\n            textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n        }\n        if (axis === \"y\") {\n            if (align === \"start\") {\n                textBaseline = \"top\";\n            } else if (align === \"end\") {\n                textBaseline = \"bottom\";\n            }\n        }\n        const labelSizes = this._getLabelSizes();\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            label = tick.label;\n            const optsAtIndex = optionTicks.setContext(this.getContext(i));\n            pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n            font = this._resolveTickFontOptions(i);\n            lineHeight = font.lineHeight;\n            lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label.length : 1;\n            const halfCount = lineCount / 2;\n            const color = optsAtIndex.color;\n            const strokeColor = optsAtIndex.textStrokeColor;\n            const strokeWidth = optsAtIndex.textStrokeWidth;\n            let tickTextAlign = textAlign;\n            if (isHorizontal) {\n                x = pixel;\n                if (textAlign === \"inner\") {\n                    if (i === ilen - 1) {\n                        tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n                    } else if (i === 0) {\n                        tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n                    } else {\n                        tickTextAlign = \"center\";\n                    }\n                }\n                if (position === \"top\") {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = -lineCount * lineHeight + lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n                    } else {\n                        textOffset = -labelSizes.highest.height + lineHeight / 2;\n                    }\n                } else {\n                    if (crossAlign === \"near\" || rotation !== 0) {\n                        textOffset = lineHeight / 2;\n                    } else if (crossAlign === \"center\") {\n                        textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n                    } else {\n                        textOffset = labelSizes.highest.height - lineCount * lineHeight;\n                    }\n                }\n                if (mirror) {\n                    textOffset *= -1;\n                }\n            } else {\n                y = pixel;\n                textOffset = (1 - lineCount) * lineHeight / 2;\n            }\n            let backdrop;\n            if (optsAtIndex.showLabelBackdrop) {\n                const labelPadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                const height = labelSizes.heights[i];\n                const width = labelSizes.widths[i];\n                let top = y + textOffset - labelPadding.top;\n                let left = x - labelPadding.left;\n                switch(textBaseline){\n                    case \"middle\":\n                        top -= height / 2;\n                        break;\n                    case \"bottom\":\n                        top -= height;\n                        break;\n                }\n                switch(textAlign){\n                    case \"center\":\n                        left -= width / 2;\n                        break;\n                    case \"right\":\n                        left -= width;\n                        break;\n                }\n                backdrop = {\n                    left,\n                    top,\n                    width: width + labelPadding.width,\n                    height: height + labelPadding.height,\n                    color: optsAtIndex.backdropColor\n                };\n            }\n            items.push({\n                rotation,\n                label,\n                font,\n                color,\n                strokeColor,\n                strokeWidth,\n                textOffset,\n                textAlign: tickTextAlign,\n                textBaseline,\n                translation: [\n                    x,\n                    y\n                ],\n                backdrop\n            });\n        }\n        return items;\n    }\n    _getXAxisLabelAlignment() {\n        const { position, ticks } = this.options;\n        const rotation = -(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.labelRotation);\n        if (rotation) {\n            return position === \"top\" ? \"left\" : \"right\";\n        }\n        let align = \"center\";\n        if (ticks.align === \"start\") {\n            align = \"left\";\n        } else if (ticks.align === \"end\") {\n            align = \"right\";\n        } else if (ticks.align === \"inner\") {\n            align = \"inner\";\n        }\n        return align;\n    }\n    _getYAxisLabelAlignment(tl) {\n        const { position, ticks: { crossAlign, mirror, padding } } = this.options;\n        const labelSizes = this._getLabelSizes();\n        const tickAndPadding = tl + padding;\n        const widest = labelSizes.widest.width;\n        let textAlign;\n        let x;\n        if (position === \"left\") {\n            if (mirror) {\n                x = this.right + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x += widest;\n                }\n            } else {\n                x = this.right - tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x = this.left;\n                }\n            }\n        } else if (position === \"right\") {\n            if (mirror) {\n                x = this.left + padding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"right\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x -= widest / 2;\n                } else {\n                    textAlign = \"left\";\n                    x -= widest;\n                }\n            } else {\n                x = this.left + tickAndPadding;\n                if (crossAlign === \"near\") {\n                    textAlign = \"left\";\n                } else if (crossAlign === \"center\") {\n                    textAlign = \"center\";\n                    x += widest / 2;\n                } else {\n                    textAlign = \"right\";\n                    x = this.right;\n                }\n            }\n        } else {\n            textAlign = \"right\";\n        }\n        return {\n            textAlign,\n            x\n        };\n    }\n    _computeLabelArea() {\n        if (this.options.ticks.mirror) {\n            return;\n        }\n        const chart = this.chart;\n        const position = this.options.position;\n        if (position === \"left\" || position === \"right\") {\n            return {\n                top: 0,\n                left: this.left,\n                bottom: chart.height,\n                right: this.right\n            };\n        }\n        if (position === \"top\" || position === \"bottom\") {\n            return {\n                top: this.top,\n                left: 0,\n                bottom: this.bottom,\n                right: chart.width\n            };\n        }\n    }\n    drawBackground() {\n        const { ctx, options: { backgroundColor }, left, top, width, height } = this;\n        if (backgroundColor) {\n            ctx.save();\n            ctx.fillStyle = backgroundColor;\n            ctx.fillRect(left, top, width, height);\n            ctx.restore();\n        }\n    }\n    getLineWidthForValue(value) {\n        const grid = this.options.grid;\n        if (!this._isVisible() || !grid.display) {\n            return 0;\n        }\n        const ticks = this.ticks;\n        const index = ticks.findIndex((t)=>t.value === value);\n        if (index >= 0) {\n            const opts = grid.setContext(this.getContext(index));\n            return opts.lineWidth;\n        }\n        return 0;\n    }\n    drawGrid(chartArea) {\n        const grid = this.options.grid;\n        const ctx = this.ctx;\n        const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n        let i, ilen;\n        const drawLine = (p1, p2, style)=>{\n            if (!style.width || !style.color) {\n                return;\n            }\n            ctx.save();\n            ctx.lineWidth = style.width;\n            ctx.strokeStyle = style.color;\n            ctx.setLineDash(style.borderDash || []);\n            ctx.lineDashOffset = style.borderDashOffset;\n            ctx.beginPath();\n            ctx.moveTo(p1.x, p1.y);\n            ctx.lineTo(p2.x, p2.y);\n            ctx.stroke();\n            ctx.restore();\n        };\n        if (grid.display) {\n            for(i = 0, ilen = items.length; i < ilen; ++i){\n                const item = items[i];\n                if (grid.drawOnChartArea) {\n                    drawLine({\n                        x: item.x1,\n                        y: item.y1\n                    }, {\n                        x: item.x2,\n                        y: item.y2\n                    }, item);\n                }\n                if (grid.drawTicks) {\n                    drawLine({\n                        x: item.tx1,\n                        y: item.ty1\n                    }, {\n                        x: item.tx2,\n                        y: item.ty2\n                    }, {\n                        color: item.tickColor,\n                        width: item.tickWidth,\n                        borderDash: item.tickBorderDash,\n                        borderDashOffset: item.tickBorderDashOffset\n                    });\n                }\n            }\n        }\n    }\n    drawBorder() {\n        const { chart, ctx, options: { grid } } = this;\n        const borderOpts = grid.setContext(this.getContext());\n        const axisWidth = grid.drawBorder ? borderOpts.borderWidth : 0;\n        if (!axisWidth) {\n            return;\n        }\n        const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n        const borderValue = this._borderValue;\n        let x1, x2, y1, y2;\n        if (this.isHorizontal()) {\n            x1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.left, axisWidth) - axisWidth / 2;\n            x2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n            y1 = y2 = borderValue;\n        } else {\n            y1 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.top, axisWidth) - axisWidth / 2;\n            y2 = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J)(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n            x1 = x2 = borderValue;\n        }\n        ctx.save();\n        ctx.lineWidth = borderOpts.borderWidth;\n        ctx.strokeStyle = borderOpts.borderColor;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y2);\n        ctx.stroke();\n        ctx.restore();\n    }\n    drawLabels(chartArea) {\n        const optionTicks = this.options.ticks;\n        if (!optionTicks.display) {\n            return;\n        }\n        const ctx = this.ctx;\n        const area = this._computeLabelArea();\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        }\n        const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n        let i, ilen;\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            const item = items[i];\n            const tickFont = item.font;\n            const label = item.label;\n            if (item.backdrop) {\n                ctx.fillStyle = item.backdrop.color;\n                ctx.fillRect(item.backdrop.left, item.backdrop.top, item.backdrop.width, item.backdrop.height);\n            }\n            let y = item.textOffset;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, label, 0, y, tickFont, item);\n        }\n        if (area) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    drawTitle() {\n        const { ctx, options: { position, title, reverse } } = this;\n        if (!title.display) {\n            return;\n        }\n        const font = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(title.font);\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(title.padding);\n        const align = title.align;\n        let offset = font.lineHeight / 2;\n        if (position === \"bottom\" || position === \"center\" || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(position)) {\n            offset += padding.bottom;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(title.text)) {\n                offset += font.lineHeight * (title.text.length - 1);\n            }\n        } else {\n            offset += padding.top;\n        }\n        const { titleX, titleY, maxWidth, rotation } = titleArgs(this, offset, position, align);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, title.text, 0, 0, font, {\n            color: title.color,\n            maxWidth,\n            rotation,\n            textAlign: titleAlign(align, position, reverse),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n    draw(chartArea) {\n        if (!this._isVisible()) {\n            return;\n        }\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawBorder();\n        this.drawTitle();\n        this.drawLabels(chartArea);\n    }\n    _layers() {\n        const opts = this.options;\n        const tz = opts.ticks && opts.ticks.z || 0;\n        const gz = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(opts.grid && opts.grid.z, -1);\n        if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n            return [\n                {\n                    z: tz,\n                    draw: (chartArea)=>{\n                        this.draw(chartArea);\n                    }\n                }\n            ];\n        }\n        return [\n            {\n                z: gz,\n                draw: (chartArea)=>{\n                    this.drawBackground();\n                    this.drawGrid(chartArea);\n                    this.drawTitle();\n                }\n            },\n            {\n                z: gz + 1,\n                draw: ()=>{\n                    this.drawBorder();\n                }\n            },\n            {\n                z: tz,\n                draw: (chartArea)=>{\n                    this.drawLabels(chartArea);\n                }\n            }\n        ];\n    }\n    getMatchingVisibleMetas(type) {\n        const metas = this.chart.getSortedVisibleDatasetMetas();\n        const axisID = this.axis + \"AxisID\";\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            const meta = metas[i];\n            if (meta[axisID] === this.id && (!type || meta.type === type)) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    _resolveTickFontOptions(index) {\n        const opts = this.options.ticks.setContext(this.getContext(index));\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n    }\n    _maxDigits() {\n        const fontSize = this._resolveTickFontOptions(0).lineHeight;\n        return (this.isHorizontal() ? this.width : this.height) / fontSize;\n    }\n}\nclass TypedRegistry {\n    constructor(type, scope, override){\n        this.type = type;\n        this.scope = scope;\n        this.override = override;\n        this.items = Object.create(null);\n    }\n    isForType(type) {\n        return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n    }\n    register(item) {\n        const proto = Object.getPrototypeOf(item);\n        let parentScope;\n        if (isIChartComponent(proto)) {\n            parentScope = this.register(proto);\n        }\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope + \".\" + id;\n        if (!id) {\n            throw new Error(\"class does not have id: \" + item);\n        }\n        if (id in items) {\n            return scope;\n        }\n        items[id] = item;\n        registerDefaults(item, scope, parentScope);\n        if (this.override) {\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.override(item.id, item.overrides);\n        }\n        return scope;\n    }\n    get(id) {\n        return this.items[id];\n    }\n    unregister(item) {\n        const items = this.items;\n        const id = item.id;\n        const scope = this.scope;\n        if (id in items) {\n            delete items[id];\n        }\n        if (scope && id in _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope]) {\n            delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d[scope][id];\n            if (this.override) {\n                delete _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[id];\n            }\n        }\n    }\n}\nfunction registerDefaults(item, scope, parentScope) {\n    const itemDefaults = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V)(Object.create(null), [\n        parentScope ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(parentScope) : {},\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.get(scope),\n        item.defaults\n    ]);\n    _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(scope, itemDefaults);\n    if (item.defaultRoutes) {\n        routeDefaults(scope, item.defaultRoutes);\n    }\n    if (item.descriptors) {\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.describe(scope, item.descriptors);\n    }\n}\nfunction routeDefaults(scope, routes) {\n    Object.keys(routes).forEach((property)=>{\n        const propertyParts = property.split(\".\");\n        const sourceName = propertyParts.pop();\n        const sourceScope = [\n            scope\n        ].concat(propertyParts).join(\".\");\n        const parts = routes[property].split(\".\");\n        const targetName = parts.pop();\n        const targetScope = parts.join(\".\");\n        _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.route(sourceScope, sourceName, targetScope, targetName);\n    });\n}\nfunction isIChartComponent(proto) {\n    return \"id\" in proto && \"defaults\" in proto;\n}\nclass Registry {\n    constructor(){\n        this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n        this.elements = new TypedRegistry(Element, \"elements\");\n        this.plugins = new TypedRegistry(Object, \"plugins\");\n        this.scales = new TypedRegistry(Scale, \"scales\");\n        this._typedRegistries = [\n            this.controllers,\n            this.scales,\n            this.elements\n        ];\n    }\n    add(...args) {\n        this._each(\"register\", args);\n    }\n    remove(...args) {\n        this._each(\"unregister\", args);\n    }\n    addControllers(...args) {\n        this._each(\"register\", args, this.controllers);\n    }\n    addElements(...args) {\n        this._each(\"register\", args, this.elements);\n    }\n    addPlugins(...args) {\n        this._each(\"register\", args, this.plugins);\n    }\n    addScales(...args) {\n        this._each(\"register\", args, this.scales);\n    }\n    getController(id) {\n        return this._get(id, this.controllers, \"controller\");\n    }\n    getElement(id) {\n        return this._get(id, this.elements, \"element\");\n    }\n    getPlugin(id) {\n        return this._get(id, this.plugins, \"plugin\");\n    }\n    getScale(id) {\n        return this._get(id, this.scales, \"scale\");\n    }\n    removeControllers(...args) {\n        this._each(\"unregister\", args, this.controllers);\n    }\n    removeElements(...args) {\n        this._each(\"unregister\", args, this.elements);\n    }\n    removePlugins(...args) {\n        this._each(\"unregister\", args, this.plugins);\n    }\n    removeScales(...args) {\n        this._each(\"unregister\", args, this.scales);\n    }\n    _each(method, args, typedRegistry) {\n        [\n            ...args\n        ].forEach((arg)=>{\n            const reg = typedRegistry || this._getRegistryForType(arg);\n            if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n                this._exec(method, reg, arg);\n            } else {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(arg, (item)=>{\n                    const itemReg = typedRegistry || this._getRegistryForType(item);\n                    this._exec(method, itemReg, item);\n                });\n            }\n        });\n    }\n    _exec(method, registry, component) {\n        const camelMethod = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W)(method);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"before\" + camelMethod], [], component);\n        registry[method](component);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(component[\"after\" + camelMethod], [], component);\n    }\n    _getRegistryForType(type) {\n        for(let i = 0; i < this._typedRegistries.length; i++){\n            const reg = this._typedRegistries[i];\n            if (reg.isForType(type)) {\n                return reg;\n            }\n        }\n        return this.plugins;\n    }\n    _get(id, typedRegistry, type) {\n        const item = typedRegistry.get(id);\n        if (item === undefined) {\n            throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n        }\n        return item;\n    }\n}\nvar registry = new Registry();\nclass ScatterController extends DatasetController {\n    update(mode) {\n        const meta = this._cachedMeta;\n        const { data: points = [] } = meta;\n        const animationsDisabled = this.chart._animationsDisabled;\n        let { start, count } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q)(meta, points, animationsDisabled);\n        this._drawStart = start;\n        this._drawCount = count;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w)(meta)) {\n            start = 0;\n            count = points.length;\n        }\n        if (this.options.showLine) {\n            const { dataset: line, _dataset } = meta;\n            line._chart = this.chart;\n            line._datasetIndex = this.index;\n            line._decimated = !!_dataset._decimated;\n            line.points = points;\n            const options = this.resolveDatasetElementOptions(mode);\n            options.segment = this.options.segment;\n            this.updateElement(line, undefined, {\n                animated: !animationsDisabled,\n                options\n            }, mode);\n        }\n        this.updateElements(points, start, count, mode);\n    }\n    addElements() {\n        const { showLine } = this.options;\n        if (!this.datasetElementType && showLine) {\n            this.datasetElementType = registry.getElement(\"line\");\n        }\n        super.addElements();\n    }\n    updateElements(points, start, count, mode) {\n        const reset = mode === \"reset\";\n        const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;\n        const firstOpts = this.resolveDataElementOptions(start, mode);\n        const sharedOptions = this.getSharedOptions(firstOpts);\n        const includeOptions = this.includeOptions(mode, sharedOptions);\n        const iAxis = iScale.axis;\n        const vAxis = vScale.axis;\n        const { spanGaps, segment } = this.options;\n        const maxGapLength = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n        const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n        let prevParsed = start > 0 && this.getParsed(start - 1);\n        for(let i = start; i < start + count; ++i){\n            const point = points[i];\n            const parsed = this.getParsed(i);\n            const properties = directUpdate ? point : {};\n            const nullData = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(parsed[vAxis]);\n            const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n            const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n            properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n            properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n            if (segment) {\n                properties.parsed = parsed;\n                properties.raw = _dataset.data[i];\n            }\n            if (includeOptions) {\n                properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n            }\n            if (!directUpdate) {\n                this.updateElement(point, i, properties, mode);\n            }\n            prevParsed = parsed;\n        }\n        this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    }\n    getMaxOverflow() {\n        const meta = this._cachedMeta;\n        const data = meta.data || [];\n        if (!this.options.showLine) {\n            let max = 0;\n            for(let i = data.length - 1; i >= 0; --i){\n                max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n            }\n            return max > 0 && max;\n        }\n        const dataset = meta.dataset;\n        const border = dataset.options && dataset.options.borderWidth || 0;\n        if (!data.length) {\n            return border;\n        }\n        const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n        const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n        return Math.max(border, firstPoint, lastPoint) / 2;\n    }\n}\nScatterController.id = \"scatter\";\nScatterController.defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n};\nScatterController.overrides = {\n    interaction: {\n        mode: \"point\"\n    },\n    plugins: {\n        tooltip: {\n            callbacks: {\n                title () {\n                    return \"\";\n                },\n                label (item) {\n                    return \"(\" + item.label + \", \" + item.formattedValue + \")\";\n                }\n            }\n        }\n    },\n    scales: {\n        x: {\n            type: \"linear\"\n        },\n        y: {\n            type: \"linear\"\n        }\n    }\n};\nvar controllers = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BarController: BarController,\n    BubbleController: BubbleController,\n    DoughnutController: DoughnutController,\n    LineController: LineController,\n    PolarAreaController: PolarAreaController,\n    PieController: PieController,\n    RadarController: RadarController,\n    ScatterController: ScatterController\n});\nfunction abstract() {\n    throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nclass DateAdapter {\n    constructor(options){\n        this.options = options || {};\n    }\n    init(chartOptions) {}\n    formats() {\n        return abstract();\n    }\n    parse(value, format) {\n        return abstract();\n    }\n    format(timestamp, format) {\n        return abstract();\n    }\n    add(timestamp, amount, unit) {\n        return abstract();\n    }\n    diff(a, b, unit) {\n        return abstract();\n    }\n    startOf(timestamp, unit, weekday) {\n        return abstract();\n    }\n    endOf(timestamp, unit) {\n        return abstract();\n    }\n}\nDateAdapter.override = function(members) {\n    Object.assign(DateAdapter.prototype, members);\n};\nvar adapters = {\n    _date: DateAdapter\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n    const { controller, data, _sorted } = metaset;\n    const iScale = controller._cachedMeta.iScale;\n    if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n        const lookupMethod = iScale._reversePixels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y : _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z;\n        if (!intersect) {\n            return lookupMethod(data, axis, value);\n        } else if (controller._sharedOptions) {\n            const el = data[0];\n            const range = typeof el.getRange === \"function\" && el.getRange(axis);\n            if (range) {\n                const start = lookupMethod(data, axis, value - range);\n                const end = lookupMethod(data, axis, value + range);\n                return {\n                    lo: start.lo,\n                    hi: end.hi\n                };\n            }\n        }\n    }\n    return {\n        lo: 0,\n        hi: data.length - 1\n    };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const value = position[axis];\n    for(let i = 0, ilen = metasets.length; i < ilen; ++i){\n        const { index, data } = metasets[i];\n        const { lo, hi } = binarySearch(metasets[i], axis, value, intersect);\n        for(let j = lo; j <= hi; ++j){\n            const element = data[j];\n            if (!element.skip) {\n                handler(element, index, j);\n            }\n        }\n    }\n}\nfunction getDistanceMetricForAxis(axis) {\n    const useX = axis.indexOf(\"x\") !== -1;\n    const useY = axis.indexOf(\"y\") !== -1;\n    return function(pt1, pt2) {\n        const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n        const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n        return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n    };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n    const items = [];\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return items;\n    }\n    const evaluationFunc = function(element, datasetIndex, index) {\n        if (!includeInvisible && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(element, chart.chartArea, 0)) {\n            return;\n        }\n        if (element.inRange(position.x, position.y, useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    };\n    evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n    return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n    let items = [];\n    function evaluationFunc(element, datasetIndex, index) {\n        const { startAngle, endAngle } = element.getProps([\n            \"startAngle\",\n            \"endAngle\"\n        ], useFinalPosition);\n        const { angle } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(element, {\n            x: position.x,\n            y: position.y\n        });\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    let items = [];\n    const distanceMetric = getDistanceMetricForAxis(axis);\n    let minDistance = Number.POSITIVE_INFINITY;\n    function evaluationFunc(element, datasetIndex, index) {\n        const inRange = element.inRange(position.x, position.y, useFinalPosition);\n        if (intersect && !inRange) {\n            return;\n        }\n        const center = element.getCenterPoint(useFinalPosition);\n        const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n        if (!pointInArea && !inRange) {\n            return;\n        }\n        const distance = distanceMetric(position, center);\n        if (distance < minDistance) {\n            items = [\n                {\n                    element,\n                    datasetIndex,\n                    index\n                }\n            ];\n            minDistance = distance;\n        } else if (distance === minDistance) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n        }\n    }\n    evaluateInteractionItems(chart, axis, position, evaluationFunc);\n    return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n    if (!includeInvisible && !chart.isPointInArea(position)) {\n        return [];\n    }\n    return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n    const items = [];\n    const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n    let intersectsItem = false;\n    evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index)=>{\n        if (element[rangeMethod](position[axis], useFinalPosition)) {\n            items.push({\n                element,\n                datasetIndex,\n                index\n            });\n            intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n        }\n    });\n    if (intersect && !intersectsItem) {\n        return [];\n    }\n    return items;\n}\nvar Interaction = {\n    evaluateInteractionItems,\n    modes: {\n        index (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"x\";\n            const includeInvisible = options.includeInvisible || false;\n            const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            const elements = [];\n            if (!items.length) {\n                return [];\n            }\n            chart.getSortedVisibleDatasetMetas().forEach((meta)=>{\n                const index = items[0].index;\n                const element = meta.data[index];\n                if (element && !element.skip) {\n                    elements.push({\n                        element,\n                        datasetIndex: meta.index,\n                        index\n                    });\n                }\n            });\n            return elements;\n        },\n        dataset (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n            if (items.length > 0) {\n                const datasetIndex = items[0].datasetIndex;\n                const data = chart.getDatasetMeta(datasetIndex).data;\n                items = [];\n                for(let i = 0; i < data.length; ++i){\n                    items.push({\n                        element: data[i],\n                        datasetIndex,\n                        index: i\n                    });\n                }\n            }\n            return items;\n        },\n        point (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n        },\n        nearest (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            const axis = options.axis || \"xy\";\n            const includeInvisible = options.includeInvisible || false;\n            return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n        },\n        x (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n        },\n        y (chart, e, options, useFinalPosition) {\n            const position = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(e, chart);\n            return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n        }\n    }\n};\nconst STATIC_POSITIONS = [\n    \"left\",\n    \"top\",\n    \"right\",\n    \"bottom\"\n];\nfunction filterByPosition(array, position) {\n    return array.filter((v)=>v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n    return array.filter((v)=>STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n    return array.sort((a, b)=>{\n        const v0 = reverse ? b : a;\n        const v1 = reverse ? a : b;\n        return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n    });\n}\nfunction wrapBoxes(boxes) {\n    const layoutBoxes = [];\n    let i, ilen, box, pos, stack, stackWeight;\n    for(i = 0, ilen = (boxes || []).length; i < ilen; ++i){\n        box = boxes[i];\n        ({ position: pos, options: { stack, stackWeight = 1 } } = box);\n        layoutBoxes.push({\n            index: i,\n            box,\n            pos,\n            horizontal: box.isHorizontal(),\n            weight: box.weight,\n            stack: stack && pos + stack,\n            stackWeight\n        });\n    }\n    return layoutBoxes;\n}\nfunction buildStacks(layouts) {\n    const stacks = {};\n    for (const wrap of layouts){\n        const { stack, pos, stackWeight } = wrap;\n        if (!stack || !STATIC_POSITIONS.includes(pos)) {\n            continue;\n        }\n        const _stack = stacks[stack] || (stacks[stack] = {\n            count: 0,\n            placed: 0,\n            weight: 0,\n            size: 0\n        });\n        _stack.count++;\n        _stack.weight += stackWeight;\n    }\n    return stacks;\n}\nfunction setLayoutDims(layouts, params) {\n    const stacks = buildStacks(layouts);\n    const { vBoxMaxWidth, hBoxMaxHeight } = params;\n    let i, ilen, layout;\n    for(i = 0, ilen = layouts.length; i < ilen; ++i){\n        layout = layouts[i];\n        const { fullSize } = layout.box;\n        const stack = stacks[layout.stack];\n        const factor = stack && layout.stackWeight / stack.weight;\n        if (layout.horizontal) {\n            layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n            layout.height = hBoxMaxHeight;\n        } else {\n            layout.width = vBoxMaxWidth;\n            layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n        }\n    }\n    return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n    const layoutBoxes = wrapBoxes(boxes);\n    const fullSize = sortByWeight(layoutBoxes.filter((wrap)=>wrap.box.fullSize), true);\n    const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n    const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n    const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n    const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n    const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n    const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n    return {\n        fullSize,\n        leftAndTop: left.concat(top),\n        rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n        chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n        vertical: left.concat(right).concat(centerVertical),\n        horizontal: top.concat(bottom).concat(centerHorizontal)\n    };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n    return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n    const { pos, box } = layout;\n    const maxPadding = chartArea.maxPadding;\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(pos)) {\n        if (layout.size) {\n            chartArea[pos] -= layout.size;\n        }\n        const stack = stacks[layout.stack] || {\n            size: 0,\n            count: 1\n        };\n        stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n        layout.size = stack.size / stack.count;\n        chartArea[pos] += layout.size;\n    }\n    if (box.getPadding) {\n        updateMaxPadding(maxPadding, box.getPadding());\n    }\n    const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n    const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n    const widthChanged = newWidth !== chartArea.w;\n    const heightChanged = newHeight !== chartArea.h;\n    chartArea.w = newWidth;\n    chartArea.h = newHeight;\n    return layout.horizontal ? {\n        same: widthChanged,\n        other: heightChanged\n    } : {\n        same: heightChanged,\n        other: widthChanged\n    };\n}\nfunction handleMaxPadding(chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function updatePos(pos) {\n        const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n        chartArea[pos] += change;\n        return change;\n    }\n    chartArea.y += updatePos(\"top\");\n    chartArea.x += updatePos(\"left\");\n    updatePos(\"right\");\n    updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n    const maxPadding = chartArea.maxPadding;\n    function marginForPositions(positions) {\n        const margin = {\n            left: 0,\n            top: 0,\n            right: 0,\n            bottom: 0\n        };\n        positions.forEach((pos)=>{\n            margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n        });\n        return margin;\n    }\n    return horizontal ? marginForPositions([\n        \"left\",\n        \"right\"\n    ]) : marginForPositions([\n        \"top\",\n        \"bottom\"\n    ]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n    const refitBoxes = [];\n    let i, ilen, layout, box, refit, changed;\n    for(i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i){\n        layout = boxes[i];\n        box = layout.box;\n        box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n        const { same, other } = updateDims(chartArea, params, layout, stacks);\n        refit |= same && refitBoxes.length;\n        changed = changed || other;\n        if (!box.fullSize) {\n            refitBoxes.push(layout);\n        }\n    }\n    return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n    box.top = top;\n    box.left = left;\n    box.right = left + width;\n    box.bottom = top + height;\n    box.width = width;\n    box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n    const userPadding = params.padding;\n    let { x, y } = chartArea;\n    for (const layout of boxes){\n        const box = layout.box;\n        const stack = stacks[layout.stack] || {\n            count: 1,\n            placed: 0,\n            weight: 1\n        };\n        const weight = layout.stackWeight / stack.weight || 1;\n        if (layout.horizontal) {\n            const width = chartArea.w * weight;\n            const height = stack.size || box.height;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                y = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n            } else {\n                setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n            }\n            stack.start = y;\n            stack.placed += width;\n            y = box.bottom;\n        } else {\n            const height = chartArea.h * weight;\n            const width = stack.size || box.width;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(stack.start)) {\n                x = stack.start;\n            }\n            if (box.fullSize) {\n                setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n            } else {\n                setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n            }\n            stack.start = x;\n            stack.placed += height;\n            x = box.right;\n        }\n    }\n    chartArea.x = x;\n    chartArea.y = y;\n}\n_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.set(\"layout\", {\n    autoPadding: true,\n    padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    }\n});\nvar layouts = {\n    addBox (chart, item) {\n        if (!chart.boxes) {\n            chart.boxes = [];\n        }\n        item.fullSize = item.fullSize || false;\n        item.position = item.position || \"top\";\n        item.weight = item.weight || 0;\n        item._layers = item._layers || function() {\n            return [\n                {\n                    z: 0,\n                    draw (chartArea) {\n                        item.draw(chartArea);\n                    }\n                }\n            ];\n        };\n        chart.boxes.push(item);\n    },\n    removeBox (chart, layoutItem) {\n        const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n        if (index !== -1) {\n            chart.boxes.splice(index, 1);\n        }\n    },\n    configure (chart, item, options) {\n        item.fullSize = options.fullSize;\n        item.position = options.position;\n        item.weight = options.weight;\n    },\n    update (chart, width, height, minPadding) {\n        if (!chart) {\n            return;\n        }\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(chart.options.layout.padding);\n        const availableWidth = Math.max(width - padding.width, 0);\n        const availableHeight = Math.max(height - padding.height, 0);\n        const boxes = buildLayoutBoxes(chart.boxes);\n        const verticalBoxes = boxes.vertical;\n        const horizontalBoxes = boxes.horizontal;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(chart.boxes, (box)=>{\n            if (typeof box.beforeLayout === \"function\") {\n                box.beforeLayout();\n            }\n        });\n        const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap)=>wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n        const params = Object.freeze({\n            outerWidth: width,\n            outerHeight: height,\n            padding,\n            availableWidth,\n            availableHeight,\n            vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n            hBoxMaxHeight: availableHeight / 2\n        });\n        const maxPadding = Object.assign({}, padding);\n        updateMaxPadding(maxPadding, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(minPadding));\n        const chartArea = Object.assign({\n            maxPadding,\n            w: availableWidth,\n            h: availableHeight,\n            x: padding.left,\n            y: padding.top\n        }, padding);\n        const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n        fitBoxes(boxes.fullSize, chartArea, params, stacks);\n        fitBoxes(verticalBoxes, chartArea, params, stacks);\n        if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n            fitBoxes(verticalBoxes, chartArea, params, stacks);\n        }\n        handleMaxPadding(chartArea);\n        placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n        chartArea.x += chartArea.w;\n        chartArea.y += chartArea.h;\n        placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n        chart.chartArea = {\n            left: chartArea.left,\n            top: chartArea.top,\n            right: chartArea.left + chartArea.w,\n            bottom: chartArea.top + chartArea.h,\n            height: chartArea.h,\n            width: chartArea.w\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(boxes.chartArea, (layout)=>{\n            const box = layout.box;\n            Object.assign(box, chart.chartArea);\n            box.update(chartArea.w, chartArea.h, {\n                left: 0,\n                top: 0,\n                right: 0,\n                bottom: 0\n            });\n        });\n    }\n};\nclass BasePlatform {\n    acquireContext(canvas, aspectRatio) {}\n    releaseContext(context) {\n        return false;\n    }\n    addEventListener(chart, type, listener) {}\n    removeEventListener(chart, type, listener) {}\n    getDevicePixelRatio() {\n        return 1;\n    }\n    getMaximumSize(element, width, height, aspectRatio) {\n        width = Math.max(0, width || element.width);\n        height = height || element.height;\n        return {\n            width,\n            height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n        };\n    }\n    isAttached(canvas) {\n        return true;\n    }\n    updateConfig(config) {}\n}\nclass BasicPlatform extends BasePlatform {\n    acquireContext(item) {\n        return item && item.getContext && item.getContext(\"2d\") || null;\n    }\n    updateConfig(config) {\n        config.options.animation = false;\n    }\n}\nconst EXPANDO_KEY = \"$chartjs\";\nconst EVENT_TYPES = {\n    touchstart: \"mousedown\",\n    touchmove: \"mousemove\",\n    touchend: \"mouseup\",\n    pointerenter: \"mouseenter\",\n    pointerdown: \"mousedown\",\n    pointermove: \"mousemove\",\n    pointerup: \"mouseup\",\n    pointerleave: \"mouseout\",\n    pointerout: \"mouseout\"\n};\nconst isNullOrEmpty = (value)=>value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n    const style = canvas.style;\n    const renderHeight = canvas.getAttribute(\"height\");\n    const renderWidth = canvas.getAttribute(\"width\");\n    canvas[EXPANDO_KEY] = {\n        initial: {\n            height: renderHeight,\n            width: renderWidth,\n            style: {\n                display: style.display,\n                height: style.height,\n                width: style.width\n            }\n        }\n    };\n    style.display = style.display || \"block\";\n    style.boxSizing = style.boxSizing || \"border-box\";\n    if (isNullOrEmpty(renderWidth)) {\n        const displayWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"width\");\n        if (displayWidth !== undefined) {\n            canvas.width = displayWidth;\n        }\n    }\n    if (isNullOrEmpty(renderHeight)) {\n        if (canvas.style.height === \"\") {\n            canvas.height = canvas.width / (aspectRatio || 2);\n        } else {\n            const displayHeight = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3)(canvas, \"height\");\n            if (displayHeight !== undefined) {\n                canvas.height = displayHeight;\n            }\n        }\n    }\n    return canvas;\n}\nconst eventListenerOptions = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5 ? {\n    passive: true\n} : false;\nfunction addListener(node, type, listener) {\n    node.addEventListener(type, listener, eventListenerOptions);\n}\nfunction removeListener(chart, type, listener) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\nfunction fromNativeEvent(event, chart) {\n    const type = EVENT_TYPES[event.type] || event.type;\n    const { x, y } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X)(event, chart);\n    return {\n        type,\n        chart,\n        native: event,\n        x: x !== undefined ? x : null,\n        y: y !== undefined ? y : null\n    };\n}\nfunction nodeListContains(nodeList, canvas) {\n    for (const node of nodeList){\n        if (node === canvas || node.contains(canvas)) {\n            return true;\n        }\n    }\n}\nfunction createAttachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const observer = new MutationObserver((entries)=>{\n        let trigger = false;\n        for (const entry of entries){\n            trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n            trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n        }\n        if (trigger) {\n            listener();\n        }\n    });\n    observer.observe(document, {\n        childList: true,\n        subtree: true\n    });\n    return observer;\n}\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr === oldDevicePixelRatio) {\n        return;\n    }\n    oldDevicePixelRatio = dpr;\n    drpListeningCharts.forEach((resize, chart)=>{\n        if (chart.currentDevicePixelRatio !== dpr) {\n            resize();\n        }\n    });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n    if (!drpListeningCharts.size) {\n        window.addEventListener(\"resize\", onWindowResize);\n    }\n    drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n    drpListeningCharts.delete(chart);\n    if (!drpListeningCharts.size) {\n        window.removeEventListener(\"resize\", onWindowResize);\n    }\n}\nfunction createResizeObserver(chart, type, listener) {\n    const canvas = chart.canvas;\n    const container = canvas && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n    if (!container) {\n        return;\n    }\n    const resize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((width, height)=>{\n        const w = container.clientWidth;\n        listener(width, height);\n        if (w < container.clientWidth) {\n            listener();\n        }\n    }, window);\n    const observer = new ResizeObserver((entries)=>{\n        const entry = entries[0];\n        const width = entry.contentRect.width;\n        const height = entry.contentRect.height;\n        if (width === 0 && height === 0) {\n            return;\n        }\n        resize(width, height);\n    });\n    observer.observe(container);\n    listenDevicePixelRatioChanges(chart, resize);\n    return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n    if (observer) {\n        observer.disconnect();\n    }\n    if (type === \"resize\") {\n        unlistenDevicePixelRatioChanges(chart);\n    }\n}\nfunction createProxyAndListen(chart, type, listener) {\n    const canvas = chart.canvas;\n    const proxy = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4)((event)=>{\n        if (chart.ctx !== null) {\n            listener(fromNativeEvent(event, chart));\n        }\n    }, chart, (args)=>{\n        const event = args[0];\n        return [\n            event,\n            event.offsetX,\n            event.offsetY\n        ];\n    });\n    addListener(canvas, type, proxy);\n    return proxy;\n}\nclass DomPlatform extends BasePlatform {\n    acquireContext(canvas, aspectRatio) {\n        const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n        if (context && context.canvas === canvas) {\n            initCanvas(canvas, aspectRatio);\n            return context;\n        }\n        return null;\n    }\n    releaseContext(context) {\n        const canvas = context.canvas;\n        if (!canvas[EXPANDO_KEY]) {\n            return false;\n        }\n        const initial = canvas[EXPANDO_KEY].initial;\n        [\n            \"height\",\n            \"width\"\n        ].forEach((prop)=>{\n            const value = initial[prop];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                canvas.removeAttribute(prop);\n            } else {\n                canvas.setAttribute(prop, value);\n            }\n        });\n        const style = initial.style || {};\n        Object.keys(style).forEach((key)=>{\n            canvas.style[key] = style[key];\n        });\n        canvas.width = canvas.width;\n        delete canvas[EXPANDO_KEY];\n        return true;\n    }\n    addEventListener(chart, type, listener) {\n        this.removeEventListener(chart, type);\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const handlers = {\n            attach: createAttachObserver,\n            detach: createDetachObserver,\n            resize: createResizeObserver\n        };\n        const handler = handlers[type] || createProxyAndListen;\n        proxies[type] = handler(chart, type, listener);\n    }\n    removeEventListener(chart, type) {\n        const proxies = chart.$proxies || (chart.$proxies = {});\n        const proxy = proxies[type];\n        if (!proxy) {\n            return;\n        }\n        const handlers = {\n            attach: releaseObserver,\n            detach: releaseObserver,\n            resize: releaseObserver\n        };\n        const handler = handlers[type] || removeListener;\n        handler(chart, type, proxy);\n        proxies[type] = undefined;\n    }\n    getDevicePixelRatio() {\n        return window.devicePixelRatio;\n    }\n    getMaximumSize(canvas, width, height, aspectRatio) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1)(canvas, width, height, aspectRatio);\n    }\n    isAttached(canvas) {\n        const container = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2)(canvas);\n        return !!(container && container.isConnected);\n    }\n}\nfunction _detectPlatform(canvas) {\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return BasicPlatform;\n    }\n    return DomPlatform;\n}\nclass PluginService {\n    constructor(){\n        this._init = [];\n    }\n    notify(chart, hook, args, filter) {\n        if (hook === \"beforeInit\") {\n            this._init = this._createDescriptors(chart, true);\n            this._notify(this._init, chart, \"install\");\n        }\n        const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n        const result = this._notify(descriptors, chart, hook, args);\n        if (hook === \"afterDestroy\") {\n            this._notify(descriptors, chart, \"stop\");\n            this._notify(this._init, chart, \"uninstall\");\n        }\n        return result;\n    }\n    _notify(descriptors, chart, hook, args) {\n        args = args || {};\n        for (const descriptor of descriptors){\n            const plugin = descriptor.plugin;\n            const method = plugin[hook];\n            const params = [\n                chart,\n                args,\n                descriptor.options\n            ];\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(method, params, plugin) === false && args.cancelable) {\n                return false;\n            }\n        }\n        return true;\n    }\n    invalidate() {\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(this._cache)) {\n            this._oldCache = this._cache;\n            this._cache = undefined;\n        }\n    }\n    _descriptors(chart) {\n        if (this._cache) {\n            return this._cache;\n        }\n        const descriptors = this._cache = this._createDescriptors(chart);\n        this._notifyStateChanges(chart);\n        return descriptors;\n    }\n    _createDescriptors(chart, all) {\n        const config = chart && chart.config;\n        const options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(config.options && config.options.plugins, {});\n        const plugins = allPlugins(config);\n        return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n    }\n    _notifyStateChanges(chart) {\n        const previousDescriptors = this._oldCache || [];\n        const descriptors = this._cache;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.plugin.id === y.plugin.id));\n        this._notify(diff(previousDescriptors, descriptors), chart, \"stop\");\n        this._notify(diff(descriptors, previousDescriptors), chart, \"start\");\n    }\n}\nfunction allPlugins(config) {\n    const localIds = {};\n    const plugins = [];\n    const keys = Object.keys(registry.plugins.items);\n    for(let i = 0; i < keys.length; i++){\n        plugins.push(registry.getPlugin(keys[i]));\n    }\n    const local = config.plugins || [];\n    for(let i = 0; i < local.length; i++){\n        const plugin = local[i];\n        if (plugins.indexOf(plugin) === -1) {\n            plugins.push(plugin);\n            localIds[plugin.id] = true;\n        }\n    }\n    return {\n        plugins,\n        localIds\n    };\n}\nfunction getOpts(options, all) {\n    if (!all && options === false) {\n        return null;\n    }\n    if (options === true) {\n        return {};\n    }\n    return options;\n}\nfunction createDescriptors(chart, { plugins, localIds }, options, all) {\n    const result = [];\n    const context = chart.getContext();\n    for (const plugin of plugins){\n        const id = plugin.id;\n        const opts = getOpts(options[id], all);\n        if (opts === null) {\n            continue;\n        }\n        result.push({\n            plugin,\n            options: pluginOpts(chart.config, {\n                plugin,\n                local: localIds[id]\n            }, opts, context)\n        });\n    }\n    return result;\n}\nfunction pluginOpts(config, { plugin, local }, opts, context) {\n    const keys = config.pluginScopeKeys(plugin);\n    const scopes = config.getOptionScopes(opts, keys);\n    if (local && plugin.defaults) {\n        scopes.push(plugin.defaults);\n    }\n    return config.createResolver(scopes, context, [\n        \"\"\n    ], {\n        scriptable: false,\n        indexable: false,\n        allKeys: true\n    });\n}\nfunction getIndexAxis(type, options) {\n    const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {};\n    const datasetOptions = (options.datasets || {})[type] || {};\n    return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n    let axis = id;\n    if (id === \"_index_\") {\n        axis = indexAxis;\n    } else if (id === \"_value_\") {\n        axis = indexAxis === \"x\" ? \"y\" : \"x\";\n    }\n    return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n    return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction axisFromPosition(position) {\n    if (position === \"top\" || position === \"bottom\") {\n        return \"x\";\n    }\n    if (position === \"left\" || position === \"right\") {\n        return \"y\";\n    }\n}\nfunction determineAxis(id, scaleOptions) {\n    if (id === \"x\" || id === \"y\") {\n        return id;\n    }\n    return scaleOptions.axis || axisFromPosition(scaleOptions.position) || id.charAt(0).toLowerCase();\n}\nfunction mergeScaleConfig(config, options) {\n    const chartDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[config.type] || {\n        scales: {}\n    };\n    const configScales = options.scales || {};\n    const chartIndexAxis = getIndexAxis(config.type, options);\n    const firstIDs = Object.create(null);\n    const scales = Object.create(null);\n    Object.keys(configScales).forEach((id)=>{\n        const scaleConf = configScales[id];\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(scaleConf)) {\n            return console.error(`Invalid scale configuration for scale: ${id}`);\n        }\n        if (scaleConf._proxy) {\n            return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n        }\n        const axis = determineAxis(id, scaleConf);\n        const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n        const defaultScaleOptions = chartDefaults.scales || {};\n        firstIDs[axis] = firstIDs[axis] || id;\n        scales[id] = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(Object.create(null), [\n            {\n                axis\n            },\n            scaleConf,\n            defaultScaleOptions[axis],\n            defaultScaleOptions[defaultId]\n        ]);\n    });\n    config.data.datasets.forEach((dataset)=>{\n        const type = dataset.type || config.type;\n        const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n        const datasetDefaults = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {};\n        const defaultScaleOptions = datasetDefaults.scales || {};\n        Object.keys(defaultScaleOptions).forEach((defaultID)=>{\n            const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n            const id = dataset[axis + \"AxisID\"] || firstIDs[axis] || axis;\n            scales[id] = scales[id] || Object.create(null);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scales[id], [\n                {\n                    axis\n                },\n                configScales[id],\n                defaultScaleOptions[defaultID]\n            ]);\n        });\n    });\n    Object.keys(scales).forEach((key)=>{\n        const scale = scales[key];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(scale, [\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scales[scale.type],\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.scale\n        ]);\n    });\n    return scales;\n}\nfunction initOptions(config) {\n    const options = config.options || (config.options = {});\n    options.plugins = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(options.plugins, {});\n    options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n    data = data || {};\n    data.datasets = data.datasets || [];\n    data.labels = data.labels || [];\n    return data;\n}\nfunction initConfig(config) {\n    config = config || {};\n    config.data = initData(config.data);\n    initOptions(config);\n    return config;\n}\nconst keyCache = new Map();\nconst keysCached = new Set();\nfunction cachedKeys(cacheKey, generate) {\n    let keys = keyCache.get(cacheKey);\n    if (!keys) {\n        keys = generate();\n        keyCache.set(cacheKey, keys);\n        keysCached.add(keys);\n    }\n    return keys;\n}\nconst addIfFound = (set, obj, key)=>{\n    const opts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);\n    if (opts !== undefined) {\n        set.add(opts);\n    }\n};\nclass Config {\n    constructor(config){\n        this._config = initConfig(config);\n        this._scopeCache = new Map();\n        this._resolverCache = new Map();\n    }\n    get platform() {\n        return this._config.platform;\n    }\n    get type() {\n        return this._config.type;\n    }\n    set type(type) {\n        this._config.type = type;\n    }\n    get data() {\n        return this._config.data;\n    }\n    set data(data) {\n        this._config.data = initData(data);\n    }\n    get options() {\n        return this._config.options;\n    }\n    set options(options) {\n        this._config.options = options;\n    }\n    get plugins() {\n        return this._config.plugins;\n    }\n    update() {\n        const config = this._config;\n        this.clearCache();\n        initOptions(config);\n    }\n    clearCache() {\n        this._scopeCache.clear();\n        this._resolverCache.clear();\n    }\n    datasetScopeKeys(datasetType) {\n        return cachedKeys(datasetType, ()=>[\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetAnimationScopeKeys(datasetType, transition) {\n        return cachedKeys(`${datasetType}.transition.${transition}`, ()=>[\n                [\n                    `datasets.${datasetType}.transitions.${transition}`,\n                    `transitions.${transition}`\n                ],\n                [\n                    `datasets.${datasetType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    datasetElementScopeKeys(datasetType, elementType) {\n        return cachedKeys(`${datasetType}-${elementType}`, ()=>[\n                [\n                    `datasets.${datasetType}.elements.${elementType}`,\n                    `datasets.${datasetType}`,\n                    `elements.${elementType}`,\n                    \"\"\n                ]\n            ]);\n    }\n    pluginScopeKeys(plugin) {\n        const id = plugin.id;\n        const type = this.type;\n        return cachedKeys(`${type}-plugin-${id}`, ()=>[\n                [\n                    `plugins.${id}`,\n                    ...plugin.additionalOptionScopes || []\n                ]\n            ]);\n    }\n    _cachedScopes(mainScope, resetCache) {\n        const _scopeCache = this._scopeCache;\n        let cache = _scopeCache.get(mainScope);\n        if (!cache || resetCache) {\n            cache = new Map();\n            _scopeCache.set(mainScope, cache);\n        }\n        return cache;\n    }\n    getOptionScopes(mainScope, keyLists, resetCache) {\n        const { options, type } = this;\n        const cache = this._cachedScopes(mainScope, resetCache);\n        const cached = cache.get(keyLists);\n        if (cached) {\n            return cached;\n        }\n        const scopes = new Set();\n        keyLists.forEach((keys)=>{\n            if (mainScope) {\n                scopes.add(mainScope);\n                keys.forEach((key)=>addIfFound(scopes, mainScope, key));\n            }\n            keys.forEach((key)=>addIfFound(scopes, options, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {}, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d, key));\n            keys.forEach((key)=>addIfFound(scopes, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7, key));\n        });\n        const array = Array.from(scopes);\n        if (array.length === 0) {\n            array.push(Object.create(null));\n        }\n        if (keysCached.has(keyLists)) {\n            cache.set(keyLists, array);\n        }\n        return array;\n    }\n    chartOptionScopes() {\n        const { options, type } = this;\n        return [\n            options,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U[type] || {},\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type] || {},\n            {\n                type\n            },\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d,\n            _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a7\n        ];\n    }\n    resolveNamedOptions(scopes, names, context, prefixes = [\n        \"\"\n    ]) {\n        const result = {\n            $shared: true\n        };\n        const { resolver, subPrefixes } = getResolver(this._resolverCache, scopes, prefixes);\n        let options = resolver;\n        if (needContext(resolver, names)) {\n            result.$shared = false;\n            context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(context) ? context() : context;\n            const subResolver = this.createResolver(scopes, context, subPrefixes);\n            options = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, subResolver);\n        }\n        for (const prop of names){\n            result[prop] = options[prop];\n        }\n        return result;\n    }\n    createResolver(scopes, context, prefixes = [\n        \"\"\n    ], descriptorDefaults) {\n        const { resolver } = getResolver(this._resolverCache, scopes, prefixes);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(context) ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9)(resolver, context, undefined, descriptorDefaults) : resolver;\n    }\n}\nfunction getResolver(resolverCache, scopes, prefixes) {\n    let cache = resolverCache.get(scopes);\n    if (!cache) {\n        cache = new Map();\n        resolverCache.set(scopes, cache);\n    }\n    const cacheKey = prefixes.join();\n    let cached = cache.get(cacheKey);\n    if (!cached) {\n        const resolver = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa)(scopes, prefixes);\n        cached = {\n            resolver,\n            subPrefixes: prefixes.filter((p)=>!p.toLowerCase().includes(\"hover\"))\n        };\n        cache.set(cacheKey, cached);\n    }\n    return cached;\n}\nconst hasFunction = (value)=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value) && Object.getOwnPropertyNames(value).reduce((acc, key)=>acc || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value[key]), false);\nfunction needContext(proxy, names) {\n    const { isScriptable, isIndexable } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab)(proxy);\n    for (const prop of names){\n        const scriptable = isScriptable(prop);\n        const indexable = isIndexable(prop);\n        const value = (indexable || scriptable) && proxy[prop];\n        if (scriptable && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(value) || hasFunction(value)) || indexable && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(value)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar version = \"3.9.1\";\nconst KNOWN_POSITIONS = [\n    \"top\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"chartArea\"\n];\nfunction positionIsHorizontal(position, axis) {\n    return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n    return function(a, b) {\n        return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n    };\n}\nfunction onAnimationsComplete(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    chart.notifyPlugins(\"afterRender\");\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onComplete, [\n        context\n    ], chart);\n}\nfunction onAnimationProgress(context) {\n    const chart = context.chart;\n    const animationOptions = chart.options.animation;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(animationOptions && animationOptions.onProgress, [\n        context\n    ], chart);\n}\nfunction getCanvas(item) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6)() && typeof item === \"string\") {\n        item = document.getElementById(item);\n    } else if (item && item.length) {\n        item = item[0];\n    }\n    if (item && item.canvas) {\n        item = item.canvas;\n    }\n    return item;\n}\nconst instances = {};\nconst getChart = (key)=>{\n    const canvas = getCanvas(key);\n    return Object.values(instances).filter((c)=>c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n    const keys = Object.keys(obj);\n    for (const key of keys){\n        const intKey = +key;\n        if (intKey >= start) {\n            const value = obj[key];\n            delete obj[key];\n            if (move > 0 || intKey > start) {\n                obj[intKey + move] = value;\n            }\n        }\n    }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n    if (!inChartArea || e.type === \"mouseout\") {\n        return null;\n    }\n    if (isClick) {\n        return lastEvent;\n    }\n    return e;\n}\nclass Chart {\n    constructor(item, userConfig){\n        const config = this.config = new Config(userConfig);\n        const initialCanvas = getCanvas(item);\n        const existingChart = getChart(initialCanvas);\n        if (existingChart) {\n            throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"'\" + \" must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n        }\n        const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n        this.platform.updateConfig(config);\n        const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n        const canvas = context && context.canvas;\n        const height = canvas && canvas.height;\n        const width = canvas && canvas.width;\n        this.id = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad)();\n        this.ctx = context;\n        this.canvas = canvas;\n        this.width = width;\n        this.height = height;\n        this._options = options;\n        this._aspectRatio = this.aspectRatio;\n        this._layers = [];\n        this._metasets = [];\n        this._stacks = undefined;\n        this.boxes = [];\n        this.currentDevicePixelRatio = undefined;\n        this.chartArea = undefined;\n        this._active = [];\n        this._lastEvent = undefined;\n        this._listeners = {};\n        this._responsiveListeners = undefined;\n        this._sortedMetasets = [];\n        this.scales = {};\n        this._plugins = new PluginService();\n        this.$proxies = {};\n        this._hiddenIndices = {};\n        this.attached = false;\n        this._animationsDisabled = undefined;\n        this.$context = undefined;\n        this._doResize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae)((mode)=>this.update(mode), options.resizeDelay || 0);\n        this._dataChanges = [];\n        instances[this.id] = this;\n        if (!context || !canvas) {\n            console.error(\"Failed to create chart: can't acquire context from the given item\");\n            return;\n        }\n        animator.listen(this, \"complete\", onAnimationsComplete);\n        animator.listen(this, \"progress\", onAnimationProgress);\n        this._initialize();\n        if (this.attached) {\n            this.update();\n        }\n    }\n    get aspectRatio() {\n        const { options: { aspectRatio, maintainAspectRatio }, width, height, _aspectRatio } = this;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(aspectRatio)) {\n            return aspectRatio;\n        }\n        if (maintainAspectRatio && _aspectRatio) {\n            return _aspectRatio;\n        }\n        return height ? width / height : null;\n    }\n    get data() {\n        return this.config.data;\n    }\n    set data(data) {\n        this.config.data = data;\n    }\n    get options() {\n        return this._options;\n    }\n    set options(options) {\n        this.config.options = options;\n    }\n    _initialize() {\n        this.notifyPlugins(\"beforeInit\");\n        if (this.options.responsive) {\n            this.resize();\n        } else {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, this.options.devicePixelRatio);\n        }\n        this.bindEvents();\n        this.notifyPlugins(\"afterInit\");\n        return this;\n    }\n    clear() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(this.canvas, this.ctx);\n        return this;\n    }\n    stop() {\n        animator.stop(this);\n        return this;\n    }\n    resize(width, height) {\n        if (!animator.running(this)) {\n            this._resize(width, height);\n        } else {\n            this._resizeBeforeDraw = {\n                width,\n                height\n            };\n        }\n    }\n    _resize(width, height) {\n        const options = this.options;\n        const canvas = this.canvas;\n        const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n        const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n        const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n        const mode = this.width ? \"resize\" : \"attach\";\n        this.width = newSize.width;\n        this.height = newSize.height;\n        this._aspectRatio = this.aspectRatio;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af)(this, newRatio, true)) {\n            return;\n        }\n        this.notifyPlugins(\"resize\", {\n            size: newSize\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onResize, [\n            this,\n            newSize\n        ], this);\n        if (this.attached) {\n            if (this._doResize(mode)) {\n                this.render();\n            }\n        }\n    }\n    ensureScalesHaveIDs() {\n        const options = this.options;\n        const scalesOptions = options.scales || {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scalesOptions, (axisOptions, axisID)=>{\n            axisOptions.id = axisID;\n        });\n    }\n    buildOrUpdateScales() {\n        const options = this.options;\n        const scaleOpts = options.scales;\n        const scales = this.scales;\n        const updated = Object.keys(scales).reduce((obj, id)=>{\n            obj[id] = false;\n            return obj;\n        }, {});\n        let items = [];\n        if (scaleOpts) {\n            items = items.concat(Object.keys(scaleOpts).map((id)=>{\n                const scaleOptions = scaleOpts[id];\n                const axis = determineAxis(id, scaleOptions);\n                const isRadial = axis === \"r\";\n                const isHorizontal = axis === \"x\";\n                return {\n                    options: scaleOptions,\n                    dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n                    dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n                };\n            }));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(items, (item)=>{\n            const scaleOptions = item.options;\n            const id = scaleOptions.id;\n            const axis = determineAxis(id, scaleOptions);\n            const scaleType = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(scaleOptions.type, item.dtype);\n            if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n                scaleOptions.position = item.dposition;\n            }\n            updated[id] = true;\n            let scale = null;\n            if (id in scales && scales[id].type === scaleType) {\n                scale = scales[id];\n            } else {\n                const scaleClass = registry.getScale(scaleType);\n                scale = new scaleClass({\n                    id,\n                    type: scaleType,\n                    ctx: this.ctx,\n                    chart: this\n                });\n                scales[scale.id] = scale;\n            }\n            scale.init(scaleOptions, options);\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(updated, (hasUpdated, id)=>{\n            if (!hasUpdated) {\n                delete scales[id];\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(scales, (scale)=>{\n            layouts.configure(this, scale, scale.options);\n            layouts.addBox(this, scale);\n        });\n    }\n    _updateMetasets() {\n        const metasets = this._metasets;\n        const numData = this.data.datasets.length;\n        const numMeta = metasets.length;\n        metasets.sort((a, b)=>a.index - b.index);\n        if (numMeta > numData) {\n            for(let i = numData; i < numMeta; ++i){\n                this._destroyDatasetMeta(i);\n            }\n            metasets.splice(numData, numMeta - numData);\n        }\n        this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n    }\n    _removeUnreferencedMetasets() {\n        const { _metasets: metasets, data: { datasets } } = this;\n        if (metasets.length > datasets.length) {\n            delete this._stacks;\n        }\n        metasets.forEach((meta, index)=>{\n            if (datasets.filter((x)=>x === meta._dataset).length === 0) {\n                this._destroyDatasetMeta(index);\n            }\n        });\n    }\n    buildOrUpdateControllers() {\n        const newControllers = [];\n        const datasets = this.data.datasets;\n        let i, ilen;\n        this._removeUnreferencedMetasets();\n        for(i = 0, ilen = datasets.length; i < ilen; i++){\n            const dataset = datasets[i];\n            let meta = this.getDatasetMeta(i);\n            const type = dataset.type || this.config.type;\n            if (meta.type && meta.type !== type) {\n                this._destroyDatasetMeta(i);\n                meta = this.getDatasetMeta(i);\n            }\n            meta.type = type;\n            meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n            meta.order = dataset.order || 0;\n            meta.index = i;\n            meta.label = \"\" + dataset.label;\n            meta.visible = this.isDatasetVisible(i);\n            if (meta.controller) {\n                meta.controller.updateIndex(i);\n                meta.controller.linkScales();\n            } else {\n                const ControllerClass = registry.getController(type);\n                const { datasetElementType, dataElementType } = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.datasets[type];\n                Object.assign(ControllerClass.prototype, {\n                    dataElementType: registry.getElement(dataElementType),\n                    datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n                });\n                meta.controller = new ControllerClass(this, i);\n                newControllers.push(meta.controller);\n            }\n        }\n        this._updateMetasets();\n        return newControllers;\n    }\n    _resetElements() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.data.datasets, (dataset, datasetIndex)=>{\n            this.getDatasetMeta(datasetIndex).controller.reset();\n        }, this);\n    }\n    reset() {\n        this._resetElements();\n        this.notifyPlugins(\"reset\");\n    }\n    update(mode) {\n        const config = this.config;\n        config.update();\n        const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n        const animsDisabled = this._animationsDisabled = !options.animation;\n        this._updateScales();\n        this._checkEventBindings();\n        this._updateHiddenIndices();\n        this._plugins.invalidate();\n        if (this.notifyPlugins(\"beforeUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const newControllers = this.buildOrUpdateControllers();\n        this.notifyPlugins(\"beforeElementsUpdate\");\n        let minPadding = 0;\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; i++){\n            const { controller } = this.getDatasetMeta(i);\n            const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n            controller.buildOrUpdateElements(reset);\n            minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n        }\n        minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n        this._updateLayout(minPadding);\n        if (!animsDisabled) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(newControllers, (controller)=>{\n                controller.reset();\n            });\n        }\n        this._updateDatasets(mode);\n        this.notifyPlugins(\"afterUpdate\", {\n            mode\n        });\n        this._layers.sort(compare2Level(\"z\", \"_idx\"));\n        const { _active, _lastEvent } = this;\n        if (_lastEvent) {\n            this._eventHandler(_lastEvent, true);\n        } else if (_active.length) {\n            this._updateHoverStyles(_active, _active, true);\n        }\n        this.render();\n    }\n    _updateScales() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.scales, (scale)=>{\n            layouts.removeBox(this, scale);\n        });\n        this.ensureScalesHaveIDs();\n        this.buildOrUpdateScales();\n    }\n    _checkEventBindings() {\n        const options = this.options;\n        const existingEvents = new Set(Object.keys(this._listeners));\n        const newEvents = new Set(options.events);\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n            this.unbindEvents();\n            this.bindEvents();\n        }\n    }\n    _updateHiddenIndices() {\n        const { _hiddenIndices } = this;\n        const changes = this._getUniformDataChanges() || [];\n        for (const { method, start, count } of changes){\n            const move = method === \"_removeElements\" ? -count : count;\n            moveNumericKeys(_hiddenIndices, start, move);\n        }\n    }\n    _getUniformDataChanges() {\n        const _dataChanges = this._dataChanges;\n        if (!_dataChanges || !_dataChanges.length) {\n            return;\n        }\n        this._dataChanges = [];\n        const datasetCount = this.data.datasets.length;\n        const makeSet = (idx)=>new Set(_dataChanges.filter((c)=>c[0] === idx).map((c, i)=>i + \",\" + c.splice(1).join(\",\")));\n        const changeSet = makeSet(0);\n        for(let i = 1; i < datasetCount; i++){\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah)(changeSet, makeSet(i))) {\n                return;\n            }\n        }\n        return Array.from(changeSet).map((c)=>c.split(\",\")).map((a)=>({\n                method: a[1],\n                start: +a[2],\n                count: +a[3]\n            }));\n    }\n    _updateLayout(minPadding) {\n        if (this.notifyPlugins(\"beforeLayout\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        layouts.update(this, this.width, this.height, minPadding);\n        const area = this.chartArea;\n        const noArea = area.width <= 0 || area.height <= 0;\n        this._layers = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.boxes, (box)=>{\n            if (noArea && box.position === \"chartArea\") {\n                return;\n            }\n            if (box.configure) {\n                box.configure();\n            }\n            this._layers.push(...box._layers());\n        }, this);\n        this._layers.forEach((item, index)=>{\n            item._idx = index;\n        });\n        this.notifyPlugins(\"afterLayout\");\n    }\n    _updateDatasets(mode) {\n        if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n            mode,\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this.getDatasetMeta(i).controller.configure();\n        }\n        for(let i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._updateDataset(i, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8)(mode) ? mode({\n                datasetIndex: i\n            }) : mode);\n        }\n        this.notifyPlugins(\"afterDatasetsUpdate\", {\n            mode\n        });\n    }\n    _updateDataset(index, mode) {\n        const meta = this.getDatasetMeta(index);\n        const args = {\n            meta,\n            index,\n            mode,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n            return;\n        }\n        meta.controller._update(mode);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetUpdate\", args);\n    }\n    render() {\n        if (this.notifyPlugins(\"beforeRender\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        if (animator.has(this)) {\n            if (this.attached && !animator.running(this)) {\n                animator.start(this);\n            }\n        } else {\n            this.draw();\n            onAnimationsComplete({\n                chart: this\n            });\n        }\n    }\n    draw() {\n        let i;\n        if (this._resizeBeforeDraw) {\n            const { width, height } = this._resizeBeforeDraw;\n            this._resize(width, height);\n            this._resizeBeforeDraw = null;\n        }\n        this.clear();\n        if (this.width <= 0 || this.height <= 0) {\n            return;\n        }\n        if (this.notifyPlugins(\"beforeDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const layers = this._layers;\n        for(i = 0; i < layers.length && layers[i].z <= 0; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this._drawDatasets();\n        for(; i < layers.length; ++i){\n            layers[i].draw(this.chartArea);\n        }\n        this.notifyPlugins(\"afterDraw\");\n    }\n    _getSortedDatasetMetas(filterVisible) {\n        const metasets = this._sortedMetasets;\n        const result = [];\n        let i, ilen;\n        for(i = 0, ilen = metasets.length; i < ilen; ++i){\n            const meta = metasets[i];\n            if (!filterVisible || meta.visible) {\n                result.push(meta);\n            }\n        }\n        return result;\n    }\n    getSortedVisibleDatasetMetas() {\n        return this._getSortedDatasetMetas(true);\n    }\n    _drawDatasets() {\n        if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n            cancelable: true\n        }) === false) {\n            return;\n        }\n        const metasets = this.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            this._drawDataset(metasets[i]);\n        }\n        this.notifyPlugins(\"afterDatasetsDraw\");\n    }\n    _drawDataset(meta) {\n        const ctx = this.ctx;\n        const clip = meta._clip;\n        const useClip = !clip.disabled;\n        const area = this.chartArea;\n        const args = {\n            meta,\n            index: meta.index,\n            cancelable: true\n        };\n        if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n            return;\n        }\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, {\n                left: clip.left === false ? 0 : area.left - clip.left,\n                right: clip.right === false ? this.width : area.right + clip.right,\n                top: clip.top === false ? 0 : area.top - clip.top,\n                bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n            });\n        }\n        meta.controller.draw();\n        if (useClip) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n        args.cancelable = false;\n        this.notifyPlugins(\"afterDatasetDraw\", args);\n    }\n    isPointInArea(point) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(point, this.chartArea, this._minPadding);\n    }\n    getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n        const method = Interaction.modes[mode];\n        if (typeof method === \"function\") {\n            return method(this, e, options, useFinalPosition);\n        }\n        return [];\n    }\n    getDatasetMeta(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        const metasets = this._metasets;\n        let meta = metasets.filter((x)=>x && x._dataset === dataset).pop();\n        if (!meta) {\n            meta = {\n                type: null,\n                data: [],\n                dataset: null,\n                controller: null,\n                hidden: null,\n                xAxisID: null,\n                yAxisID: null,\n                order: dataset && dataset.order || 0,\n                index: datasetIndex,\n                _dataset: dataset,\n                _parsed: [],\n                _sorted: false\n            };\n            metasets.push(meta);\n        }\n        return meta;\n    }\n    getContext() {\n        return this.$context || (this.$context = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(null, {\n            chart: this,\n            type: \"chart\"\n        }));\n    }\n    getVisibleDatasetCount() {\n        return this.getSortedVisibleDatasetMetas().length;\n    }\n    isDatasetVisible(datasetIndex) {\n        const dataset = this.data.datasets[datasetIndex];\n        if (!dataset) {\n            return false;\n        }\n        const meta = this.getDatasetMeta(datasetIndex);\n        return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n    }\n    setDatasetVisibility(datasetIndex, visible) {\n        const meta = this.getDatasetMeta(datasetIndex);\n        meta.hidden = !visible;\n    }\n    toggleDataVisibility(index) {\n        this._hiddenIndices[index] = !this._hiddenIndices[index];\n    }\n    getDataVisibility(index) {\n        return !this._hiddenIndices[index];\n    }\n    _updateVisibility(datasetIndex, dataIndex, visible) {\n        const mode = visible ? \"show\" : \"hide\";\n        const meta = this.getDatasetMeta(datasetIndex);\n        const anims = meta.controller._resolveAnimations(undefined, mode);\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j)(dataIndex)) {\n            meta.data[dataIndex].hidden = !visible;\n            this.update();\n        } else {\n            this.setDatasetVisibility(datasetIndex, visible);\n            anims.update(meta, {\n                visible\n            });\n            this.update((ctx)=>ctx.datasetIndex === datasetIndex ? mode : undefined);\n        }\n    }\n    hide(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, false);\n    }\n    show(datasetIndex, dataIndex) {\n        this._updateVisibility(datasetIndex, dataIndex, true);\n    }\n    _destroyDatasetMeta(datasetIndex) {\n        const meta = this._metasets[datasetIndex];\n        if (meta && meta.controller) {\n            meta.controller._destroy();\n        }\n        delete this._metasets[datasetIndex];\n    }\n    _stop() {\n        let i, ilen;\n        this.stop();\n        animator.remove(this);\n        for(i = 0, ilen = this.data.datasets.length; i < ilen; ++i){\n            this._destroyDatasetMeta(i);\n        }\n    }\n    destroy() {\n        this.notifyPlugins(\"beforeDestroy\");\n        const { canvas, ctx } = this;\n        this._stop();\n        this.config.clearCache();\n        if (canvas) {\n            this.unbindEvents();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag)(canvas, ctx);\n            this.platform.releaseContext(ctx);\n            this.canvas = null;\n            this.ctx = null;\n        }\n        this.notifyPlugins(\"destroy\");\n        delete instances[this.id];\n        this.notifyPlugins(\"afterDestroy\");\n    }\n    toBase64Image(...args) {\n        return this.canvas.toDataURL(...args);\n    }\n    bindEvents() {\n        this.bindUserEvents();\n        if (this.options.responsive) {\n            this.bindResponsiveEvents();\n        } else {\n            this.attached = true;\n        }\n    }\n    bindUserEvents() {\n        const listeners = this._listeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const listener = (e, x, y)=>{\n            e.offsetX = x;\n            e.offsetY = y;\n            this._eventHandler(e);\n        };\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.options.events, (type)=>_add(type, listener));\n    }\n    bindResponsiveEvents() {\n        if (!this._responsiveListeners) {\n            this._responsiveListeners = {};\n        }\n        const listeners = this._responsiveListeners;\n        const platform = this.platform;\n        const _add = (type, listener)=>{\n            platform.addEventListener(this, type, listener);\n            listeners[type] = listener;\n        };\n        const _remove = (type, listener)=>{\n            if (listeners[type]) {\n                platform.removeEventListener(this, type, listener);\n                delete listeners[type];\n            }\n        };\n        const listener = (width, height)=>{\n            if (this.canvas) {\n                this.resize(width, height);\n            }\n        };\n        let detached;\n        const attached = ()=>{\n            _remove(\"attach\", attached);\n            this.attached = true;\n            this.resize();\n            _add(\"resize\", listener);\n            _add(\"detach\", detached);\n        };\n        detached = ()=>{\n            this.attached = false;\n            _remove(\"resize\", listener);\n            this._stop();\n            this._resize(0, 0);\n            _add(\"attach\", attached);\n        };\n        if (platform.isAttached(this.canvas)) {\n            attached();\n        } else {\n            detached();\n        }\n    }\n    unbindEvents() {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._listeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._listeners = {};\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this._responsiveListeners, (listener, type)=>{\n            this.platform.removeEventListener(this, type, listener);\n        });\n        this._responsiveListeners = undefined;\n    }\n    updateHoverStyle(items, mode, enabled) {\n        const prefix = enabled ? \"set\" : \"remove\";\n        let meta, item, i, ilen;\n        if (mode === \"dataset\") {\n            meta = this.getDatasetMeta(items[0].datasetIndex);\n            meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            item = items[i];\n            const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n            if (controller) {\n                controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n            }\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements) {\n        const lastActive = this._active || [];\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"No dataset found at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed) {\n            this._active = active;\n            this._lastEvent = null;\n            this._updateHoverStyles(active, lastActive);\n        }\n    }\n    notifyPlugins(hook, args, filter) {\n        return this._plugins.notify(this, hook, args, filter);\n    }\n    _updateHoverStyles(active, lastActive, replay) {\n        const hoverOptions = this.options.hover;\n        const diff = (a, b)=>a.filter((x)=>!b.some((y)=>x.datasetIndex === y.datasetIndex && x.index === y.index));\n        const deactivated = diff(lastActive, active);\n        const activated = replay ? active : diff(active, lastActive);\n        if (deactivated.length) {\n            this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n        }\n        if (activated.length && hoverOptions.mode) {\n            this.updateHoverStyle(activated, hoverOptions.mode, true);\n        }\n    }\n    _eventHandler(e, replay) {\n        const args = {\n            event: e,\n            replay,\n            cancelable: true,\n            inChartArea: this.isPointInArea(e)\n        };\n        const eventFilter = (plugin)=>(plugin.options.events || this.options.events).includes(e.native.type);\n        if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n            return;\n        }\n        const changed = this._handleEvent(e, replay, args.inChartArea);\n        args.cancelable = false;\n        this.notifyPlugins(\"afterEvent\", args, eventFilter);\n        if (changed || args.changed) {\n            this.render();\n        }\n        return this;\n    }\n    _handleEvent(e, replay, inChartArea) {\n        const { _active: lastActive = [], options } = this;\n        const useFinalPosition = replay;\n        const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n        const isClick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj)(e);\n        const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n        if (inChartArea) {\n            this._lastEvent = null;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onHover, [\n                e,\n                active,\n                this\n            ], this);\n            if (isClick) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(options.onClick, [\n                    e,\n                    active,\n                    this\n                ], this);\n            }\n        }\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive);\n        if (changed || replay) {\n            this._active = active;\n            this._updateHoverStyles(active, lastActive, replay);\n        }\n        this._lastEvent = lastEvent;\n        return changed;\n    }\n    _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const hoverOptions = this.options.hover;\n        return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n    }\n}\nconst invalidatePlugins = ()=>(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(Chart.instances, (chart)=>chart._plugins.invalidate());\nconst enumerable = true;\nObject.defineProperties(Chart, {\n    defaults: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d\n    },\n    instances: {\n        enumerable,\n        value: instances\n    },\n    overrides: {\n        enumerable,\n        value: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.U\n    },\n    registry: {\n        enumerable,\n        value: registry\n    },\n    version: {\n        enumerable,\n        value: version\n    },\n    getChart: {\n        enumerable,\n        value: getChart\n    },\n    register: {\n        enumerable,\n        value: (...items)=>{\n            registry.add(...items);\n            invalidatePlugins();\n        }\n    },\n    unregister: {\n        enumerable,\n        value: (...items)=>{\n            registry.remove(...items);\n            invalidatePlugins();\n        }\n    }\n});\nfunction clipArc(ctx, element, endAngle) {\n    const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } = element;\n    let angleMargin = pixelMargin / outerRadius;\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n    if (innerRadius > pixelMargin) {\n        angleMargin = pixelMargin / innerRadius;\n        ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n    } else {\n        ctx.arc(x, y, pixelMargin, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n    }\n    ctx.closePath();\n    ctx.clip();\n}\nfunction toRadiusCorners(value) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al)(value, [\n        \"outerStart\",\n        \"outerEnd\",\n        \"innerStart\",\n        \"innerEnd\"\n    ]);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n    const o = toRadiusCorners(arc.options.borderRadius);\n    const halfThickness = (outerRadius - innerRadius) / 2;\n    const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n    const computeOuterLimit = (val)=>{\n        const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(val, 0, Math.min(halfThickness, outerArcLimit));\n    };\n    return {\n        outerStart: computeOuterLimit(o.outerStart),\n        outerEnd: computeOuterLimit(o.outerEnd),\n        innerStart: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerStart, 0, innerLimit),\n        innerEnd: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(o.innerEnd, 0, innerLimit)\n    };\n}\nfunction rThetaToXY(r, theta, x, y) {\n    return {\n        x: x + r * Math.cos(theta),\n        y: y + r * Math.sin(theta)\n    };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n    const { x, y, startAngle: start, pixelMargin, innerRadius: innerR } = element;\n    const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n    const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n    let spacingOffset = 0;\n    const alpha = end - start;\n    if (spacing) {\n        const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n        const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n        const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n        const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;\n        spacingOffset = (alpha - adjustedAngle) / 2;\n    }\n    const beta = Math.max(0.001, alpha * outerRadius - offset / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) / outerRadius;\n    const angleOffset = (alpha - beta) / 2;\n    const startAngle = start + angleOffset + spacingOffset;\n    const endAngle = end - angleOffset - spacingOffset;\n    const { outerStart, outerEnd, innerStart, innerEnd } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n    const outerStartAdjustedRadius = outerRadius - outerStart;\n    const outerEndAdjustedRadius = outerRadius - outerEnd;\n    const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n    const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n    const innerStartAdjustedRadius = innerRadius + innerStart;\n    const innerEndAdjustedRadius = innerRadius + innerEnd;\n    const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n    const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n    ctx.beginPath();\n    if (circular) {\n        ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerEndAdjustedAngle);\n        if (outerEnd > 0) {\n            const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n        ctx.lineTo(p4.x, p4.y);\n        if (innerEnd > 0) {\n            const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, innerEndAdjustedAngle + Math.PI);\n        }\n        ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, startAngle + innerStart / innerRadius, true);\n        if (innerStart > 0) {\n            const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H);\n        }\n        const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n        ctx.lineTo(p8.x, p8.y);\n        if (outerStart > 0) {\n            const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n            ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H, outerStartAdjustedAngle);\n        }\n    } else {\n        ctx.moveTo(x, y);\n        const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n        const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerStartX, outerStartY);\n        const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n        const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n        ctx.lineTo(outerEndX, outerEndY);\n    }\n    ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n    const { fullCircles, startAngle, circumference } = element;\n    let endAngle = element.endAngle;\n    if (fullCircles) {\n        pathArc(ctx, element, offset, spacing, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, circular);\n        for(let i = 0; i < fullCircles; ++i){\n            ctx.fill();\n        }\n        if (!isNaN(circumference)) {\n            endAngle = startAngle + circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            if (circumference % _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T === 0) {\n                endAngle += _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T;\n            }\n        }\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.fill();\n    return endAngle;\n}\nfunction drawFullCircleBorders(ctx, element, inner) {\n    const { x, y, startAngle, pixelMargin, fullCircles } = element;\n    const outerRadius = Math.max(element.outerRadius - pixelMargin, 0);\n    const innerRadius = element.innerRadius + pixelMargin;\n    let i;\n    if (inner) {\n        clipArc(ctx, element, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, innerRadius, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T, startAngle, true);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n    ctx.beginPath();\n    ctx.arc(x, y, outerRadius, startAngle, startAngle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    for(i = 0; i < fullCircles; ++i){\n        ctx.stroke();\n    }\n}\nfunction drawBorder(ctx, element, offset, spacing, endAngle, circular) {\n    const { options } = element;\n    const { borderWidth, borderJoinStyle } = options;\n    const inner = options.borderAlign === \"inner\";\n    if (!borderWidth) {\n        return;\n    }\n    if (inner) {\n        ctx.lineWidth = borderWidth * 2;\n        ctx.lineJoin = borderJoinStyle || \"round\";\n    } else {\n        ctx.lineWidth = borderWidth;\n        ctx.lineJoin = borderJoinStyle || \"bevel\";\n    }\n    if (element.fullCircles) {\n        drawFullCircleBorders(ctx, element, inner);\n    }\n    if (inner) {\n        clipArc(ctx, element, endAngle);\n    }\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n}\nclass ArcElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.circumference = undefined;\n        this.startAngle = undefined;\n        this.endAngle = undefined;\n        this.innerRadius = undefined;\n        this.outerRadius = undefined;\n        this.pixelMargin = 0;\n        this.fullCircles = 0;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(chartX, chartY, useFinalPosition) {\n        const point = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        const { angle, distance } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0)(point, {\n            x: chartX,\n            y: chartY\n        });\n        const { startAngle, endAngle, innerRadius, outerRadius, circumference } = this.getProps([\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const rAdjust = this.options.spacing / 2;\n        const _circumference = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(circumference, endAngle - startAngle);\n        const betweenAngles = _circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p)(angle, startAngle, endAngle);\n        const withinRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n        return betweenAngles && withinRadius;\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, startAngle, endAngle, innerRadius, outerRadius } = this.getProps([\n            \"x\",\n            \"y\",\n            \"startAngle\",\n            \"endAngle\",\n            \"innerRadius\",\n            \"outerRadius\",\n            \"circumference\"\n        ], useFinalPosition);\n        const { offset, spacing } = this.options;\n        const halfAngle = (startAngle + endAngle) / 2;\n        const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n        return {\n            x: x + Math.cos(halfAngle) * halfRadius,\n            y: y + Math.sin(halfAngle) * halfRadius\n        };\n    }\n    tooltipPosition(useFinalPosition) {\n        return this.getCenterPoint(useFinalPosition);\n    }\n    draw(ctx) {\n        const { options, circumference } = this;\n        const offset = (options.offset || 0) / 2;\n        const spacing = (options.spacing || 0) / 2;\n        const circular = options.circular;\n        this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n        this.fullCircles = circumference > _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T ? Math.floor(circumference / _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T) : 0;\n        if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n            return;\n        }\n        ctx.save();\n        let radiusOffset = 0;\n        if (offset) {\n            radiusOffset = offset / 2;\n            const halfAngle = (this.startAngle + this.endAngle) / 2;\n            ctx.translate(Math.cos(halfAngle) * radiusOffset, Math.sin(halfAngle) * radiusOffset);\n            if (this.circumference >= _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P) {\n                radiusOffset = offset;\n            }\n        }\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        const endAngle = drawArc(ctx, this, radiusOffset, spacing, circular);\n        drawBorder(ctx, this, radiusOffset, spacing, endAngle, circular);\n        ctx.restore();\n    }\n}\nArcElement.id = \"arc\";\nArcElement.defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true\n};\nArcElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n};\nfunction setStyle(ctx, options, style = options) {\n    ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderCapStyle, options.borderCapStyle);\n    ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDash, options.borderDash));\n    ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderDashOffset, options.borderDashOffset);\n    ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderJoinStyle, options.borderJoinStyle);\n    ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderWidth, options.borderWidth);\n    ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n    ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at;\n    }\n    return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n    const count = points.length;\n    const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;\n    const { start: segmentStart, end: segmentEnd } = segment;\n    const start = Math.max(paramsStart, segmentStart);\n    const end = Math.min(paramsEnd, segmentEnd);\n    const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n    return {\n        count,\n        start,\n        loop: segment.loop,\n        ilen: end < start && !outside ? count + end - start : end - start\n    };\n}\nfunction pathSegment(ctx, line, segment, params) {\n    const { points, options } = line;\n    const { count, start, loop, ilen } = pathVars(points, segment, params);\n    const lineMethod = getLineMethod(options);\n    let { move = true, reverse } = params || {};\n    let i, point, prev;\n    for(i = 0; i <= ilen; ++i){\n        point = points[(start + (reverse ? ilen - i : i)) % count];\n        if (point.skip) {\n            continue;\n        } else if (move) {\n            ctx.moveTo(point.x, point.y);\n            move = false;\n        } else {\n            lineMethod(ctx, prev, point, reverse, options.stepped);\n        }\n        prev = point;\n    }\n    if (loop) {\n        point = points[(start + (reverse ? ilen : 0)) % count];\n        lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n    const points = line.points;\n    const { count, start, ilen } = pathVars(points, segment, params);\n    const { move = true, reverse } = params || {};\n    let avgX = 0;\n    let countX = 0;\n    let i, point, prevX, minY, maxY, lastY;\n    const pointIndex = (index)=>(start + (reverse ? ilen - index : index)) % count;\n    const drawX = ()=>{\n        if (minY !== maxY) {\n            ctx.lineTo(avgX, maxY);\n            ctx.lineTo(avgX, minY);\n            ctx.lineTo(avgX, lastY);\n        }\n    };\n    if (move) {\n        point = points[pointIndex(0)];\n        ctx.moveTo(point.x, point.y);\n    }\n    for(i = 0; i <= ilen; ++i){\n        point = points[pointIndex(i)];\n        if (point.skip) {\n            continue;\n        }\n        const x = point.x;\n        const y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n            } else if (y > maxY) {\n                maxY = y;\n            }\n            avgX = (countX * avgX + x) / ++countX;\n        } else {\n            drawX();\n            ctx.lineTo(x, y);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n        }\n        lastY = y;\n    }\n    drawX();\n}\nfunction _getSegmentMethod(line) {\n    const opts = line.options;\n    const borderDash = opts.borderDash && opts.borderDash.length;\n    const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n    return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n    if (options.stepped) {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap;\n    }\n    if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n        return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq;\n    }\n    return _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n    let path = line._path;\n    if (!path) {\n        path = line._path = new Path2D();\n        if (line.path(path, start, count)) {\n            path.closePath();\n        }\n    }\n    setStyle(ctx, line.options);\n    ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n    const { segments, options } = line;\n    const segmentMethod = _getSegmentMethod(line);\n    for (const segment of segments){\n        setStyle(ctx, options, segment.style);\n        ctx.beginPath();\n        if (segmentMethod(ctx, line, segment, {\n            start,\n            end: start + count - 1\n        })) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n    }\n}\nconst usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n    if (usePath2D && !line.options.segment) {\n        strokePathWithCache(ctx, line, start, count);\n    } else {\n        strokePathDirect(ctx, line, start, count);\n    }\n}\nclass LineElement extends Element {\n    constructor(cfg){\n        super();\n        this.animated = true;\n        this.options = undefined;\n        this._chart = undefined;\n        this._loop = undefined;\n        this._fullLoop = undefined;\n        this._path = undefined;\n        this._points = undefined;\n        this._segments = undefined;\n        this._decimated = false;\n        this._pointsUpdated = false;\n        this._datasetIndex = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    updateControlPoints(chartArea, indexAxis) {\n        const options = this.options;\n        if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n            const loop = options.spanGaps ? this._loop : this._fullLoop;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am)(this._points, options, chartArea, loop, indexAxis);\n            this._pointsUpdated = true;\n        }\n    }\n    set points(points) {\n        this._points = points;\n        delete this._segments;\n        delete this._path;\n        this._pointsUpdated = false;\n    }\n    get points() {\n        return this._points;\n    }\n    get segments() {\n        return this._segments || (this._segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an)(this, this.options.segment));\n    }\n    first() {\n        const segments = this.segments;\n        const points = this.points;\n        return segments.length && points[segments[0].start];\n    }\n    last() {\n        const segments = this.segments;\n        const points = this.points;\n        const count = segments.length;\n        return count && points[segments[count - 1].end];\n    }\n    interpolate(point, property) {\n        const options = this.options;\n        const value = point[property];\n        const points = this.points;\n        const segments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(this, {\n            property,\n            start: value,\n            end: value\n        });\n        if (!segments.length) {\n            return;\n        }\n        const result = [];\n        const _interpolate = _getInterpolationMethod(options);\n        let i, ilen;\n        for(i = 0, ilen = segments.length; i < ilen; ++i){\n            const { start, end } = segments[i];\n            const p1 = points[start];\n            const p2 = points[end];\n            if (p1 === p2) {\n                result.push(p1);\n                continue;\n            }\n            const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n            const interpolated = _interpolate(p1, p2, t, options.stepped);\n            interpolated[property] = point[property];\n            result.push(interpolated);\n        }\n        return result.length === 1 ? result[0] : result;\n    }\n    pathSegment(ctx, segment, params) {\n        const segmentMethod = _getSegmentMethod(this);\n        return segmentMethod(ctx, this, segment, params);\n    }\n    path(ctx, start, count) {\n        const segments = this.segments;\n        const segmentMethod = _getSegmentMethod(this);\n        let loop = this._loop;\n        start = start || 0;\n        count = count || this.points.length - start;\n        for (const segment of segments){\n            loop &= segmentMethod(ctx, this, segment, {\n                start,\n                end: start + count - 1\n            });\n        }\n        return !!loop;\n    }\n    draw(ctx, chartArea, start, count) {\n        const options = this.options || {};\n        const points = this.points || [];\n        if (points.length && options.borderWidth) {\n            ctx.save();\n            draw(ctx, this, start, count);\n            ctx.restore();\n        }\n        if (this.animated) {\n            this._pointsUpdated = false;\n            this._path = undefined;\n        }\n    }\n}\nLineElement.id = \"line\";\nLineElement.defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n};\nLineElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nLineElement.descriptors = {\n    _scriptable: true,\n    _indexable: (name)=>name !== \"borderDash\" && name !== \"fill\"\n};\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n    const options = el.options;\n    const { [axis]: value } = el.getProps([\n        axis\n    ], useFinalPosition);\n    return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nclass PointElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.parsed = undefined;\n        this.skip = undefined;\n        this.stop = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        const options = this.options;\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange$1(this, mouseX, \"x\", useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange$1(this, mouseY, \"y\", useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y } = this.getProps([\n            \"x\",\n            \"y\"\n        ], useFinalPosition);\n        return {\n            x,\n            y\n        };\n    }\n    size(options) {\n        options = options || this.options || {};\n        let radius = options.radius || 0;\n        radius = Math.max(radius, radius && options.hoverRadius || 0);\n        const borderWidth = radius && options.borderWidth || 0;\n        return (radius + borderWidth) * 2;\n    }\n    draw(ctx, area) {\n        const options = this.options;\n        if (this.skip || options.radius < 0.1 || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$)(this, area, this.size(options) / 2)) {\n            return;\n        }\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.fillStyle = options.backgroundColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, options, this.x, this.y);\n    }\n    getRange() {\n        const options = this.options || {};\n        return options.radius + options.hitRadius;\n    }\n}\nPointElement.id = \"point\";\nPointElement.defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n};\nPointElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nfunction getBarBounds(bar, useFinalPosition) {\n    const { x, y, base, width, height } = bar.getProps([\n        \"x\",\n        \"y\",\n        \"base\",\n        \"width\",\n        \"height\"\n    ], useFinalPosition);\n    let left, right, top, bottom, half;\n    if (bar.horizontal) {\n        half = height / 2;\n        left = Math.min(x, base);\n        right = Math.max(x, base);\n        top = y - half;\n        bottom = y + half;\n    } else {\n        half = width / 2;\n        left = x - half;\n        right = x + half;\n        top = Math.min(y, base);\n        bottom = Math.max(y, base);\n    }\n    return {\n        left,\n        top,\n        right,\n        bottom\n    };\n}\nfunction skipOrLimit(skip, value, min, max) {\n    return skip ? 0 : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n    const value = bar.options.borderWidth;\n    const skip = bar.borderSkipped;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw)(value);\n    return {\n        t: skipOrLimit(skip.top, o.top, 0, maxH),\n        r: skipOrLimit(skip.right, o.right, 0, maxW),\n        b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n        l: skipOrLimit(skip.left, o.left, 0, maxW)\n    };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n    const { enableBorderRadius } = bar.getProps([\n        \"enableBorderRadius\"\n    ]);\n    const value = bar.options.borderRadius;\n    const o = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(value);\n    const maxR = Math.min(maxW, maxH);\n    const skip = bar.borderSkipped;\n    const enableBorder = enableBorderRadius || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(value);\n    return {\n        topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n        topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n        bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n        bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n    };\n}\nfunction boundingRects(bar) {\n    const bounds = getBarBounds(bar);\n    const width = bounds.right - bounds.left;\n    const height = bounds.bottom - bounds.top;\n    const border = parseBorderWidth(bar, width / 2, height / 2);\n    const radius = parseBorderRadius(bar, width / 2, height / 2);\n    return {\n        outer: {\n            x: bounds.left,\n            y: bounds.top,\n            w: width,\n            h: height,\n            radius\n        },\n        inner: {\n            x: bounds.left + border.l,\n            y: bounds.top + border.t,\n            w: width - border.l - border.r,\n            h: height - border.t - border.b,\n            radius: {\n                topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n                topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n                bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n                bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n            }\n        }\n    };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n    const skipX = x === null;\n    const skipY = y === null;\n    const skipBoth = skipX && skipY;\n    const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n    return bounds && (skipX || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, bounds.left, bounds.right)) && (skipY || (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n    return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n    ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n    const x = rect.x !== refRect.x ? -amount : 0;\n    const y = rect.y !== refRect.y ? -amount : 0;\n    const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n    const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n    return {\n        x: rect.x + x,\n        y: rect.y + y,\n        w: rect.w + w,\n        h: rect.h + h,\n        radius: rect.radius\n    };\n}\nclass BarElement extends Element {\n    constructor(cfg){\n        super();\n        this.options = undefined;\n        this.horizontal = undefined;\n        this.base = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.inflateAmount = undefined;\n        if (cfg) {\n            Object.assign(this, cfg);\n        }\n    }\n    draw(ctx) {\n        const { inflateAmount, options: { borderColor, backgroundColor } } = this;\n        const { inner, outer } = boundingRects(this);\n        const addRectPath = hasRadius(outer.radius) ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av : addNormalRectPath;\n        ctx.save();\n        if (outer.w !== inner.w || outer.h !== inner.h) {\n            ctx.beginPath();\n            addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n            ctx.clip();\n            addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n            ctx.fillStyle = borderColor;\n            ctx.fill(\"evenodd\");\n        }\n        ctx.beginPath();\n        addRectPath(ctx, inflateRect(inner, inflateAmount));\n        ctx.fillStyle = backgroundColor;\n        ctx.fill();\n        ctx.restore();\n    }\n    inRange(mouseX, mouseY, useFinalPosition) {\n        return inRange(this, mouseX, mouseY, useFinalPosition);\n    }\n    inXRange(mouseX, useFinalPosition) {\n        return inRange(this, mouseX, null, useFinalPosition);\n    }\n    inYRange(mouseY, useFinalPosition) {\n        return inRange(this, null, mouseY, useFinalPosition);\n    }\n    getCenterPoint(useFinalPosition) {\n        const { x, y, base, horizontal } = this.getProps([\n            \"x\",\n            \"y\",\n            \"base\",\n            \"horizontal\"\n        ], useFinalPosition);\n        return {\n            x: horizontal ? (x + base) / 2 : x,\n            y: horizontal ? y : (y + base) / 2\n        };\n    }\n    getRange(axis) {\n        return axis === \"x\" ? this.width / 2 : this.height / 2;\n    }\n}\nBarElement.id = \"bar\";\nBarElement.defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: undefined\n};\nBarElement.defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n};\nvar elements = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ArcElement: ArcElement,\n    LineElement: LineElement,\n    PointElement: PointElement,\n    BarElement: BarElement\n});\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n    const samples = options.samples || availableWidth;\n    if (samples >= count) {\n        return data.slice(start, start + count);\n    }\n    const decimated = [];\n    const bucketWidth = (count - 2) / (samples - 2);\n    let sampledIndex = 0;\n    const endIndex = start + count - 1;\n    let a = start;\n    let i, maxAreaPoint, maxArea, area, nextA;\n    decimated[sampledIndex++] = data[a];\n    for(i = 0; i < samples - 2; i++){\n        let avgX = 0;\n        let avgY = 0;\n        let j;\n        const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n        const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n        const avgRangeLength = avgRangeEnd - avgRangeStart;\n        for(j = avgRangeStart; j < avgRangeEnd; j++){\n            avgX += data[j].x;\n            avgY += data[j].y;\n        }\n        avgX /= avgRangeLength;\n        avgY /= avgRangeLength;\n        const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n        const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n        const { x: pointAx, y: pointAy } = data[a];\n        maxArea = area = -1;\n        for(j = rangeOffs; j < rangeTo; j++){\n            area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n            if (area > maxArea) {\n                maxArea = area;\n                maxAreaPoint = data[j];\n                nextA = j;\n            }\n        }\n        decimated[sampledIndex++] = maxAreaPoint;\n        a = nextA;\n    }\n    decimated[sampledIndex++] = data[endIndex];\n    return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n    let avgX = 0;\n    let countX = 0;\n    let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n    const decimated = [];\n    const endIndex = start + count - 1;\n    const xMin = data[start].x;\n    const xMax = data[endIndex].x;\n    const dx = xMax - xMin;\n    for(i = start; i < start + count; ++i){\n        point = data[i];\n        x = (point.x - xMin) / dx * availableWidth;\n        y = point.y;\n        const truncX = x | 0;\n        if (truncX === prevX) {\n            if (y < minY) {\n                minY = y;\n                minIndex = i;\n            } else if (y > maxY) {\n                maxY = y;\n                maxIndex = i;\n            }\n            avgX = (countX * avgX + point.x) / ++countX;\n        } else {\n            const lastIndex = i - 1;\n            if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(minIndex) && !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(maxIndex)) {\n                const intermediateIndex1 = Math.min(minIndex, maxIndex);\n                const intermediateIndex2 = Math.max(minIndex, maxIndex);\n                if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex1],\n                        x: avgX\n                    });\n                }\n                if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n                    decimated.push({\n                        ...data[intermediateIndex2],\n                        x: avgX\n                    });\n                }\n            }\n            if (i > 0 && lastIndex !== startIndex) {\n                decimated.push(data[lastIndex]);\n            }\n            decimated.push(point);\n            prevX = truncX;\n            countX = 0;\n            minY = maxY = y;\n            minIndex = maxIndex = startIndex = i;\n        }\n    }\n    return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n    if (dataset._decimated) {\n        const data = dataset._data;\n        delete dataset._decimated;\n        delete dataset._data;\n        Object.defineProperty(dataset, \"data\", {\n            value: data\n        });\n    }\n}\nfunction cleanDecimatedData(chart) {\n    chart.data.datasets.forEach((dataset)=>{\n        cleanDecimatedDataset(dataset);\n    });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n    const pointCount = points.length;\n    let start = 0;\n    let count;\n    const { iScale } = meta;\n    const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n    if (minDefined) {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, min).lo, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n        count = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n    } else {\n        count = pointCount - start;\n    }\n    return {\n        start,\n        count\n    };\n}\nvar plugin_decimation = {\n    id: \"decimation\",\n    defaults: {\n        algorithm: \"min-max\",\n        enabled: false\n    },\n    beforeElementsUpdate: (chart, args, options)=>{\n        if (!options.enabled) {\n            cleanDecimatedData(chart);\n            return;\n        }\n        const availableWidth = chart.width;\n        chart.data.datasets.forEach((dataset, datasetIndex)=>{\n            const { _data, indexAxis } = dataset;\n            const meta = chart.getDatasetMeta(datasetIndex);\n            const data = _data || dataset.data;\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a)([\n                indexAxis,\n                chart.options.indexAxis\n            ]) === \"y\") {\n                return;\n            }\n            if (!meta.controller.supportsDecimation) {\n                return;\n            }\n            const xAxis = chart.scales[meta.xAxisID];\n            if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n                return;\n            }\n            if (chart.options.parsing) {\n                return;\n            }\n            let { start, count } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n            const threshold = options.threshold || 4 * availableWidth;\n            if (count <= threshold) {\n                cleanDecimatedDataset(dataset);\n                return;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(_data)) {\n                dataset._data = data;\n                delete dataset.data;\n                Object.defineProperty(dataset, \"data\", {\n                    configurable: true,\n                    enumerable: true,\n                    get: function() {\n                        return this._decimated;\n                    },\n                    set: function(d) {\n                        this._data = d;\n                    }\n                });\n            }\n            let decimated;\n            switch(options.algorithm){\n                case \"lttb\":\n                    decimated = lttbDecimation(data, start, count, availableWidth, options);\n                    break;\n                case \"min-max\":\n                    decimated = minMaxDecimation(data, start, count, availableWidth);\n                    break;\n                default:\n                    throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n            }\n            dataset._decimated = decimated;\n        });\n    },\n    destroy (chart) {\n        cleanDecimatedData(chart);\n    }\n};\nfunction _segments(line, target, property) {\n    const segments = line.segments;\n    const points = line.points;\n    const tpoints = target.points;\n    const parts = [];\n    for (const segment of segments){\n        let { start, end } = segment;\n        end = _findSegmentEnd(start, end, points);\n        const bounds = _getBounds(property, points[start], points[end], segment.loop);\n        if (!target.segments) {\n            parts.push({\n                source: segment,\n                target: bounds,\n                start: points[start],\n                end: points[end]\n            });\n            continue;\n        }\n        const targetSegments = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao)(target, bounds);\n        for (const tgt of targetSegments){\n            const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n            const fillSources = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay)(segment, points, subBounds);\n            for (const fillSource of fillSources){\n                parts.push({\n                    source: fillSource,\n                    target: tgt,\n                    start: {\n                        [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n                    },\n                    end: {\n                        [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n                    }\n                });\n            }\n        }\n    }\n    return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n    if (loop) {\n        return;\n    }\n    let start = first[property];\n    let end = last[property];\n    if (property === \"angle\") {\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(start);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(end);\n    }\n    return {\n        property,\n        start,\n        end\n    };\n}\nfunction _pointsFromSegments(boundary, line) {\n    const { x = null, y = null } = boundary || {};\n    const linePoints = line.points;\n    const points = [];\n    line.segments.forEach(({ start, end })=>{\n        end = _findSegmentEnd(start, end, linePoints);\n        const first = linePoints[start];\n        const last = linePoints[end];\n        if (y !== null) {\n            points.push({\n                x: first.x,\n                y\n            });\n            points.push({\n                x: last.x,\n                y\n            });\n        } else if (x !== null) {\n            points.push({\n                x,\n                y: first.y\n            });\n            points.push({\n                x,\n                y: last.y\n            });\n        }\n    });\n    return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n    for(; end > start; end--){\n        const point = points[end];\n        if (!isNaN(point.x) && !isNaN(point.y)) {\n            break;\n        }\n    }\n    return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n    if (a && b) {\n        return fn(a[prop], b[prop]);\n    }\n    return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n    let points = [];\n    let _loop = false;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(boundary)) {\n        _loop = true;\n        points = boundary;\n    } else {\n        points = _pointsFromSegments(boundary, line);\n    }\n    return points.length ? new LineElement({\n        points,\n        options: {\n            tension: 0\n        },\n        _loop,\n        _fullLoop: _loop\n    }) : null;\n}\nfunction _shouldApplyFill(source) {\n    return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index, propagate) {\n    const source = sources[index];\n    let fill = source.fill;\n    const visited = [\n        index\n    ];\n    let target;\n    if (!propagate) {\n        return fill;\n    }\n    while(fill !== false && visited.indexOf(fill) === -1){\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n            return fill;\n        }\n        target = sources[fill];\n        if (!target) {\n            return false;\n        }\n        if (target.visible) {\n            return fill;\n        }\n        visited.push(fill);\n        fill = target.fill;\n    }\n    return false;\n}\nfunction _decodeFill(line, index, count) {\n    const fill = parseFillOption(line);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        return isNaN(fill.value) ? false : fill;\n    }\n    let target = parseFloat(fill);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(target) && Math.floor(target) === target) {\n        return decodeTargetIndex(fill[0], index, target, count);\n    }\n    return [\n        \"origin\",\n        \"start\",\n        \"end\",\n        \"stack\",\n        \"shape\"\n    ].indexOf(fill) >= 0 && fill;\n}\nfunction decodeTargetIndex(firstCh, index, target, count) {\n    if (firstCh === \"-\" || firstCh === \"+\") {\n        target = index + target;\n    }\n    if (target === index || target < 0 || target >= count) {\n        return false;\n    }\n    return target;\n}\nfunction _getTargetPixel(fill, scale) {\n    let pixel = null;\n    if (fill === \"start\") {\n        pixel = scale.bottom;\n    } else if (fill === \"end\") {\n        pixel = scale.top;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        pixel = scale.getPixelForValue(fill.value);\n    } else if (scale.getBasePixel) {\n        pixel = scale.getBasePixel();\n    }\n    return pixel;\n}\nfunction _getTargetValue(fill, scale, startValue) {\n    let value;\n    if (fill === \"start\") {\n        value = startValue;\n    } else if (fill === \"end\") {\n        value = scale.options.reverse ? scale.min : scale.max;\n    } else if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(fill)) {\n        value = fill.value;\n    } else {\n        value = scale.getBaseValue();\n    }\n    return value;\n}\nfunction parseFillOption(line) {\n    const options = line.options;\n    const fillOption = options.fill;\n    let fill = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(fillOption && fillOption.target, fillOption);\n    if (fill === undefined) {\n        fill = !!options.backgroundColor;\n    }\n    if (fill === false || fill === null) {\n        return false;\n    }\n    if (fill === true) {\n        return \"origin\";\n    }\n    return fill;\n}\nfunction _buildStackLine(source) {\n    const { scale, index, line } = source;\n    const points = [];\n    const segments = line.segments;\n    const sourcePoints = line.points;\n    const linesBelow = getLinesBelow(scale, index);\n    linesBelow.push(_createBoundaryLine({\n        x: null,\n        y: scale.bottom\n    }, line));\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        for(let j = segment.start; j <= segment.end; j++){\n            addPointsBelow(points, sourcePoints[j], linesBelow);\n        }\n    }\n    return new LineElement({\n        points,\n        options: {}\n    });\n}\nfunction getLinesBelow(scale, index) {\n    const below = [];\n    const metas = scale.getMatchingVisibleMetas(\"line\");\n    for(let i = 0; i < metas.length; i++){\n        const meta = metas[i];\n        if (meta.index === index) {\n            break;\n        }\n        if (!meta.hidden) {\n            below.unshift(meta.dataset);\n        }\n    }\n    return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n    const postponed = [];\n    for(let j = 0; j < linesBelow.length; j++){\n        const line = linesBelow[j];\n        const { first, last, point } = findPoint(line, sourcePoint, \"x\");\n        if (!point || first && last) {\n            continue;\n        }\n        if (first) {\n            postponed.unshift(point);\n        } else {\n            points.push(point);\n            if (!last) {\n                break;\n            }\n        }\n    }\n    points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n    const point = line.interpolate(sourcePoint, property);\n    if (!point) {\n        return {};\n    }\n    const pointValue = point[property];\n    const segments = line.segments;\n    const linePoints = line.points;\n    let first = false;\n    let last = false;\n    for(let i = 0; i < segments.length; i++){\n        const segment = segments[i];\n        const firstValue = linePoints[segment.start][property];\n        const lastValue = linePoints[segment.end][property];\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(pointValue, firstValue, lastValue)) {\n            first = pointValue === firstValue;\n            last = pointValue === lastValue;\n            break;\n        }\n    }\n    return {\n        first,\n        last,\n        point\n    };\n}\nclass simpleArc {\n    constructor(opts){\n        this.x = opts.x;\n        this.y = opts.y;\n        this.radius = opts.radius;\n    }\n    pathSegment(ctx, bounds, opts) {\n        const { x, y, radius } = this;\n        bounds = bounds || {\n            start: 0,\n            end: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T\n        };\n        ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n        return !opts.bounds;\n    }\n    interpolate(point) {\n        const { x, y, radius } = this;\n        const angle = point.angle;\n        return {\n            x: x + Math.cos(angle) * radius,\n            y: y + Math.sin(angle) * radius,\n            angle\n        };\n    }\n}\nfunction _getTarget(source) {\n    const { chart, fill, line } = source;\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(fill)) {\n        return getLineByIndex(chart, fill);\n    }\n    if (fill === \"stack\") {\n        return _buildStackLine(source);\n    }\n    if (fill === \"shape\") {\n        return true;\n    }\n    const boundary = computeBoundary(source);\n    if (boundary instanceof simpleArc) {\n        return boundary;\n    }\n    return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index) {\n    const meta = chart.getDatasetMeta(index);\n    const visible = meta && chart.isDatasetVisible(index);\n    return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n    const scale = source.scale || {};\n    if (scale.getPointPositionForValue) {\n        return computeCircularBoundary(source);\n    }\n    return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n    const { scale = {}, fill } = source;\n    const pixel = _getTargetPixel(fill, scale);\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(pixel)) {\n        const horizontal = scale.isHorizontal();\n        return {\n            x: horizontal ? pixel : null,\n            y: horizontal ? null : pixel\n        };\n    }\n    return null;\n}\nfunction computeCircularBoundary(source) {\n    const { scale, fill } = source;\n    const options = scale.options;\n    const length = scale.getLabels().length;\n    const start = options.reverse ? scale.max : scale.min;\n    const value = _getTargetValue(fill, scale, start);\n    const target = [];\n    if (options.grid.circular) {\n        const center = scale.getPointPositionForValue(0, start);\n        return new simpleArc({\n            x: center.x,\n            y: center.y,\n            radius: scale.getDistanceFromCenterForValue(value)\n        });\n    }\n    for(let i = 0; i < length; ++i){\n        target.push(scale.getPointPositionForValue(i, value));\n    }\n    return target;\n}\nfunction _drawfill(ctx, source, area) {\n    const target = _getTarget(source);\n    const { line, scale, axis } = source;\n    const lineOpts = line.options;\n    const fillOption = lineOpts.fill;\n    const color = lineOpts.backgroundColor;\n    const { above = color, below = color } = fillOption || {};\n    if (target && line.points.length) {\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, area);\n        doFill(ctx, {\n            line,\n            target,\n            above,\n            below,\n            area,\n            scale,\n            axis\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n    }\n}\nfunction doFill(ctx, cfg) {\n    const { line, target, above, below, area, scale } = cfg;\n    const property = line._loop ? \"angle\" : cfg.axis;\n    ctx.save();\n    if (property === \"x\" && below !== above) {\n        clipVertical(ctx, target, area.top);\n        fill(ctx, {\n            line,\n            target,\n            color: above,\n            scale,\n            property\n        });\n        ctx.restore();\n        ctx.save();\n        clipVertical(ctx, target, area.bottom);\n    }\n    fill(ctx, {\n        line,\n        target,\n        color: below,\n        scale,\n        property\n    });\n    ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n    const { segments, points } = target;\n    let first = true;\n    let lineLoop = false;\n    ctx.beginPath();\n    for (const segment of segments){\n        const { start, end } = segment;\n        const firstPoint = points[start];\n        const lastPoint = points[_findSegmentEnd(start, end, points)];\n        if (first) {\n            ctx.moveTo(firstPoint.x, firstPoint.y);\n            first = false;\n        } else {\n            ctx.lineTo(firstPoint.x, clipY);\n            ctx.lineTo(firstPoint.x, firstPoint.y);\n        }\n        lineLoop = !!target.pathSegment(ctx, segment, {\n            move: lineLoop\n        });\n        if (lineLoop) {\n            ctx.closePath();\n        } else {\n            ctx.lineTo(lastPoint.x, clipY);\n        }\n    }\n    ctx.lineTo(target.first().x, clipY);\n    ctx.closePath();\n    ctx.clip();\n}\nfunction fill(ctx, cfg) {\n    const { line, target, property, color, scale } = cfg;\n    const segments = _segments(line, target, property);\n    for (const { source: src, target: tgt, start, end } of segments){\n        const { style: { backgroundColor = color } = {} } = src;\n        const notShape = target !== true;\n        ctx.save();\n        ctx.fillStyle = backgroundColor;\n        clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n        ctx.beginPath();\n        const lineLoop = !!line.pathSegment(ctx, src);\n        let loop;\n        if (notShape) {\n            if (lineLoop) {\n                ctx.closePath();\n            } else {\n                interpolatedLineTo(ctx, target, end, property);\n            }\n            const targetLoop = !!target.pathSegment(ctx, tgt, {\n                move: lineLoop,\n                reverse: true\n            });\n            loop = lineLoop && targetLoop;\n            if (!loop) {\n                interpolatedLineTo(ctx, target, start, property);\n            }\n        }\n        ctx.closePath();\n        ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n        ctx.restore();\n    }\n}\nfunction clipBounds(ctx, scale, bounds) {\n    const { top, bottom } = scale.chart.chartArea;\n    const { property, start, end } = bounds || {};\n    if (property === \"x\") {\n        ctx.beginPath();\n        ctx.rect(start, top, end - start, bottom - top);\n        ctx.clip();\n    }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n    const interpolatedPoint = target.interpolate(point, property);\n    if (interpolatedPoint) {\n        ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n    }\n}\nvar index = {\n    id: \"filler\",\n    afterDatasetsUpdate (chart, _args, options) {\n        const count = (chart.data.datasets || []).length;\n        const sources = [];\n        let meta, i, line, source;\n        for(i = 0; i < count; ++i){\n            meta = chart.getDatasetMeta(i);\n            line = meta.dataset;\n            source = null;\n            if (line && line.options && line instanceof LineElement) {\n                source = {\n                    visible: chart.isDatasetVisible(i),\n                    index: i,\n                    fill: _decodeFill(line, i, count),\n                    chart,\n                    axis: meta.controller.options.indexAxis,\n                    scale: meta.vScale,\n                    line\n                };\n            }\n            meta.$filler = source;\n            sources.push(source);\n        }\n        for(i = 0; i < count; ++i){\n            source = sources[i];\n            if (!source || source.fill === false) {\n                continue;\n            }\n            source.fill = _resolveTarget(sources, i, options.propagate);\n        }\n    },\n    beforeDraw (chart, _args, options) {\n        const draw = options.drawTime === \"beforeDraw\";\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        const area = chart.chartArea;\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (!source) {\n                continue;\n            }\n            source.line.updateControlPoints(area, source.axis);\n            if (draw && source.fill) {\n                _drawfill(chart.ctx, source, area);\n            }\n        }\n    },\n    beforeDatasetsDraw (chart, _args, options) {\n        if (options.drawTime !== \"beforeDatasetsDraw\") {\n            return;\n        }\n        const metasets = chart.getSortedVisibleDatasetMetas();\n        for(let i = metasets.length - 1; i >= 0; --i){\n            const source = metasets[i].$filler;\n            if (_shouldApplyFill(source)) {\n                _drawfill(chart.ctx, source, chart.chartArea);\n            }\n        }\n    },\n    beforeDatasetDraw (chart, args, options) {\n        const source = args.meta.$filler;\n        if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n            return;\n        }\n        _drawfill(chart.ctx, source, chart.chartArea);\n    },\n    defaults: {\n        propagate: true,\n        drawTime: \"beforeDatasetDraw\"\n    }\n};\nconst getBoxSize = (labelOpts, fontSize)=>{\n    let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;\n    if (labelOpts.usePointStyle) {\n        boxHeight = Math.min(boxHeight, fontSize);\n        boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n    }\n    return {\n        boxWidth,\n        boxHeight,\n        itemHeight: Math.max(fontSize, boxHeight)\n    };\n};\nconst itemsEqual = (a, b)=>a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nclass Legend extends Element {\n    constructor(config){\n        super();\n        this._added = false;\n        this.legendHitBoxes = [];\n        this._hoveredItem = null;\n        this.doughnutMode = false;\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this.legendItems = undefined;\n        this.columnSizes = undefined;\n        this.lineWidths = undefined;\n        this.maxHeight = undefined;\n        this.maxWidth = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this._margins = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight, margins) {\n        this.maxWidth = maxWidth;\n        this.maxHeight = maxHeight;\n        this._margins = margins;\n        this.setDimensions();\n        this.buildLabels();\n        this.fit();\n    }\n    setDimensions() {\n        if (this.isHorizontal()) {\n            this.width = this.maxWidth;\n            this.left = this._margins.left;\n            this.right = this.width;\n        } else {\n            this.height = this.maxHeight;\n            this.top = this._margins.top;\n            this.bottom = this.height;\n        }\n    }\n    buildLabels() {\n        const labelOpts = this.options.labels || {};\n        let legendItems = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(labelOpts.generateLabels, [\n            this.chart\n        ], this) || [];\n        if (labelOpts.filter) {\n            legendItems = legendItems.filter((item)=>labelOpts.filter(item, this.chart.data));\n        }\n        if (labelOpts.sort) {\n            legendItems = legendItems.sort((a, b)=>labelOpts.sort(a, b, this.chart.data));\n        }\n        if (this.options.reverse) {\n            legendItems.reverse();\n        }\n        this.legendItems = legendItems;\n    }\n    fit() {\n        const { options, ctx } = this;\n        if (!options.display) {\n            this.width = this.height = 0;\n            return;\n        }\n        const labelOpts = options.labels;\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const fontSize = labelFont.size;\n        const titleHeight = this._computeTitleHeight();\n        const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);\n        let width, height;\n        ctx.font = labelFont.string;\n        if (this.isHorizontal()) {\n            width = this.maxWidth;\n            height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        } else {\n            height = this.maxHeight;\n            width = this._fitCols(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n        }\n        this.width = Math.min(width, options.maxWidth || this.maxWidth);\n        this.height = Math.min(height, options.maxHeight || this.maxHeight);\n    }\n    _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxWidth, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const lineWidths = this.lineWidths = [\n            0\n        ];\n        const lineHeight = itemHeight + padding;\n        let totalHeight = titleHeight;\n        ctx.textAlign = \"left\";\n        ctx.textBaseline = \"middle\";\n        let row = -1;\n        let top = -lineHeight;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n                totalHeight += lineHeight;\n                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                top += lineHeight;\n                row++;\n            }\n            hitboxes[i] = {\n                left: 0,\n                top,\n                row,\n                width: itemWidth,\n                height: itemHeight\n            };\n            lineWidths[lineWidths.length - 1] += itemWidth + padding;\n        });\n        return totalHeight;\n    }\n    _fitCols(titleHeight, fontSize, boxWidth, itemHeight) {\n        const { ctx, maxHeight, options: { labels: { padding } } } = this;\n        const hitboxes = this.legendHitBoxes = [];\n        const columnSizes = this.columnSizes = [];\n        const heightLimit = maxHeight - titleHeight;\n        let totalWidth = padding;\n        let currentColWidth = 0;\n        let currentColHeight = 0;\n        let left = 0;\n        let col = 0;\n        this.legendItems.forEach((legendItem, i)=>{\n            const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n            if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n                totalWidth += currentColWidth + padding;\n                columnSizes.push({\n                    width: currentColWidth,\n                    height: currentColHeight\n                });\n                left += currentColWidth + padding;\n                col++;\n                currentColWidth = currentColHeight = 0;\n            }\n            hitboxes[i] = {\n                left,\n                top: currentColHeight,\n                col,\n                width: itemWidth,\n                height: itemHeight\n            };\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight + padding;\n        });\n        totalWidth += currentColWidth;\n        columnSizes.push({\n            width: currentColWidth,\n            height: currentColHeight\n        });\n        return totalWidth;\n    }\n    adjustHitBoxes() {\n        if (!this.options.display) {\n            return;\n        }\n        const titleHeight = this._computeTitleHeight();\n        const { legendHitBoxes: hitboxes, options: { align, labels: { padding }, rtl } } = this;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(rtl, this.left, this.width);\n        if (this.isHorizontal()) {\n            let row = 0;\n            let left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n            for (const hitbox of hitboxes){\n                if (row !== hitbox.row) {\n                    row = hitbox.row;\n                    left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - this.lineWidths[row]);\n                }\n                hitbox.top += this.top + titleHeight + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n                left += hitbox.width + padding;\n            }\n        } else {\n            let col = 0;\n            let top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n            for (const hitbox of hitboxes){\n                if (hitbox.col !== col) {\n                    col = hitbox.col;\n                    top = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n                }\n                hitbox.top = top;\n                hitbox.left += this.left + padding;\n                hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n                top += hitbox.height + padding;\n            }\n        }\n    }\n    isHorizontal() {\n        return this.options.position === \"top\" || this.options.position === \"bottom\";\n    }\n    draw() {\n        if (this.options.display) {\n            const ctx = this.ctx;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L)(ctx, this);\n            this._draw();\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N)(ctx);\n        }\n    }\n    _draw() {\n        const { options: opts, columnSizes, lineWidths, ctx } = this;\n        const { align, labels: labelOpts } = opts;\n        const defaultColor = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.color;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const labelFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(labelOpts.font);\n        const { color: fontColor, padding } = labelOpts;\n        const fontSize = labelFont.size;\n        const halfFontSize = fontSize / 2;\n        let cursor;\n        this.drawTitle();\n        ctx.textAlign = rtlHelper.textAlign(\"left\");\n        ctx.textBaseline = \"middle\";\n        ctx.lineWidth = 0.5;\n        ctx.font = labelFont.string;\n        const { boxWidth, boxHeight, itemHeight } = getBoxSize(labelOpts, fontSize);\n        const drawLegendBox = function(x, y, legendItem) {\n            if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n                return;\n            }\n            ctx.save();\n            const lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineWidth, 1);\n            ctx.fillStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.fillStyle, defaultColor);\n            ctx.lineCap = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineCap, \"butt\");\n            ctx.lineDashOffset = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDashOffset, 0);\n            ctx.lineJoin = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineJoin, \"miter\");\n            ctx.lineWidth = lineWidth;\n            ctx.strokeStyle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.strokeStyle, defaultColor);\n            ctx.setLineDash((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(legendItem.lineDash, []));\n            if (labelOpts.usePointStyle) {\n                const drawOptions = {\n                    radius: boxHeight * Math.SQRT2 / 2,\n                    pointStyle: legendItem.pointStyle,\n                    rotation: legendItem.rotation,\n                    borderWidth: lineWidth\n                };\n                const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n                const centerY = y + halfFontSize;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE)(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n            } else {\n                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n                const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(legendItem.borderRadius);\n                ctx.beginPath();\n                if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                        x: xBoxLeft,\n                        y: yBoxTop,\n                        w: boxWidth,\n                        h: boxHeight,\n                        radius: borderRadius\n                    });\n                } else {\n                    ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n                }\n                ctx.fill();\n                if (lineWidth !== 0) {\n                    ctx.stroke();\n                }\n            }\n            ctx.restore();\n        };\n        const fillText = function(x, y, legendItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n                strikethrough: legendItem.hidden,\n                textAlign: rtlHelper.textAlign(legendItem.textAlign)\n            });\n        };\n        const isHorizontal = this.isHorizontal();\n        const titleHeight = this._computeTitleHeight();\n        if (isHorizontal) {\n            cursor = {\n                x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[0]),\n                y: this.top + padding + titleHeight,\n                line: 0\n            };\n        } else {\n            cursor = {\n                x: this.left + padding,\n                y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n                line: 0\n            };\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(this.ctx, opts.textDirection);\n        const lineHeight = itemHeight + padding;\n        this.legendItems.forEach((legendItem, i)=>{\n            ctx.strokeStyle = legendItem.fontColor || fontColor;\n            ctx.fillStyle = legendItem.fontColor || fontColor;\n            const textWidth = ctx.measureText(legendItem.text).width;\n            const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n            const width = boxWidth + halfFontSize + textWidth;\n            let x = cursor.x;\n            let y = cursor.y;\n            rtlHelper.setWidth(this.width);\n            if (isHorizontal) {\n                if (i > 0 && x + width + padding > this.right) {\n                    y = cursor.y += lineHeight;\n                    cursor.line++;\n                    x = cursor.x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.left + padding, this.right - lineWidths[cursor.line]);\n                }\n            } else if (i > 0 && y + lineHeight > this.bottom) {\n                x = cursor.x = x + columnSizes[cursor.line].width + padding;\n                cursor.line++;\n                y = cursor.y = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n            }\n            const realX = rtlHelper.x(x);\n            drawLegendBox(realX, y, legendItem);\n            x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC)(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n            fillText(rtlHelper.x(x), y, legendItem);\n            if (isHorizontal) {\n                cursor.x += width + padding;\n            } else {\n                cursor.y += lineHeight;\n            }\n        });\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(this.ctx, opts.textDirection);\n    }\n    drawTitle() {\n        const opts = this.options;\n        const titleOpts = opts.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        if (!titleOpts.display) {\n            return;\n        }\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(opts.rtl, this.left, this.width);\n        const ctx = this.ctx;\n        const position = titleOpts.position;\n        const halfFontSize = titleFont.size / 2;\n        const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n        let y;\n        let left = this.left;\n        let maxWidth = this.width;\n        if (this.isHorizontal()) {\n            maxWidth = Math.max(...this.lineWidths);\n            y = this.top + topPaddingPlusHalfFontSize;\n            left = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, left, this.right - maxWidth);\n        } else {\n            const maxHeight = this.columnSizes.reduce((acc, size)=>Math.max(acc, size.height), 0);\n            y = topPaddingPlusHalfFontSize + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n        }\n        const x = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(position, left, left + maxWidth);\n        ctx.textAlign = rtlHelper.textAlign((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(position));\n        ctx.textBaseline = \"middle\";\n        ctx.strokeStyle = titleOpts.color;\n        ctx.fillStyle = titleOpts.color;\n        ctx.font = titleFont.string;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, titleOpts.text, x, y, titleFont);\n    }\n    _computeTitleHeight() {\n        const titleOpts = this.options.title;\n        const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(titleOpts.font);\n        const titlePadding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(titleOpts.padding);\n        return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n    }\n    _getLegendItemAt(x, y) {\n        let i, hitBox, lh;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, this.left, this.right) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, this.top, this.bottom)) {\n            lh = this.legendHitBoxes;\n            for(i = 0; i < lh.length; ++i){\n                hitBox = lh[i];\n                if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(x, hitBox.left, hitBox.left + hitBox.width) && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak)(y, hitBox.top, hitBox.top + hitBox.height)) {\n                    return this.legendItems[i];\n                }\n            }\n        }\n        return null;\n    }\n    handleEvent(e) {\n        const opts = this.options;\n        if (!isListened(e.type, opts)) {\n            return;\n        }\n        const hoveredItem = this._getLegendItemAt(e.x, e.y);\n        if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n            const previous = this._hoveredItem;\n            const sameItem = itemsEqual(previous, hoveredItem);\n            if (previous && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onLeave, [\n                    e,\n                    previous,\n                    this\n                ], this);\n            }\n            this._hoveredItem = hoveredItem;\n            if (hoveredItem && !sameItem) {\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onHover, [\n                    e,\n                    hoveredItem,\n                    this\n                ], this);\n            }\n        } else if (hoveredItem) {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(opts.onClick, [\n                e,\n                hoveredItem,\n                this\n            ], this);\n        }\n    }\n}\nfunction isListened(type, opts) {\n    if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n        return true;\n    }\n    if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n        return true;\n    }\n    return false;\n}\nvar plugin_legend = {\n    id: \"legend\",\n    _element: Legend,\n    start (chart, _args, options) {\n        const legend = chart.legend = new Legend({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, legend, options);\n        layouts.addBox(chart, legend);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, chart.legend);\n        delete chart.legend;\n    },\n    beforeUpdate (chart, _args, options) {\n        const legend = chart.legend;\n        layouts.configure(chart, legend, options);\n        legend.options = options;\n    },\n    afterUpdate (chart) {\n        const legend = chart.legend;\n        legend.buildLabels();\n        legend.adjustHitBoxes();\n    },\n    afterEvent (chart, args) {\n        if (!args.replay) {\n            chart.legend.handleEvent(args.event);\n        }\n    },\n    defaults: {\n        display: true,\n        position: \"top\",\n        align: \"center\",\n        fullSize: true,\n        reverse: false,\n        weight: 1000,\n        onClick (e, legendItem, legend) {\n            const index = legendItem.datasetIndex;\n            const ci = legend.chart;\n            if (ci.isDatasetVisible(index)) {\n                ci.hide(index);\n                legendItem.hidden = true;\n            } else {\n                ci.show(index);\n                legendItem.hidden = false;\n            }\n        },\n        onHover: null,\n        onLeave: null,\n        labels: {\n            color: (ctx)=>ctx.chart.options.color,\n            boxWidth: 40,\n            padding: 10,\n            generateLabels (chart) {\n                const datasets = chart.data.datasets;\n                const { labels: { usePointStyle, pointStyle, textAlign, color } } = chart.legend.options;\n                return chart._getSortedDatasetMetas().map((meta)=>{\n                    const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n                    const borderWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(style.borderWidth);\n                    return {\n                        text: datasets[meta.index].label,\n                        fillStyle: style.backgroundColor,\n                        fontColor: color,\n                        hidden: !meta.visible,\n                        lineCap: style.borderCapStyle,\n                        lineDash: style.borderDash,\n                        lineDashOffset: style.borderDashOffset,\n                        lineJoin: style.borderJoinStyle,\n                        lineWidth: (borderWidth.width + borderWidth.height) / 4,\n                        strokeStyle: style.borderColor,\n                        pointStyle: pointStyle || style.pointStyle,\n                        rotation: style.rotation,\n                        textAlign: textAlign || style.textAlign,\n                        borderRadius: 0,\n                        datasetIndex: meta.index\n                    };\n                }, this);\n            }\n        },\n        title: {\n            color: (ctx)=>ctx.chart.options.color,\n            display: false,\n            position: \"center\",\n            text: \"\"\n        }\n    },\n    descriptors: {\n        _scriptable: (name)=>!name.startsWith(\"on\"),\n        labels: {\n            _scriptable: (name)=>![\n                    \"generateLabels\",\n                    \"filter\",\n                    \"sort\"\n                ].includes(name)\n        }\n    }\n};\nclass Title extends Element {\n    constructor(config){\n        super();\n        this.chart = config.chart;\n        this.options = config.options;\n        this.ctx = config.ctx;\n        this._padding = undefined;\n        this.top = undefined;\n        this.bottom = undefined;\n        this.left = undefined;\n        this.right = undefined;\n        this.width = undefined;\n        this.height = undefined;\n        this.position = undefined;\n        this.weight = undefined;\n        this.fullSize = undefined;\n    }\n    update(maxWidth, maxHeight) {\n        const opts = this.options;\n        this.left = 0;\n        this.top = 0;\n        if (!opts.display) {\n            this.width = this.height = this.right = this.bottom = 0;\n            return;\n        }\n        this.width = this.right = maxWidth;\n        this.height = this.bottom = maxHeight;\n        const lineCount = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(opts.text) ? opts.text.length : 1;\n        this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(opts.padding);\n        const textSize = lineCount * (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font).lineHeight + this._padding.height;\n        if (this.isHorizontal()) {\n            this.height = textSize;\n        } else {\n            this.width = textSize;\n        }\n    }\n    isHorizontal() {\n        const pos = this.options.position;\n        return pos === \"top\" || pos === \"bottom\";\n    }\n    _drawArgs(offset) {\n        const { top, left, bottom, right, options } = this;\n        const align = options.align;\n        let rotation = 0;\n        let maxWidth, titleX, titleY;\n        if (this.isHorizontal()) {\n            titleX = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, left, right);\n            titleY = top + offset;\n            maxWidth = right - left;\n        } else {\n            if (options.position === \"left\") {\n                titleX = left + offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, bottom, top);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * -0.5;\n            } else {\n                titleX = right - offset;\n                titleY = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S)(align, top, bottom);\n                rotation = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P * 0.5;\n            }\n            maxWidth = bottom - top;\n        }\n        return {\n            titleX,\n            titleY,\n            maxWidth,\n            rotation\n        };\n    }\n    draw() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        if (!opts.display) {\n            return;\n        }\n        const fontOpts = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const lineHeight = fontOpts.lineHeight;\n        const offset = lineHeight / 2 + this._padding.top;\n        const { titleX, titleY, maxWidth, rotation } = this._drawArgs(offset);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, opts.text, 0, 0, fontOpts, {\n            color: opts.color,\n            maxWidth,\n            rotation,\n            textAlign: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R)(opts.align),\n            textBaseline: \"middle\",\n            translation: [\n                titleX,\n                titleY\n            ]\n        });\n    }\n}\nfunction createTitle(chart, titleOpts) {\n    const title = new Title({\n        ctx: chart.ctx,\n        options: titleOpts,\n        chart\n    });\n    layouts.configure(chart, title, titleOpts);\n    layouts.addBox(chart, title);\n    chart.titleBlock = title;\n}\nvar plugin_title = {\n    id: \"title\",\n    _element: Title,\n    start (chart, _args, options) {\n        createTitle(chart, options);\n    },\n    stop (chart) {\n        const titleBlock = chart.titleBlock;\n        layouts.removeBox(chart, titleBlock);\n        delete chart.titleBlock;\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = chart.titleBlock;\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"bold\"\n        },\n        fullSize: true,\n        padding: 10,\n        position: \"top\",\n        text: \"\",\n        weight: 2000\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst map = new WeakMap();\nvar plugin_subtitle = {\n    id: \"subtitle\",\n    start (chart, _args, options) {\n        const title = new Title({\n            ctx: chart.ctx,\n            options,\n            chart\n        });\n        layouts.configure(chart, title, options);\n        layouts.addBox(chart, title);\n        map.set(chart, title);\n    },\n    stop (chart) {\n        layouts.removeBox(chart, map.get(chart));\n        map.delete(chart);\n    },\n    beforeUpdate (chart, _args, options) {\n        const title = map.get(chart);\n        layouts.configure(chart, title, options);\n        title.options = options;\n    },\n    defaults: {\n        align: \"center\",\n        display: false,\n        font: {\n            weight: \"normal\"\n        },\n        fullSize: true,\n        padding: 0,\n        position: \"top\",\n        text: \"\",\n        weight: 1500\n    },\n    defaultRoutes: {\n        color: \"color\"\n    },\n    descriptors: {\n        _scriptable: true,\n        _indexable: false\n    }\n};\nconst positioners = {\n    average (items) {\n        if (!items.length) {\n            return false;\n        }\n        let i, len;\n        let x = 0;\n        let y = 0;\n        let count = 0;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const pos = el.tooltipPosition();\n                x += pos.x;\n                y += pos.y;\n                ++count;\n            }\n        }\n        return {\n            x: x / count,\n            y: y / count\n        };\n    },\n    nearest (items, eventPosition) {\n        if (!items.length) {\n            return false;\n        }\n        let x = eventPosition.x;\n        let y = eventPosition.y;\n        let minDistance = Number.POSITIVE_INFINITY;\n        let i, len, nearestElement;\n        for(i = 0, len = items.length; i < len; ++i){\n            const el = items[i].element;\n            if (el && el.hasValue()) {\n                const center = el.getCenterPoint();\n                const d = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG)(eventPosition, center);\n                if (d < minDistance) {\n                    minDistance = d;\n                    nearestElement = el;\n                }\n            }\n        }\n        if (nearestElement) {\n            const tp = nearestElement.tooltipPosition();\n            x = tp.x;\n            y = tp.y;\n        }\n        return {\n            x,\n            y\n        };\n    }\n};\nfunction pushOrConcat(base, toPush) {\n    if (toPush) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(toPush)) {\n            Array.prototype.push.apply(base, toPush);\n        } else {\n            base.push(toPush);\n        }\n    }\n    return base;\n}\nfunction splitNewlines(str) {\n    if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n        return str.split(\"\\n\");\n    }\n    return str;\n}\nfunction createTooltipItem(chart, item) {\n    const { element, datasetIndex, index } = item;\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    const { label, value } = controller.getLabelAndValue(index);\n    return {\n        chart,\n        label,\n        parsed: controller.getParsed(index),\n        raw: chart.data.datasets[datasetIndex].data[index],\n        formattedValue: value,\n        dataset: controller.getDataset(),\n        dataIndex: index,\n        datasetIndex,\n        element\n    };\n}\nfunction getTooltipSize(tooltip, options) {\n    const ctx = tooltip.chart.ctx;\n    const { body, footer, title } = tooltip;\n    const { boxWidth, boxHeight } = options;\n    const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n    const titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n    const footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n    const titleLineCount = title.length;\n    const footerLineCount = footer.length;\n    const bodyLineItemCount = body.length;\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    let height = padding.height;\n    let width = 0;\n    let combinedBodyLength = body.reduce((count, bodyItem)=>count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n    combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n    if (titleLineCount) {\n        height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n    }\n    if (combinedBodyLength) {\n        const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n        height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n    }\n    if (footerLineCount) {\n        height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n    }\n    let widthPadding = 0;\n    const maxLineWidth = function(line) {\n        width = Math.max(width, ctx.measureText(line).width + widthPadding);\n    };\n    ctx.save();\n    ctx.font = titleFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.title, maxLineWidth);\n    ctx.font = bodyFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n    widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(body, (bodyItem)=>{\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.lines, maxLineWidth);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, maxLineWidth);\n    });\n    widthPadding = 0;\n    ctx.font = footerFont.string;\n    (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltip.footer, maxLineWidth);\n    ctx.restore();\n    width += padding.width;\n    return {\n        width,\n        height\n    };\n}\nfunction determineYAlign(chart, size) {\n    const { y, height } = size;\n    if (y < height / 2) {\n        return \"top\";\n    } else if (y > chart.height - height / 2) {\n        return \"bottom\";\n    }\n    return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n    const { x, width } = size;\n    const caret = options.caretSize + options.caretPadding;\n    if (xAlign === \"left\" && x + width + caret > chart.width) {\n        return true;\n    }\n    if (xAlign === \"right\" && x - width - caret < 0) {\n        return true;\n    }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n    const { x, width } = size;\n    const { width: chartWidth, chartArea: { left, right } } = chart;\n    let xAlign = \"center\";\n    if (yAlign === \"center\") {\n        xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n    } else if (x <= width / 2) {\n        xAlign = \"left\";\n    } else if (x >= chartWidth - width / 2) {\n        xAlign = \"right\";\n    }\n    if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n        xAlign = \"center\";\n    }\n    return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n    const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n    return {\n        xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n        yAlign\n    };\n}\nfunction alignX(size, xAlign) {\n    let { x, width } = size;\n    if (xAlign === \"right\") {\n        x -= width;\n    } else if (xAlign === \"center\") {\n        x -= width / 2;\n    }\n    return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n    let { y, height } = size;\n    if (yAlign === \"top\") {\n        y += paddingAndSize;\n    } else if (yAlign === \"bottom\") {\n        y -= height + paddingAndSize;\n    } else {\n        y -= height / 2;\n    }\n    return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n    const { caretSize, caretPadding, cornerRadius } = options;\n    const { xAlign, yAlign } = alignment;\n    const paddingAndSize = caretSize + caretPadding;\n    const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n    let x = alignX(size, xAlign);\n    const y = alignY(size, yAlign, paddingAndSize);\n    if (yAlign === \"center\") {\n        if (xAlign === \"left\") {\n            x += paddingAndSize;\n        } else if (xAlign === \"right\") {\n            x -= paddingAndSize;\n        }\n    } else if (xAlign === \"left\") {\n        x -= Math.max(topLeft, bottomLeft) + caretSize;\n    } else if (xAlign === \"right\") {\n        x += Math.max(topRight, bottomRight) + caretSize;\n    }\n    return {\n        x: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(x, 0, chart.width - size.width),\n        y: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(y, 0, chart.height - size.height)\n    };\n}\nfunction getAlignedX(tooltip, align, options) {\n    const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n    return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback) {\n    return pushOrConcat([], splitNewlines(callback));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        tooltip,\n        tooltipItems,\n        type: \"tooltip\"\n    });\n}\nfunction overrideCallbacks(callbacks, context) {\n    const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n    return override ? callbacks.override(override) : callbacks;\n}\nclass Tooltip extends Element {\n    constructor(config){\n        super();\n        this.opacity = 0;\n        this._active = [];\n        this._eventPosition = undefined;\n        this._size = undefined;\n        this._cachedAnimations = undefined;\n        this._tooltipItems = [];\n        this.$animations = undefined;\n        this.$context = undefined;\n        this.chart = config.chart || config._chart;\n        this._chart = this.chart;\n        this.options = config.options;\n        this.dataPoints = undefined;\n        this.title = undefined;\n        this.beforeBody = undefined;\n        this.body = undefined;\n        this.afterBody = undefined;\n        this.footer = undefined;\n        this.xAlign = undefined;\n        this.yAlign = undefined;\n        this.x = undefined;\n        this.y = undefined;\n        this.height = undefined;\n        this.width = undefined;\n        this.caretX = undefined;\n        this.caretY = undefined;\n        this.labelColors = undefined;\n        this.labelPointStyles = undefined;\n        this.labelTextColors = undefined;\n    }\n    initialize(options) {\n        this.options = options;\n        this._cachedAnimations = undefined;\n        this.$context = undefined;\n    }\n    _resolveAnimations() {\n        const cached = this._cachedAnimations;\n        if (cached) {\n            return cached;\n        }\n        const chart = this.chart;\n        const options = this.options.setContext(this.getContext());\n        const opts = options.enabled && chart.options.animation && options.animations;\n        const animations = new Animations(this.chart, opts);\n        if (opts._cacheable) {\n            this._cachedAnimations = Object.freeze(animations);\n        }\n        return animations;\n    }\n    getContext() {\n        return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n    }\n    getTitle(context, options) {\n        const { callbacks } = options;\n        const beforeTitle = callbacks.beforeTitle.apply(this, [\n            context\n        ]);\n        const title = callbacks.title.apply(this, [\n            context\n        ]);\n        const afterTitle = callbacks.afterTitle.apply(this, [\n            context\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n        lines = pushOrConcat(lines, splitNewlines(title));\n        lines = pushOrConcat(lines, splitNewlines(afterTitle));\n        return lines;\n    }\n    getBeforeBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.beforeBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getBody(tooltipItems, options) {\n        const { callbacks } = options;\n        const bodyItems = [];\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const bodyItem = {\n                before: [],\n                lines: [],\n                after: []\n            };\n            const scoped = overrideCallbacks(callbacks, context);\n            pushOrConcat(bodyItem.before, splitNewlines(scoped.beforeLabel.call(this, context)));\n            pushOrConcat(bodyItem.lines, scoped.label.call(this, context));\n            pushOrConcat(bodyItem.after, splitNewlines(scoped.afterLabel.call(this, context)));\n            bodyItems.push(bodyItem);\n        });\n        return bodyItems;\n    }\n    getAfterBody(tooltipItems, options) {\n        return getBeforeAfterBodyLines(options.callbacks.afterBody.apply(this, [\n            tooltipItems\n        ]));\n    }\n    getFooter(tooltipItems, options) {\n        const { callbacks } = options;\n        const beforeFooter = callbacks.beforeFooter.apply(this, [\n            tooltipItems\n        ]);\n        const footer = callbacks.footer.apply(this, [\n            tooltipItems\n        ]);\n        const afterFooter = callbacks.afterFooter.apply(this, [\n            tooltipItems\n        ]);\n        let lines = [];\n        lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n        lines = pushOrConcat(lines, splitNewlines(footer));\n        lines = pushOrConcat(lines, splitNewlines(afterFooter));\n        return lines;\n    }\n    _createItems(options) {\n        const active = this._active;\n        const data = this.chart.data;\n        const labelColors = [];\n        const labelPointStyles = [];\n        const labelTextColors = [];\n        let tooltipItems = [];\n        let i, len;\n        for(i = 0, len = active.length; i < len; ++i){\n            tooltipItems.push(createTooltipItem(this.chart, active[i]));\n        }\n        if (options.filter) {\n            tooltipItems = tooltipItems.filter((element, index, array)=>options.filter(element, index, array, data));\n        }\n        if (options.itemSort) {\n            tooltipItems = tooltipItems.sort((a, b)=>options.itemSort(a, b, data));\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(tooltipItems, (context)=>{\n            const scoped = overrideCallbacks(options.callbacks, context);\n            labelColors.push(scoped.labelColor.call(this, context));\n            labelPointStyles.push(scoped.labelPointStyle.call(this, context));\n            labelTextColors.push(scoped.labelTextColor.call(this, context));\n        });\n        this.labelColors = labelColors;\n        this.labelPointStyles = labelPointStyles;\n        this.labelTextColors = labelTextColors;\n        this.dataPoints = tooltipItems;\n        return tooltipItems;\n    }\n    update(changed, replay) {\n        const options = this.options.setContext(this.getContext());\n        const active = this._active;\n        let properties;\n        let tooltipItems = [];\n        if (!active.length) {\n            if (this.opacity !== 0) {\n                properties = {\n                    opacity: 0\n                };\n            }\n        } else {\n            const position = positioners[options.position].call(this, active, this._eventPosition);\n            tooltipItems = this._createItems(options);\n            this.title = this.getTitle(tooltipItems, options);\n            this.beforeBody = this.getBeforeBody(tooltipItems, options);\n            this.body = this.getBody(tooltipItems, options);\n            this.afterBody = this.getAfterBody(tooltipItems, options);\n            this.footer = this.getFooter(tooltipItems, options);\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, size);\n            const alignment = determineAlignment(this.chart, options, positionAndSize);\n            const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n            this.xAlign = alignment.xAlign;\n            this.yAlign = alignment.yAlign;\n            properties = {\n                opacity: 1,\n                x: backgroundPoint.x,\n                y: backgroundPoint.y,\n                width: size.width,\n                height: size.height,\n                caretX: position.x,\n                caretY: position.y\n            };\n        }\n        this._tooltipItems = tooltipItems;\n        this.$context = undefined;\n        if (properties) {\n            this._resolveAnimations().update(this, properties);\n        }\n        if (changed && options.external) {\n            options.external.call(this, {\n                chart: this.chart,\n                tooltip: this,\n                replay\n            });\n        }\n    }\n    drawCaret(tooltipPoint, ctx, size, options) {\n        const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n        ctx.lineTo(caretPosition.x1, caretPosition.y1);\n        ctx.lineTo(caretPosition.x2, caretPosition.y2);\n        ctx.lineTo(caretPosition.x3, caretPosition.y3);\n    }\n    getCaretPosition(tooltipPoint, size, options) {\n        const { xAlign, yAlign } = this;\n        const { caretSize, cornerRadius } = options;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(cornerRadius);\n        const { x: ptX, y: ptY } = tooltipPoint;\n        const { width, height } = size;\n        let x1, x2, x3, y1, y2, y3;\n        if (yAlign === \"center\") {\n            y2 = ptY + height / 2;\n            if (xAlign === \"left\") {\n                x1 = ptX;\n                x2 = x1 - caretSize;\n                y1 = y2 + caretSize;\n                y3 = y2 - caretSize;\n            } else {\n                x1 = ptX + width;\n                x2 = x1 + caretSize;\n                y1 = y2 - caretSize;\n                y3 = y2 + caretSize;\n            }\n            x3 = x1;\n        } else {\n            if (xAlign === \"left\") {\n                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n            } else if (xAlign === \"right\") {\n                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n            } else {\n                x2 = this.caretX;\n            }\n            if (yAlign === \"top\") {\n                y1 = ptY;\n                y2 = y1 - caretSize;\n                x1 = x2 - caretSize;\n                x3 = x2 + caretSize;\n            } else {\n                y1 = ptY + height;\n                y2 = y1 + caretSize;\n                x1 = x2 + caretSize;\n                x3 = x2 - caretSize;\n            }\n            y3 = y1;\n        }\n        return {\n            x1,\n            x2,\n            x3,\n            y1,\n            y2,\n            y3\n        };\n    }\n    drawTitle(pt, ctx, options) {\n        const title = this.title;\n        const length = title.length;\n        let titleFont, titleSpacing, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.titleAlign, options);\n            ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n            ctx.textBaseline = \"middle\";\n            titleFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.titleFont);\n            titleSpacing = options.titleSpacing;\n            ctx.fillStyle = options.titleColor;\n            ctx.font = titleFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n                pt.y += titleFont.lineHeight + titleSpacing;\n                if (i + 1 === length) {\n                    pt.y += options.titleMarginBottom - titleSpacing;\n                }\n            }\n        }\n    }\n    _drawColorBox(ctx, pt, i, rtlHelper, options) {\n        const labelColors = this.labelColors[i];\n        const labelPointStyle = this.labelPointStyles[i];\n        const { boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        const colorX = getAlignedX(this, \"left\", options);\n        const rtlColorX = rtlHelper.x(colorX);\n        const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n        const colorY = pt.y + yOffSet;\n        if (options.usePointStyle) {\n            const drawOptions = {\n                radius: Math.min(boxWidth, boxHeight) / 2,\n                pointStyle: labelPointStyle.pointStyle,\n                rotation: labelPointStyle.rotation,\n                borderWidth: 1\n            };\n            const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n            const centerY = colorY + boxHeight / 2;\n            ctx.strokeStyle = options.multiKeyBackground;\n            ctx.fillStyle = options.multiKeyBackground;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.fillStyle = labelColors.backgroundColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au)(ctx, drawOptions, centerX, centerY);\n        } else {\n            ctx.lineWidth = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i)(labelColors.borderWidth) ? Math.max(...Object.values(labelColors.borderWidth)) : labelColors.borderWidth || 1;\n            ctx.strokeStyle = labelColors.borderColor;\n            ctx.setLineDash(labelColors.borderDash || []);\n            ctx.lineDashOffset = labelColors.borderDashOffset || 0;\n            const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth - boxPadding);\n            const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - boxPadding - 2);\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(labelColors.borderRadius);\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                ctx.fillStyle = options.multiKeyBackground;\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: outerX,\n                    y: colorY,\n                    w: boxWidth,\n                    h: boxHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n                ctx.stroke();\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: innerX,\n                    y: colorY + 1,\n                    w: boxWidth - 2,\n                    h: boxHeight - 2,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillStyle = options.multiKeyBackground;\n                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n                ctx.fillStyle = labelColors.backgroundColor;\n                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n            }\n        }\n        ctx.fillStyle = this.labelTextColors[i];\n    }\n    drawBody(pt, ctx, options) {\n        const { body } = this;\n        const { bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding } = options;\n        const bodyFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.bodyFont);\n        let bodyLineHeight = bodyFont.lineHeight;\n        let xLinePadding = 0;\n        const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n        const fillLineOfText = function(line) {\n            ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n            pt.y += bodyLineHeight + bodySpacing;\n        };\n        const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n        let bodyItem, textColor, lines, i, j, ilen, jlen;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = \"middle\";\n        ctx.font = bodyFont.string;\n        pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n        ctx.fillStyle = options.bodyColor;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.beforeBody, fillLineOfText);\n        xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n        for(i = 0, ilen = body.length; i < ilen; ++i){\n            bodyItem = body[i];\n            textColor = this.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.before, fillLineOfText);\n            lines = bodyItem.lines;\n            if (displayColors && lines.length) {\n                this._drawColorBox(ctx, pt, i, rtlHelper, options);\n                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n            }\n            for(j = 0, jlen = lines.length; j < jlen; ++j){\n                fillLineOfText(lines[j]);\n                bodyLineHeight = bodyFont.lineHeight;\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(bodyItem.after, fillLineOfText);\n        }\n        xLinePadding = 0;\n        bodyLineHeight = bodyFont.lineHeight;\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q)(this.afterBody, fillLineOfText);\n        pt.y -= bodySpacing;\n    }\n    drawFooter(pt, ctx, options) {\n        const footer = this.footer;\n        const length = footer.length;\n        let footerFont, i;\n        if (length) {\n            const rtlHelper = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA)(options.rtl, this.x, this.width);\n            pt.x = getAlignedX(this, options.footerAlign, options);\n            pt.y += options.footerMarginTop;\n            ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n            ctx.textBaseline = \"middle\";\n            footerFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(options.footerFont);\n            ctx.fillStyle = options.footerColor;\n            ctx.font = footerFont.string;\n            for(i = 0; i < length; ++i){\n                ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n                pt.y += footerFont.lineHeight + options.footerSpacing;\n            }\n        }\n    }\n    drawBackground(pt, ctx, tooltipSize, options) {\n        const { xAlign, yAlign } = this;\n        const { x, y } = pt;\n        const { width, height } = tooltipSize;\n        const { topLeft, topRight, bottomLeft, bottomRight } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(options.cornerRadius);\n        ctx.fillStyle = options.backgroundColor;\n        ctx.strokeStyle = options.borderColor;\n        ctx.lineWidth = options.borderWidth;\n        ctx.beginPath();\n        ctx.moveTo(x + topLeft, y);\n        if (yAlign === \"top\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width - topRight, y);\n        ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n        if (yAlign === \"center\" && xAlign === \"right\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + width, y + height - bottomRight);\n        ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n        if (yAlign === \"bottom\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x + bottomLeft, y + height);\n        ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n        if (yAlign === \"center\" && xAlign === \"left\") {\n            this.drawCaret(pt, ctx, tooltipSize, options);\n        }\n        ctx.lineTo(x, y + topLeft);\n        ctx.quadraticCurveTo(x, y, x + topLeft, y);\n        ctx.closePath();\n        ctx.fill();\n        if (options.borderWidth > 0) {\n            ctx.stroke();\n        }\n    }\n    _updateAnimationTarget(options) {\n        const chart = this.chart;\n        const anims = this.$animations;\n        const animX = anims && anims.x;\n        const animY = anims && anims.y;\n        if (animX || animY) {\n            const position = positioners[options.position].call(this, this._active, this._eventPosition);\n            if (!position) {\n                return;\n            }\n            const size = this._size = getTooltipSize(this, options);\n            const positionAndSize = Object.assign({}, position, this._size);\n            const alignment = determineAlignment(chart, options, positionAndSize);\n            const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n            if (animX._to !== point.x || animY._to !== point.y) {\n                this.xAlign = alignment.xAlign;\n                this.yAlign = alignment.yAlign;\n                this.width = size.width;\n                this.height = size.height;\n                this.caretX = position.x;\n                this.caretY = position.y;\n                this._resolveAnimations().update(this, point);\n            }\n        }\n    }\n    _willRender() {\n        return !!this.opacity;\n    }\n    draw(ctx) {\n        const options = this.options.setContext(this.getContext());\n        let opacity = this.opacity;\n        if (!opacity) {\n            return;\n        }\n        this._updateAnimationTarget(options);\n        const tooltipSize = {\n            width: this.width,\n            height: this.height\n        };\n        const pt = {\n            x: this.x,\n            y: this.y\n        };\n        opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(options.padding);\n        const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n        if (options.enabled && hasTooltipContent) {\n            ctx.save();\n            ctx.globalAlpha = opacity;\n            this.drawBackground(pt, ctx, tooltipSize, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB)(ctx, options.textDirection);\n            pt.y += padding.top;\n            this.drawTitle(pt, ctx, options);\n            this.drawBody(pt, ctx, options);\n            this.drawFooter(pt, ctx, options);\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD)(ctx, options.textDirection);\n            ctx.restore();\n        }\n    }\n    getActiveElements() {\n        return this._active || [];\n    }\n    setActiveElements(activeElements, eventPosition) {\n        const lastActive = this._active;\n        const active = activeElements.map(({ datasetIndex, index })=>{\n            const meta = this.chart.getDatasetMeta(datasetIndex);\n            if (!meta) {\n                throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n            }\n            return {\n                datasetIndex,\n                element: meta.data[index],\n                index\n            };\n        });\n        const changed = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(lastActive, active);\n        const positionChanged = this._positionChanged(active, eventPosition);\n        if (changed || positionChanged) {\n            this._active = active;\n            this._eventPosition = eventPosition;\n            this._ignoreReplayEvents = true;\n            this.update(true);\n        }\n    }\n    handleEvent(e, replay, inChartArea = true) {\n        if (replay && this._ignoreReplayEvents) {\n            return false;\n        }\n        this._ignoreReplayEvents = false;\n        const options = this.options;\n        const lastActive = this._active || [];\n        const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n        const positionChanged = this._positionChanged(active, e);\n        const changed = replay || !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai)(active, lastActive) || positionChanged;\n        if (changed) {\n            this._active = active;\n            if (options.enabled || options.external) {\n                this._eventPosition = {\n                    x: e.x,\n                    y: e.y\n                };\n                this.update(true, replay);\n            }\n        }\n        return changed;\n    }\n    _getActiveElements(e, lastActive, replay, inChartArea) {\n        const options = this.options;\n        if (e.type === \"mouseout\") {\n            return [];\n        }\n        if (!inChartArea) {\n            return lastActive;\n        }\n        const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n        if (options.reverse) {\n            active.reverse();\n        }\n        return active;\n    }\n    _positionChanged(active, e) {\n        const { caretX, caretY, options } = this;\n        const position = positioners[options.position].call(this, active, e);\n        return position !== false && (caretX !== position.x || caretY !== position.y);\n    }\n}\nTooltip.positioners = positioners;\nvar plugin_tooltip = {\n    id: \"tooltip\",\n    _element: Tooltip,\n    positioners,\n    afterInit (chart, _args, options) {\n        if (options) {\n            chart.tooltip = new Tooltip({\n                chart,\n                options\n            });\n        }\n    },\n    beforeUpdate (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    reset (chart, _args, options) {\n        if (chart.tooltip) {\n            chart.tooltip.initialize(options);\n        }\n    },\n    afterDraw (chart) {\n        const tooltip = chart.tooltip;\n        if (tooltip && tooltip._willRender()) {\n            const args = {\n                tooltip\n            };\n            if (chart.notifyPlugins(\"beforeTooltipDraw\", args) === false) {\n                return;\n            }\n            tooltip.draw(chart.ctx);\n            chart.notifyPlugins(\"afterTooltipDraw\", args);\n        }\n    },\n    afterEvent (chart, args) {\n        if (chart.tooltip) {\n            const useFinalPosition = args.replay;\n            if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n                args.changed = true;\n            }\n        }\n    },\n    defaults: {\n        enabled: true,\n        external: null,\n        position: \"average\",\n        backgroundColor: \"rgba(0,0,0,0.8)\",\n        titleColor: \"#fff\",\n        titleFont: {\n            weight: \"bold\"\n        },\n        titleSpacing: 2,\n        titleMarginBottom: 6,\n        titleAlign: \"left\",\n        bodyColor: \"#fff\",\n        bodySpacing: 2,\n        bodyFont: {},\n        bodyAlign: \"left\",\n        footerColor: \"#fff\",\n        footerSpacing: 2,\n        footerMarginTop: 6,\n        footerFont: {\n            weight: \"bold\"\n        },\n        footerAlign: \"left\",\n        padding: 6,\n        caretPadding: 2,\n        caretSize: 5,\n        cornerRadius: 6,\n        boxHeight: (ctx, opts)=>opts.bodyFont.size,\n        boxWidth: (ctx, opts)=>opts.bodyFont.size,\n        multiKeyBackground: \"#fff\",\n        displayColors: true,\n        boxPadding: 0,\n        borderColor: \"rgba(0,0,0,0)\",\n        borderWidth: 0,\n        animation: {\n            duration: 400,\n            easing: \"easeOutQuart\"\n        },\n        animations: {\n            numbers: {\n                type: \"number\",\n                properties: [\n                    \"x\",\n                    \"y\",\n                    \"width\",\n                    \"height\",\n                    \"caretX\",\n                    \"caretY\"\n                ]\n            },\n            opacity: {\n                easing: \"linear\",\n                duration: 200\n            }\n        },\n        callbacks: {\n            beforeTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            title (tooltipItems) {\n                if (tooltipItems.length > 0) {\n                    const item = tooltipItems[0];\n                    const labels = item.chart.data.labels;\n                    const labelCount = labels ? labels.length : 0;\n                    if (this && this.options && this.options.mode === \"dataset\") {\n                        return item.dataset.label || \"\";\n                    } else if (item.label) {\n                        return item.label;\n                    } else if (labelCount > 0 && item.dataIndex < labelCount) {\n                        return labels[item.dataIndex];\n                    }\n                }\n                return \"\";\n            },\n            afterTitle: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            label (tooltipItem) {\n                if (this && this.options && this.options.mode === \"dataset\") {\n                    return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n                }\n                let label = tooltipItem.dataset.label || \"\";\n                if (label) {\n                    label += \": \";\n                }\n                const value = tooltipItem.formattedValue;\n                if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n                    label += value;\n                }\n                return label;\n            },\n            labelColor (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    borderColor: options.borderColor,\n                    backgroundColor: options.backgroundColor,\n                    borderWidth: options.borderWidth,\n                    borderDash: options.borderDash,\n                    borderDashOffset: options.borderDashOffset,\n                    borderRadius: 0\n                };\n            },\n            labelTextColor () {\n                return this.options.bodyColor;\n            },\n            labelPointStyle (tooltipItem) {\n                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n                const options = meta.controller.getStyle(tooltipItem.dataIndex);\n                return {\n                    pointStyle: options.pointStyle,\n                    rotation: options.rotation\n                };\n            },\n            afterLabel: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterBody: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            beforeFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            footer: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF,\n            afterFooter: _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF\n        }\n    },\n    defaultRoutes: {\n        bodyFont: \"font\",\n        footerFont: \"font\",\n        titleFont: \"font\"\n    },\n    descriptors: {\n        _scriptable: (name)=>name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n        _indexable: false,\n        callbacks: {\n            _scriptable: false,\n            _indexable: false\n        },\n        animation: {\n            _fallback: false\n        },\n        animations: {\n            _fallback: \"animation\"\n        }\n    },\n    additionalOptionScopes: [\n        \"interaction\"\n    ]\n};\nvar plugins = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    Decimation: plugin_decimation,\n    Filler: index,\n    Legend: plugin_legend,\n    SubTitle: plugin_subtitle,\n    Title: plugin_title,\n    Tooltip: plugin_tooltip\n});\nconst addIfString = (labels, raw, index, addedLabels)=>{\n    if (typeof raw === \"string\") {\n        index = labels.push(raw) - 1;\n        addedLabels.unshift({\n            index,\n            label: raw\n        });\n    } else if (isNaN(raw)) {\n        index = null;\n    }\n    return index;\n};\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n    const first = labels.indexOf(raw);\n    if (first === -1) {\n        return addIfString(labels, raw, index, addedLabels);\n    }\n    const last = labels.lastIndexOf(raw);\n    return first !== last ? index : first;\n}\nconst validIndex = (index, max)=>index === null ? null : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(Math.round(index), 0, max);\nclass CategoryScale extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this._startValue = undefined;\n        this._valueRange = 0;\n        this._addedLabels = [];\n    }\n    init(scaleOptions) {\n        const added = this._addedLabels;\n        if (added.length) {\n            const labels = this.getLabels();\n            for (const { index, label } of added){\n                if (labels[index] === label) {\n                    labels.splice(index, 1);\n                }\n            }\n            this._addedLabels = [];\n        }\n        super.init(scaleOptions);\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        const labels = this.getLabels();\n        index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(index, raw), this._addedLabels);\n        return validIndex(index, labels.length - 1);\n    }\n    determineDataLimits() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this.getMinMax(true);\n        if (this.options.bounds === \"ticks\") {\n            if (!minDefined) {\n                min = 0;\n            }\n            if (!maxDefined) {\n                max = this.getLabels().length - 1;\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const min = this.min;\n        const max = this.max;\n        const offset = this.options.offset;\n        const ticks = [];\n        let labels = this.getLabels();\n        labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n        this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n        this._startValue = this.min - (offset ? 0.5 : 0);\n        for(let value = min; value <= max; value++){\n            ticks.push({\n                value\n            });\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        const labels = this.getLabels();\n        if (value >= 0 && value < labels.length) {\n            return labels[value];\n        }\n        return value;\n    }\n    configure() {\n        super.configure();\n        if (!this.isHorizontal()) {\n            this._reversePixels = !this._reversePixels;\n        }\n    }\n    getPixelForValue(value) {\n        if (typeof value !== \"number\") {\n            value = this.parse(value);\n        }\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getPixelForTick(index) {\n        const ticks = this.ticks;\n        if (index < 0 || index > ticks.length - 1) {\n            return null;\n        }\n        return this.getPixelForValue(ticks[index].value);\n    }\n    getValueForPixel(pixel) {\n        return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n    }\n    getBasePixel() {\n        return this.bottom;\n    }\n}\nCategoryScale.id = \"category\";\nCategoryScale.defaults = {\n    ticks: {\n        callback: CategoryScale.prototype.getLabelForValue\n    }\n};\nfunction generateTicks$1(generationOptions, dataRange) {\n    const ticks = [];\n    const MIN_SPACING = 1e-14;\n    const { bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds } = generationOptions;\n    const unit = step || 1;\n    const maxSpaces = maxTicks - 1;\n    const { min: rmin, max: rmax } = dataRange;\n    const minDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(min);\n    const maxDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(max);\n    const countDefined = !(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(count);\n    const minSpacing = (rmax - rmin) / (maxDigits + 1);\n    let spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)((rmax - rmin) / maxSpaces / unit) * unit;\n    let factor, niceMin, niceMax, numSpaces;\n    if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n        return [\n            {\n                value: rmin\n            },\n            {\n                value: rmax\n            }\n        ];\n    }\n    numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n    if (numSpaces > maxSpaces) {\n        spacing = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI)(numSpaces * spacing / maxSpaces / unit) * unit;\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision)) {\n        factor = Math.pow(10, precision);\n        spacing = Math.ceil(spacing * factor) / factor;\n    }\n    if (bounds === \"ticks\") {\n        niceMin = Math.floor(rmin / spacing) * spacing;\n        niceMax = Math.ceil(rmax / spacing) * spacing;\n    } else {\n        niceMin = rmin;\n        niceMax = rmax;\n    }\n    if (minDefined && maxDefined && step && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ)((max - min) / step, spacing / 1000)) {\n        numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n        spacing = (max - min) / numSpaces;\n        niceMin = min;\n        niceMax = max;\n    } else if (countDefined) {\n        niceMin = minDefined ? min : niceMin;\n        niceMax = maxDefined ? max : niceMax;\n        numSpaces = count - 1;\n        spacing = (niceMax - niceMin) / numSpaces;\n    } else {\n        numSpaces = (niceMax - niceMin) / spacing;\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n            numSpaces = Math.round(numSpaces);\n        } else {\n            numSpaces = Math.ceil(numSpaces);\n        }\n    }\n    const decimalPlaces = Math.max((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(spacing), (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL)(niceMin));\n    factor = Math.pow(10, (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(precision) ? decimalPlaces : precision);\n    niceMin = Math.round(niceMin * factor) / factor;\n    niceMax = Math.round(niceMax * factor) / factor;\n    let j = 0;\n    if (minDefined) {\n        if (includeBounds && niceMin !== min) {\n            ticks.push({\n                value: min\n            });\n            if (niceMin < min) {\n                j++;\n            }\n            if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n                j++;\n            }\n        } else if (niceMin < min) {\n            j++;\n        }\n    }\n    for(; j < numSpaces; ++j){\n        ticks.push({\n            value: Math.round((niceMin + j * spacing) * factor) / factor\n        });\n    }\n    if (maxDefined && includeBounds && niceMax !== max) {\n        if (ticks.length && (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK)(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n            ticks[ticks.length - 1].value = max;\n        } else {\n            ticks.push({\n                value: max\n            });\n        }\n    } else if (!maxDefined || niceMax === max) {\n        ticks.push({\n            value: niceMax\n        });\n    }\n    return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, { horizontal, minRotation }) {\n    const rad = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(minRotation);\n    const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n    const length = 0.75 * minSpacing * (\"\" + value).length;\n    return Math.min(minSpacing / ratio, length);\n}\nclass LinearScaleBase extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._endValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(raw)) {\n            return null;\n        }\n        if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n            return null;\n        }\n        return +raw;\n    }\n    handleTickRangeOptions() {\n        const { beginAtZero } = this.options;\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let { min, max } = this;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        if (beginAtZero) {\n            const minSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(min);\n            const maxSign = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s)(max);\n            if (minSign < 0 && maxSign < 0) {\n                setMax(0);\n            } else if (minSign > 0 && maxSign > 0) {\n                setMin(0);\n            }\n        }\n        if (min === max) {\n            let offset = 1;\n            if (max >= Number.MAX_SAFE_INTEGER || min <= Number.MIN_SAFE_INTEGER) {\n                offset = Math.abs(max * 0.05);\n            }\n            setMax(max + offset);\n            if (!beginAtZero) {\n                setMin(min - offset);\n            }\n        }\n        this.min = min;\n        this.max = max;\n    }\n    getTickLimit() {\n        const tickOpts = this.options.ticks;\n        let { maxTicksLimit, stepSize } = tickOpts;\n        let maxTicks;\n        if (stepSize) {\n            maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n            if (maxTicks > 1000) {\n                console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n                maxTicks = 1000;\n            }\n        } else {\n            maxTicks = this.computeTickLimit();\n            maxTicksLimit = maxTicksLimit || 11;\n        }\n        if (maxTicksLimit) {\n            maxTicks = Math.min(maxTicksLimit, maxTicks);\n        }\n        return maxTicks;\n    }\n    computeTickLimit() {\n        return Number.POSITIVE_INFINITY;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        let maxTicks = this.getTickLimit();\n        maxTicks = Math.max(2, maxTicks);\n        const numericGeneratorOptions = {\n            maxTicks,\n            bounds: opts.bounds,\n            min: opts.min,\n            max: opts.max,\n            precision: tickOpts.precision,\n            step: tickOpts.stepSize,\n            count: tickOpts.count,\n            maxDigits: this._maxDigits(),\n            horizontal: this.isHorizontal(),\n            minRotation: tickOpts.minRotation || 0,\n            includeBounds: tickOpts.includeBounds !== false\n        };\n        const dataRange = this._range || this;\n        const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    configure() {\n        const ticks = this.ticks;\n        let start = this.min;\n        let end = this.max;\n        super.configure();\n        if (this.options.offset && ticks.length) {\n            const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n            start -= offset;\n            end += offset;\n        }\n        this._startValue = start;\n        this._endValue = end;\n        this._valueRange = end - start;\n    }\n    getLabelForValue(value) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n}\nclass LinearScale extends LinearScaleBase {\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? max : 1;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        const horizontal = this.isHorizontal();\n        const length = horizontal ? this.width : this.height;\n        const minRotation = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.options.ticks.minRotation);\n        const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n        const tickFont = this._resolveTickFontOptions(0);\n        return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n    }\n    getPixelForValue(value) {\n        return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n    }\n}\nLinearScale.id = \"linear\";\nLinearScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.numeric\n    }\n};\nfunction isMajor(tickVal) {\n    const remain = tickVal / Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal)));\n    return remain === 1;\n}\nfunction generateTicks(generationOptions, dataRange) {\n    const endExp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.max));\n    const endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n    const ticks = [];\n    let tickVal = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.min, Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(dataRange.min))));\n    let exp = Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(tickVal));\n    let significand = Math.floor(tickVal / Math.pow(10, exp));\n    let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n    do {\n        ticks.push({\n            value: tickVal,\n            major: isMajor(tickVal)\n        });\n        ++significand;\n        if (significand === 10) {\n            significand = 1;\n            ++exp;\n            precision = exp >= 0 ? 1 : precision;\n        }\n        tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;\n    }while (exp < endExp || exp === endExp && significand < endSignificand);\n    const lastTick = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B)(generationOptions.max, tickVal);\n    ticks.push({\n        value: lastTick,\n        major: isMajor(tickVal)\n    });\n    return ticks;\n}\nclass LogarithmicScale extends Scale {\n    constructor(cfg){\n        super(cfg);\n        this.start = undefined;\n        this.end = undefined;\n        this._startValue = undefined;\n        this._valueRange = 0;\n    }\n    parse(raw, index) {\n        const value = LinearScaleBase.prototype.parse.apply(this, [\n            raw,\n            index\n        ]);\n        if (value === 0) {\n            this._zero = true;\n            return undefined;\n        }\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value) && value > 0 ? value : null;\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(true);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) ? Math.max(0, min) : null;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) ? Math.max(0, max) : null;\n        if (this.options.beginAtZero) {\n            this._zero = true;\n        }\n        this.handleTickRangeOptions();\n    }\n    handleTickRangeOptions() {\n        const { minDefined, maxDefined } = this.getUserBounds();\n        let min = this.min;\n        let max = this.max;\n        const setMin = (v)=>min = minDefined ? min : v;\n        const setMax = (v)=>max = maxDefined ? max : v;\n        const exp = (v, m)=>Math.pow(10, Math.floor((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(v)) + m);\n        if (min === max) {\n            if (min <= 0) {\n                setMin(1);\n                setMax(10);\n            } else {\n                setMin(exp(min, -1));\n                setMax(exp(max, +1));\n            }\n        }\n        if (min <= 0) {\n            setMin(exp(max, -1));\n        }\n        if (max <= 0) {\n            setMax(exp(min, +1));\n        }\n        if (this._zero && this.min !== this._suggestedMin && min === exp(this.min, 0)) {\n            setMin(exp(min, -1));\n        }\n        this.min = min;\n        this.max = max;\n    }\n    buildTicks() {\n        const opts = this.options;\n        const generationOptions = {\n            min: this._userMin,\n            max: this._userMax\n        };\n        const ticks = generateTicks(generationOptions, this);\n        if (opts.bounds === \"ticks\") {\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH)(ticks, this, \"value\");\n        }\n        if (opts.reverse) {\n            ticks.reverse();\n            this.start = this.max;\n            this.end = this.min;\n        } else {\n            this.start = this.min;\n            this.end = this.max;\n        }\n        return ticks;\n    }\n    getLabelForValue(value) {\n        return value === undefined ? \"0\" : (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o)(value, this.chart.options.locale, this.options.ticks.format);\n    }\n    configure() {\n        const start = this.min;\n        super.configure();\n        this._startValue = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n        this._valueRange = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(this.max) - (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(start);\n    }\n    getPixelForValue(value) {\n        if (value === undefined || value === 0) {\n            value = this.min;\n        }\n        if (value === null || isNaN(value)) {\n            return NaN;\n        }\n        return this.getPixelForDecimal(value === this.min ? 0 : ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z)(value) - this._startValue) / this._valueRange);\n    }\n    getValueForPixel(pixel) {\n        const decimal = this.getDecimalForPixel(pixel);\n        return Math.pow(10, this._startValue + decimal * this._valueRange);\n    }\n}\nLogarithmicScale.id = \"logarithmic\";\nLogarithmicScale.defaults = {\n    ticks: {\n        callback: Ticks.formatters.logarithmic,\n        major: {\n            enabled: true\n        }\n    }\n};\nfunction getTickBackdropHeight(opts) {\n    const tickOpts = opts.ticks;\n    if (tickOpts.display && opts.display) {\n        const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(tickOpts.backdropPadding);\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(tickOpts.font && tickOpts.font.size, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.d.font.size) + padding.height;\n    }\n    return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n    label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b)(label) ? label : [\n        label\n    ];\n    return {\n        w: (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM)(ctx, font.string, label),\n        h: label.length * font.lineHeight\n    };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n    if (angle === min || angle === max) {\n        return {\n            start: pos - size / 2,\n            end: pos + size / 2\n        };\n    } else if (angle < min || angle > max) {\n        return {\n            start: pos - size,\n            end: pos\n        };\n    }\n    return {\n        start: pos,\n        end: pos + size\n    };\n}\nfunction fitWithPointLabels(scale) {\n    const orig = {\n        l: scale.left + scale._padding.left,\n        r: scale.right - scale._padding.right,\n        t: scale.top + scale._padding.top,\n        b: scale.bottom - scale._padding.bottom\n    };\n    const limits = Object.assign({}, orig);\n    const labelSizes = [];\n    const padding = [];\n    const valueCount = scale._pointLabels.length;\n    const pointLabelOpts = scale.options.pointLabels;\n    const additionalAngle = pointLabelOpts.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n        padding[i] = opts.padding;\n        const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(opts.font);\n        const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n        labelSizes[i] = textSize;\n        const angleRadians = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(scale.getIndexAngle(i) + additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)(angleRadians));\n        const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n        const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n        updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n    }\n    scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n    scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n    const sin = Math.abs(Math.sin(angle));\n    const cos = Math.abs(Math.cos(angle));\n    let x = 0;\n    let y = 0;\n    if (hLimits.start < orig.l) {\n        x = (orig.l - hLimits.start) / sin;\n        limits.l = Math.min(limits.l, orig.l - x);\n    } else if (hLimits.end > orig.r) {\n        x = (hLimits.end - orig.r) / sin;\n        limits.r = Math.max(limits.r, orig.r + x);\n    }\n    if (vLimits.start < orig.t) {\n        y = (orig.t - vLimits.start) / cos;\n        limits.t = Math.min(limits.t, orig.t - y);\n    } else if (vLimits.end > orig.b) {\n        y = (vLimits.end - orig.b) / cos;\n        limits.b = Math.max(limits.b, orig.b + y);\n    }\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n    const items = [];\n    const valueCount = scale._pointLabels.length;\n    const opts = scale.options;\n    const extra = getTickBackdropHeight(opts) / 2;\n    const outerDistance = scale.drawingArea;\n    const additionalAngle = opts.pointLabels.centerPointLabels ? _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P / valueCount : 0;\n    for(let i = 0; i < valueCount; i++){\n        const pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + padding[i], additionalAngle);\n        const angle = Math.round((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F)((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(pointLabelPosition.angle + _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H)));\n        const size = labelSizes[i];\n        const y = yForAngle(pointLabelPosition.y, size.h, angle);\n        const textAlign = getTextAlignForAngle(angle);\n        const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n        items.push({\n            x: pointLabelPosition.x,\n            y,\n            textAlign,\n            left,\n            top: y,\n            right: left + size.w,\n            bottom: y + size.h\n        });\n    }\n    return items;\n}\nfunction getTextAlignForAngle(angle) {\n    if (angle === 0 || angle === 180) {\n        return \"center\";\n    } else if (angle < 180) {\n        return \"left\";\n    }\n    return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n    if (align === \"right\") {\n        x -= w;\n    } else if (align === \"center\") {\n        x -= w / 2;\n    }\n    return x;\n}\nfunction yForAngle(y, h, angle) {\n    if (angle === 90 || angle === 270) {\n        y -= h / 2;\n    } else if (angle > 270 || angle < 90) {\n        y -= h;\n    }\n    return y;\n}\nfunction drawPointLabels(scale, labelCount) {\n    const { ctx, options: { pointLabels } } = scale;\n    for(let i = labelCount - 1; i >= 0; i--){\n        const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n        const plFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n        const { x, y, textAlign, left, top, right, bottom } = scale._pointLabelItems[i];\n        const { backdropColor } = optsAtIndex;\n        if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(backdropColor)) {\n            const borderRadius = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax)(optsAtIndex.borderRadius);\n            const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n            ctx.fillStyle = backdropColor;\n            const backdropLeft = left - padding.left;\n            const backdropTop = top - padding.top;\n            const backdropWidth = right - left + padding.width;\n            const backdropHeight = bottom - top + padding.height;\n            if (Object.values(borderRadius).some((v)=>v !== 0)) {\n                ctx.beginPath();\n                (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av)(ctx, {\n                    x: backdropLeft,\n                    y: backdropTop,\n                    w: backdropWidth,\n                    h: backdropHeight,\n                    radius: borderRadius\n                });\n                ctx.fill();\n            } else {\n                ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n            }\n        }\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n            color: optsAtIndex.color,\n            textAlign: textAlign,\n            textBaseline: \"middle\"\n        });\n    }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n    const { ctx } = scale;\n    if (circular) {\n        ctx.arc(scale.xCenter, scale.yCenter, radius, 0, _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T);\n    } else {\n        let pointPosition = scale.getPointPosition(0, radius);\n        ctx.moveTo(pointPosition.x, pointPosition.y);\n        for(let i = 1; i < labelCount; i++){\n            pointPosition = scale.getPointPosition(i, radius);\n            ctx.lineTo(pointPosition.x, pointPosition.y);\n        }\n    }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount) {\n    const ctx = scale.ctx;\n    const circular = gridLineOpts.circular;\n    const { color, lineWidth } = gridLineOpts;\n    if (!circular && !labelCount || !color || !lineWidth || radius < 0) {\n        return;\n    }\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.lineWidth = lineWidth;\n    ctx.setLineDash(gridLineOpts.borderDash);\n    ctx.lineDashOffset = gridLineOpts.borderDashOffset;\n    ctx.beginPath();\n    pathRadiusLine(scale, radius, circular, labelCount);\n    ctx.closePath();\n    ctx.stroke();\n    ctx.restore();\n}\nfunction createPointLabelContext(parent, index, label) {\n    return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h)(parent, {\n        label,\n        index,\n        type: \"pointLabel\"\n    });\n}\nclass RadialLinearScale extends LinearScaleBase {\n    constructor(cfg){\n        super(cfg);\n        this.xCenter = undefined;\n        this.yCenter = undefined;\n        this.drawingArea = undefined;\n        this._pointLabels = [];\n        this._pointLabelItems = [];\n    }\n    setDimensions() {\n        const padding = this._padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(getTickBackdropHeight(this.options) / 2);\n        const w = this.width = this.maxWidth - padding.width;\n        const h = this.height = this.maxHeight - padding.height;\n        this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n        this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n        this.drawingArea = Math.floor(Math.min(w, h) / 2);\n    }\n    determineDataLimits() {\n        const { min, max } = this.getMinMax(false);\n        this.min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : 0;\n        this.max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : 0;\n        this.handleTickRangeOptions();\n    }\n    computeTickLimit() {\n        return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n    }\n    generateTickLabels(ticks) {\n        LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n        this._pointLabels = this.getLabels().map((value, index)=>{\n            const label = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(this.options.pointLabels.callback, [\n                value,\n                index\n            ], this);\n            return label || label === 0 ? label : \"\";\n        }).filter((v, i)=>this.chart.getDataVisibility(i));\n    }\n    fit() {\n        const opts = this.options;\n        if (opts.display && opts.pointLabels.display) {\n            fitWithPointLabels(this);\n        } else {\n            this.setCenterPoint(0, 0, 0, 0);\n        }\n    }\n    setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n        this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n        this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n        this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n    }\n    getIndexAngle(index) {\n        const angleMultiplier = _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T / (this._pointLabels.length || 1);\n        const startAngle = this.options.startAngle || 0;\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az)(index * angleMultiplier + (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(startAngle));\n    }\n    getDistanceFromCenterForValue(value) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(value)) {\n            return NaN;\n        }\n        const scalingFactor = this.drawingArea / (this.max - this.min);\n        if (this.options.reverse) {\n            return (this.max - value) * scalingFactor;\n        }\n        return (value - this.min) * scalingFactor;\n    }\n    getValueForDistanceFromCenter(distance) {\n        if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(distance)) {\n            return NaN;\n        }\n        const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n        return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n    }\n    getPointLabelContext(index) {\n        const pointLabels = this._pointLabels || [];\n        if (index >= 0 && index < pointLabels.length) {\n            const pointLabel = pointLabels[index];\n            return createPointLabelContext(this.getContext(), index, pointLabel);\n        }\n    }\n    getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n        const angle = this.getIndexAngle(index) - _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H + additionalAngle;\n        return {\n            x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n            y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n            angle\n        };\n    }\n    getPointPositionForValue(index, value) {\n        return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n    }\n    getBasePosition(index) {\n        return this.getPointPositionForValue(index || 0, this.getBaseValue());\n    }\n    getPointLabelPosition(index) {\n        const { left, top, right, bottom } = this._pointLabelItems[index];\n        return {\n            left,\n            top,\n            right,\n            bottom\n        };\n    }\n    drawBackground() {\n        const { backgroundColor, grid: { circular } } = this.options;\n        if (backgroundColor) {\n            const ctx = this.ctx;\n            ctx.save();\n            ctx.beginPath();\n            pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n            ctx.closePath();\n            ctx.fillStyle = backgroundColor;\n            ctx.fill();\n            ctx.restore();\n        }\n    }\n    drawGrid() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const { angleLines, grid } = opts;\n        const labelCount = this._pointLabels.length;\n        let i, offset, position;\n        if (opts.pointLabels.display) {\n            drawPointLabels(this, labelCount);\n        }\n        if (grid.display) {\n            this.ticks.forEach((tick, index)=>{\n                if (index !== 0) {\n                    offset = this.getDistanceFromCenterForValue(tick.value);\n                    const optsAtIndex = grid.setContext(this.getContext(index - 1));\n                    drawRadiusLine(this, optsAtIndex, offset, labelCount);\n                }\n            });\n        }\n        if (angleLines.display) {\n            ctx.save();\n            for(i = labelCount - 1; i >= 0; i--){\n                const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n                const { color, lineWidth } = optsAtIndex;\n                if (!lineWidth || !color) {\n                    continue;\n                }\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = color;\n                ctx.setLineDash(optsAtIndex.borderDash);\n                ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n                offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n                position = this.getPointPosition(i, offset);\n                ctx.beginPath();\n                ctx.moveTo(this.xCenter, this.yCenter);\n                ctx.lineTo(position.x, position.y);\n                ctx.stroke();\n            }\n            ctx.restore();\n        }\n    }\n    drawBorder() {}\n    drawLabels() {\n        const ctx = this.ctx;\n        const opts = this.options;\n        const tickOpts = opts.ticks;\n        if (!tickOpts.display) {\n            return;\n        }\n        const startAngle = this.getIndexAngle(0);\n        let offset, width;\n        ctx.save();\n        ctx.translate(this.xCenter, this.yCenter);\n        ctx.rotate(startAngle);\n        ctx.textAlign = \"center\";\n        ctx.textBaseline = \"middle\";\n        this.ticks.forEach((tick, index)=>{\n            if (index === 0 && !opts.reverse) {\n                return;\n            }\n            const optsAtIndex = tickOpts.setContext(this.getContext(index));\n            const tickFont = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O)(optsAtIndex.font);\n            offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n            if (optsAtIndex.showLabelBackdrop) {\n                ctx.font = tickFont.string;\n                width = ctx.measureText(tick.label).width;\n                ctx.fillStyle = optsAtIndex.backdropColor;\n                const padding = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K)(optsAtIndex.backdropPadding);\n                ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n            }\n            (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M)(ctx, tick.label, 0, -offset, tickFont, {\n                color: optsAtIndex.color\n            });\n        });\n        ctx.restore();\n    }\n    drawTitle() {}\n}\nRadialLinearScale.id = \"radialLinear\";\nRadialLinearScale.defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n        display: true,\n        lineWidth: 1,\n        borderDash: [],\n        borderDashOffset: 0.0\n    },\n    grid: {\n        circular: false\n    },\n    startAngle: 0,\n    ticks: {\n        showLabelBackdrop: true,\n        callback: Ticks.formatters.numeric\n    },\n    pointLabels: {\n        backdropColor: undefined,\n        backdropPadding: 2,\n        display: true,\n        font: {\n            size: 10\n        },\n        callback (label) {\n            return label;\n        },\n        padding: 5,\n        centerPointLabels: false\n    }\n};\nRadialLinearScale.defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n};\nRadialLinearScale.descriptors = {\n    angleLines: {\n        _fallback: \"grid\"\n    }\n};\nconst INTERVALS = {\n    millisecond: {\n        common: true,\n        size: 1,\n        steps: 1000\n    },\n    second: {\n        common: true,\n        size: 1000,\n        steps: 60\n    },\n    minute: {\n        common: true,\n        size: 60000,\n        steps: 60\n    },\n    hour: {\n        common: true,\n        size: 3600000,\n        steps: 24\n    },\n    day: {\n        common: true,\n        size: 86400000,\n        steps: 30\n    },\n    week: {\n        common: false,\n        size: 604800000,\n        steps: 4\n    },\n    month: {\n        common: true,\n        size: 2.628e9,\n        steps: 12\n    },\n    quarter: {\n        common: false,\n        size: 7.884e9,\n        steps: 4\n    },\n    year: {\n        common: true,\n        size: 3.154e10\n    }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction sorter(a, b) {\n    return a - b;\n}\nfunction parse(scale, input) {\n    if ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k)(input)) {\n        return null;\n    }\n    const adapter = scale._adapter;\n    const { parser, round, isoWeekday } = scale._parseOpts;\n    let value = input;\n    if (typeof parser === \"function\") {\n        value = parser(value);\n    }\n    if (!(0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(value)) {\n        value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n    }\n    if (value === null) {\n        return null;\n    }\n    if (round) {\n        value = round === \"week\" && ((0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round);\n    }\n    return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n    const ilen = UNITS.length;\n    for(let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i){\n        const interval = INTERVALS[UNITS[i]];\n        const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n        if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n            return UNITS[i];\n        }\n    }\n    return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n    for(let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--){\n        const unit = UNITS[i];\n        if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n            return unit;\n        }\n    }\n    return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n    for(let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i){\n        if (INTERVALS[UNITS[i]].common) {\n            return UNITS[i];\n        }\n    }\n}\nfunction addTick(ticks, time, timestamps) {\n    if (!timestamps) {\n        ticks[time] = true;\n    } else if (timestamps.length) {\n        const { lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO)(timestamps, time);\n        const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n        ticks[timestamp] = true;\n    }\n}\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n    const adapter = scale._adapter;\n    const first = +adapter.startOf(ticks[0].value, majorUnit);\n    const last = ticks[ticks.length - 1].value;\n    let major, index;\n    for(major = first; major <= last; major = +adapter.add(major, 1, majorUnit)){\n        index = map[major];\n        if (index >= 0) {\n            ticks[index].major = true;\n        }\n    }\n    return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n    const ticks = [];\n    const map = {};\n    const ilen = values.length;\n    let i, value;\n    for(i = 0; i < ilen; ++i){\n        value = values[i];\n        map[value] = i;\n        ticks.push({\n            value,\n            major: false\n        });\n    }\n    return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\nclass TimeScale extends Scale {\n    constructor(props){\n        super(props);\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n        this._unit = \"day\";\n        this._majorUnit = undefined;\n        this._offsets = {};\n        this._normalized = false;\n        this._parseOpts = undefined;\n    }\n    init(scaleOpts, opts) {\n        const time = scaleOpts.time || (scaleOpts.time = {});\n        const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n        adapter.init(opts);\n        (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac)(time.displayFormats, adapter.formats());\n        this._parseOpts = {\n            parser: time.parser,\n            round: time.round,\n            isoWeekday: time.isoWeekday\n        };\n        super.init(scaleOpts);\n        this._normalized = opts.normalized;\n    }\n    parse(raw, index) {\n        if (raw === undefined) {\n            return null;\n        }\n        return parse(this, raw);\n    }\n    beforeLayout() {\n        super.beforeLayout();\n        this._cache = {\n            data: [],\n            labels: [],\n            all: []\n        };\n    }\n    determineDataLimits() {\n        const options = this.options;\n        const adapter = this._adapter;\n        const unit = options.time.unit || \"day\";\n        let { min, max, minDefined, maxDefined } = this.getUserBounds();\n        function _applyBounds(bounds) {\n            if (!minDefined && !isNaN(bounds.min)) {\n                min = Math.min(min, bounds.min);\n            }\n            if (!maxDefined && !isNaN(bounds.max)) {\n                max = Math.max(max, bounds.max);\n            }\n        }\n        if (!minDefined || !maxDefined) {\n            _applyBounds(this._getLabelBounds());\n            if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n                _applyBounds(this.getMinMax(false));\n            }\n        }\n        min = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n        max = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g)(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n        this.min = Math.min(min, max - 1);\n        this.max = Math.max(min + 1, max);\n    }\n    _getLabelBounds() {\n        const arr = this.getLabelTimestamps();\n        let min = Number.POSITIVE_INFINITY;\n        let max = Number.NEGATIVE_INFINITY;\n        if (arr.length) {\n            min = arr[0];\n            max = arr[arr.length - 1];\n        }\n        return {\n            min,\n            max\n        };\n    }\n    buildTicks() {\n        const options = this.options;\n        const timeOpts = options.time;\n        const tickOpts = options.ticks;\n        const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n        if (options.bounds === \"ticks\" && timestamps.length) {\n            this.min = this._userMin || timestamps[0];\n            this.max = this._userMax || timestamps[timestamps.length - 1];\n        }\n        const min = this.min;\n        const max = this.max;\n        const ticks = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN)(timestamps, min, max);\n        this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n        this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? undefined : determineMajorUnit(this._unit);\n        this.initOffsets(timestamps);\n        if (options.reverse) {\n            ticks.reverse();\n        }\n        return ticksFromTimestamps(this, ticks, this._majorUnit);\n    }\n    afterAutoSkip() {\n        if (this.options.offsetAfterAutoskip) {\n            this.initOffsets(this.ticks.map((tick)=>+tick.value));\n        }\n    }\n    initOffsets(timestamps) {\n        let start = 0;\n        let end = 0;\n        let first, last;\n        if (this.options.offset && timestamps.length) {\n            first = this.getDecimalForValue(timestamps[0]);\n            if (timestamps.length === 1) {\n                start = 1 - first;\n            } else {\n                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n            }\n            last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n            if (timestamps.length === 1) {\n                end = last;\n            } else {\n                end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n            }\n        }\n        const limit = timestamps.length < 3 ? 0.5 : 0.25;\n        start = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(start, 0, limit);\n        end = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E)(end, 0, limit);\n        this._offsets = {\n            start,\n            end,\n            factor: 1 / (start + 1 + end)\n        };\n    }\n    _generate() {\n        const adapter = this._adapter;\n        const min = this.min;\n        const max = this.max;\n        const options = this.options;\n        const timeOpts = options.time;\n        const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n        const stepSize = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)(timeOpts.stepSize, 1);\n        const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n        const hasWeekday = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x)(weekday) || weekday === true;\n        const ticks = {};\n        let first = min;\n        let time, count;\n        if (hasWeekday) {\n            first = +adapter.startOf(first, \"isoWeek\", weekday);\n        }\n        first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n        if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n            throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n        }\n        const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n        for(time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++){\n            addTick(ticks, time, timestamps);\n        }\n        if (time === max || options.bounds === \"ticks\" || count === 1) {\n            addTick(ticks, time, timestamps);\n        }\n        return Object.keys(ticks).sort((a, b)=>a - b).map((x)=>+x);\n    }\n    getLabelForValue(value) {\n        const adapter = this._adapter;\n        const timeOpts = this.options.time;\n        if (timeOpts.tooltipFormat) {\n            return adapter.format(value, timeOpts.tooltipFormat);\n        }\n        return adapter.format(value, timeOpts.displayFormats.datetime);\n    }\n    _tickFormatFunction(time, index, ticks, format) {\n        const options = this.options;\n        const formats = options.time.displayFormats;\n        const unit = this._unit;\n        const majorUnit = this._majorUnit;\n        const minorFormat = unit && formats[unit];\n        const majorFormat = majorUnit && formats[majorUnit];\n        const tick = ticks[index];\n        const major = majorUnit && majorFormat && tick && tick.major;\n        const label = this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n        const formatter = options.ticks.callback;\n        return formatter ? (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C)(formatter, [\n            label,\n            index,\n            ticks\n        ], this) : label;\n    }\n    generateTickLabels(ticks) {\n        let i, ilen, tick;\n        for(i = 0, ilen = ticks.length; i < ilen; ++i){\n            tick = ticks[i];\n            tick.label = this._tickFormatFunction(tick.value, i, ticks);\n        }\n    }\n    getDecimalForValue(value) {\n        return value === null ? NaN : (value - this.min) / (this.max - this.min);\n    }\n    getPixelForValue(value) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForValue(value);\n        return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return this.min + pos * (this.max - this.min);\n    }\n    _getLabelSize(label) {\n        const ticksOpts = this.options.ticks;\n        const tickLabelWidth = this.ctx.measureText(label).width;\n        const angle = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t)(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n        const cosRotation = Math.cos(angle);\n        const sinRotation = Math.sin(angle);\n        const tickFontSize = this._resolveTickFontOptions(0).size;\n        return {\n            w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n            h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n        };\n    }\n    _getLabelCapacity(exampleTime) {\n        const timeOpts = this.options.time;\n        const displayFormats = timeOpts.displayFormats;\n        const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n        const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [\n            exampleTime\n        ], this._majorUnit), format);\n        const size = this._getLabelSize(exampleLabel);\n        const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n        return capacity > 0 ? capacity : 1;\n    }\n    getDataTimestamps() {\n        let timestamps = this._cache.data || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const metas = this.getMatchingVisibleMetas();\n        if (this._normalized && metas.length) {\n            return this._cache.data = metas[0].controller.getAllParsedValues(this);\n        }\n        for(i = 0, ilen = metas.length; i < ilen; ++i){\n            timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n        }\n        return this._cache.data = this.normalize(timestamps);\n    }\n    getLabelTimestamps() {\n        const timestamps = this._cache.labels || [];\n        let i, ilen;\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const labels = this.getLabels();\n        for(i = 0, ilen = labels.length; i < ilen; ++i){\n            timestamps.push(parse(this, labels[i]));\n        }\n        return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n    }\n    normalize(values) {\n        return (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._)(values.sort(sorter));\n    }\n}\nTimeScale.id = \"time\";\nTimeScale.defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n        parser: false,\n        unit: false,\n        round: false,\n        isoWeekday: false,\n        minUnit: \"millisecond\",\n        displayFormats: {}\n    },\n    ticks: {\n        source: \"auto\",\n        major: {\n            enabled: false\n        }\n    }\n};\nfunction interpolate(table, val, reverse) {\n    let lo = 0;\n    let hi = table.length - 1;\n    let prevSource, nextSource, prevTarget, nextTarget;\n    if (reverse) {\n        if (val >= table[lo].pos && val <= table[hi].pos) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"pos\", val));\n        }\n        ({ pos: prevSource, time: prevTarget } = table[lo]);\n        ({ pos: nextSource, time: nextTarget } = table[hi]);\n    } else {\n        if (val >= table[lo].time && val <= table[hi].time) {\n            ({ lo, hi } = (0,_chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z)(table, \"time\", val));\n        }\n        ({ time: prevSource, pos: prevTarget } = table[lo]);\n        ({ time: nextSource, pos: nextTarget } = table[hi]);\n    }\n    const span = nextSource - prevSource;\n    return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nclass TimeSeriesScale extends TimeScale {\n    constructor(props){\n        super(props);\n        this._table = [];\n        this._minPos = undefined;\n        this._tableRange = undefined;\n    }\n    initOffsets() {\n        const timestamps = this._getTimestampsForTable();\n        const table = this._table = this.buildLookupTable(timestamps);\n        this._minPos = interpolate(table, this.min);\n        this._tableRange = interpolate(table, this.max) - this._minPos;\n        super.initOffsets(timestamps);\n    }\n    buildLookupTable(timestamps) {\n        const { min, max } = this;\n        const items = [];\n        const table = [];\n        let i, ilen, prev, curr, next;\n        for(i = 0, ilen = timestamps.length; i < ilen; ++i){\n            curr = timestamps[i];\n            if (curr >= min && curr <= max) {\n                items.push(curr);\n            }\n        }\n        if (items.length < 2) {\n            return [\n                {\n                    time: min,\n                    pos: 0\n                },\n                {\n                    time: max,\n                    pos: 1\n                }\n            ];\n        }\n        for(i = 0, ilen = items.length; i < ilen; ++i){\n            next = items[i + 1];\n            prev = items[i - 1];\n            curr = items[i];\n            if (Math.round((next + prev) / 2) !== curr) {\n                table.push({\n                    time: curr,\n                    pos: i / (ilen - 1)\n                });\n            }\n        }\n        return table;\n    }\n    _getTimestampsForTable() {\n        let timestamps = this._cache.all || [];\n        if (timestamps.length) {\n            return timestamps;\n        }\n        const data = this.getDataTimestamps();\n        const label = this.getLabelTimestamps();\n        if (data.length && label.length) {\n            timestamps = this.normalize(data.concat(label));\n        } else {\n            timestamps = data.length ? data : label;\n        }\n        timestamps = this._cache.all = timestamps;\n        return timestamps;\n    }\n    getDecimalForValue(value) {\n        return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n    }\n    getValueForPixel(pixel) {\n        const offsets = this._offsets;\n        const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n        return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n    }\n}\nTimeSeriesScale.id = \"timeseries\";\nTimeSeriesScale.defaults = TimeScale.defaults;\nvar scales = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    CategoryScale: CategoryScale,\n    LinearScale: LinearScale,\n    LogarithmicScale: LogarithmicScale,\n    RadialLinearScale: RadialLinearScale,\n    TimeScale: TimeScale,\n    TimeSeriesScale: TimeSeriesScale\n});\nconst registerables = [\n    controllers,\n    elements,\n    plugins,\n    scales\n];\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Q0FLQyxHQUNva0U7QUFDeGdFO0FBRTdELE1BQU1rTjtJQUNKQyxhQUFjO1FBQ1osSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxPQUFPLEdBQUcsSUFBSUM7UUFDbkIsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdDO0lBQ25CO0lBQ0FDLFFBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRTtRQUNoQyxNQUFNQyxZQUFZSCxNQUFNSSxTQUFTLENBQUNGLEtBQUs7UUFDdkMsTUFBTUcsV0FBV0wsTUFBTU0sUUFBUTtRQUMvQkgsVUFBVUksT0FBTyxDQUFDQyxDQUFBQSxLQUFNQSxHQUFHO2dCQUN6QlQ7Z0JBQ0FVLFNBQVNULE1BQU1TLE9BQU87Z0JBQ3RCSjtnQkFDQUssYUFBYUMsS0FBS0MsR0FBRyxDQUFDWCxPQUFPRCxNQUFNYSxLQUFLLEVBQUVSO1lBQzVDO0lBQ0Y7SUFDQVMsV0FBVztRQUNULElBQUksSUFBSSxDQUFDdEIsUUFBUSxFQUFFO1lBQ2pCO1FBQ0Y7UUFDQSxJQUFJLENBQUNHLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUNILFFBQVEsR0FBR25OLDBEQUFnQkEsQ0FBQzBPLElBQUksQ0FBQ0MsUUFBUTtZQUM1QyxJQUFJLENBQUNDLE9BQU87WUFDWixJQUFJLENBQUN6QixRQUFRLEdBQUc7WUFDaEIsSUFBSSxJQUFJLENBQUNHLFFBQVEsRUFBRTtnQkFDakIsSUFBSSxDQUFDbUIsUUFBUTtZQUNmO1FBQ0Y7SUFDRjtJQUNBRyxRQUFRaEIsT0FBT2lCLEtBQUtDLEdBQUcsRUFBRSxFQUFFO1FBQ3pCLElBQUlDLFlBQVk7UUFDaEIsSUFBSSxD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RCxhQUFhLElBQUksQ0FBQ3ZnRCxNQUFNLENBQUM1TyxHQUFHLEdBQUdtdkQ7UUFDL0IsT0FBT0E7SUFDVDtJQUNBbUIsbUJBQW1CMXdELEtBQUssRUFBRTtRQUN4QixPQUFPLENBQUNneEMsWUFBWSxJQUFJLENBQUNvaEIsTUFBTSxFQUFFcHlELFNBQVMsSUFBSSxDQUFDcXlELE9BQU8sSUFBSSxJQUFJLENBQUNDLFdBQVc7SUFDNUU7SUFDQWhvQyxpQkFBaUJDLEtBQUssRUFBRTtRQUN0QixNQUFNNG1DLFVBQVUsSUFBSSxDQUFDckIsUUFBUTtRQUM3QixNQUFNdGxDLFVBQVUsSUFBSSxDQUFDQyxrQkFBa0IsQ0FBQ0YsU0FBUzRtQyxRQUFROTFELE1BQU0sR0FBRzgxRCxRQUFRendELEdBQUc7UUFDN0UsT0FBT3N3QyxZQUFZLElBQUksQ0FBQ29oQixNQUFNLEVBQUU1bkMsVUFBVSxJQUFJLENBQUM4bkMsV0FBVyxHQUFHLElBQUksQ0FBQ0QsT0FBTyxFQUFFO0lBQzdFO0FBQ0Y7QUFDQUYsZ0JBQWdCeHZELEVBQUUsR0FBRztBQUNyQnd2RCxnQkFBZ0IxbkUsUUFBUSxHQUFHa2xFLFVBQVVsbEUsUUFBUTtBQUU3QyxJQUFJK1osU0FBUyxXQUFXLEdBQUUzRyxPQUFPeU8sTUFBTSxDQUFDO0lBQ3hDNmxCLFdBQVc7SUFDWHExQixlQUFlQTtJQUNmc0MsYUFBYUE7SUFDYlMsa0JBQWtCQTtJQUNsQnFDLG1CQUFtQkE7SUFDbkIrQyxXQUFXQTtJQUNYd0MsaUJBQWlCQTtBQUNqQjtBQUVBLE1BQU1NLGdCQUFnQjtJQUNwQmhpQztJQUNBcmxCO0lBQ0FzSztJQUNBbFI7Q0FDRDtBQUUyckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jbGllbnQvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaGFydC5tanM/YmMxMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENoYXJ0LmpzIHYzLjkuMVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDIyIENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGQgYXMgZGVmYXVsdHMsIGkgYXMgaXNPYmplY3QsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgY3JlYXRlQ29udGV4dCwgaiBhcyBkZWZpbmVkLCBzIGFzIHNpZ24sIGsgYXMgaXNOdWxsT3JVbmRlZiwgXyBhcyBfYXJyYXlVbmlxdWUsIHQgYXMgdG9SYWRpYW5zLCBtIGFzIHRvUGVyY2VudGFnZSwgbiBhcyB0b0RpbWVuc2lvbiwgVCBhcyBUQVUsIG8gYXMgZm9ybWF0TnVtYmVyLCBwIGFzIF9hbmdsZUJldHdlZW4sIEggYXMgSEFMRl9QSSwgUCBhcyBQSSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgdyBhcyBfc2NhbGVSYW5nZXNDaGFuZ2VkLCB4IGFzIGlzTnVtYmVyLCB5IGFzIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSwgeiBhcyBsb2cxMCwgQSBhcyBfZmFjdG9yaXplLCBCIGFzIGZpbml0ZU9yRGVmYXVsdCwgQyBhcyBjYWxsYmFjaywgRCBhcyBfYWRkR3JhY2UsIEUgYXMgX2xpbWl0VmFsdWUsIEYgYXMgdG9EZWdyZWVzLCBHIGFzIF9tZWFzdXJlVGV4dCwgSSBhcyBfaW50MTZSYW5nZSwgSiBhcyBfYWxpZ25QaXhlbCwgSyBhcyB0b1BhZGRpbmcsIEwgYXMgY2xpcEFyZWEsIE0gYXMgcmVuZGVyVGV4dCwgTiBhcyB1bmNsaXBBcmVhLCBPIGFzIHRvRm9udCwgUSBhcyBlYWNoLCBSIGFzIF90b0xlZnRSaWdodENlbnRlciwgUyBhcyBfYWxpZ25TdGFydEVuZCwgVSBhcyBvdmVycmlkZXMsIFYgYXMgbWVyZ2UsIFcgYXMgX2NhcGl0YWxpemUsIFggYXMgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgWSBhcyBfcmxvb2t1cEJ5S2V5LCBaIGFzIF9sb29rdXBCeUtleSwgJCBhcyBfaXNQb2ludEluQXJlYSwgYTAgYXMgZ2V0QW5nbGVGcm9tUG9pbnQsIGExIGFzIGdldE1heGltdW1TaXplLCBhMiBhcyBfZ2V0UGFyZW50Tm9kZSwgYTMgYXMgcmVhZFVzZWRTaXplLCBhNCBhcyB0aHJvdHRsZWQsIGE1IGFzIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIGE2IGFzIF9pc0RvbVN1cHBvcnRlZCwgYTcgYXMgZGVzY3JpcHRvcnMsIGE4IGFzIGlzRnVuY3Rpb24sIGE5IGFzIF9hdHRhY2hDb250ZXh0LCBhYSBhcyBfY3JlYXRlUmVzb2x2ZXIsIGFiIGFzIF9kZXNjcmlwdG9ycywgYWMgYXMgbWVyZ2VJZiwgYWQgYXMgdWlkLCBhZSBhcyBkZWJvdW5jZSwgYWYgYXMgcmV0aW5hU2NhbGUsIGFnIGFzIGNsZWFyQ2FudmFzLCBhaCBhcyBzZXRzRXF1YWwsIGFpIGFzIF9lbGVtZW50c0VxdWFsLCBhaiBhcyBfaXNDbGlja0V2ZW50LCBhayBhcyBfaXNCZXR3ZWVuLCBhbCBhcyBfcmVhZFZhbHVlVG9Qcm9wcywgYW0gYXMgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMsIGFuIGFzIF9jb21wdXRlU2VnbWVudHMsIGFvIGFzIF9ib3VuZFNlZ21lbnRzLCBhcCBhcyBfc3RlcHBlZEludGVycG9sYXRpb24sIGFxIGFzIF9iZXppZXJJbnRlcnBvbGF0aW9uLCBhciBhcyBfcG9pbnRJbkxpbmUsIGFzIGFzIF9zdGVwcGVkTGluZVRvLCBhdCBhcyBfYmV6aWVyQ3VydmVUbywgYXUgYXMgZHJhd1BvaW50LCBhdiBhcyBhZGRSb3VuZGVkUmVjdFBhdGgsIGF3IGFzIHRvVFJCTCwgYXggYXMgdG9UUkJMQ29ybmVycywgYXkgYXMgX2JvdW5kU2VnbWVudCwgYXogYXMgX25vcm1hbGl6ZUFuZ2xlLCBhQSBhcyBnZXRSdGxBZGFwdGVyLCBhQiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIGFDIGFzIF90ZXh0WCwgYUQgYXMgcmVzdG9yZVRleHREaXJlY3Rpb24sIGFFIGFzIGRyYXdQb2ludExlZ2VuZCwgYUYgYXMgbm9vcCwgYUcgYXMgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBhSCBhcyBfc2V0TWluQW5kTWF4QnlLZXksIGFJIGFzIG5pY2VOdW0sIGFKIGFzIGFsbW9zdFdob2xlLCBhSyBhcyBhbG1vc3RFcXVhbHMsIGFMIGFzIF9kZWNpbWFsUGxhY2VzLCBhTSBhcyBfbG9uZ2VzdFRleHQsIGFOIGFzIF9maWx0ZXJCZXR3ZWVuLCBhTyBhcyBfbG9va3VwIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyc7XG5leHBvcnQgeyBkIGFzIGRlZmF1bHRzIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyc7XG5cbmNsYXNzIEFuaW1hdG9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9sYXN0RGF0ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGFuaW1zLmxpc3RlbmVyc1t0eXBlXTtcbiAgICBjb25zdCBudW1TdGVwcyA9IGFuaW1zLmR1cmF0aW9uO1xuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZuID0+IGZuKHtcbiAgICAgIGNoYXJ0LFxuICAgICAgaW5pdGlhbDogYW5pbXMuaW5pdGlhbCxcbiAgICAgIG51bVN0ZXBzLFxuICAgICAgY3VycmVudFN0ZXA6IE1hdGgubWluKGRhdGUgLSBhbmltcy5zdGFydCwgbnVtU3RlcHMpXG4gICAgfSkpO1xuICB9XG4gIF9yZWZyZXNoKCkge1xuICAgIGlmICh0aGlzLl9yZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0QW5pbUZyYW1lLmNhbGwod2luZG93LCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGUoZGF0ZSA9IERhdGUubm93KCkpIHtcbiAgICBsZXQgcmVtYWluaW5nID0gMDtcbiAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KSA9PiB7XG4gICAgICBpZiAoIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgaWYgKGl0ZW0uX2FjdGl2ZSkge1xuICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLnRpY2soZGF0ZSk7XG4gICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpdGVtcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgY2hhcnQuZHJhdygpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAncHJvZ3Jlc3MnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ2NvbXBsZXRlJyk7XG4gICAgICAgIGFuaW1zLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJlbWFpbmluZyArPSBpdGVtcy5sZW5ndGg7XG4gICAgfSk7XG4gICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuICAgIGlmIChyZW1haW5pbmcgPT09IDApIHtcbiAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgY29uc3QgY2hhcnRzID0gdGhpcy5fY2hhcnRzO1xuICAgIGxldCBhbmltcyA9IGNoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMpIHtcbiAgICAgIGFuaW1zID0ge1xuICAgICAgICBydW5uaW5nOiBmYWxzZSxcbiAgICAgICAgaW5pdGlhbDogdHJ1ZSxcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgcHJvZ3Jlc3M6IFtdXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltcztcbiAgfVxuICBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgIHRoaXMuX2dldEFuaW1zKGNoYXJ0KS5saXN0ZW5lcnNbZXZlbnRdLnB1c2goY2IpO1xuICB9XG4gIGFkZChjaGFydCwgaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLnB1c2goLi4uaXRlbXMpO1xuICB9XG4gIGhhcyhjaGFydCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMubGVuZ3RoID4gMDtcbiAgfVxuICBzdGFydChjaGFydCkge1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgaWYgKCFhbmltcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICBhbmltcy5zdGFydCA9IERhdGUubm93KCk7XG4gICAgYW5pbXMuZHVyYXRpb24gPSBhbmltcy5pdGVtcy5yZWR1Y2UoKGFjYywgY3VyKSA9PiBNYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICB0aGlzLl9yZWZyZXNoKCk7XG4gIH1cbiAgcnVubmluZyhjaGFydCkge1xuICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmltcyA9IHRoaXMuX2NoYXJ0cy5nZXQoY2hhcnQpO1xuICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzdG9wKGNoYXJ0KSB7XG4gICAgY29uc3QgYW5pbXMgPSB0aGlzLl9jaGFydHMuZ2V0KGNoYXJ0KTtcbiAgICBpZiAoIWFuaW1zIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBhbmltcy5pdGVtcztcbiAgICBsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpdGVtc1tpXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBEYXRlLm5vdygpLCAnY29tcGxldGUnKTtcbiAgfVxuICByZW1vdmUoY2hhcnQpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gIH1cbn1cbnZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcigpO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICBib29sZWFuKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICByZXR1cm4gZmFjdG9yID4gMC41ID8gdG8gOiBmcm9tO1xuICB9LFxuICBjb2xvcihmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgY29uc3QgYzAgPSBjb2xvcihmcm9tIHx8IHRyYW5zcGFyZW50KTtcbiAgICBjb25zdCBjMSA9IGMwLnZhbGlkICYmIGNvbG9yKHRvIHx8IHRyYW5zcGFyZW50KTtcbiAgICByZXR1cm4gYzEgJiYgYzEudmFsaWRcbiAgICAgID8gYzEubWl4KGMwLCBmYWN0b3IpLmhleFN0cmluZygpXG4gICAgICA6IHRvO1xuICB9LFxuICBudW1iZXIoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgIHJldHVybiBmcm9tICsgKHRvIC0gZnJvbSkgKiBmYWN0b3I7XG4gIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICBjb25zdHJ1Y3RvcihjZmcsIHRhcmdldCwgcHJvcCwgdG8pIHtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcHJvcF07XG4gICAgdG8gPSByZXNvbHZlKFtjZmcudG8sIHRvLCBjdXJyZW50VmFsdWUsIGNmZy5mcm9tXSk7XG4gICAgY29uc3QgZnJvbSA9IHJlc29sdmUoW2NmZy5mcm9tLCBjdXJyZW50VmFsdWUsIHRvXSk7XG4gICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcbiAgICB0aGlzLl9mbiA9IGNmZy5mbiB8fCBpbnRlcnBvbGF0b3JzW2NmZy50eXBlIHx8IHR5cGVvZiBmcm9tXTtcbiAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgIHRoaXMuX3N0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpICsgKGNmZy5kZWxheSB8fCAwKSk7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLl90b3RhbCA9IE1hdGguZmxvb3IoY2ZnLmR1cmF0aW9uKTtcbiAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fcHJvcCA9IHByb3A7XG4gICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgdGhpcy5fdG8gPSB0bztcbiAgICB0aGlzLl9wcm9taXNlcyA9IHVuZGVmaW5lZDtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICB1cGRhdGUoY2ZnLCB0bywgZGF0ZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICB0aGlzLl90byA9IHJlc29sdmUoW2NmZy50bywgdG8sIGN1cnJlbnRWYWx1ZSwgY2ZnLmZyb21dKTtcbiAgICAgIHRoaXMuX2Zyb20gPSByZXNvbHZlKFtjZmcuZnJvbSwgY3VycmVudFZhbHVlLCB0b10pO1xuICAgIH1cbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy50aWNrKERhdGUubm93KCkpO1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLl9ub3RpZnkoZmFsc2UpO1xuICAgIH1cbiAgfVxuICB0aWNrKGRhdGUpIHtcbiAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuX3Byb3A7XG4gICAgY29uc3QgZnJvbSA9IHRoaXMuX2Zyb207XG4gICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgY29uc3QgdG8gPSB0aGlzLl90bztcbiAgICBsZXQgZmFjdG9yO1xuICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IChlbGFwc2VkIDwgZHVyYXRpb24pKTtcbiAgICBpZiAoIXRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdG87XG4gICAgICB0aGlzLl9ub3RpZnkodHJ1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGFwc2VkIDwgMCkge1xuICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gZnJvbTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmFjdG9yID0gKGVsYXBzZWQgLyBkdXJhdGlvbikgJSAyO1xuICAgIGZhY3RvciA9IGxvb3AgJiYgZmFjdG9yID4gMSA/IDIgLSBmYWN0b3IgOiBmYWN0b3I7XG4gICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcbiAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0aGlzLl9mbihmcm9tLCB0bywgZmFjdG9yKTtcbiAgfVxuICB3YWl0KCkge1xuICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHByb21pc2VzLnB1c2goe3JlcywgcmVqfSk7XG4gICAgfSk7XG4gIH1cbiAgX25vdGlmeShyZXNvbHZlZCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMuX3Byb21pc2VzIHx8IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbnVtYmVycyA9IFsneCcsICd5JywgJ2JvcmRlcldpZHRoJywgJ3JhZGl1cycsICd0ZW5zaW9uJ107XG5jb25zdCBjb2xvcnMgPSBbJ2NvbG9yJywgJ2JvcmRlckNvbG9yJywgJ2JhY2tncm91bmRDb2xvciddO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb24nLCB7XG4gIGRlbGF5OiB1bmRlZmluZWQsXG4gIGR1cmF0aW9uOiAxMDAwLFxuICBlYXNpbmc6ICdlYXNlT3V0UXVhcnQnLFxuICBmbjogdW5kZWZpbmVkLFxuICBmcm9tOiB1bmRlZmluZWQsXG4gIGxvb3A6IHVuZGVmaW5lZCxcbiAgdG86IHVuZGVmaW5lZCxcbiAgdHlwZTogdW5kZWZpbmVkLFxufSk7XG5jb25zdCBhbmltYXRpb25PcHRpb25zID0gT2JqZWN0LmtleXMoZGVmYXVsdHMuYW5pbWF0aW9uKTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdhbmltYXRpb24nLCB7XG4gIF9mYWxsYmFjazogZmFsc2UsXG4gIF9pbmRleGFibGU6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdvblByb2dyZXNzJyAmJiBuYW1lICE9PSAnb25Db21wbGV0ZScgJiYgbmFtZSAhPT0gJ2ZuJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICBjb2xvcnM6IHtcbiAgICB0eXBlOiAnY29sb3InLFxuICAgIHByb3BlcnRpZXM6IGNvbG9yc1xuICB9LFxuICBudW1iZXJzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgcHJvcGVydGllczogbnVtYmVyc1xuICB9LFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJyxcbn0pO1xuZGVmYXVsdHMuc2V0KCd0cmFuc2l0aW9ucycsIHtcbiAgYWN0aXZlOiB7XG4gICAgYW5pbWF0aW9uOiB7XG4gICAgICBkdXJhdGlvbjogNDAwXG4gICAgfVxuICB9LFxuICByZXNpemU6IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgIGR1cmF0aW9uOiAwXG4gICAgfVxuICB9LFxuICBzaG93OiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIGZyb206ICd0cmFuc3BhcmVudCdcbiAgICAgIH0sXG4gICAgICB2aXNpYmxlOiB7XG4gICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgZHVyYXRpb246IDBcbiAgICAgIH0sXG4gICAgfVxuICB9LFxuICBoaWRlOiB7XG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgY29sb3JzOiB7XG4gICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICB9LFxuICAgICAgdmlzaWJsZToge1xuICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgIGVhc2luZzogJ2xpbmVhcicsXG4gICAgICAgIGZuOiB2ID0+IHYgfCAwXG4gICAgICB9LFxuICAgIH1cbiAgfVxufSk7XG5jbGFzcyBBbmltYXRpb25zIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZykge1xuICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5fcHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmNvbmZpZ3VyZShjb25maWcpO1xuICB9XG4gIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZWRQcm9wcyA9IHRoaXMuX3Byb3BlcnRpZXM7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY29uZmlnKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBjZmcgPSBjb25maWdba2V5XTtcbiAgICAgIGlmICghaXNPYmplY3QoY2ZnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlZCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICByZXNvbHZlZFtvcHRpb25dID0gY2ZnW29wdGlvbl07XG4gICAgICB9XG4gICAgICAoaXNBcnJheShjZmcucHJvcGVydGllcykgJiYgY2ZnLnByb3BlcnRpZXMgfHwgW2tleV0pLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgaWYgKHByb3AgPT09IGtleSB8fCAhYW5pbWF0ZWRQcm9wcy5oYXMocHJvcCkpIHtcbiAgICAgICAgICBhbmltYXRlZFByb3BzLnNldChwcm9wLCByZXNvbHZlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgIGNvbnN0IG5ld09wdGlvbnMgPSB2YWx1ZXMub3B0aW9ucztcbiAgICBjb25zdCBvcHRpb25zID0gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKTtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnMob3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICB9LCAoKSA9PiB7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gIH1cbiAgX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICBjb25zdCBhbmltYXRlZFByb3BzID0gdGhpcy5fcHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgcnVubmluZyA9IHRhcmdldC4kYW5pbWF0aW9ucyB8fCAodGFyZ2V0LiRhbmltYXRpb25zID0ge30pO1xuICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmtleXModmFsdWVzKTtcbiAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSBwcm9wcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcCA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi50aGlzLl9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgaWYgKGNmZyAmJiBhbmltYXRpb24uYWN0aXZlKCkpIHtcbiAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBydW5uaW5nW3Byb3BdID0gYW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbihjZmcsIHRhcmdldCwgcHJvcCwgdmFsdWUpO1xuICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIHVwZGF0ZSh0YXJnZXQsIHZhbHVlcykge1xuICAgIGlmICh0aGlzLl9wcm9wZXJ0aWVzLnNpemUgPT09IDApIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyh0YXJnZXQsIHZhbHVlcyk7XG4gICAgaWYgKGFuaW1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBhbmltYXRvci5hZGQodGhpcy5fY2hhcnQsIGFuaW1hdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBhd2FpdEFsbChhbmltYXRpb25zLCBwcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IHJ1bm5pbmcgPSBbXTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhbmltID0gYW5pbWF0aW9uc1trZXlzW2ldXTtcbiAgICBpZiAoYW5pbSAmJiBhbmltLmFjdGl2ZSgpKSB7XG4gICAgICBydW5uaW5nLnB1c2goYW5pbS53YWl0KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwocnVubmluZyk7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpIHtcbiAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBvcHRpb25zID0gdGFyZ2V0Lm9wdGlvbnM7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRhcmdldC5vcHRpb25zID0gbmV3T3B0aW9ucztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG9wdGlvbnMuJHNoYXJlZCkge1xuICAgIHRhcmdldC5vcHRpb25zID0gb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHskc2hhcmVkOiBmYWxzZSwgJGFuaW1hdGlvbnM6IHt9fSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQ2xpcChzY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICBjb25zdCByZXZlcnNlID0gb3B0cy5yZXZlcnNlO1xuICBjb25zdCBtaW4gPSBvcHRzLm1pbiA9PT0gdW5kZWZpbmVkID8gYWxsb3dlZE92ZXJmbG93IDogMDtcbiAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgZW5kOiByZXZlcnNlID8gbWluIDogbWF4XG4gIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gIGlmIChhbGxvd2VkT3ZlcmZsb3cgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHggPSBzY2FsZUNsaXAoeFNjYWxlLCBhbGxvd2VkT3ZlcmZsb3cpO1xuICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IHkuZW5kLFxuICAgIHJpZ2h0OiB4LmVuZCxcbiAgICBib3R0b206IHkuc3RhcnQsXG4gICAgbGVmdDogeC5zdGFydFxuICB9O1xufVxuZnVuY3Rpb24gdG9DbGlwKHZhbHVlKSB7XG4gIGxldCB0LCByLCBiLCBsO1xuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdCA9IHZhbHVlLnRvcDtcbiAgICByID0gdmFsdWUucmlnaHQ7XG4gICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICBsID0gdmFsdWUubGVmdDtcbiAgfSBlbHNlIHtcbiAgICB0ID0gciA9IGIgPSBsID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3A6IHQsXG4gICAgcmlnaHQ6IHIsXG4gICAgYm90dG9tOiBiLFxuICAgIGxlZnQ6IGwsXG4gICAgZGlzYWJsZWQ6IHZhbHVlID09PSBmYWxzZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gbWV0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAga2V5cy5wdXNoKG1ldGFzZXRzW2ldLmluZGV4KTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBkc0luZGV4LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qga2V5cyA9IHN0YWNrLmtleXM7XG4gIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICBsZXQgaSwgaWxlbiwgZGF0YXNldEluZGV4LCBvdGhlclZhbHVlO1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZGF0YXNldEluZGV4ID0gK2tleXNbaV07XG4gICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG90aGVyVmFsdWUgPSBzdGFjay52YWx1ZXNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUob3RoZXJWYWx1ZSkgJiYgKHNpbmdsZU1vZGUgfHwgKHZhbHVlID09PSAwIHx8IHNpZ24odmFsdWUpID09PSBzaWduKG90aGVyVmFsdWUpKSkpIHtcbiAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgY29uc3QgYWRhdGEgPSBuZXcgQXJyYXkoa2V5cy5sZW5ndGgpO1xuICBsZXQgaSwgaWxlbiwga2V5O1xuICBmb3IgKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIGFkYXRhW2ldID0ge1xuICAgICAgeDoga2V5LFxuICAgICAgeTogZGF0YVtrZXldXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWRhdGE7XG59XG5mdW5jdGlvbiBpc1N0YWNrZWQoc2NhbGUsIG1ldGEpIHtcbiAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgcmV0dXJuIHN0YWNrZWQgfHwgKHN0YWNrZWQgPT09IHVuZGVmaW5lZCAmJiBtZXRhLnN0YWNrICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICByZXR1cm4gYCR7aW5kZXhTY2FsZS5pZH0uJHt2YWx1ZVNjYWxlLmlkfS4ke21ldGEuc3RhY2sgfHwgbWV0YS50eXBlfWA7XG59XG5mdW5jdGlvbiBnZXRVc2VyQm91bmRzKHNjYWxlKSB7XG4gIGNvbnN0IHttaW4sIG1heCwgbWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSBzY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIHJldHVybiB7XG4gICAgbWluOiBtaW5EZWZpbmVkID8gbWluIDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuICAgIG1heDogbWF4RGVmaW5lZCA/IG1heCA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIHN0YWNrS2V5LCBpbmRleFZhbHVlKSB7XG4gIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgcmV0dXJuIHN1YlN0YWNrW2luZGV4VmFsdWVdIHx8IChzdWJTdGFja1tpbmRleFZhbHVlXSA9IHt9KTtcbn1cbmZ1bmN0aW9uIGdldExhc3RJbmRleEluU3RhY2soc3RhY2ssIHZTY2FsZSwgcG9zaXRpdmUsIHR5cGUpIHtcbiAgZm9yIChjb25zdCBtZXRhIG9mIHZTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKS5yZXZlcnNlKCkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0YWNrW21ldGEuaW5kZXhdO1xuICAgIGlmICgocG9zaXRpdmUgJiYgdmFsdWUgPiAwKSB8fCAoIXBvc2l0aXZlICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgIHJldHVybiBtZXRhLmluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgY29uc3Qge2NoYXJ0LCBfY2FjaGVkTWV0YTogbWV0YX0gPSBjb250cm9sbGVyO1xuICBjb25zdCBzdGFja3MgPSBjaGFydC5fc3RhY2tzIHx8IChjaGFydC5fc3RhY2tzID0ge30pO1xuICBjb25zdCB7aVNjYWxlLCB2U2NhbGUsIGluZGV4OiBkYXRhc2V0SW5kZXh9ID0gbWV0YTtcbiAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICBjb25zdCBpbGVuID0gcGFyc2VkLmxlbmd0aDtcbiAgbGV0IHN0YWNrO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgIGNvbnN0IGl0ZW0gPSBwYXJzZWRbaV07XG4gICAgY29uc3Qge1tpQXhpc106IGluZGV4LCBbdkF4aXNdOiB2YWx1ZX0gPSBpdGVtO1xuICAgIGNvbnN0IGl0ZW1TdGFja3MgPSBpdGVtLl9zdGFja3MgfHwgKGl0ZW0uX3N0YWNrcyA9IHt9KTtcbiAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgIHN0YWNrW2RhdGFzZXRJbmRleF0gPSB2YWx1ZTtcbiAgICBzdGFjay5fdG9wID0gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCB0cnVlLCBtZXRhLnR5cGUpO1xuICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsIGF4aXMpIHtcbiAgY29uc3Qgc2NhbGVzID0gY2hhcnQuc2NhbGVzO1xuICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoa2V5ID0+IHNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCxcbiAgICB7XG4gICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgZGF0YXNldDogdW5kZWZpbmVkLFxuICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgIGluZGV4LFxuICAgICAgbW9kZTogJ2RlZmF1bHQnLFxuICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YUNvbnRleHQocGFyZW50LCBpbmRleCwgZWxlbWVudCkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgcGFyc2VkOiB1bmRlZmluZWQsXG4gICAgcmF3OiB1bmRlZmluZWQsXG4gICAgZWxlbWVudCxcbiAgICBpbmRleCxcbiAgICBtb2RlOiAnZGVmYXVsdCcsXG4gICAgdHlwZTogJ2RhdGEnXG4gIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJTdGFja3MobWV0YSwgaXRlbXMpIHtcbiAgY29uc3QgZGF0YXNldEluZGV4ID0gbWV0YS5jb250cm9sbGVyLmluZGV4O1xuICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgaWYgKCFheGlzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGl0ZW1zID0gaXRlbXMgfHwgbWV0YS5fcGFyc2VkO1xuICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcykge1xuICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgIGlmICghc3RhY2tzIHx8IHN0YWNrc1theGlzXSA9PT0gdW5kZWZpbmVkIHx8IHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICB9XG59XG5jb25zdCBpc0RpcmVjdFVwZGF0ZU1vZGUgPSAobW9kZSkgPT4gbW9kZSA9PT0gJ3Jlc2V0JyB8fCBtb2RlID09PSAnbm9uZSc7XG5jb25zdCBjbG9uZUlmTm90U2hhcmVkID0gKGNhY2hlZCwgc2hhcmVkKSA9PiBzaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KSA9PiBjYW5TdGFjayAmJiAhbWV0YS5oaWRkZW4gJiYgbWV0YS5fc3RhY2tlZFxuICAmJiB7a2V5czogZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIHRydWUpLCB2YWx1ZXM6IG51bGx9O1xuY2xhc3MgRGF0YXNldENvbnRyb2xsZXIge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuX2N0eCA9IGNoYXJ0LmN0eDtcbiAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIHRoaXMuX2NhY2hlZERhdGFPcHRzID0ge307XG4gICAgdGhpcy5fY2FjaGVkTWV0YSA9IHRoaXMuZ2V0TWV0YSgpO1xuICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX29iamVjdERhdGEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZHJhd0NvdW50ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gZmFsc2U7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIGluaXRpYWxpemUoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICB0aGlzLmxpbmtTY2FsZXMoKTtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICB0aGlzLmFkZEVsZW1lbnRzKCk7XG4gIH1cbiAgdXBkYXRlSW5kZXgoZGF0YXNldEluZGV4KSB7XG4gICAgaWYgKHRoaXMuaW5kZXggIT09IGRhdGFzZXRJbmRleCkge1xuICAgICAgY2xlYXJTdGFja3ModGhpcy5fY2FjaGVkTWV0YSk7XG4gICAgfVxuICAgIHRoaXMuaW5kZXggPSBkYXRhc2V0SW5kZXg7XG4gIH1cbiAgbGlua1NjYWxlcygpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpID0+IGF4aXMgPT09ICd4JyA/IHggOiBheGlzID09PSAncicgPyByIDogeTtcbiAgICBjb25zdCB4aWQgPSBtZXRhLnhBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnhBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3gnKSk7XG4gICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgIGNvbnN0IHJpZCA9IG1ldGEuckF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQuckF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAncicpKTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBtZXRhLmluZGV4QXhpcztcbiAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgIGNvbnN0IHZpZCA9IG1ldGEudkF4aXNJRCA9IGNob29zZUlkKGluZGV4QXhpcywgeWlkLCB4aWQsIHJpZCk7XG4gICAgbWV0YS54U2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoeGlkKTtcbiAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgIG1ldGEuclNjYWxlID0gdGhpcy5nZXRTY2FsZUZvcklkKHJpZCk7XG4gICAgbWV0YS5pU2NhbGUgPSB0aGlzLmdldFNjYWxlRm9ySWQoaWlkKTtcbiAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICB9XG4gIGdldERhdGFzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0c1t0aGlzLmluZGV4XTtcbiAgfVxuICBnZXRNZXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRoaXMuaW5kZXgpO1xuICB9XG4gIGdldFNjYWxlRm9ySWQoc2NhbGVJRCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgfVxuICBfZ2V0T3RoZXJTY2FsZShzY2FsZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGVcbiAgICAgID8gbWV0YS52U2NhbGVcbiAgICAgIDogbWV0YS5pU2NhbGU7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgfVxuICB9XG4gIF9kYXRhQ2hlY2soKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICBjb25zdCBfZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gY29udmVydE9iamVjdERhdGFUb0FycmF5KGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoX2RhdGEgIT09IGRhdGEpIHtcbiAgICAgIGlmIChfZGF0YSkge1xuICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKF9kYXRhLCB0aGlzKTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgICBtZXRhLl9wYXJzZWQgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhICYmIE9iamVjdC5pc0V4dGVuc2libGUoZGF0YSkpIHtcbiAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIGFkZEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgbWV0YS5kYXRhc2V0ID0gbmV3IHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKCk7XG4gICAgfVxuICB9XG4gIGJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBzdGFja0NoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICBpZiAobWV0YS5zdGFjayAhPT0gZGF0YXNldC5zdGFjaykge1xuICAgICAgc3RhY2tDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIGNsZWFyU3RhY2tzKG1ldGEpO1xuICAgICAgbWV0YS5zdGFjayA9IGRhdGFzZXQuc3RhY2s7XG4gICAgfVxuICAgIHRoaXMuX3Jlc3luY0VsZW1lbnRzKHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIGlmIChzdGFja0NoYW5nZWQgfHwgb2xkU3RhY2tlZCAhPT0gbWV0YS5fc3RhY2tlZCkge1xuICAgICAgdXBkYXRlU3RhY2tzKHRoaXMsIG1ldGEuX3BhcnNlZCk7XG4gICAgfVxuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldFNjb3BlS2V5cyh0aGlzLl90eXBlKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLl9wYXJzaW5nID0gdGhpcy5vcHRpb25zLnBhcnNpbmc7XG4gICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgfVxuICBwYXJzZShzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7X2NhY2hlZE1ldGE6IG1ldGEsIF9kYXRhOiBkYXRhfSA9IHRoaXM7XG4gICAgY29uc3Qge2lTY2FsZSwgX3N0YWNrZWR9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGxldCBzb3J0ZWQgPSBzdGFydCA9PT0gMCAmJiBjb3VudCA9PT0gZGF0YS5sZW5ndGggPyB0cnVlIDogbWV0YS5fc29ydGVkO1xuICAgIGxldCBwcmV2ID0gc3RhcnQgPiAwICYmIG1ldGEuX3BhcnNlZFtzdGFydCAtIDFdO1xuICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcbiAgICBpZiAodGhpcy5fcGFyc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgIG1ldGEuX3BhcnNlZCA9IGRhdGE7XG4gICAgICBtZXRhLl9zb3J0ZWQgPSB0cnVlO1xuICAgICAgcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzQXJyYXkoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZGF0YVtzdGFydF0pKSB7XG4gICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYgPSAoKSA9PiBjdXJbaUF4aXNdID09PSBudWxsIHx8IChwcmV2ICYmIGN1cltpQXhpc10gPCBwcmV2W2lBeGlzXSk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaSArIHN0YXJ0XSA9IGN1ciA9IHBhcnNlZFtpXTtcbiAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgIGlmIChpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldigpKSB7XG4gICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWV0YS5fc29ydGVkID0gc29ydGVkO1xuICAgIH1cbiAgICBpZiAoX3N0YWNrZWQpIHtcbiAgICAgIHVwZGF0ZVN0YWNrcyh0aGlzLCBwYXJzZWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3Qge2lTY2FsZSwgdlNjYWxlfSA9IG1ldGE7XG4gICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4O1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgIFt2QXhpc106IHZTY2FsZS5wYXJzZShkYXRhW2luZGV4XSwgaW5kZXgpXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgICBpdGVtID0gZGF0YVtpbmRleF07XG4gICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgIHg6IHhTY2FsZS5wYXJzZShpdGVtWzBdLCBpbmRleCksXG4gICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHt4U2NhbGUsIHlTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICB4OiB4U2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCB4QXhpc0tleSksIGluZGV4KSxcbiAgICAgICAgeTogeVNjYWxlLnBhcnNlKHJlc29sdmVPYmplY3RLZXkoaXRlbSwgeUF4aXNLZXkpLCBpbmRleClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgZ2V0UGFyc2VkKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuX3BhcnNlZFtpbmRleF07XG4gIH1cbiAgZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5kYXRhW2luZGV4XTtcbiAgfVxuICBhcHBseVN0YWNrKHNjYWxlLCBwYXJzZWQsIG1vZGUpIHtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgdmFsdWUgPSBwYXJzZWRbc2NhbGUuYXhpc107XG4gICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdXG4gICAgfTtcbiAgICByZXR1cm4gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIG1ldGEuaW5kZXgsIHttb2RlfSk7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlZFZhbHVlID09PSBudWxsID8gTmFOIDogcGFyc2VkVmFsdWU7XG4gICAgY29uc3QgdmFsdWVzID0gc3RhY2sgJiYgcGFyc2VkLl9zdGFja3Nbc2NhbGUuYXhpc107XG4gICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgfVxuICAgIHJhbmdlLm1pbiA9IE1hdGgubWluKHJhbmdlLm1pbiwgdmFsdWUpO1xuICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICB9XG4gIGdldE1pbk1heChzY2FsZSwgY2FuU3RhY2spIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgIGNvbnN0IHNvcnRlZCA9IG1ldGEuX3NvcnRlZCAmJiBzY2FsZSA9PT0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgaWxlbiA9IF9wYXJzZWQubGVuZ3RoO1xuICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICBjb25zdCBzdGFjayA9IGNyZWF0ZVN0YWNrKGNhblN0YWNrLCBtZXRhLCB0aGlzLmNoYXJ0KTtcbiAgICBjb25zdCByYW5nZSA9IHttaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFl9O1xuICAgIGNvbnN0IHttaW46IG90aGVyTWluLCBtYXg6IG90aGVyTWF4fSA9IGdldFVzZXJCb3VuZHMob3RoZXJTY2FsZSk7XG4gICAgbGV0IGksIHBhcnNlZDtcbiAgICBmdW5jdGlvbiBfc2tpcCgpIHtcbiAgICAgIHBhcnNlZCA9IF9wYXJzZWRbaV07XG4gICAgICBjb25zdCBvdGhlclZhbHVlID0gcGFyc2VkW290aGVyU2NhbGUuYXhpc107XG4gICAgICByZXR1cm4gIWlzTnVtYmVyRmluaXRlKHBhcnNlZFtzY2FsZS5heGlzXSkgfHwgb3RoZXJNaW4gPiBvdGhlclZhbHVlIHx8IG90aGVyTWF4IDwgb3RoZXJWYWx1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaWYgKF9za2lwKCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNvcnRlZCkge1xuICAgICAgZm9yIChpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBnZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgY29uc3QgdmFsdWVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIHZhbHVlO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBwYXJzZWQubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB2YWx1ZSA9IHBhcnNlZFtpXVtzY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bWJlckZpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogaVNjYWxlID8gJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSA6ICcnLFxuICAgICAgdmFsdWU6IHZTY2FsZSA/ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSkgOiAnJ1xuICAgIH07XG4gIH1cbiAgX3VwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgdGhpcy51cGRhdGUobW9kZSB8fCAnZGVmYXVsdCcpO1xuICAgIG1ldGEuX2NsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQodGhpcy5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7fVxuICBkcmF3KCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZWxlbWVudHMgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuX2RyYXdTdGFydCB8fCAwO1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZHJhd0NvdW50IHx8IChlbGVtZW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgY29uc3QgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0aGlzLm9wdGlvbnMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3A7XG4gICAgbGV0IGk7XG4gICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYWN0aXZlICYmIGRyYXdBY3RpdmVFbGVtZW50c09uVG9wKSB7XG4gICAgICAgIGFjdGl2ZS5wdXNoKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgfVxuICB9XG4gIGdldFN0eWxlKGluZGV4LCBhY3RpdmUpIHtcbiAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgcmV0dXJuIGluZGV4ID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY2FjaGVkTWV0YS5kYXRhc2V0XG4gICAgICA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKVxuICAgICAgOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXggfHwgMCwgbW9kZSk7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgIGxldCBjb250ZXh0O1xuICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fFxuICAgICAgICAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGV4dCA9IHRoaXMuJGNvbnRleHQgfHxcbiAgICAgICAgKHRoaXMuJGNvbnRleHQgPSBjcmVhdGVEYXRhc2V0Q29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcy5pbmRleCkpO1xuICAgICAgY29udGV4dC5kYXRhc2V0ID0gZGF0YXNldDtcbiAgICAgIGNvbnRleHQuaW5kZXggPSBjb250ZXh0LmRhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgfVxuICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgY29udGV4dC5tb2RlID0gbW9kZTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuICByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZUVsZW1lbnRPcHRpb25zKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlLmlkLCBtb2RlKTtcbiAgfVxuICByZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICB9XG4gIF9yZXNvbHZlRWxlbWVudE9wdGlvbnMoZWxlbWVudFR5cGUsIG1vZGUgPSAnZGVmYXVsdCcsIGluZGV4KSB7XG4gICAgY29uc3QgYWN0aXZlID0gbW9kZSA9PT0gJ2FjdGl2ZSc7XG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICBjb25zdCBjYWNoZUtleSA9IGVsZW1lbnRUeXBlICsgJy0nICsgbW9kZTtcbiAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgY29uc3Qgc2hhcmluZyA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2xvbmVJZk5vdFNoYXJlZChjYWNoZWQsIHNoYXJpbmcpO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICBjb25zdCBzY29wZUtleXMgPSBjb25maWcuZGF0YXNldEVsZW1lbnRTY29wZUtleXModGhpcy5fdHlwZSwgZWxlbWVudFR5cGUpO1xuICAgIGNvbnN0IHByZWZpeGVzID0gYWN0aXZlID8gW2Ake2VsZW1lbnRUeXBlfUhvdmVyYCwgJ2hvdmVyJywgZWxlbWVudFR5cGUsICcnXSA6IFtlbGVtZW50VHlwZSwgJyddO1xuICAgIGNvbnN0IHNjb3BlcyA9IGNvbmZpZy5nZXRPcHRpb25TY29wZXModGhpcy5nZXREYXRhc2V0KCksIHNjb3BlS2V5cyk7XG4gICAgY29uc3QgbmFtZXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0cy5lbGVtZW50c1tlbGVtZW50VHlwZV0pO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoKSA9PiB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSk7XG4gICAgY29uc3QgdmFsdWVzID0gY29uZmlnLnJlc29sdmVOYW1lZE9wdGlvbnMoc2NvcGVzLCBuYW1lcywgY29udGV4dCwgcHJlZml4ZXMpO1xuICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG4gIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkRGF0YU9wdHM7XG4gICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBsZXQgb3B0aW9ucztcbiAgICBpZiAoY2hhcnQub3B0aW9ucy5hbmltYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKHRoaXMuX3R5cGUsIHRyYW5zaXRpb24pO1xuICAgICAgY29uc3Qgc2NvcGVzID0gY29uZmlnLmdldE9wdGlvblNjb3Blcyh0aGlzLmdldERhdGFzZXQoKSwgc2NvcGVLZXlzKTtcbiAgICAgIG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoaW5kZXgsIGFjdGl2ZSwgdHJhbnNpdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoY2hhcnQsIG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRpb25zKTtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLl9jYWNoZWFibGUpIHtcbiAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IE9iamVjdC5mcmVlemUoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xuICB9XG4gIGdldFNoYXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zaGFyZWRPcHRpb25zIHx8ICh0aGlzLl9zaGFyZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICB9XG4gIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICByZXR1cm4gIXNoYXJlZE9wdGlvbnMgfHwgaXNEaXJlY3RVcGRhdGVNb2RlKG1vZGUpIHx8IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgfVxuICBfZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSkge1xuICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgY29uc3QgcHJldmlvdXNseVNoYXJlZE9wdGlvbnMgPSB0aGlzLl9zaGFyZWRPcHRpb25zO1xuICAgIGNvbnN0IHNoYXJlZE9wdGlvbnMgPSB0aGlzLmdldFNoYXJlZE9wdGlvbnMoZmlyc3RPcHRzKTtcbiAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgKHNoYXJlZE9wdGlvbnMgIT09IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zKTtcbiAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICByZXR1cm4ge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfTtcbiAgfVxuICB1cGRhdGVFbGVtZW50KGVsZW1lbnQsIGluZGV4LCBwcm9wZXJ0aWVzLCBtb2RlKSB7XG4gICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUpLnVwZGF0ZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKHNoYXJlZE9wdGlvbnMgJiYgIWlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnModW5kZWZpbmVkLCBtb2RlKS51cGRhdGUoc2hhcmVkT3B0aW9ucywgbmV3T3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgZWxlbWVudC5hY3RpdmUgPSBhY3RpdmU7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSk7XG4gICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgIG9wdGlvbnM6ICghYWN0aXZlICYmIHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSkgfHwgb3B0aW9uc1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgZmFsc2UpO1xuICB9XG4gIHNldEhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gIH1cbiAgX3JlbW92ZURhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgX3NldERhdGFzZXRIb3ZlclN0eWxlKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIHRydWUpO1xuICAgIH1cbiAgfVxuICBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3QpIHtcbiAgICAgIHRoaXNbbWV0aG9kXShhcmcxLCBhcmcyKTtcbiAgICB9XG4gICAgdGhpcy5fc3luY0xpc3QgPSBbXTtcbiAgICBjb25zdCBudW1NZXRhID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKG51bURhdGEsIG51bU1ldGEpO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgdGhpcy5wYXJzZSgwLCBjb3VudCk7XG4gICAgfVxuICAgIGlmIChudW1EYXRhID4gbnVtTWV0YSkge1xuICAgICAgdGhpcy5faW5zZXJ0RWxlbWVudHMobnVtTWV0YSwgbnVtRGF0YSAtIG51bU1ldGEsIHJlc2V0TmV3RWxlbWVudHMpO1xuICAgIH0gZWxzZSBpZiAobnVtRGF0YSA8IG51bU1ldGEpIHtcbiAgICAgIHRoaXMuX3JlbW92ZUVsZW1lbnRzKG51bURhdGEsIG51bU1ldGEgLSBudW1EYXRhKTtcbiAgICB9XG4gIH1cbiAgX2luc2VydEVsZW1lbnRzKHN0YXJ0LCBjb3VudCwgcmVzZXROZXdFbGVtZW50cyA9IHRydWUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgY291bnQ7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgbW92ZSA9IChhcnIpID0+IHtcbiAgICAgIGFyci5sZW5ndGggKz0gY291bnQ7XG4gICAgICBmb3IgKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSkge1xuICAgICAgICBhcnJbaV0gPSBhcnJbaSAtIGNvdW50XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIG1vdmUoZGF0YSk7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgZGF0YVtpXSA9IG5ldyB0aGlzLmRhdGFFbGVtZW50VHlwZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgbW92ZShtZXRhLl9wYXJzZWQpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG4gICAgaWYgKHJlc2V0TmV3RWxlbWVudHMpIHtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMoZGF0YSwgc3RhcnQsIGNvdW50LCAncmVzZXQnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fVxuICBfcmVtb3ZlRWxlbWVudHMoc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSBtZXRhLl9wYXJzZWQuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICBpZiAobWV0YS5fc3RhY2tlZCkge1xuICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbWV0YS5kYXRhLnNwbGljZShzdGFydCwgY291bnQpO1xuICB9XG4gIF9zeW5jKGFyZ3MpIHtcbiAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgdGhpcy5fc3luY0xpc3QucHVzaChhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gPSBhcmdzO1xuICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgIH1cbiAgICB0aGlzLmNoYXJ0Ll9kYXRhQ2hhbmdlcy5wdXNoKFt0aGlzLmluZGV4LCAuLi5hcmdzXSk7XG4gIH1cbiAgX29uRGF0YVB1c2goKSB7XG4gICAgY29uc3QgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCB0aGlzLmdldERhdGFzZXQoKS5kYXRhLmxlbmd0aCAtIGNvdW50LCBjb3VudF0pO1xuICB9XG4gIF9vbkRhdGFQb3AoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19yZW1vdmVFbGVtZW50cycsIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNoaWZ0KCkge1xuICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCAwLCAxXSk7XG4gIH1cbiAgX29uRGF0YVNwbGljZShzdGFydCwgY291bnQpIHtcbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfcmVtb3ZlRWxlbWVudHMnLCBzdGFydCwgY291bnRdKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q291bnQgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgICBpZiAobmV3Q291bnQpIHtcbiAgICAgIHRoaXMuX3N5bmMoWydfaW5zZXJ0RWxlbWVudHMnLCBzdGFydCwgbmV3Q291bnRdKTtcbiAgICB9XG4gIH1cbiAgX29uRGF0YVVuc2hpZnQoKSB7XG4gICAgdGhpcy5fc3luYyhbJ19pbnNlcnRFbGVtZW50cycsIDAsIGFyZ3VtZW50cy5sZW5ndGhdKTtcbiAgfVxufVxuRGF0YXNldENvbnRyb2xsZXIuZGVmYXVsdHMgPSB7fTtcbkRhdGFzZXRDb250cm9sbGVyLnByb3RvdHlwZS5kYXRhc2V0RWxlbWVudFR5cGUgPSBudWxsO1xuRGF0YXNldENvbnRyb2xsZXIucHJvdG90eXBlLmRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCB0eXBlKSB7XG4gIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICBjb25zdCB2aXNpYmxlTWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0eXBlKTtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB2aXNpYmxlTWV0YXMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKSB7XG4gICAgICB2YWx1ZXMgPSB2YWx1ZXMuY29uY2F0KHZpc2libGVNZXRhc1tpXS5jb250cm9sbGVyLmdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkpO1xuICAgIH1cbiAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpKTtcbiAgfVxuICByZXR1cm4gc2NhbGUuX2NhY2hlLiRiYXI7XG59XG5mdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gIGNvbnN0IHNjYWxlID0gbWV0YS5pU2NhbGU7XG4gIGNvbnN0IHZhbHVlcyA9IGdldEFsbFNjYWxlVmFsdWVzKHNjYWxlLCBtZXRhLnR5cGUpO1xuICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgbGV0IGksIGlsZW4sIGN1cnIsIHByZXY7XG4gIGNvbnN0IHVwZGF0ZU1pbkFuZFByZXYgPSAoKSA9PiB7XG4gICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVmaW5lZChwcmV2KSkge1xuICAgICAgbWluID0gTWF0aC5taW4obWluLCBNYXRoLmFicyhjdXJyIC0gcHJldikgfHwgbWluKTtcbiAgICB9XG4gICAgcHJldiA9IGN1cnI7XG4gIH07XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgY3VyciA9IHNjYWxlLmdldFBpeGVsRm9yVmFsdWUodmFsdWVzW2ldKTtcbiAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gIH1cbiAgcHJldiA9IHVuZGVmaW5lZDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IHNjYWxlLnRpY2tzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2soaSk7XG4gICAgdXBkYXRlTWluQW5kUHJldigpO1xuICB9XG4gIHJldHVybiBtaW47XG59XG5mdW5jdGlvbiBjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KSB7XG4gIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICBsZXQgc2l6ZSwgcmF0aW87XG4gIGlmIChpc051bGxPclVuZGVmKHRoaWNrbmVzcykpIHtcbiAgICBzaXplID0gcnVsZXIubWluICogb3B0aW9ucy5jYXRlZ29yeVBlcmNlbnRhZ2U7XG4gICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgcmF0aW8gPSAxO1xuICB9XG4gIHJldHVybiB7XG4gICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgIHJhdGlvLFxuICAgIHN0YXJ0OiBydWxlci5waXhlbHNbaW5kZXhdIC0gKHNpemUgLyAyKVxuICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgY29uc3QgcGl4ZWxzID0gcnVsZXIucGl4ZWxzO1xuICBjb25zdCBjdXJyID0gcGl4ZWxzW2luZGV4XTtcbiAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gIGxldCBuZXh0ID0gaW5kZXggPCBwaXhlbHMubGVuZ3RoIC0gMSA/IHBpeGVsc1tpbmRleCArIDFdIDogbnVsbDtcbiAgY29uc3QgcGVyY2VudCA9IG9wdGlvbnMuY2F0ZWdvcnlQZXJjZW50YWdlO1xuICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgIHByZXYgPSBjdXJyIC0gKG5leHQgPT09IG51bGwgPyBydWxlci5lbmQgLSBydWxlci5zdGFydCA6IG5leHQgLSBjdXJyKTtcbiAgfVxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gIH1cbiAgY29uc3Qgc3RhcnQgPSBjdXJyIC0gKGN1cnIgLSBNYXRoLm1pbihwcmV2LCBuZXh0KSkgLyAyICogcGVyY2VudDtcbiAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuICByZXR1cm4ge1xuICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICByYXRpbzogb3B0aW9ucy5iYXJQZXJjZW50YWdlLFxuICAgIHN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpIHtcbiAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gIGNvbnN0IGVuZFZhbHVlID0gdlNjYWxlLnBhcnNlKGVudHJ5WzFdLCBpKTtcbiAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRWYWx1ZSwgZW5kVmFsdWUpO1xuICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gIGxldCBiYXJTdGFydCA9IG1pbjtcbiAgbGV0IGJhckVuZCA9IG1heDtcbiAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgYmFyU3RhcnQgPSBtYXg7XG4gICAgYmFyRW5kID0gbWluO1xuICB9XG4gIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuICBpdGVtLl9jdXN0b20gPSB7XG4gICAgYmFyU3RhcnQsXG4gICAgYmFyRW5kLFxuICAgIHN0YXJ0OiBzdGFydFZhbHVlLFxuICAgIGVuZDogZW5kVmFsdWUsXG4gICAgbWluLFxuICAgIG1heFxuICB9O1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZShlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgIHBhcnNlRmxvYXRCYXIoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgaXRlbVt2U2NhbGUuYXhpc10gPSB2U2NhbGUucGFyc2UoZW50cnksIGkpO1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICBjb25zdCBpU2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gIGNvbnN0IGxhYmVscyA9IGlTY2FsZS5nZXRMYWJlbHMoKTtcbiAgY29uc3Qgc2luZ2xlU2NhbGUgPSBpU2NhbGUgPT09IHZTY2FsZTtcbiAgY29uc3QgcGFyc2VkID0gW107XG4gIGxldCBpLCBpbGVuLCBpdGVtLCBlbnRyeTtcbiAgZm9yIChpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZW50cnkgPSBkYXRhW2ldO1xuICAgIGl0ZW0gPSB7fTtcbiAgICBpdGVtW2lTY2FsZS5heGlzXSA9IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaV0sIGkpO1xuICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG5mdW5jdGlvbiBpc0Zsb2F0QmFyKGN1c3RvbSkge1xuICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gIGlmIChzaXplICE9PSAwKSB7XG4gICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gIH1cbiAgcmV0dXJuICh2U2NhbGUuaXNIb3Jpem9udGFsKCkgPyAxIDogLTEpICogKHZTY2FsZS5taW4gPj0gYWN0dWFsQmFzZSA/IDEgOiAtMSk7XG59XG5mdW5jdGlvbiBib3JkZXJQcm9wcyhwcm9wZXJ0aWVzKSB7XG4gIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgaWYgKHByb3BlcnRpZXMuaG9yaXpvbnRhbCkge1xuICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgc3RhcnQgPSAnbGVmdCc7XG4gICAgZW5kID0gJ3JpZ2h0JztcbiAgfSBlbHNlIHtcbiAgICByZXZlcnNlID0gcHJvcGVydGllcy5iYXNlIDwgcHJvcGVydGllcy55O1xuICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgZW5kID0gJ3RvcCc7XG4gIH1cbiAgaWYgKHJldmVyc2UpIHtcbiAgICB0b3AgPSAnZW5kJztcbiAgICBib3R0b20gPSAnc3RhcnQnO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9ICdzdGFydCc7XG4gICAgYm90dG9tID0gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHtzdGFydCwgZW5kLCByZXZlcnNlLCB0b3AsIGJvdHRvbX07XG59XG5mdW5jdGlvbiBzZXRCb3JkZXJTa2lwcGVkKHByb3BlcnRpZXMsIG9wdGlvbnMsIHN0YWNrLCBpbmRleCkge1xuICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgY29uc3QgcmVzID0ge307XG4gIGlmICghZWRnZSkge1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGVkZ2UgPT09IHRydWUpIHtcbiAgICBwcm9wZXJ0aWVzLmJvcmRlclNraXBwZWQgPSB7dG9wOiB0cnVlLCByaWdodDogdHJ1ZSwgYm90dG9tOiB0cnVlLCBsZWZ0OiB0cnVlfTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qge3N0YXJ0LCBlbmQsIHJldmVyc2UsIHRvcCwgYm90dG9tfSA9IGJvcmRlclByb3BzKHByb3BlcnRpZXMpO1xuICBpZiAoZWRnZSA9PT0gJ21pZGRsZScgJiYgc3RhY2spIHtcbiAgICBwcm9wZXJ0aWVzLmVuYWJsZUJvcmRlclJhZGl1cyA9IHRydWU7XG4gICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IHRvcDtcbiAgICB9IGVsc2UgaWYgKChzdGFjay5fYm90dG9tIHx8IDApID09PSBpbmRleCkge1xuICAgICAgZWRnZSA9IGJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW3BhcnNlRWRnZShib3R0b20sIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gICAgICBlZGdlID0gdG9wO1xuICAgIH1cbiAgfVxuICByZXNbcGFyc2VFZGdlKGVkZ2UsIHN0YXJ0LCBlbmQsIHJldmVyc2UpXSA9IHRydWU7XG4gIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgZWRnZSA9IHN0YXJ0RW5kKGVkZ2UsIGIsIGEpO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBhLCBiKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cbmZ1bmN0aW9uIHN3YXAob3JpZywgdjEsIHYyKSB7XG4gIHJldHVybiBvcmlnID09PSB2MSA/IHYyIDogb3JpZyA9PT0gdjIgPyB2MSA6IG9yaWc7XG59XG5mdW5jdGlvbiBzdGFydEVuZCh2LCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHtpbmZsYXRlQW1vdW50fSwgcmF0aW8pIHtcbiAgcHJvcGVydGllcy5pbmZsYXRlQW1vdW50ID0gaW5mbGF0ZUFtb3VudCA9PT0gJ2F1dG8nXG4gICAgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwXG4gICAgOiBpbmZsYXRlQW1vdW50O1xufVxuY2xhc3MgQmFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheU9yUHJpbWl0aXZlKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHt4QXhpc0tleSA9ICd4JywgeUF4aXNLZXkgPSAneSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICBjb25zdCBpQXhpc0tleSA9IGlTY2FsZS5heGlzID09PSAneCcgPyB4QXhpc0tleSA6IHlBeGlzS2V5O1xuICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIG9iajtcbiAgICBmb3IgKGkgPSBzdGFydCwgaWxlbiA9IHN0YXJ0ICsgY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IGRhdGFbaV07XG4gICAgICBpdGVtID0ge307XG4gICAgICBpdGVtW2lTY2FsZS5heGlzXSA9IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KG9iaiwgaUF4aXNLZXkpLCBpKTtcbiAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUocmVzb2x2ZU9iamVjdEtleShvYmosIHZBeGlzS2V5KSwgaXRlbSwgdlNjYWxlLCBpKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgdXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjaykge1xuICAgIHN1cGVyLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgIGlmIChjdXN0b20gJiYgc2NhbGUgPT09IHRoaXMuX2NhY2hlZE1ldGEudlNjYWxlKSB7XG4gICAgICByYW5nZS5taW4gPSBNYXRoLm1pbihyYW5nZS5taW4sIGN1c3RvbS5taW4pO1xuICAgICAgcmFuZ2UubWF4ID0gTWF0aC5tYXgocmFuZ2UubWF4LCBjdXN0b20ubWF4KTtcbiAgICB9XG4gIH1cbiAgZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSBtZXRhO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzRmxvYXRCYXIoY3VzdG9tKVxuICAgICAgPyAnWycgKyBjdXN0b20uc3RhcnQgKyAnLCAnICsgY3VzdG9tLmVuZCArICddJ1xuICAgICAgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogJycgKyBpU2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWRbaVNjYWxlLmF4aXNdKSxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuc3RhY2sgPSB0aGlzLmdldERhdGFzZXQoKS5zdGFjaztcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMobWV0YS5kYXRhLCAwLCBtZXRhLmRhdGEubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICB1cGRhdGVFbGVtZW50cyhiYXJzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgY29uc3Qge2luZGV4LCBfY2FjaGVkTWV0YToge3ZTY2FsZX19ID0gdGhpcztcbiAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB2U2NhbGUuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgcnVsZXIgPSB0aGlzLl9nZXRSdWxlcigpO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7YmFzZSwgaGVhZDogYmFzZX0gOiB0aGlzLl9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpKTtcbiAgICAgIGNvbnN0IGlwaXhlbHMgPSB0aGlzLl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpLCBydWxlcik7XG4gICAgICBjb25zdCBzdGFjayA9IChwYXJzZWQuX3N0YWNrcyB8fCB7fSlbdlNjYWxlLmF4aXNdO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgYmFzZTogdnBpeGVscy5iYXNlLFxuICAgICAgICBlbmFibGVCb3JkZXJSYWRpdXM6ICFzdGFjayB8fCBpc0Zsb2F0QmFyKHBhcnNlZC5fY3VzdG9tKSB8fCAoaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20pLFxuICAgICAgICB4OiBob3Jpem9udGFsID8gdnBpeGVscy5oZWFkIDogaXBpeGVscy5jZW50ZXIsXG4gICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgaGVpZ2h0OiBob3Jpem9udGFsID8gaXBpeGVscy5zaXplIDogTWF0aC5hYnModnBpeGVscy5zaXplKSxcbiAgICAgICAgd2lkdGg6IGhvcml6b250YWwgPyBNYXRoLmFicyh2cGl4ZWxzLnNpemUpIDogaXBpeGVscy5zaXplXG4gICAgICB9O1xuICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgfVxuICB9XG4gIF9nZXRTdGFja3MobGFzdCwgZGF0YUluZGV4KSB7XG4gICAgY29uc3Qge2lTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IG1ldGFzZXRzID0gaVNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHRoaXMuX3R5cGUpXG4gICAgICAuZmlsdGVyKG1ldGEgPT4gbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuZ3JvdXBlZCk7XG4gICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgY29uc3Qgc3RhY2tzID0gW107XG4gICAgY29uc3Qgc2tpcE51bGwgPSAobWV0YSkgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkID0gbWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgY29uc3QgdmFsID0gcGFyc2VkICYmIHBhcnNlZFttZXRhLnZTY2FsZS5heGlzXTtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHZhbCkgfHwgaXNOYU4odmFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cykge1xuICAgICAgaWYgKGRhdGFJbmRleCAhPT0gdW5kZWZpbmVkICYmIHNraXBOdWxsKG1ldGEpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0YWNrZWQgPT09IGZhbHNlIHx8IHN0YWNrcy5pbmRleE9mKG1ldGEuc3RhY2spID09PSAtMSB8fFxuXHRcdFx0XHQoc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgc3RhY2tzLnB1c2gobWV0YS5zdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAobWV0YS5pbmRleCA9PT0gbGFzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGFja3MubGVuZ3RoKSB7XG4gICAgICBzdGFja3MucHVzaCh1bmRlZmluZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG4gIF9nZXRTdGFja0NvdW50KGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gIH1cbiAgX2dldFN0YWNrSW5kZXgoZGF0YXNldEluZGV4LCBuYW1lLCBkYXRhSW5kZXgpIHtcbiAgICBjb25zdCBzdGFja3MgPSB0aGlzLl9nZXRTdGFja3MoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpO1xuICAgIGNvbnN0IGluZGV4ID0gKG5hbWUgIT09IHVuZGVmaW5lZClcbiAgICAgID8gc3RhY2tzLmluZGV4T2YobmFtZSlcbiAgICAgIDogLTE7XG4gICAgcmV0dXJuIChpbmRleCA9PT0gLTEpXG4gICAgICA/IHN0YWNrcy5sZW5ndGggLSAxXG4gICAgICA6IGluZGV4O1xuICB9XG4gIF9nZXRSdWxlcigpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgIGNvbnN0IHBpeGVscyA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhLmRhdGEubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBwaXhlbHMucHVzaChpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpKVtpU2NhbGUuYXhpc10sIGkpKTtcbiAgICB9XG4gICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgY29uc3QgbWluID0gYmFyVGhpY2tuZXNzIHx8IGNvbXB1dGVNaW5TYW1wbGVTaXplKG1ldGEpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW4sXG4gICAgICBwaXhlbHMsXG4gICAgICBzdGFydDogaVNjYWxlLl9zdGFydFBpeGVsLFxuICAgICAgZW5kOiBpU2NhbGUuX2VuZFBpeGVsLFxuICAgICAgc3RhY2tDb3VudDogdGhpcy5fZ2V0U3RhY2tDb3VudCgpLFxuICAgICAgc2NhbGU6IGlTY2FsZSxcbiAgICAgIGdyb3VwZWQ6IG9wdHMuZ3JvdXBlZCxcbiAgICAgIHJhdGlvOiBiYXJUaGlja25lc3MgPyAxIDogb3B0cy5jYXRlZ29yeVBlcmNlbnRhZ2UgKiBvcHRzLmJhclBlcmNlbnRhZ2VcbiAgICB9O1xuICB9XG4gIF9jYWxjdWxhdGVCYXJWYWx1ZVBpeGVscyhpbmRleCkge1xuICAgIGNvbnN0IHtfY2FjaGVkTWV0YToge3ZTY2FsZSwgX3N0YWNrZWR9LCBvcHRpb25zOiB7YmFzZTogYmFzZVZhbHVlLCBtaW5CYXJMZW5ndGh9fSA9IHRoaXM7XG4gICAgY29uc3QgYWN0dWFsQmFzZSA9IGJhc2VWYWx1ZSB8fCAwO1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICBjb25zdCBmbG9hdGluZyA9IGlzRmxvYXRCYXIoY3VzdG9tKTtcbiAgICBsZXQgdmFsdWUgPSBwYXJzZWRbdlNjYWxlLmF4aXNdO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGxlbmd0aCA9IF9zdGFja2VkID8gdGhpcy5hcHBseVN0YWNrKHZTY2FsZSwgcGFyc2VkLCBfc3RhY2tlZCkgOiB2YWx1ZTtcbiAgICBsZXQgaGVhZCwgc2l6ZTtcbiAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgIHZhbHVlID0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgbGVuZ3RoID0gY3VzdG9tLmJhckVuZCAtIGN1c3RvbS5iYXJTdGFydDtcbiAgICAgIGlmICh2YWx1ZSAhPT0gMCAmJiBzaWduKHZhbHVlKSAhPT0gc2lnbihjdXN0b20uYmFyRW5kKSkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCArPSB2YWx1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgbGV0IGJhc2UgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydFZhbHVlKTtcbiAgICBpZiAodGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkpIHtcbiAgICAgIGhlYWQgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShzdGFydCArIGxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQgPSBiYXNlO1xuICAgIH1cbiAgICBzaXplID0gaGVhZCAtIGJhc2U7XG4gICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgIGJhc2UgLT0gc2l6ZSAvIDI7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgwKTtcbiAgICAgIGNvbnN0IGVuZFBpeGVsID0gdlNjYWxlLmdldFBpeGVsRm9yRGVjaW1hbCgxKTtcbiAgICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHN0YXJ0UGl4ZWwsIGVuZFBpeGVsKTtcbiAgICAgIGJhc2UgPSBNYXRoLm1heChNYXRoLm1pbihiYXNlLCBtYXgpLCBtaW4pO1xuICAgICAgaGVhZCA9IGJhc2UgKyBzaXplO1xuICAgIH1cbiAgICBpZiAoYmFzZSA9PT0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoYWN0dWFsQmFzZSkpIHtcbiAgICAgIGNvbnN0IGhhbGZHcmlkID0gc2lnbihzaXplKSAqIHZTY2FsZS5nZXRMaW5lV2lkdGhGb3JWYWx1ZShhY3R1YWxCYXNlKSAvIDI7XG4gICAgICBiYXNlICs9IGhhbGZHcmlkO1xuICAgICAgc2l6ZSAtPSBoYWxmR3JpZDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpemUsXG4gICAgICBiYXNlLFxuICAgICAgaGVhZCxcbiAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgfTtcbiAgfVxuICBfY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaW5kZXgsIHJ1bGVyKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHNraXBOdWxsID0gb3B0aW9ucy5za2lwTnVsbDtcbiAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgIGxldCBjZW50ZXIsIHNpemU7XG4gICAgaWYgKHJ1bGVyLmdyb3VwZWQpIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSBza2lwTnVsbCA/IHRoaXMuX2dldFN0YWNrQ291bnQoaW5kZXgpIDogcnVsZXIuc3RhY2tDb3VudDtcbiAgICAgIGNvbnN0IHJhbmdlID0gb3B0aW9ucy5iYXJUaGlja25lc3MgPT09ICdmbGV4J1xuICAgICAgICA/IGNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMoaW5kZXgsIHJ1bGVyLCBvcHRpb25zLCBzdGFja0NvdW50KVxuICAgICAgICA6IGNvbXB1dGVGaXRDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpO1xuICAgICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuX2dldFN0YWNrSW5kZXgodGhpcy5pbmRleCwgdGhpcy5fY2FjaGVkTWV0YS5zdGFjaywgc2tpcE51bGwgPyBpbmRleCA6IHVuZGVmaW5lZCk7XG4gICAgICBjZW50ZXIgPSByYW5nZS5zdGFydCArIChyYW5nZS5jaHVuayAqIHN0YWNrSW5kZXgpICsgKHJhbmdlLmNodW5rIC8gMik7XG4gICAgICBzaXplID0gTWF0aC5taW4obWF4QmFyVGhpY2tuZXNzLCByYW5nZS5jaHVuayAqIHJhbmdlLnJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VudGVyID0gc2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZSh0aGlzLmdldFBhcnNlZChpbmRleClbc2NhbGUuYXhpc10sIGluZGV4KTtcbiAgICAgIHNpemUgPSBNYXRoLm1pbihtYXhCYXJUaGlja25lc3MsIHJ1bGVyLm1pbiAqIHJ1bGVyLnJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhc2U6IGNlbnRlciAtIHNpemUgLyAyLFxuICAgICAgaGVhZDogY2VudGVyICsgc2l6ZSAvIDIsXG4gICAgICBjZW50ZXIsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHZTY2FsZSA9IG1ldGEudlNjYWxlO1xuICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgIGNvbnN0IGlsZW4gPSByZWN0cy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGZvciAoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBpZiAodGhpcy5nZXRQYXJzZWQoaSlbdlNjYWxlLmF4aXNdICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3RzW2ldLmRyYXcodGhpcy5fY3R4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbkJhckNvbnRyb2xsZXIuaWQgPSAnYmFyJztcbkJhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ2JhcicsXG4gIGNhdGVnb3J5UGVyY2VudGFnZTogMC44LFxuICBiYXJQZXJjZW50YWdlOiAwLjksXG4gIGdyb3VwZWQ6IHRydWUsXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J11cbiAgICB9XG4gIH1cbn07XG5CYXJDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgX2luZGV4Xzoge1xuICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgIG9mZnNldDogdHJ1ZSxcbiAgICAgIGdyaWQ6IHtcbiAgICAgICAgb2Zmc2V0OiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBfdmFsdWVfOiB7XG4gICAgICB0eXBlOiAnbGluZWFyJyxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgQnViYmxlQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgfVxuICBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIHBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBkYXRhW3N0YXJ0ICsgaV07XG4gICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHZhbHVlT3JEZWZhdWx0KGl0ZW1bMl0sIHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJzZWQ7XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHN1cGVyLnBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyc2VkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtICYmIGl0ZW0uciAmJiAraXRlbS5yLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgZGF0YVtpXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKSkgLyAyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICB9XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7eFNjYWxlLCB5U2NhbGV9ID0gbWV0YTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgY29uc3QgeCA9IHhTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZC54KTtcbiAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWw6IG1ldGEubGFiZWwsXG4gICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgKHIgPyAnLCAnICsgciA6ICcnKSArICcpJ1xuICAgIH07XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBwb2ludHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIDAsIHBvaW50cy5sZW5ndGgsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZX0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICBsZXQgdmFsdWVzID0gc3VwZXIucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSk7XG4gICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHskc2hhcmVkOiBmYWxzZX0pO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXMgPSB2YWx1ZXMucmFkaXVzO1xuICAgIGlmIChtb2RlICE9PSAnYWN0aXZlJykge1xuICAgICAgdmFsdWVzLnJhZGl1cyA9IDA7XG4gICAgfVxuICAgIHZhbHVlcy5yYWRpdXMgKz0gdmFsdWVPckRlZmF1bHQocGFyc2VkICYmIHBhcnNlZC5fY3VzdG9tLCByYWRpdXMpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbn1cbkJ1YmJsZUNvbnRyb2xsZXIuaWQgPSAnYnViYmxlJztcbkJ1YmJsZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWyd4JywgJ3knLCAnYm9yZGVyV2lkdGgnLCAncmFkaXVzJ11cbiAgICB9XG4gIH1cbn07XG5CdWJibGVDb250cm9sbGVyLm92ZXJyaWRlcyA9IHtcbiAgc2NhbGVzOiB7XG4gICAgeDoge1xuICAgICAgdHlwZTogJ2xpbmVhcidcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfVxuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCkge1xuICBsZXQgcmF0aW9YID0gMTtcbiAgbGV0IHJhdGlvWSA9IDE7XG4gIGxldCBvZmZzZXRYID0gMDtcbiAgbGV0IG9mZnNldFkgPSAwO1xuICBpZiAoY2lyY3VtZmVyZW5jZSA8IFRBVSkge1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICBjb25zdCBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlO1xuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IGVuZFggPSBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gICAgY29uc3QgZW5kWSA9IE1hdGguc2luKGVuZEFuZ2xlKTtcbiAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKSA9PiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgdHJ1ZSkgPyAxIDogTWF0aC5tYXgoYSwgYSAqIGN1dG91dCwgYiwgYiAqIGN1dG91dCk7XG4gICAgY29uc3QgY2FsY01pbiA9IChhbmdsZSwgYSwgYikgPT4gX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICBjb25zdCBtYXhYID0gY2FsY01heCgwLCBzdGFydFgsIGVuZFgpO1xuICAgIGNvbnN0IG1heFkgPSBjYWxjTWF4KEhBTEZfUEksIHN0YXJ0WSwgZW5kWSk7XG4gICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgY29uc3QgbWluWSA9IGNhbGNNaW4oUEkgKyBIQUxGX1BJLCBzdGFydFksIGVuZFkpO1xuICAgIHJhdGlvWCA9IChtYXhYIC0gbWluWCkgLyAyO1xuICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgIG9mZnNldFggPSAtKG1heFggKyBtaW5YKSAvIDI7XG4gICAgb2Zmc2V0WSA9IC0obWF4WSArIG1pblkpIC8gMjtcbiAgfVxuICByZXR1cm4ge3JhdGlvWCwgcmF0aW9ZLCBvZmZzZXRYLCBvZmZzZXRZfTtcbn1cbmNsYXNzIERvdWdobnV0Q29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm91dGVyUmFkaXVzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub2Zmc2V0WCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgbGlua1NjYWxlcygpIHt9XG4gIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmdldERhdGFzZXQoKS5kYXRhO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGdldHRlciA9IChpKSA9PiArZGF0YVtpXTtcbiAgICAgIGlmIChpc09iamVjdChkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgY29uc3Qge2tleSA9ICd2YWx1ZSd9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgZ2V0dGVyID0gKGkpID0+ICtyZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICB9XG4gICAgICBsZXQgaSwgaWxlbjtcbiAgICAgIGZvciAoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9nZXRSb3RhdGlvbigpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgfVxuICBfZ2V0Q2lyY3VtZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5jaXJjdW1mZXJlbmNlKTtcbiAgfVxuICBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgIGxldCBtaW4gPSBUQVU7XG4gICAgbGV0IG1heCA9IC1UQVU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gY29udHJvbGxlci5fZ2V0Q2lyY3VtZmVyZW5jZSgpO1xuICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJvdGF0aW9uKTtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IG1pbixcbiAgICAgIGNpcmN1bWZlcmVuY2U6IG1heCAtIG1pbixcbiAgICB9O1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHtjaGFydEFyZWF9ID0gY2hhcnQ7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgYXJjcyA9IG1ldGEuZGF0YTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRNYXhCb3JkZXJXaWR0aCgpICsgdGhpcy5nZXRNYXhPZmZzZXQoYXJjcykgKyB0aGlzLm9wdGlvbnMuc3BhY2luZztcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgIGNvbnN0IGN1dG91dCA9IE1hdGgubWluKHRvUGVyY2VudGFnZSh0aGlzLm9wdGlvbnMuY3V0b3V0LCBtYXhTaXplKSwgMSk7XG4gICAgY29uc3QgY2hhcnRXZWlnaHQgPSB0aGlzLl9nZXRSaW5nV2VpZ2h0KHRoaXMuaW5kZXgpO1xuICAgIGNvbnN0IHtjaXJjdW1mZXJlbmNlLCByb3RhdGlvbn0gPSB0aGlzLl9nZXRSb3RhdGlvbkV4dGVudHMoKTtcbiAgICBjb25zdCB7cmF0aW9YLCByYXRpb1ksIG9mZnNldFgsIG9mZnNldFl9ID0gZ2V0UmF0aW9BbmRPZmZzZXQocm90YXRpb24sIGNpcmN1bWZlcmVuY2UsIGN1dG91dCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gKGNoYXJ0QXJlYS5oZWlnaHQgLSBzcGFjaW5nKSAvIHJhdGlvWTtcbiAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1heChNYXRoLm1pbihtYXhXaWR0aCwgbWF4SGVpZ2h0KSAvIDIsIDApO1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG91dGVyUmFkaXVzICogY3V0b3V0LCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyB0aGlzLl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsKCk7XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFkgKiBvdXRlclJhZGl1cztcbiAgICBtZXRhLnRvdGFsID0gdGhpcy5jYWxjdWxhdGVUb3RhbCgpO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IE1hdGgubWF4KHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGggKiBjaGFydFdlaWdodCwgMCk7XG4gICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgaWYgKChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlKSB8fCAhdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSB8fCBtZXRhLl9wYXJzZWRbaV0gPT09IG51bGwgfHwgbWV0YS5kYXRhW2ldLmhpZGRlbikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UobWV0YS5fcGFyc2VkW2ldICogY2lyY3VtZmVyZW5jZSAvIFRBVSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMoYXJjcywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IGNlbnRlclggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMjtcbiAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgY29uc3QgYW5pbWF0ZVNjYWxlID0gcmVzZXQgJiYgYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBhbmltYXRlU2NhbGUgPyAwIDogdGhpcy5pbm5lclJhZGl1cztcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgIGNvbnN0IHtzaGFyZWRPcHRpb25zLCBpbmNsdWRlT3B0aW9uc30gPSB0aGlzLl9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YXJ0OyArK2kpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgfVxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgKytpKSB7XG4gICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeDogY2VudGVyWCArIHRoaXMub2Zmc2V0WCxcbiAgICAgICAgeTogY2VudGVyWSArIHRoaXMub2Zmc2V0WSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGU6IHN0YXJ0QW5nbGUgKyBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBjaXJjdW1mZXJlbmNlLFxuICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXNcbiAgICAgIH07XG4gICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICB9XG4gICAgICBzdGFydEFuZ2xlICs9IGNpcmN1bWZlcmVuY2U7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgbWV0YURhdGEgPSBtZXRhLmRhdGE7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsO1xuICB9XG4gIGNhbGN1bGF0ZUNpcmN1bWZlcmVuY2UodmFsdWUpIHtcbiAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgaWYgKHRvdGFsID4gMCAmJiAhaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4gVEFVICogKE1hdGguYWJzKHZhbHVlKSAvIHRvdGFsKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBsYWJlbHMgPSBjaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICBjb25zdCB2YWx1ZSA9IGZvcm1hdE51bWJlcihtZXRhLl9wYXJzZWRbaW5kZXhdLCBjaGFydC5vcHRpb25zLmxvY2FsZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgdmFsdWUsXG4gICAgfTtcbiAgfVxuICBnZXRNYXhCb3JkZXJXaWR0aChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGxldCBpLCBpbGVuLCBtZXRhLCBjb250cm9sbGVyLCBvcHRpb25zO1xuICAgIGlmICghYXJjcykge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICAgIGlmIChjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpKSB7XG4gICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgIGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgICAgY29udHJvbGxlciA9IG1ldGEuY29udHJvbGxlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWFyY3MpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIG9wdGlvbnMgPSBjb250cm9sbGVyLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3JkZXJBbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgbGV0IG1heCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxuICBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICBsZXQgcmluZ1dlaWdodE9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhc2V0SW5kZXg7ICsraSkge1xuICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICByaW5nV2VpZ2h0T2Zmc2V0ICs9IHRoaXMuX2dldFJpbmdXZWlnaHQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByaW5nV2VpZ2h0T2Zmc2V0O1xuICB9XG4gIF9nZXRSaW5nV2VpZ2h0KGRhdGFzZXRJbmRleCkge1xuICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgfVxuICBfZ2V0VmlzaWJsZURhdGFzZXRXZWlnaHRUb3RhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0UmluZ1dlaWdodE9mZnNldCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoKSB8fCAxO1xuICB9XG59XG5Eb3VnaG51dENvbnRyb2xsZXIuaWQgPSAnZG91Z2hudXQnO1xuRG91Z2hudXRDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdhcmMnLFxuICBhbmltYXRpb246IHtcbiAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgfSxcbiAgYW5pbWF0aW9uczoge1xuICAgIG51bWJlcnM6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgcHJvcGVydGllczogWydjaXJjdW1mZXJlbmNlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3N0YXJ0QW5nbGUnLCAneCcsICd5JywgJ29mZnNldCcsICdib3JkZXJXaWR0aCcsICdzcGFjaW5nJ11cbiAgICB9LFxuICB9LFxuICBjdXRvdXQ6ICc1MCUnLFxuICByb3RhdGlvbjogMCxcbiAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICByYWRpdXM6ICcxMDAlJyxcbiAgc3BhY2luZzogMCxcbiAgaW5kZXhBeGlzOiAncicsXG59O1xuRG91Z2hudXRDb250cm9sbGVyLmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdzcGFjaW5nJyxcbn07XG5Eb3VnaG51dENvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbCh0b29sdGlwSXRlbSkge1xuICAgICAgICAgIGxldCBkYXRhTGFiZWwgPSB0b29sdGlwSXRlbS5sYWJlbDtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9ICc6ICcgKyB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICBpZiAoaXNBcnJheShkYXRhTGFiZWwpKSB7XG4gICAgICAgICAgICBkYXRhTGFiZWwgPSBkYXRhTGFiZWwuc2xpY2UoKTtcbiAgICAgICAgICAgIGRhdGFMYWJlbFswXSArPSB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUxhYmVsICs9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGF0YUxhYmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gIH1cbiAgdXBkYXRlKG1vZGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgZGF0YTogcG9pbnRzID0gW10sIF9kYXRhc2V0fSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBsaW5lLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgbGluZS5wb2ludHMgPSBwb2ludHM7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgb3B0aW9ucy5ib3JkZXJXaWR0aCA9IDA7XG4gICAgfVxuICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgIGFuaW1hdGVkOiAhYW5pbWF0aW9uc0Rpc2FibGVkLFxuICAgICAgb3B0aW9uc1xuICAgIH0sIG1vZGUpO1xuICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge3NoYXJlZE9wdGlvbnMsIGluY2x1ZGVPcHRpb25zfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGFzZXQgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGJvcmRlcjtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgIGNvbnN0IGxhc3RQb2ludCA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhkYXRhLmxlbmd0aCAtIDEpKTtcbiAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgfVxuICBkcmF3KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIG1ldGEuZGF0YXNldC51cGRhdGVDb250cm9sUG9pbnRzKHRoaXMuY2hhcnQuY2hhcnRBcmVhLCBtZXRhLmlTY2FsZS5heGlzKTtcbiAgICBzdXBlci5kcmF3KCk7XG4gIH1cbn1cbkxpbmVDb250cm9sbGVyLmlkID0gJ2xpbmUnO1xuTGluZUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiB0cnVlLFxuICBzcGFuR2FwczogZmFsc2UsXG59O1xuTGluZUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBzY2FsZXM6IHtcbiAgICBfaW5kZXhfOiB7XG4gICAgICB0eXBlOiAnY2F0ZWdvcnknLFxuICAgIH0sXG4gICAgX3ZhbHVlXzoge1xuICAgICAgdHlwZTogJ2xpbmVhcicsXG4gICAgfSxcbiAgfVxufTtcblxuY2xhc3MgUG9sYXJBcmVhQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCkge1xuICAgIHN1cGVyKGNoYXJ0LCBkYXRhc2V0SW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGxhYmVscyA9IGNoYXJ0LmRhdGEubGFiZWxzIHx8IFtdO1xuICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbDogbGFiZWxzW2luZGV4XSB8fCAnJyxcbiAgICAgIHZhbHVlLFxuICAgIH07XG4gIH1cbiAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICB9XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgYXJjcyA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgfVxuICBnZXRNaW5NYXgoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgcmFuZ2UgPSB7bWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIG1heDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZfTtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yO1xuICAgICAgaWYgKCFpc05hTihwYXJzZWQpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICByYW5nZS5taW4gPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZCA+IHJhbmdlLm1heCkge1xuICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBfdXBkYXRlUmFkaXVzKCkge1xuICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICBjb25zdCBjaGFydEFyZWEgPSBjaGFydC5jaGFydEFyZWE7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChtaW5TaXplIC8gMiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvcHRzLmN1dG91dFBlcmNlbnRhZ2UgPyAob3V0ZXJSYWRpdXMgLyAxMDApICogKG9wdHMuY3V0b3V0UGVyY2VudGFnZSkgOiAxLCAwKTtcbiAgICBjb25zdCByYWRpdXNMZW5ndGggPSAob3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cykgLyBjaGFydC5nZXRWaXNpYmxlRGF0YXNldENvdW50KCk7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gKHJhZGl1c0xlbmd0aCAqIHRoaXMuaW5kZXgpO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0cyA9IG9wdHMuYW5pbWF0aW9uO1xuICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS5yU2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgY29uc3QgY2VudGVyWSA9IHNjYWxlLnlDZW50ZXI7XG4gICAgY29uc3QgZGF0YXNldFN0YXJ0QW5nbGUgPSBzY2FsZS5nZXRJbmRleEFuZ2xlKDApIC0gMC41ICogUEk7XG4gICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgbGV0IGk7XG4gICAgY29uc3QgZGVmYXVsdEFuZ2xlID0gMzYwIC8gdGhpcy5jb3VudFZpc2libGVFbGVtZW50cygpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFydDsgKytpKSB7XG4gICAgICBhbmdsZSArPSB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICB9XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFyYyA9IGFyY3NbaV07XG4gICAgICBsZXQgc3RhcnRBbmdsZSA9IGFuZ2xlO1xuICAgICAgbGV0IGVuZEFuZ2xlID0gYW5nbGUgKyB0aGlzLl9jb21wdXRlQW5nbGUoaSwgbW9kZSwgZGVmYXVsdEFuZ2xlKTtcbiAgICAgIGxldCBvdXRlclJhZGl1cyA9IGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpID8gc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSkucikgOiAwO1xuICAgICAgYW5nbGUgPSBlbmRBbmdsZTtcbiAgICAgIGlmIChyZXNldCkge1xuICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICBvdXRlclJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVJvdGF0ZSkge1xuICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICBpbm5lclJhZGl1czogMCxcbiAgICAgICAgb3V0ZXJSYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICBvcHRpb25zOiB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgYXJjLmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSlcbiAgICAgIH07XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYXJjLCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbiAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICghaXNOYU4odGhpcy5nZXRQYXJzZWQoaW5kZXgpLnIpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpKSB7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KVxuICAgICAgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpXG4gICAgICA6IDA7XG4gIH1cbn1cblBvbGFyQXJlYUNvbnRyb2xsZXIuaWQgPSAncG9sYXJBcmVhJztcblBvbGFyQXJlYUNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gIGFuaW1hdGlvbjoge1xuICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gIH0sXG4gIGFuaW1hdGlvbnM6IHtcbiAgICBudW1iZXJzOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIHByb3BlcnRpZXM6IFsneCcsICd5JywgJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXVxuICAgIH0sXG4gIH0sXG4gIGluZGV4QXhpczogJ3InLFxuICBzdGFydEFuZ2xlOiAwLFxufTtcblBvbGFyQXJlYUNvbnRyb2xsZXIub3ZlcnJpZGVzID0ge1xuICBhc3BlY3RSYXRpbzogMSxcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgaWYgKGRhdGEubGFiZWxzLmxlbmd0aCAmJiBkYXRhLmRhdGFzZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qge2xhYmVsczoge3BvaW50U3R5bGV9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogIWNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpLFxuICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB0b29sdGlwOiB7XG4gICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgdGl0bGUoKSB7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9LFxuICAgICAgICBsYWJlbChjb250ZXh0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuY2hhcnQuZGF0YS5sYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdICsgJzogJyArIGNvbnRleHQuZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHI6IHtcbiAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInLFxuICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgfSxcbiAgICAgIGJlZ2luQXRaZXJvOiB0cnVlLFxuICAgICAgZ3JpZDoge1xuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgc3RhcnRBbmdsZTogMFxuICAgIH1cbiAgfVxufTtcblxuY2xhc3MgUGllQ29udHJvbGxlciBleHRlbmRzIERvdWdobnV0Q29udHJvbGxlciB7XG59XG5QaWVDb250cm9sbGVyLmlkID0gJ3BpZSc7XG5QaWVDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBjdXRvdXQ6IDAsXG4gIHJvdGF0aW9uOiAwLFxuICBjaXJjdW1mZXJlbmNlOiAzNjAsXG4gIHJhZGl1czogJzEwMCUnXG59O1xuXG5jbGFzcyBSYWRhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICBjb25zdCB2U2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZTtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICB9O1xuICB9XG4gIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgY29uc3QgcG9pbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGxhYmVscyA9IG1ldGEuaVNjYWxlLmdldExhYmVscygpO1xuICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgIGlmIChtb2RlICE9PSAncmVzaXplJykge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgX2xvb3A6IHRydWUsXG4gICAgICAgIF9mdWxsTG9vcDogbGFiZWxzLmxlbmd0aCA9PT0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfTtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gIH1cbiAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuX2NhY2hlZE1ldGEuclNjYWxlO1xuICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgY29uc3QgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB0aGlzLmdldFBhcnNlZChpKS5yKTtcbiAgICAgIGNvbnN0IHggPSByZXNldCA/IHNjYWxlLnhDZW50ZXIgOiBwb2ludFBvc2l0aW9uLng7XG4gICAgICBjb25zdCB5ID0gcmVzZXQgPyBzY2FsZS55Q2VudGVyIDogcG9pbnRQb3NpdGlvbi55O1xuICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgYW5nbGU6IHBvaW50UG9zaXRpb24uYW5nbGUsXG4gICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9O1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICB9XG4gIH1cbn1cblJhZGFyQ29udHJvbGxlci5pZCA9ICdyYWRhcic7XG5SYWRhckNvbnRyb2xsZXIuZGVmYXVsdHMgPSB7XG4gIGRhdGFzZXRFbGVtZW50VHlwZTogJ2xpbmUnLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIGluZGV4QXhpczogJ3InLFxuICBzaG93TGluZTogdHJ1ZSxcbiAgZWxlbWVudHM6IHtcbiAgICBsaW5lOiB7XG4gICAgICBmaWxsOiAnc3RhcnQnXG4gICAgfVxuICB9LFxufTtcblJhZGFyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGFzcGVjdFJhdGlvOiAxLFxuICBzY2FsZXM6IHtcbiAgICByOiB7XG4gICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICB9XG4gIH1cbn07XG5cbmNsYXNzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7eCwgeX0gPSB0aGlzLmdldFByb3BzKFsneCcsICd5J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7eCwgeX07XG4gIH1cbiAgaGFzVmFsdWUoKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyKHRoaXMueCkgJiYgaXNOdW1iZXIodGhpcy55KTtcbiAgfVxuICBnZXRQcm9wcyhwcm9wcywgZmluYWwpIHtcbiAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgaWYgKCFmaW5hbCB8fCAhYW5pbXMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBwcm9wcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgcmV0W3Byb3BdID0gYW5pbXNbcHJvcF0gJiYgYW5pbXNbcHJvcF0uYWN0aXZlKCkgPyBhbmltc1twcm9wXS5fdG8gOiB0aGlzW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiByZXQ7XG4gIH1cbn1cbkVsZW1lbnQuZGVmYXVsdHMgPSB7fTtcbkVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHVuZGVmaW5lZDtcblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiAgdmFsdWVzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiAnJyArIHZhbHVlO1xuICB9LFxuICBudW1lcmljKHRpY2tWYWx1ZSwgaW5kZXgsIHRpY2tzKSB7XG4gICAgaWYgKHRpY2tWYWx1ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuICcwJztcbiAgICB9XG4gICAgY29uc3QgbG9jYWxlID0gdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZTtcbiAgICBsZXQgbm90YXRpb247XG4gICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgIGlmICh0aWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBtYXhUaWNrID0gTWF0aC5tYXgoTWF0aC5hYnModGlja3NbMF0udmFsdWUpLCBNYXRoLmFicyh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZSkpO1xuICAgICAgaWYgKG1heFRpY2sgPCAxZS00IHx8IG1heFRpY2sgPiAxZSsxNSkge1xuICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgIH1cbiAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxvZ0RlbHRhID0gbG9nMTAoTWF0aC5hYnMoZGVsdGEpKTtcbiAgICBjb25zdCBudW1EZWNpbWFsID0gTWF0aC5tYXgoTWF0aC5taW4oLTEgKiBNYXRoLmZsb29yKGxvZ0RlbHRhKSwgMjApLCAwKTtcbiAgICBjb25zdCBvcHRpb25zID0ge25vdGF0aW9uLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHM6IG51bURlY2ltYWwsIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbH07XG4gICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgfSxcbiAgbG9nYXJpdGhtaWModGlja1ZhbHVlLCBpbmRleCwgdGlja3MpIHtcbiAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICByZXR1cm4gJzAnO1xuICAgIH1cbiAgICBjb25zdCByZW1haW4gPSB0aWNrVmFsdWUgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbHVlKSkpKTtcbiAgICBpZiAocmVtYWluID09PSAxIHx8IHJlbWFpbiA9PT0gMiB8fCByZW1haW4gPT09IDUpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxufTtcbmZ1bmN0aW9uIGNhbGN1bGF0ZURlbHRhKHRpY2tWYWx1ZSwgdGlja3MpIHtcbiAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICBpZiAoTWF0aC5hYnMoZGVsdGEpID49IDEgJiYgdGlja1ZhbHVlICE9PSBNYXRoLmZsb29yKHRpY2tWYWx1ZSkpIHtcbiAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZGVsdGE7XG59XG52YXIgVGlja3MgPSB7Zm9ybWF0dGVyc307XG5cbmRlZmF1bHRzLnNldCgnc2NhbGUnLCB7XG4gIGRpc3BsYXk6IHRydWUsXG4gIG9mZnNldDogZmFsc2UsXG4gIHJldmVyc2U6IGZhbHNlLFxuICBiZWdpbkF0WmVybzogZmFsc2UsXG4gIGJvdW5kczogJ3RpY2tzJyxcbiAgZ3JhY2U6IDAsXG4gIGdyaWQ6IHtcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGxpbmVXaWR0aDogMSxcbiAgICBkcmF3Qm9yZGVyOiB0cnVlLFxuICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICBkcmF3VGlja3M6IHRydWUsXG4gICAgdGlja0xlbmd0aDogOCxcbiAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmxpbmVXaWR0aCxcbiAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKSA9PiBvcHRpb25zLmNvbG9yLFxuICAgIG9mZnNldDogZmFsc2UsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wLFxuICAgIGJvcmRlcldpZHRoOiAxXG4gIH0sXG4gIHRpdGxlOiB7XG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgdGV4dDogJycsXG4gICAgcGFkZGluZzoge1xuICAgICAgdG9wOiA0LFxuICAgICAgYm90dG9tOiA0XG4gICAgfVxuICB9LFxuICB0aWNrczoge1xuICAgIG1pblJvdGF0aW9uOiAwLFxuICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICBtaXJyb3I6IGZhbHNlLFxuICAgIHRleHRTdHJva2VXaWR0aDogMCxcbiAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgIHBhZGRpbmc6IDMsXG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICBhdXRvU2tpcFBhZGRpbmc6IDMsXG4gICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgIG1pbm9yOiB7fSxcbiAgICBtYWpvcjoge30sXG4gICAgYWxpZ246ICdjZW50ZXInLFxuICAgIGNyb3NzQWxpZ246ICduZWFyJyxcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogZmFsc2UsXG4gICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgfVxufSk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG5kZWZhdWx0cy5yb3V0ZSgnc2NhbGUuZ3JpZCcsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbmRlZmF1bHRzLnJvdXRlKCdzY2FsZS5ncmlkJywgJ2JvcmRlckNvbG9yJywgJycsICdib3JkZXJDb2xvcicpO1xuZGVmYXVsdHMucm91dGUoJ3NjYWxlLnRpdGxlJywgJ2NvbG9yJywgJycsICdjb2xvcicpO1xuZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICBfZmFsbGJhY2s6IGZhbHNlLFxuICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ2JlZm9yZScpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ2FmdGVyJykgJiYgbmFtZSAhPT0gJ2NhbGxiYWNrJyAmJiBuYW1lICE9PSAncGFyc2VyJyxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAndGlja0JvcmRlckRhc2gnLFxufSk7XG5kZWZhdWx0cy5kZXNjcmliZSgnc2NhbGVzJywge1xuICBfZmFsbGJhY2s6ICdzY2FsZScsXG59KTtcbmRlZmF1bHRzLmRlc2NyaWJlKCdzY2FsZS50aWNrcycsIHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2JhY2tkcm9wUGFkZGluZycsXG59KTtcblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gIGNvbnN0IHRpY2tPcHRzID0gc2NhbGUub3B0aW9ucy50aWNrcztcbiAgY29uc3QgdGlja3NMaW1pdCA9IHRpY2tPcHRzLm1heFRpY2tzTGltaXQgfHwgZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpO1xuICBjb25zdCBtYWpvckluZGljZXMgPSB0aWNrT3B0cy5tYWpvci5lbmFibGVkID8gZ2V0TWFqb3JJbmRpY2VzKHRpY2tzKSA6IFtdO1xuICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICBjb25zdCBmaXJzdCA9IG1ham9ySW5kaWNlc1swXTtcbiAgY29uc3QgbGFzdCA9IG1ham9ySW5kaWNlc1tudW1NYWpvckluZGljZXMgLSAxXTtcbiAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgaWYgKG51bU1ham9ySW5kaWNlcyA+IHRpY2tzTGltaXQpIHtcbiAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICByZXR1cm4gbmV3VGlja3M7XG4gIH1cbiAgY29uc3Qgc3BhY2luZyA9IGNhbGN1bGF0ZVNwYWNpbmcobWFqb3JJbmRpY2VzLCB0aWNrcywgdGlja3NMaW1pdCk7XG4gIGlmIChudW1NYWpvckluZGljZXMgPiAwKSB7XG4gICAgbGV0IGksIGlsZW47XG4gICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gMCA6IGZpcnN0IC0gYXZnTWFqb3JTcGFjaW5nLCBmaXJzdCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG51bU1ham9ySW5kaWNlcyAtIDE7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbGFzdCwgaXNOdWxsT3JVbmRlZihhdmdNYWpvclNwYWNpbmcpID8gdGlja3MubGVuZ3RoIDogbGFzdCArIGF2Z01ham9yU3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xuICB9XG4gIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nKTtcbiAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgY29uc3Qgb2Zmc2V0ID0gc2NhbGUub3B0aW9ucy5vZmZzZXQ7XG4gIGNvbnN0IHRpY2tMZW5ndGggPSBzY2FsZS5fdGlja1NpemUoKTtcbiAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gIGNvbnN0IG1heENoYXJ0ID0gc2NhbGUuX21heExlbmd0aCAvIHRpY2tMZW5ndGg7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWluKG1heFNjYWxlLCBtYXhDaGFydCkpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KSB7XG4gIGNvbnN0IGV2ZW5NYWpvclNwYWNpbmcgPSBnZXRFdmVuU3BhY2luZyhtYWpvckluZGljZXMpO1xuICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgaWYgKCFldmVuTWFqb3JTcGFjaW5nKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICB9XG4gIGNvbnN0IGZhY3RvcnMgPSBfZmFjdG9yaXplKGV2ZW5NYWpvclNwYWNpbmcpO1xuICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IGZhY3RvcnMubGVuZ3RoIC0gMTsgaSA8IGlsZW47IGkrKykge1xuICAgIGNvbnN0IGZhY3RvciA9IGZhY3RvcnNbaV07XG4gICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLm1heChzcGFjaW5nLCAxKTtcbn1cbmZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGksIGlsZW47XG4gIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICBpZiAodGlja3NbaV0ubWFqb3IpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2tpcE1ham9ycyh0aWNrcywgbmV3VGlja3MsIG1ham9ySW5kaWNlcywgc3BhY2luZykge1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgbGV0IGk7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpID09PSBuZXh0KSB7XG4gICAgICBuZXdUaWNrcy5wdXNoKHRpY2tzW2ldKTtcbiAgICAgIGNvdW50Kys7XG4gICAgICBuZXh0ID0gbWFqb3JJbmRpY2VzW2NvdW50ICogc3BhY2luZ107XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgY29uc3Qgc3RhcnQgPSB2YWx1ZU9yRGVmYXVsdChtYWpvclN0YXJ0LCAwKTtcbiAgY29uc3QgZW5kID0gTWF0aC5taW4odmFsdWVPckRlZmF1bHQobWFqb3JFbmQsIHRpY2tzLmxlbmd0aCksIHRpY2tzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGxldCBsZW5ndGgsIGksIG5leHQ7XG4gIHNwYWNpbmcgPSBNYXRoLmNlaWwoc3BhY2luZyk7XG4gIGlmIChtYWpvckVuZCkge1xuICAgIGxlbmd0aCA9IG1ham9yRW5kIC0gbWFqb3JTdGFydDtcbiAgICBzcGFjaW5nID0gbGVuZ3RoIC8gTWF0aC5mbG9vcihsZW5ndGggLyBzcGFjaW5nKTtcbiAgfVxuICBuZXh0ID0gc3RhcnQ7XG4gIHdoaWxlIChuZXh0IDwgMCkge1xuICAgIGNvdW50Kys7XG4gICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICB9XG4gIGZvciAoaSA9IE1hdGgubWF4KHN0YXJ0LCAwKTsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgY291bnQrKztcbiAgICAgIG5leHQgPSBNYXRoLnJvdW5kKHN0YXJ0ICsgY291bnQgKiBzcGFjaW5nKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICBsZXQgaSwgZGlmZjtcbiAgaWYgKGxlbiA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChkaWZmID0gYXJyWzBdLCBpID0gMTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFycltpXSAtIGFycltpIC0gMV0gIT09IGRpZmYpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6IGFsaWduO1xuY29uc3Qgb2Zmc2V0RnJvbUVkZ2UgPSAoc2NhbGUsIGVkZ2UsIG9mZnNldCkgPT4gZWRnZSA9PT0gJ3RvcCcgfHwgZWRnZSA9PT0gJ2xlZnQnID8gc2NhbGVbZWRnZV0gKyBvZmZzZXQgOiBzY2FsZVtlZGdlXSAtIG9mZnNldDtcbmZ1bmN0aW9uIHNhbXBsZShhcnIsIG51bUl0ZW1zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBpbmNyZW1lbnQgPSBhcnIubGVuZ3RoIC8gbnVtSXRlbXM7XG4gIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgZm9yICg7IGkgPCBsZW47IGkgKz0gaW5jcmVtZW50KSB7XG4gICAgcmVzdWx0LnB1c2goYXJyW01hdGguZmxvb3IoaSldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS50aWNrcy5sZW5ndGg7XG4gIGNvbnN0IHZhbGlkSW5kZXggPSBNYXRoLm1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gIGNvbnN0IGVuZCA9IHNjYWxlLl9lbmRQaXhlbDtcbiAgY29uc3QgZXBzaWxvbiA9IDFlLTY7XG4gIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gIGxldCBvZmZzZXQ7XG4gIGlmIChvZmZzZXRHcmlkTGluZXMpIHtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICBvZmZzZXQgPSBNYXRoLm1heChsaW5lVmFsdWUgLSBzdGFydCwgZW5kIC0gbGluZVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldCA9IChsaW5lVmFsdWUgLSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCAtIDEpKSAvIDI7XG4gICAgfVxuICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgIGlmIChsaW5lVmFsdWUgPCBzdGFydCAtIGVwc2lsb24gfHwgbGluZVZhbHVlID4gZW5kICsgZXBzaWxvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGluZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpIHtcbiAgZWFjaChjYWNoZXMsIChjYWNoZSkgPT4ge1xuICAgIGNvbnN0IGdjID0gY2FjaGUuZ2M7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGxldCBpO1xuICAgIGlmIChnY0xlbiA+IGxlbmd0aCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyArK2kpIHtcbiAgICAgICAgZGVsZXRlIGNhY2hlLmRhdGFbZ2NbaV1dO1xuICAgICAgfVxuICAgICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5kcmF3VGlja3MgPyBvcHRpb25zLnRpY2tMZW5ndGggOiAwO1xufVxuZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBmb250ID0gdG9Gb250KG9wdGlvbnMuZm9udCwgZmFsbGJhY2spO1xuICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gIGNvbnN0IGxpbmVzID0gaXNBcnJheShvcHRpb25zLnRleHQpID8gb3B0aW9ucy50ZXh0Lmxlbmd0aCA6IDE7XG4gIHJldHVybiAobGluZXMgKiBmb250LmxpbmVIZWlnaHQpICsgcGFkZGluZy5oZWlnaHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTY2FsZUNvbnRleHQocGFyZW50LCBzY2FsZSkge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICBzY2FsZSxcbiAgICB0eXBlOiAnc2NhbGUnXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGlja0NvbnRleHQocGFyZW50LCBpbmRleCwgdGljaykge1xuICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICB0aWNrLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICd0aWNrJ1xuICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICBpZiAoKHJldmVyc2UgJiYgcG9zaXRpb24gIT09ICdyaWdodCcpIHx8ICghcmV2ZXJzZSAmJiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JykpIHtcbiAgICByZXQgPSByZXZlcnNlQWxpZ24ocmV0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICBjb25zdCB7dG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0LCBjaGFydH0gPSBzY2FsZTtcbiAgY29uc3Qge2NoYXJ0QXJlYSwgc2NhbGVzfSA9IGNoYXJ0O1xuICBsZXQgcm90YXRpb24gPSAwO1xuICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICBpZiAoc2NhbGUuaXNIb3Jpem9udGFsKCkpIHtcbiAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVkgPSAoY2hhcnRBcmVhLmJvdHRvbSArIGNoYXJ0QXJlYS50b3ApIC8gMiArIGhlaWdodCAtIG9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGl0bGVZID0gb2Zmc2V0RnJvbUVkZ2Uoc2NhbGUsIHBvc2l0aW9uLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtYXhXaWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgdGl0bGVYID0gc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICB0aXRsZVggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHdpZHRoICsgb2Zmc2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgfVxuICAgIHRpdGxlWSA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBib3R0b20sIHRvcCk7XG4gICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICB9XG4gIHJldHVybiB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn07XG59XG5jbGFzcyBTY2FsZSBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgdGhpcy50eXBlID0gY2ZnLnR5cGU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICB0aGlzLmNoYXJ0ID0gY2ZnLmNoYXJ0O1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucGFkZGluZ0xlZnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYWRkaW5nUmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1heCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYW5nZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnRpY2tzID0gW107XG4gICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxJdGVtcyA9IG51bGw7XG4gICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgIHRoaXMuX2xvbmdlc3RUZXh0Q2FjaGUgPSB7fTtcbiAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFBpeGVsID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VyTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3VzZXJNaW4gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1Z2dlc3RlZE1pbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl90aWNrc0xlbmd0aCA9IDA7XG4gICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgdGhpcy5fdXNlck1pbiA9IHRoaXMucGFyc2Uob3B0aW9ucy5taW4pO1xuICAgIHRoaXMuX3VzZXJNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMubWF4KTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICB0aGlzLl9zdWdnZXN0ZWRNYXggPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWF4KTtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgcmV0dXJuIHJhdztcbiAgfVxuICBnZXRVc2VyQm91bmRzKCkge1xuICAgIGxldCB7X3VzZXJNaW4sIF91c2VyTWF4LCBfc3VnZ2VzdGVkTWluLCBfc3VnZ2VzdGVkTWF4fSA9IHRoaXM7XG4gICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgX3VzZXJNYXggPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgX3N1Z2dlc3RlZE1pbiA9IGZpbml0ZU9yRGVmYXVsdChfc3VnZ2VzdGVkTWluLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIF9zdWdnZXN0ZWRNaW4pLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQoX3VzZXJNYXgsIF9zdWdnZXN0ZWRNYXgpLFxuICAgICAgbWluRGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNaW4pLFxuICAgICAgbWF4RGVmaW5lZDogaXNOdW1iZXJGaW5pdGUoX3VzZXJNYXgpXG4gICAgfTtcbiAgfVxuICBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGxldCByYW5nZTtcbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgICB9XG4gICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHJhbmdlID0gbWV0YXNbaV0uY29udHJvbGxlci5nZXRNaW5NYXgodGhpcywgY2FuU3RhY2spO1xuICAgICAgaWYgKCFtaW5EZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgcmFuZ2UubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1pbiA9IG1heERlZmluZWQgJiYgbWluID4gbWF4ID8gbWF4IDogbWluO1xuICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuICAgIHJldHVybiB7XG4gICAgICBtaW46IGZpbml0ZU9yRGVmYXVsdChtaW4sIGZpbml0ZU9yRGVmYXVsdChtYXgsIG1pbikpLFxuICAgICAgbWF4OiBmaW5pdGVPckRlZmF1bHQobWF4LCBmaW5pdGVPckRlZmF1bHQobWluLCBtYXgpKVxuICAgIH07XG4gIH1cbiAgZ2V0UGFkZGluZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogdGhpcy5wYWRkaW5nTGVmdCB8fCAwLFxuICAgICAgdG9wOiB0aGlzLnBhZGRpbmdUb3AgfHwgMCxcbiAgICAgIHJpZ2h0OiB0aGlzLnBhZGRpbmdSaWdodCB8fCAwLFxuICAgICAgYm90dG9tOiB0aGlzLnBhZGRpbmdCb3R0b20gfHwgMFxuICAgIH07XG4gIH1cbiAgZ2V0VGlja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxzKCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbHMgfHwgKHRoaXMuaXNIb3Jpem9udGFsKCkgPyBkYXRhLnhMYWJlbHMgOiBkYXRhLnlMYWJlbHMpIHx8IGRhdGEubGFiZWxzIHx8IFtdO1xuICB9XG4gIGJlZm9yZUxheW91dCgpIHtcbiAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgfVxuICBiZWZvcmVVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVVwZGF0ZSwgW3RoaXNdKTtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIGNvbnN0IHtiZWdpbkF0WmVybywgZ3JhY2UsIHRpY2tzOiB0aWNrT3B0c30gPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRpY2tPcHRzLnNhbXBsZVNpemU7XG4gICAgdGhpcy5iZWZvcmVVcGRhdGUoKTtcbiAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgdGhpcy5tYXhIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogMCxcbiAgICAgIHRvcDogMCxcbiAgICAgIGJvdHRvbTogMFxuICAgIH0sIG1hcmdpbnMpO1xuICAgIHRoaXMudGlja3MgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsSXRlbXMgPSBudWxsO1xuICAgIHRoaXMuYmVmb3JlU2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgIHRoaXMuYWZ0ZXJTZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pc0hvcml6b250YWwoKVxuICAgICAgPyB0aGlzLndpZHRoICsgbWFyZ2lucy5sZWZ0ICsgbWFyZ2lucy5yaWdodFxuICAgICAgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgaWYgKCF0aGlzLl9kYXRhTGltaXRzQ2FjaGVkKSB7XG4gICAgICB0aGlzLmJlZm9yZURhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuZGV0ZXJtaW5lRGF0YUxpbWl0cygpO1xuICAgICAgdGhpcy5hZnRlckRhdGFMaW1pdHMoKTtcbiAgICAgIHRoaXMuX3JhbmdlID0gX2FkZEdyYWNlKHRoaXMsIGdyYWNlLCBiZWdpbkF0WmVybyk7XG4gICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgdGhpcy50aWNrcyA9IHRoaXMuYnVpbGRUaWNrcygpIHx8IFtdO1xuICAgIHRoaXMuYWZ0ZXJCdWlsZFRpY2tzKCk7XG4gICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHNhbXBsaW5nRW5hYmxlZCA/IHNhbXBsZSh0aGlzLnRpY2tzLCBzYW1wbGVTaXplKSA6IHRoaXMudGlja3MpO1xuICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5jYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgdGhpcy5hZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKTtcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgIH1cbiAgICBpZiAoc2FtcGxpbmdFbmFibGVkKSB7XG4gICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyh0aGlzLnRpY2tzKTtcbiAgICB9XG4gICAgdGhpcy5iZWZvcmVGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICB0aGlzLmFmdGVyVXBkYXRlKCk7XG4gIH1cbiAgY29uZmlndXJlKCkge1xuICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgbGV0IHN0YXJ0UGl4ZWwsIGVuZFBpeGVsO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy5sZWZ0O1xuICAgICAgZW5kUGl4ZWwgPSB0aGlzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFBpeGVsID0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSByZXZlcnNlUGl4ZWxzO1xuICAgIHRoaXMuX2xlbmd0aCA9IGVuZFBpeGVsIC0gc3RhcnRQaXhlbDtcbiAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gIH1cbiAgYWZ0ZXJVcGRhdGUoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVXBkYXRlLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZVNldERpbWVuc2lvbnMsIFt0aGlzXSk7XG4gIH1cbiAgc2V0RGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQ7XG4gICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdUb3AgPSAwO1xuICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gMDtcbiAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICB9XG4gIGFmdGVyU2V0RGltZW5zaW9ucygpIHtcbiAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJTZXREaW1lbnNpb25zLCBbdGhpc10pO1xuICB9XG4gIF9jYWxsSG9va3MobmFtZSkge1xuICAgIHRoaXMuY2hhcnQubm90aWZ5UGx1Z2lucyhuYW1lLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zW25hbWVdLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVEYXRhTGltaXRzJyk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHt9XG4gIGFmdGVyRGF0YUxpbWl0cygpIHtcbiAgICB0aGlzLl9jYWxsSG9va3MoJ2FmdGVyRGF0YUxpbWl0cycpO1xuICB9XG4gIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgdGhpcy5fY2FsbEhvb2tzKCdiZWZvcmVCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYnVpbGRUaWNrcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgYWZ0ZXJCdWlsZFRpY2tzKCkge1xuICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJCdWlsZFRpY2tzJyk7XG4gIH1cbiAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVUaWNrVG9MYWJlbENvbnZlcnNpb24sIFt0aGlzXSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgbGV0IGksIGlsZW4sIHRpY2s7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbdGljay52YWx1ZSwgaSwgdGlja3NdLCB0aGlzKTtcbiAgICB9XG4gIH1cbiAgYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbdGhpc10pO1xuICB9XG4gIGJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmJlZm9yZUNhbGN1bGF0ZUxhYmVsUm90YXRpb24sIFt0aGlzXSk7XG4gIH1cbiAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0aW9ucy50aWNrcztcbiAgICBjb25zdCBudW1UaWNrcyA9IHRoaXMudGlja3MubGVuZ3RoO1xuICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICBjb25zdCBtYXhSb3RhdGlvbiA9IHRpY2tPcHRzLm1heFJvdGF0aW9uO1xuICAgIGxldCBsYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIXRpY2tPcHRzLmRpc3BsYXkgfHwgbWluUm90YXRpb24gPj0gbWF4Um90YXRpb24gfHwgbnVtVGlja3MgPD0gMSB8fCAhdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbWluUm90YXRpb247XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgY29uc3QgbWF4TGFiZWxXaWR0aCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGNvbnN0IG1heExhYmVsSGVpZ2h0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodDtcbiAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICB0aWNrV2lkdGggPSBvcHRpb25zLm9mZnNldCA/IHRoaXMubWF4V2lkdGggLyBudW1UaWNrcyA6IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gMSk7XG4gICAgaWYgKG1heExhYmVsV2lkdGggKyA2ID4gdGlja1dpZHRoKSB7XG4gICAgICB0aWNrV2lkdGggPSBtYXhXaWR0aCAvIChudW1UaWNrcyAtIChvcHRpb25zLm9mZnNldCA/IDAuNSA6IDEpKTtcbiAgICAgIG1heEhlaWdodCA9IHRoaXMubWF4SGVpZ2h0IC0gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucy5ncmlkKVxuXHRcdFx0XHQtIHRpY2tPcHRzLnBhZGRpbmcgLSBnZXRUaXRsZUhlaWdodChvcHRpb25zLnRpdGxlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBtYXhMYWJlbERpYWdvbmFsID0gTWF0aC5zcXJ0KG1heExhYmVsV2lkdGggKiBtYXhMYWJlbFdpZHRoICsgbWF4TGFiZWxIZWlnaHQgKiBtYXhMYWJlbEhlaWdodCk7XG4gICAgICBsYWJlbFJvdGF0aW9uID0gdG9EZWdyZWVzKE1hdGgubWluKFxuICAgICAgICBNYXRoLmFzaW4oX2xpbWl0VmFsdWUoKGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgKyA2KSAvIHRpY2tXaWR0aCwgLTEsIDEpKSxcbiAgICAgICAgTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heEhlaWdodCAvIG1heExhYmVsRGlhZ29uYWwsIC0xLCAxKSkgLSBNYXRoLmFzaW4oX2xpbWl0VmFsdWUobWF4TGFiZWxIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpXG4gICAgICApKTtcbiAgICAgIGxhYmVsUm90YXRpb24gPSBNYXRoLm1heChtaW5Sb3RhdGlvbiwgTWF0aC5taW4obWF4Um90YXRpb24sIGxhYmVsUm90YXRpb24pKTtcbiAgICB9XG4gICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gbGFiZWxSb3RhdGlvbjtcbiAgfVxuICBhZnRlckNhbGN1bGF0ZUxhYmVsUm90YXRpb24oKSB7XG4gICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW3RoaXNdKTtcbiAgfVxuICBhZnRlckF1dG9Ta2lwKCkge31cbiAgYmVmb3JlRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVGaXQsIFt0aGlzXSk7XG4gIH1cbiAgZml0KCkge1xuICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgY29uc3Qge2NoYXJ0LCBvcHRpb25zOiB7dGlja3M6IHRpY2tPcHRzLCB0aXRsZTogdGl0bGVPcHRzLCBncmlkOiBncmlkT3B0c319ID0gdGhpcztcbiAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSBnZXRUaXRsZUhlaWdodCh0aXRsZU9wdHMsIGNoYXJ0Lm9wdGlvbnMuZm9udCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIG1pblNpemUud2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluU2l6ZS5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgbWluU2l6ZS53aWR0aCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgfVxuICAgICAgaWYgKHRpY2tPcHRzLmRpc3BsYXkgJiYgdGhpcy50aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qge2ZpcnN0LCBsYXN0LCB3aWRlc3QsIGhpZ2hlc3R9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCB0aWNrUGFkZGluZyA9IHRpY2tPcHRzLnBhZGRpbmcgKiAyO1xuICAgICAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgY29uc3Qgc2luID0gTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gdGlja09wdHMubWlycm9yID8gMCA6IHNpbiAqIHdpZGVzdC53aWR0aCArIGNvcyAqIGhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICBtaW5TaXplLndpZHRoID0gTWF0aC5taW4odGhpcy5tYXhXaWR0aCwgbWluU2l6ZS53aWR0aCArIGxhYmVsV2lkdGggKyB0aWNrUGFkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVNYXJnaW5zKCk7XG4gICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX2xlbmd0aCA9IGNoYXJ0LndpZHRoIC0gdGhpcy5fbWFyZ2lucy5sZWZ0IC0gdGhpcy5fbWFyZ2lucy5yaWdodDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gbWluU2l6ZS5oZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgIH1cbiAgfVxuICBfY2FsY3VsYXRlUGFkZGluZyhmaXJzdCwgbGFzdCwgc2luLCBjb3MpIHtcbiAgICBjb25zdCB7dGlja3M6IHthbGlnbiwgcGFkZGluZ30sIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgY29uc3QgbGFiZWxzQmVsb3dUaWNrcyA9IHBvc2l0aW9uICE9PSAndG9wJyAmJiB0aGlzLmF4aXMgPT09ICd4JztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgY29uc3Qgb2Zmc2V0TGVmdCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKDApIC0gdGhpcy5sZWZ0O1xuICAgICAgY29uc3Qgb2Zmc2V0UmlnaHQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5nZXRQaXhlbEZvclRpY2sodGhpcy50aWNrcy5sZW5ndGggLSAxKTtcbiAgICAgIGxldCBwYWRkaW5nTGVmdCA9IDA7XG4gICAgICBsZXQgcGFkZGluZ1JpZ2h0ID0gMDtcbiAgICAgIGlmIChpc1JvdGF0ZWQpIHtcbiAgICAgICAgaWYgKGxhYmVsc0JlbG93VGlja3MpIHtcbiAgICAgICAgICBwYWRkaW5nTGVmdCA9IGNvcyAqIGZpcnN0LndpZHRoO1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGNvcyAqIGxhc3Qud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1JpZ2h0ID0gbGFzdC53aWR0aDtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSAnaW5uZXInKSB7XG4gICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoIC8gMjtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFkZGluZ0xlZnQgPSBNYXRoLm1heCgocGFkZGluZ0xlZnQgLSBvZmZzZXRMZWZ0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRMZWZ0KSwgMCk7XG4gICAgICB0aGlzLnBhZGRpbmdSaWdodCA9IE1hdGgubWF4KChwYWRkaW5nUmlnaHQgLSBvZmZzZXRSaWdodCArIHBhZGRpbmcpICogdGhpcy53aWR0aCAvICh0aGlzLndpZHRoIC0gb2Zmc2V0UmlnaHQpLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgcGFkZGluZ1RvcCA9IDA7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSBmaXJzdC5oZWlnaHQ7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgIHBhZGRpbmdCb3R0b20gPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nVG9wID0gcGFkZGluZ1RvcCArIHBhZGRpbmc7XG4gICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSBwYWRkaW5nQm90dG9tICsgcGFkZGluZztcbiAgICB9XG4gIH1cbiAgX2hhbmRsZU1hcmdpbnMoKSB7XG4gICAgaWYgKHRoaXMuX21hcmdpbnMpIHtcbiAgICAgIHRoaXMuX21hcmdpbnMubGVmdCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ0xlZnQsIHRoaXMuX21hcmdpbnMubGVmdCk7XG4gICAgICB0aGlzLl9tYXJnaW5zLnRvcCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1RvcCwgdGhpcy5fbWFyZ2lucy50b3ApO1xuICAgICAgdGhpcy5fbWFyZ2lucy5yaWdodCA9IE1hdGgubWF4KHRoaXMucGFkZGluZ1JpZ2h0LCB0aGlzLl9tYXJnaW5zLnJpZ2h0KTtcbiAgICAgIHRoaXMuX21hcmdpbnMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nQm90dG9tLCB0aGlzLl9tYXJnaW5zLmJvdHRvbSk7XG4gICAgfVxuICB9XG4gIGFmdGVyRml0KCkge1xuICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlckZpdCwgW3RoaXNdKTtcbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3Qge2F4aXMsIHBvc2l0aW9ufSA9IHRoaXMub3B0aW9ucztcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gIH1cbiAgaXNGdWxsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZ1bGxTaXplO1xuICB9XG4gIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgIHRoaXMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gICAgdGhpcy5nZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspIHtcbiAgICAgIGlmIChpc051bGxPclVuZGVmKHRpY2tzW2ldLmxhYmVsKSkge1xuICAgICAgICB0aWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGlsZW4tLTtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uKCk7XG4gIH1cbiAgX2dldExhYmVsU2l6ZXMoKSB7XG4gICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgIGlmICghbGFiZWxTaXplcykge1xuICAgICAgY29uc3Qgc2FtcGxlU2l6ZSA9IHRoaXMub3B0aW9ucy50aWNrcy5zYW1wbGVTaXplO1xuICAgICAgbGV0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgIGlmIChzYW1wbGVTaXplIDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbFNpemVzO1xuICB9XG4gIF9jb21wdXRlTGFiZWxTaXplcyh0aWNrcywgbGVuZ3RoKSB7XG4gICAgY29uc3Qge2N0eCwgX2xvbmdlc3RUZXh0Q2FjaGU6IGNhY2hlc30gPSB0aGlzO1xuICAgIGNvbnN0IHdpZHRocyA9IFtdO1xuICAgIGNvbnN0IGhlaWdodHMgPSBbXTtcbiAgICBsZXQgd2lkZXN0TGFiZWxTaXplID0gMDtcbiAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgbGV0IGksIGosIGpsZW4sIGxhYmVsLCB0aWNrRm9udCwgZm9udFN0cmluZywgY2FjaGUsIGxpbmVIZWlnaHQsIHdpZHRoLCBoZWlnaHQsIG5lc3RlZExhYmVsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgbGFiZWwgPSB0aWNrc1tpXS5sYWJlbDtcbiAgICAgIHRpY2tGb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgIGN0eC5mb250ID0gZm9udFN0cmluZyA9IHRpY2tGb250LnN0cmluZztcbiAgICAgIGNhY2hlID0gY2FjaGVzW2ZvbnRTdHJpbmddID0gY2FjaGVzW2ZvbnRTdHJpbmddIHx8IHtkYXRhOiB7fSwgZ2M6IFtdfTtcbiAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgd2lkdGggPSBfbWVhc3VyZVRleHQoY3R4LCBjYWNoZS5kYXRhLCBjYWNoZS5nYywgd2lkdGgsIGxhYmVsKTtcbiAgICAgICAgaGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVsLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIG5lc3RlZExhYmVsID0gbGFiZWxbal07XG4gICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG5lc3RlZExhYmVsKSAmJiAhaXNBcnJheShuZXN0ZWRMYWJlbCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gX21lYXN1cmVUZXh0KGN0eCwgY2FjaGUuZGF0YSwgY2FjaGUuZ2MsIHdpZHRoLCBuZXN0ZWRMYWJlbCk7XG4gICAgICAgICAgICBoZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdpZHRocy5wdXNoKHdpZHRoKTtcbiAgICAgIGhlaWdodHMucHVzaChoZWlnaHQpO1xuICAgICAgd2lkZXN0TGFiZWxTaXplID0gTWF0aC5tYXgod2lkdGgsIHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgICBoaWdoZXN0TGFiZWxTaXplID0gTWF0aC5tYXgoaGVpZ2h0LCBoaWdoZXN0TGFiZWxTaXplKTtcbiAgICB9XG4gICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgIGNvbnN0IHdpZGVzdCA9IHdpZHRocy5pbmRleE9mKHdpZGVzdExhYmVsU2l6ZSk7XG4gICAgY29uc3QgaGlnaGVzdCA9IGhlaWdodHMuaW5kZXhPZihoaWdoZXN0TGFiZWxTaXplKTtcbiAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCkgPT4gKHt3aWR0aDogd2lkdGhzW2lkeF0gfHwgMCwgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMH0pO1xuICAgIHJldHVybiB7XG4gICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICB3aWR0aHMsXG4gICAgICBoZWlnaHRzLFxuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgIHJldHVybiBOYU47XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge31cbiAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JWYWx1ZSh0aWNrc1tpbmRleF0udmFsdWUpO1xuICB9XG4gIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgaWYgKHRoaXMuX3JldmVyc2VQaXhlbHMpIHtcbiAgICAgIGRlY2ltYWwgPSAxIC0gZGVjaW1hbDtcbiAgICB9XG4gICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICByZXR1cm4gX2ludDE2UmFuZ2UodGhpcy5fYWxpZ25Ub1BpeGVscyA/IF9hbGlnblBpeGVsKHRoaXMuY2hhcnQsIHBpeGVsLCAwKSA6IHBpeGVsKTtcbiAgfVxuICBnZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3JldmVyc2VQaXhlbHMgPyAxIC0gZGVjaW1hbCA6IGRlY2ltYWw7XG4gIH1cbiAgZ2V0QmFzZVBpeGVsKCkge1xuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0QmFzZVZhbHVlKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzO1xuICAgIHJldHVybiBtaW4gPCAwICYmIG1heCA8IDAgPyBtYXggOlxuICAgICAgbWluID4gMCAmJiBtYXggPiAwID8gbWluIDpcbiAgICAgIDA7XG4gIH1cbiAgZ2V0Q29udGV4dChpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgIHJldHVybiB0aWNrLiRjb250ZXh0IHx8XG5cdFx0XHRcdCh0aWNrLiRjb250ZXh0ID0gY3JlYXRlVGlja0NvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCB0aWNrKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICB9XG4gIF90aWNrU2l6ZSgpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3QpKTtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihyb3QpKTtcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBvcHRpb25UaWNrcy5hdXRvU2tpcFBhZGRpbmcgfHwgMDtcbiAgICBjb25zdCB3ID0gbGFiZWxTaXplcyA/IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoICsgcGFkZGluZyA6IDA7XG4gICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgcmV0dXJuIHRoaXMuaXNIb3Jpem9udGFsKClcbiAgICAgID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpblxuICAgICAgOiBoICogc2luIDwgdyAqIGNvcyA/IGggLyBjb3MgOiB3IC8gc2luO1xuICB9XG4gIF9pc1Zpc2libGUoKSB7XG4gICAgY29uc3QgZGlzcGxheSA9IHRoaXMub3B0aW9ucy5kaXNwbGF5O1xuICAgIGlmIChkaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgIHJldHVybiAhIWRpc3BsYXk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCkubGVuZ3RoID4gMDtcbiAgfVxuICBfY29tcHV0ZUdyaWRMaW5lSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7Z3JpZCwgcG9zaXRpb259ID0gb3B0aW9ucztcbiAgICBjb25zdCBvZmZzZXQgPSBncmlkLm9mZnNldDtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBjb25zdCB0aWNrc0xlbmd0aCA9IHRpY2tzLmxlbmd0aCArIChvZmZzZXQgPyAxIDogMCk7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGJvcmRlck9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlck9wdHMuZHJhd0JvcmRlciA/IGJvcmRlck9wdHMuYm9yZGVyV2lkdGggOiAwO1xuICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgIGNvbnN0IGFsaWduQm9yZGVyVmFsdWUgPSBmdW5jdGlvbihwaXhlbCkge1xuICAgICAgcmV0dXJuIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgYXhpc1dpZHRoKTtcbiAgICB9O1xuICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgIGxldCB0eDEsIHR5MSwgdHgyLCB0eTIsIHgxLCB5MSwgeDIsIHkyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmJvdHRvbSk7XG4gICAgICB0eTEgPSB0aGlzLmJvdHRvbSAtIHRsO1xuICAgICAgdHkyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeTEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS50b3ApICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0Jykge1xuICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMucmlnaHQpO1xuICAgICAgdHgxID0gdGhpcy5yaWdodCAtIHRsO1xuICAgICAgdHgyID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgeDEgPSBhbGlnbkJvcmRlclZhbHVlKGNoYXJ0QXJlYS5sZWZ0KSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5sZWZ0KTtcbiAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICB4MiA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnJpZ2h0KSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICB0eDIgPSB0aGlzLmxlZnQgKyB0bDtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyAwLjUpO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICBib3JkZXJWYWx1ZSA9IGFsaWduQm9yZGVyVmFsdWUodGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgIHkyID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgIHR5MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgIHR5MiA9IHR5MSArIHRsO1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMik7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgICAgdHgxID0gYm9yZGVyVmFsdWUgLSBheGlzSGFsZldpZHRoO1xuICAgICAgdHgyID0gdHgxIC0gdGw7XG4gICAgICB4MSA9IGNoYXJ0QXJlYS5sZWZ0O1xuICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5tYXhUaWNrc0xpbWl0LCB0aWNrc0xlbmd0aCk7XG4gICAgY29uc3Qgc3RlcCA9IE1hdGgubWF4KDEsIE1hdGguY2VpbCh0aWNrc0xlbmd0aCAvIGxpbWl0KSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRpY2tzTGVuZ3RoOyBpICs9IHN0ZXApIHtcbiAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICBjb25zdCBsaW5lV2lkdGggPSBvcHRzQXRJbmRleC5saW5lV2lkdGg7XG4gICAgICBjb25zdCBsaW5lQ29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgYm9yZGVyRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICBjb25zdCB0aWNrV2lkdGggPSBvcHRzQXRJbmRleC50aWNrV2lkdGg7XG4gICAgICBjb25zdCB0aWNrQ29sb3IgPSBvcHRzQXRJbmRleC50aWNrQ29sb3I7XG4gICAgICBjb25zdCB0aWNrQm9yZGVyRGFzaCA9IG9wdHNBdEluZGV4LnRpY2tCb3JkZXJEYXNoIHx8IFtdO1xuICAgICAgY29uc3QgdGlja0JvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaE9mZnNldDtcbiAgICAgIGxpbmVWYWx1ZSA9IGdldFBpeGVsRm9yR3JpZExpbmUodGhpcywgaSwgb2Zmc2V0KTtcbiAgICAgIGlmIChsaW5lVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB0eDEgPSB0eDIgPSB4MSA9IHgyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5MSA9IHR5MiA9IHkxID0geTIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgfVxuICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgIHR4MSxcbiAgICAgICAgdHkxLFxuICAgICAgICB0eDIsXG4gICAgICAgIHR5MixcbiAgICAgICAgeDEsXG4gICAgICAgIHkxLFxuICAgICAgICB4MixcbiAgICAgICAgeTIsXG4gICAgICAgIHdpZHRoOiBsaW5lV2lkdGgsXG4gICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgIGJvcmRlckRhc2gsXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgdGlja0NvbG9yLFxuICAgICAgICB0aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXQsXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdGlja3NMZW5ndGggPSB0aWNrc0xlbmd0aDtcbiAgICB0aGlzLl9ib3JkZXJWYWx1ZSA9IGJvcmRlclZhbHVlO1xuICAgIHJldHVybiBpdGVtcztcbiAgfVxuICBfY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IG9wdGlvblRpY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3Qge2FsaWduLCBjcm9zc0FsaWduLCBwYWRkaW5nLCBtaXJyb3J9ID0gb3B0aW9uVGlja3M7XG4gICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IGhUaWNrQW5kUGFkZGluZyA9IG1pcnJvciA/IC1wYWRkaW5nIDogdGlja0FuZFBhZGRpbmc7XG4gICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgdGljaywgbGFiZWwsIHgsIHksIHRleHRBbGlnbiwgcGl4ZWwsIGZvbnQsIGxpbmVIZWlnaHQsIGxpbmVDb3VudCwgdGV4dE9mZnNldDtcbiAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgeSA9IHRoaXMuYm90dG9tIC0gaFRpY2tBbmRQYWRkaW5nO1xuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdib3R0b20nKSB7XG4gICAgICB5ID0gdGhpcy50b3AgKyBoVGlja0FuZFBhZGRpbmc7XG4gICAgICB0ZXh0QWxpZ24gPSB0aGlzLl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCk7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICB4ID0gcmV0Lng7XG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgY29uc3QgcmV0ID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCk7XG4gICAgICB0ZXh0QWxpZ24gPSByZXQudGV4dEFsaWduO1xuICAgICAgeCA9IHJldC54O1xuICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHkgPSAoKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIpICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgIHkgPSB0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgIH1cbiAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICB4ID0gKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKSAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgIH1cbiAgICBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICBsYWJlbCA9IHRpY2subGFiZWw7XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IG9wdGlvblRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGkpKTtcbiAgICAgIHBpeGVsID0gdGhpcy5nZXRQaXhlbEZvclRpY2soaSkgKyBvcHRpb25UaWNrcy5sYWJlbE9mZnNldDtcbiAgICAgIGZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgbGluZUhlaWdodCA9IGZvbnQubGluZUhlaWdodDtcbiAgICAgIGxpbmVDb3VudCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IGhhbGZDb3VudCA9IGxpbmVDb3VudCAvIDI7XG4gICAgICBjb25zdCBjb2xvciA9IG9wdHNBdEluZGV4LmNvbG9yO1xuICAgICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VXaWR0aCA9IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aDtcbiAgICAgIGxldCB0aWNrVGV4dEFsaWduID0gdGV4dEFsaWduO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICF0aGlzLm9wdGlvbnMucmV2ZXJzZSA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGluZUNvdW50ICogbGluZUhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1sYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicgfHwgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgPSBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAtIGxpbmVDb3VudCAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICB0ZXh0T2Zmc2V0ICo9IC0xO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5ID0gcGl4ZWw7XG4gICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICAgIGxldCBiYWNrZHJvcDtcbiAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICBjb25zdCBsYWJlbFBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gbGFiZWxTaXplcy5oZWlnaHRzW2ldO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuICAgICAgICBsZXQgdG9wID0geSArIHRleHRPZmZzZXQgLSBsYWJlbFBhZGRpbmcudG9wO1xuICAgICAgICBsZXQgbGVmdCA9IHggLSBsYWJlbFBhZGRpbmcubGVmdDtcbiAgICAgICAgc3dpdGNoICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGV4dEFsaWduKSB7XG4gICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgdG9wLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArIGxhYmVsUGFkZGluZy5oZWlnaHQsXG4gICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3IsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIGxhYmVsLFxuICAgICAgICBmb250LFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc3Ryb2tlQ29sb3IsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICB0ZXh0T2Zmc2V0LFxuICAgICAgICB0ZXh0QWxpZ246IHRpY2tUZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgdHJhbnNsYXRpb246IFt4LCB5XSxcbiAgICAgICAgYmFja2Ryb3AsXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIF9nZXRYQXhpc0xhYmVsQWxpZ25tZW50KCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3N9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gLXRvUmFkaWFucyh0aGlzLmxhYmVsUm90YXRpb24pO1xuICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgfVxuICAgIGxldCBhbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgfSBlbHNlIGlmICh0aWNrcy5hbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHRpY2tzLmFsaWduID09PSAnaW5uZXInKSB7XG4gICAgICBhbGlnbiA9ICdpbm5lcic7XG4gICAgfVxuICAgIHJldHVybiBhbGlnbjtcbiAgfVxuICBfZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkge1xuICAgIGNvbnN0IHtwb3NpdGlvbiwgdGlja3M6IHtjcm9zc0FsaWduLCBtaXJyb3IsIHBhZGRpbmd9fSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgIGNvbnN0IHRpY2tBbmRQYWRkaW5nID0gdGwgKyBwYWRkaW5nO1xuICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgIGxldCB0ZXh0QWxpZ247XG4gICAgbGV0IHg7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgKyBwYWRkaW5nO1xuICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCArPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ICs9IHdpZGVzdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4IC09ICh3aWRlc3QgLyAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgeCA9IHRoaXMubGVmdCArIHBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgICAgeCAtPSAod2lkZXN0IC8gMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgIHggLT0gd2lkZXN0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgIGlmIChjcm9zc0FsaWduID09PSAnbmVhcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICB4ICs9IHdpZGVzdCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgICB4ID0gdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICByZXR1cm4ge3RleHRBbGlnbiwgeH07XG4gIH1cbiAgX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy50aWNrcy5taXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICByZXR1cm4ge3RvcDogMCwgbGVmdDogdGhpcy5sZWZ0LCBib3R0b206IGNoYXJ0LmhlaWdodCwgcmlnaHQ6IHRoaXMucmlnaHR9O1xuICAgIH0gaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiB7dG9wOiB0aGlzLnRvcCwgbGVmdDogMCwgYm90dG9tOiB0aGlzLmJvdHRvbSwgcmlnaHQ6IGNoYXJ0LndpZHRofTtcbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQoKSB7XG4gICAgY29uc3Qge2N0eCwgb3B0aW9uczoge2JhY2tncm91bmRDb2xvcn0sIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodH0gPSB0aGlzO1xuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICFncmlkLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgY29uc3QgaW5kZXggPSB0aWNrcy5maW5kSW5kZXgodCA9PiB0LnZhbHVlID09PSB2YWx1ZSk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgIGNvbnN0IGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBjb25zdCBkcmF3TGluZSA9IChwMSwgcDIsIHN0eWxlKSA9PiB7XG4gICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0eWxlLndpZHRoO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2goc3R5bGUuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhwMS54LCBwMS55KTtcbiAgICAgIGN0eC5saW5lVG8ocDIueCwgcDIueSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgIGRyYXdMaW5lKFxuICAgICAgICAgICAge3g6IGl0ZW0ueDEsIHk6IGl0ZW0ueTF9LFxuICAgICAgICAgICAge3g6IGl0ZW0ueDIsIHk6IGl0ZW0ueTJ9LFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgZHJhd0xpbmUoXG4gICAgICAgICAgICB7eDogaXRlbS50eDEsIHk6IGl0ZW0udHkxfSxcbiAgICAgICAgICAgIHt4OiBpdGVtLnR4MiwgeTogaXRlbS50eTJ9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgIHdpZHRoOiBpdGVtLnRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaDogaXRlbS50aWNrQm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JvcmRlcigpIHtcbiAgICBjb25zdCB7Y2hhcnQsIGN0eCwgb3B0aW9uczoge2dyaWR9fSA9IHRoaXM7XG4gICAgY29uc3QgYm9yZGVyT3B0cyA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYXhpc1dpZHRoID0gZ3JpZC5kcmF3Qm9yZGVyID8gYm9yZGVyT3B0cy5ib3JkZXJXaWR0aCA6IDA7XG4gICAgaWYgKCFheGlzV2lkdGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICBjb25zdCBib3JkZXJWYWx1ZSA9IHRoaXMuX2JvcmRlclZhbHVlO1xuICAgIGxldCB4MSwgeDIsIHkxLCB5MjtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkxID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMudG9wLCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgIHkyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMuYm90dG9tLCBsYXN0TGluZVdpZHRoKSArIGxhc3RMaW5lV2lkdGggLyAyO1xuICAgICAgeDEgPSB4MiA9IGJvcmRlclZhbHVlO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJPcHRzLmJvcmRlcldpZHRoO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGJvcmRlck9wdHMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd0xhYmVscyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBpZiAoIW9wdGlvblRpY2tzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuX2NvbXB1dGVMYWJlbEFyZWEoKTtcbiAgICBpZiAoYXJlYSkge1xuICAgICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9sYWJlbEl0ZW1zIHx8ICh0aGlzLl9sYWJlbEl0ZW1zID0gdGhpcy5fY29tcHV0ZUxhYmVsSXRlbXMoY2hhcnRBcmVhKSk7XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgdGlja0ZvbnQgPSBpdGVtLmZvbnQ7XG4gICAgICBjb25zdCBsYWJlbCA9IGl0ZW0ubGFiZWw7XG4gICAgICBpZiAoaXRlbS5iYWNrZHJvcCkge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gaXRlbS5iYWNrZHJvcC5jb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGl0ZW0uYmFja2Ryb3AubGVmdCwgaXRlbS5iYWNrZHJvcC50b3AsIGl0ZW0uYmFja2Ryb3Aud2lkdGgsIGl0ZW0uYmFja2Ryb3AuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGxldCB5ID0gaXRlbS50ZXh0T2Zmc2V0O1xuICAgICAgcmVuZGVyVGV4dChjdHgsIGxhYmVsLCAwLCB5LCB0aWNrRm9udCwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChhcmVhKSB7XG4gICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCB7Y3R4LCBvcHRpb25zOiB7cG9zaXRpb24sIHRpdGxlLCByZXZlcnNlfX0gPSB0aGlzO1xuICAgIGlmICghdGl0bGUuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250ID0gdG9Gb250KHRpdGxlLmZvbnQpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGUucGFkZGluZyk7XG4gICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICBsZXQgb2Zmc2V0ID0gZm9udC5saW5lSGVpZ2h0IC8gMjtcbiAgICBpZiAocG9zaXRpb24gPT09ICdib3R0b20nIHx8IHBvc2l0aW9uID09PSAnY2VudGVyJyB8fCBpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgIG9mZnNldCArPSBwYWRkaW5nLmJvdHRvbTtcbiAgICAgIGlmIChpc0FycmF5KHRpdGxlLnRleHQpKSB7XG4gICAgICAgIG9mZnNldCArPSBmb250LmxpbmVIZWlnaHQgKiAodGl0bGUudGV4dC5sZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcudG9wO1xuICAgIH1cbiAgICBjb25zdCB7dGl0bGVYLCB0aXRsZVksIG1heFdpZHRoLCByb3RhdGlvbn0gPSB0aXRsZUFyZ3ModGhpcywgb2Zmc2V0LCBwb3NpdGlvbiwgYWxpZ24pO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZS50ZXh0LCAwLCAwLCBmb250LCB7XG4gICAgICBjb2xvcjogdGl0bGUuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiB0aXRsZUFsaWduKGFsaWduLCBwb3NpdGlvbiwgcmV2ZXJzZSksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbiAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgdGhpcy5kcmF3VGl0bGUoKTtcbiAgICB0aGlzLmRyYXdMYWJlbHMoY2hhcnRBcmVhKTtcbiAgfVxuICBfbGF5ZXJzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdHogPSBvcHRzLnRpY2tzICYmIG9wdHMudGlja3MueiB8fCAwO1xuICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgaWYgKCF0aGlzLl9pc1Zpc2libGUoKSB8fCB0aGlzLmRyYXcgIT09IFNjYWxlLnByb3RvdHlwZS5kcmF3KSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogdHosXG4gICAgICAgIGRyYXc6IChjaGFydEFyZWEpID0+IHtcbiAgICAgICAgICB0aGlzLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBbe1xuICAgICAgejogZ3osXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0JhY2tncm91bmQoKTtcbiAgICAgICAgdGhpcy5kcmF3R3JpZChjaGFydEFyZWEpO1xuICAgICAgICB0aGlzLmRyYXdUaXRsZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIHo6IGd6ICsgMSxcbiAgICAgIGRyYXc6ICgpID0+IHtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgejogdHosXG4gICAgICBkcmF3OiAoY2hhcnRBcmVhKSA9PiB7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgfVxuICAgIH1dO1xuICB9XG4gIGdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKHR5cGUpIHtcbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGNvbnN0IGF4aXNJRCA9IHRoaXMuYXhpcyArICdBeGlzSUQnO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgIGlmIChtZXRhW2F4aXNJRF0gPT09IHRoaXMuaWQgJiYgKCF0eXBlIHx8IG1ldGEudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoaW5kZXgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICB9XG4gIF9tYXhEaWdpdHMoKSB7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLmxpbmVIZWlnaHQ7XG4gICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICB9XG59XG5cbmNsYXNzIFR5cGVkUmVnaXN0cnkge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBzY29wZSwgb3ZlcnJpZGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgdGhpcy5pdGVtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgaXNGb3JUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICB9XG4gIHJlZ2lzdGVyKGl0ZW0pIHtcbiAgICBjb25zdCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihpdGVtKTtcbiAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgaWYgKGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSkge1xuICAgICAgcGFyZW50U2NvcGUgPSB0aGlzLnJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGUgKyAnLicgKyBpZDtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICB9XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGl0ZW1zW2lkXSA9IGl0ZW07XG4gICAgcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpO1xuICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtc1tpZF07XG4gIH1cbiAgdW5yZWdpc3RlcihpdGVtKSB7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgIGNvbnN0IGlkID0gaXRlbS5pZDtcbiAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgIH1cbiAgICBpZiAoc2NvcGUgJiYgaWQgaW4gZGVmYXVsdHNbc2NvcGVdKSB7XG4gICAgICBkZWxldGUgZGVmYXVsdHNbc2NvcGVdW2lkXTtcbiAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXNbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0cyhpdGVtLCBzY29wZSwgcGFyZW50U2NvcGUpIHtcbiAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgIHBhcmVudFNjb3BlID8gZGVmYXVsdHMuZ2V0KHBhcmVudFNjb3BlKSA6IHt9LFxuICAgIGRlZmF1bHRzLmdldChzY29wZSksXG4gICAgaXRlbS5kZWZhdWx0c1xuICBdKTtcbiAgZGVmYXVsdHMuc2V0KHNjb3BlLCBpdGVtRGVmYXVsdHMpO1xuICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgcm91dGVEZWZhdWx0cyhzY29wZSwgaXRlbS5kZWZhdWx0Um91dGVzKTtcbiAgfVxuICBpZiAoaXRlbS5kZXNjcmlwdG9ycykge1xuICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgfVxufVxuZnVuY3Rpb24gcm91dGVEZWZhdWx0cyhzY29wZSwgcm91dGVzKSB7XG4gIE9iamVjdC5rZXlzKHJvdXRlcykuZm9yRWFjaChwcm9wZXJ0eSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlQYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgY29uc3Qgc291cmNlU2NvcGUgPSBbc2NvcGVdLmNvbmNhdChwcm9wZXJ0eVBhcnRzKS5qb2luKCcuJyk7XG4gICAgY29uc3QgcGFydHMgPSByb3V0ZXNbcHJvcGVydHldLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlID0gcGFydHMuam9pbignLicpO1xuICAgIGRlZmF1bHRzLnJvdXRlKHNvdXJjZVNjb3BlLCBzb3VyY2VOYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaXNJQ2hhcnRDb21wb25lbnQocHJvdG8pIHtcbiAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXJzID0gbmV3IFR5cGVkUmVnaXN0cnkoRGF0YXNldENvbnRyb2xsZXIsICdkYXRhc2V0cycsIHRydWUpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBuZXcgVHlwZWRSZWdpc3RyeShPYmplY3QsICdwbHVnaW5zJyk7XG4gICAgdGhpcy5zY2FsZXMgPSBuZXcgVHlwZWRSZWdpc3RyeShTY2FsZSwgJ3NjYWxlcycpO1xuICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFt0aGlzLmNvbnRyb2xsZXJzLCB0aGlzLnNjYWxlcywgdGhpcy5lbGVtZW50c107XG4gIH1cbiAgYWRkKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIHJlbW92ZSguLi5hcmdzKSB7XG4gICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICB9XG4gIGFkZENvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuY29udHJvbGxlcnMpO1xuICB9XG4gIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCdyZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICB9XG4gIGFkZFBsdWdpbnMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICBhZGRTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5zY2FsZXMpO1xuICB9XG4gIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmNvbnRyb2xsZXJzLCAnY29udHJvbGxlcicpO1xuICB9XG4gIGdldEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICB9XG4gIGdldFBsdWdpbihpZCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMucGx1Z2lucywgJ3BsdWdpbicpO1xuICB9XG4gIGdldFNjYWxlKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5zY2FsZXMsICdzY2FsZScpO1xuICB9XG4gIHJlbW92ZUNvbnRyb2xsZXJzKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudHMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgfVxuICByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgfVxuICByZW1vdmVTY2FsZXMoLi4uYXJncykge1xuICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gIH1cbiAgX2VhY2gobWV0aG9kLCBhcmdzLCB0eXBlZFJlZ2lzdHJ5KSB7XG4gICAgWy4uLmFyZ3NdLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGNvbnN0IHJlZyA9IHR5cGVkUmVnaXN0cnkgfHwgdGhpcy5fZ2V0UmVnaXN0cnlGb3JUeXBlKGFyZyk7XG4gICAgICBpZiAodHlwZWRSZWdpc3RyeSB8fCByZWcuaXNGb3JUeXBlKGFyZykgfHwgKHJlZyA9PT0gdGhpcy5wbHVnaW5zICYmIGFyZy5pZCkpIHtcbiAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIHJlZywgYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVhY2goYXJnLCBpdGVtID0+IHtcbiAgICAgICAgICBjb25zdCBpdGVtUmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoaXRlbSk7XG4gICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZXhlYyhtZXRob2QsIHJlZ2lzdHJ5LCBjb21wb25lbnQpIHtcbiAgICBjb25zdCBjYW1lbE1ldGhvZCA9IF9jYXBpdGFsaXplKG1ldGhvZCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICByZWdpc3RyeVttZXRob2RdKGNvbXBvbmVudCk7XG4gICAgY2FsbGJhY2soY29tcG9uZW50WydhZnRlcicgKyBjYW1lbE1ldGhvZF0sIFtdLCBjb21wb25lbnQpO1xuICB9XG4gIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByZWcgPSB0aGlzLl90eXBlZFJlZ2lzdHJpZXNbaV07XG4gICAgICBpZiAocmVnLmlzRm9yVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gcmVnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICB9XG4gIF9nZXQoaWQsIHR5cGVkUmVnaXN0cnksIHR5cGUpIHtcbiAgICBjb25zdCBpdGVtID0gdHlwZWRSZWdpc3RyeS5nZXQoaWQpO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtO1xuICB9XG59XG52YXIgcmVnaXN0cnkgPSBuZXcgUmVnaXN0cnkoKTtcblxuY2xhc3MgU2NhdHRlckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gIHVwZGF0ZShtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3Qge2RhdGE6IHBvaW50cyA9IFtdfSA9IG1ldGE7XG4gICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLl9kcmF3Q291bnQgPSBjb3VudDtcbiAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgc3RhcnQgPSAwO1xuICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnNob3dMaW5lKSB7XG4gICAgICBjb25zdCB7ZGF0YXNldDogbGluZSwgX2RhdGFzZXR9ID0gbWV0YTtcbiAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgYW5pbWF0ZWQ6ICFhbmltYXRpb25zRGlzYWJsZWQsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKTtcbiAgfVxuICBhZGRFbGVtZW50cygpIHtcbiAgICBjb25zdCB7c2hvd0xpbmV9ID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICghdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUgJiYgc2hvd0xpbmUpIHtcbiAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gcmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgIH1cbiAgICBzdXBlci5hZGRFbGVtZW50cygpO1xuICB9XG4gIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgIGNvbnN0IHtpU2NhbGUsIHZTY2FsZSwgX3N0YWNrZWQsIF9kYXRhc2V0fSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICBjb25zdCBzaGFyZWRPcHRpb25zID0gdGhpcy5nZXRTaGFyZWRPcHRpb25zKGZpcnN0T3B0cyk7XG4gICAgY29uc3QgaW5jbHVkZU9wdGlvbnMgPSB0aGlzLmluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpO1xuICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICBjb25zdCB7c3BhbkdhcHMsIHNlZ21lbnR9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IG1heEdhcExlbmd0aCA9IGlzTnVtYmVyKHNwYW5HYXBzKSA/IHNwYW5HYXBzIDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGNvbnN0IGRpcmVjdFVwZGF0ZSA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZCB8fCByZXNldCB8fCBtb2RlID09PSAnbm9uZSc7XG4gICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaSk7XG4gICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZGlyZWN0VXBkYXRlID8gcG9pbnQgOiB7fTtcbiAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgKE1hdGguYWJzKHBhcnNlZFtpQXhpc10gLSBwcmV2UGFyc2VkW2lBeGlzXSkpID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIHByb3BlcnRpZXMucmF3ID0gX2RhdGFzZXQuZGF0YVtpXTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgIH1cbiAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICB9XG4gIGdldE1heE92ZXJmbG93KCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgIGxldCBtYXggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1heCA+IDAgJiYgbWF4O1xuICAgIH1cbiAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgIGNvbnN0IGJvcmRlciA9IGRhdGFzZXQub3B0aW9ucyAmJiBkYXRhc2V0Lm9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYm9yZGVyO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBvaW50ID0gZGF0YVswXS5zaXplKHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucygwKSk7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICB9XG59XG5TY2F0dGVyQ29udHJvbGxlci5pZCA9ICdzY2F0dGVyJztcblNjYXR0ZXJDb250cm9sbGVyLmRlZmF1bHRzID0ge1xuICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gIHNob3dMaW5lOiBmYWxzZSxcbiAgZmlsbDogZmFsc2Vcbn07XG5TY2F0dGVyQ29udHJvbGxlci5vdmVycmlkZXMgPSB7XG4gIGludGVyYWN0aW9uOiB7XG4gICAgbW9kZTogJ3BvaW50J1xuICB9LFxuICBwbHVnaW5zOiB7XG4gICAgdG9vbHRpcDoge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIHRpdGxlKCkge1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWwoaXRlbSkge1xuICAgICAgICAgIHJldHVybiAnKCcgKyBpdGVtLmxhYmVsICsgJywgJyArIGl0ZW0uZm9ybWF0dGVkVmFsdWUgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYWxlczoge1xuICAgIHg6IHtcbiAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB0eXBlOiAnbGluZWFyJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbnRyb2xsZXJzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQmFyQ29udHJvbGxlcjogQmFyQ29udHJvbGxlcixcbkJ1YmJsZUNvbnRyb2xsZXI6IEJ1YmJsZUNvbnRyb2xsZXIsXG5Eb3VnaG51dENvbnRyb2xsZXI6IERvdWdobnV0Q29udHJvbGxlcixcbkxpbmVDb250cm9sbGVyOiBMaW5lQ29udHJvbGxlcixcblBvbGFyQXJlYUNvbnRyb2xsZXI6IFBvbGFyQXJlYUNvbnRyb2xsZXIsXG5QaWVDb250cm9sbGVyOiBQaWVDb250cm9sbGVyLFxuUmFkYXJDb250cm9sbGVyOiBSYWRhckNvbnRyb2xsZXIsXG5TY2F0dGVyQ29udHJvbGxlcjogU2NhdHRlckNvbnRyb2xsZXJcbn0pO1xuXG5mdW5jdGlvbiBhYnN0cmFjdCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQ6IENoZWNrIHRoYXQgYSBjb21wbGV0ZSBkYXRlIGFkYXB0ZXIgaXMgcHJvdmlkZWQuJyk7XG59XG5jbGFzcyBEYXRlQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB9XG4gIGluaXQoY2hhcnRPcHRpb25zKSB7fVxuICBmb3JtYXRzKCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIHBhcnNlKHZhbHVlLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBmb3JtYXQodGltZXN0YW1wLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBhZGQodGltZXN0YW1wLCBhbW91bnQsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBkaWZmKGEsIGIsIHVuaXQpIHtcbiAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgfVxuICBzdGFydE9mKHRpbWVzdGFtcCwgdW5pdCwgd2Vla2RheSkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG4gIGVuZE9mKHRpbWVzdGFtcCwgdW5pdCkge1xuICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICB9XG59XG5EYXRlQWRhcHRlci5vdmVycmlkZSA9IGZ1bmN0aW9uKG1lbWJlcnMpIHtcbiAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlci5wcm90b3R5cGUsIG1lbWJlcnMpO1xufTtcbnZhciBhZGFwdGVycyA9IHtcbiAgX2RhdGU6IERhdGVBZGFwdGVyXG59O1xuXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICBjb25zdCB7Y29udHJvbGxlciwgZGF0YSwgX3NvcnRlZH0gPSBtZXRhc2V0O1xuICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgaWYgKGlTY2FsZSAmJiBheGlzID09PSBpU2NhbGUuYXhpcyAmJiBheGlzICE9PSAncicgJiYgX3NvcnRlZCAmJiBkYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgaWYgKCFpbnRlcnNlY3QpIHtcbiAgICAgIHJldHVybiBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoY29udHJvbGxlci5fc2hhcmVkT3B0aW9ucykge1xuICAgICAgY29uc3QgZWwgPSBkYXRhWzBdO1xuICAgICAgY29uc3QgcmFuZ2UgPSB0eXBlb2YgZWwuZ2V0UmFuZ2UgPT09ICdmdW5jdGlvbicgJiYgZWwuZ2V0UmFuZ2UoYXhpcyk7XG4gICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUgLSByYW5nZSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtsbzogc3RhcnQubG8sIGhpOiBlbmQuaGl9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4ge2xvOiAwLCBoaTogZGF0YS5sZW5ndGggLSAxfTtcbn1cbmZ1bmN0aW9uIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGhhbmRsZXIsIGludGVyc2VjdCkge1xuICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltheGlzXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBjb25zdCB7aW5kZXgsIGRhdGF9ID0gbWV0YXNldHNbaV07XG4gICAgY29uc3Qge2xvLCBoaX0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgIGZvciAobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZGF0YVtqXTtcbiAgICAgIGlmICghZWxlbWVudC5za2lwKSB7XG4gICAgICAgIGhhbmRsZXIoZWxlbWVudCwgaW5kZXgsIGopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpIHtcbiAgY29uc3QgdXNlWCA9IGF4aXMuaW5kZXhPZigneCcpICE9PSAtMTtcbiAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKHB0MSwgcHQyKSB7XG4gICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICBjb25zdCBkZWx0YVkgPSB1c2VZID8gTWF0aC5hYnMocHQxLnkgLSBwdDIueSkgOiAwO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZGVsdGFYLCAyKSArIE1hdGgucG93KGRlbHRhWSwgMikpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICByZXR1cm4gaXRlbXM7XG4gIH1cbiAgY29uc3QgZXZhbHVhdGlvbkZ1bmMgPSBmdW5jdGlvbihlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH07XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jLCB0cnVlKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBsZXQgaXRlbXMgPSBbXTtcbiAgZnVuY3Rpb24gZXZhbHVhdGlvbkZ1bmMoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgIGNvbnN0IHtzdGFydEFuZ2xlLCBlbmRBbmdsZX0gPSBlbGVtZW50LmdldFByb3BzKFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCB7YW5nbGV9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge3g6IHBvc2l0aW9uLngsIHk6IHBvc2l0aW9uLnl9KTtcbiAgICBpZiAoX2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpKSB7XG4gICAgICBpdGVtcy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSk7XG4gICAgfVxuICB9XG4gIGV2YWx1YXRlSW50ZXJhY3Rpb25JdGVtcyhjaGFydCwgYXhpcywgcG9zaXRpb24sIGV2YWx1YXRpb25GdW5jKTtcbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKSB7XG4gIGxldCBpdGVtcyA9IFtdO1xuICBjb25zdCBkaXN0YW5jZU1ldHJpYyA9IGdldERpc3RhbmNlTWV0cmljRm9yQXhpcyhheGlzKTtcbiAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgY29uc3QgaW5SYW5nZSA9IGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpblJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNlbnRlciA9IGVsZW1lbnQuZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgcG9pbnRJbkFyZWEgPSAhIWluY2x1ZGVJbnZpc2libGUgfHwgY2hhcnQuaXNQb2ludEluQXJlYShjZW50ZXIpO1xuICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGlzdGFuY2UgPSBkaXN0YW5jZU1ldHJpYyhwb3NpdGlvbiwgY2VudGVyKTtcbiAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgaXRlbXMgPSBbe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9XTtcbiAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgfSBlbHNlIGlmIChkaXN0YW5jZSA9PT0gbWluRGlzdGFuY2UpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICB9XG4gIH1cbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFjaGFydC5pc1BvaW50SW5BcmVhKHBvc2l0aW9uKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gYXhpcyA9PT0gJ3InICYmICFpbnRlcnNlY3RcbiAgICA/IGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pXG4gICAgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0l0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHJhbmdlTWV0aG9kID0gYXhpcyA9PT0gJ3gnID8gJ2luWFJhbmdlJyA6ICdpbllSYW5nZSc7XG4gIGxldCBpbnRlcnNlY3RzSXRlbSA9IGZhbHNlO1xuICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkgPT4ge1xuICAgIGlmIChlbGVtZW50W3JhbmdlTWV0aG9kXShwb3NpdGlvbltheGlzXSwgdXNlRmluYWxQb3NpdGlvbikpIHtcbiAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXh9KTtcbiAgICAgIGludGVyc2VjdHNJdGVtID0gaW50ZXJzZWN0c0l0ZW0gfHwgZWxlbWVudC5pblJhbmdlKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgfSk7XG4gIGlmIChpbnRlcnNlY3QgJiYgIWludGVyc2VjdHNJdGVtKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBpdGVtcztcbn1cbnZhciBJbnRlcmFjdGlvbiA9IHtcbiAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuICBtb2Rlczoge1xuICAgIGluZGV4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSlcbiAgICAgICAgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmZvckVhY2goKG1ldGEpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBpdGVtc1swXS5pbmRleDtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IG1ldGEuZGF0YVtpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKHtlbGVtZW50LCBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXgsIGluZGV4fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGVsZW1lbnRzO1xuICAgIH0sXG4gICAgZGF0YXNldChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICBsZXQgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdFxuICAgICAgICA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOlxuICAgICAgICBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmRhdGE7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGl0ZW1zLnB1c2goe2VsZW1lbnQ6IGRhdGFbaV0sIGRhdGFzZXRJbmRleCwgaW5kZXg6IGl9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH0sXG4gICAgcG9pbnQoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgcmV0dXJuIGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICBuZWFyZXN0KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneHknO1xuICAgICAgY29uc3QgaW5jbHVkZUludmlzaWJsZSA9IG9wdGlvbnMuaW5jbHVkZUludmlzaWJsZSB8fCBmYWxzZTtcbiAgICAgIHJldHVybiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBvcHRpb25zLmludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgfSxcbiAgICB4KGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH0sXG4gICAgeShjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgIHJldHVybiBnZXRBeGlzSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCAneScsIG9wdGlvbnMuaW50ZXJzZWN0LCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IFNUQVRJQ19QT1NJVElPTlMgPSBbJ2xlZnQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbSddO1xuZnVuY3Rpb24gZmlsdGVyQnlQb3NpdGlvbihhcnJheSwgcG9zaXRpb24pIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IHYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcih2ID0+IFNUQVRJQ19QT1NJVElPTlMuaW5kZXhPZih2LnBvcykgPT09IC0xICYmIHYuYm94LmF4aXMgPT09IGF4aXMpO1xufVxuZnVuY3Rpb24gc29ydEJ5V2VpZ2h0KGFycmF5LCByZXZlcnNlKSB7XG4gIHJldHVybiBhcnJheS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgY29uc3QgdjEgPSByZXZlcnNlID8gYSA6IGI7XG4gICAgcmV0dXJuIHYwLndlaWdodCA9PT0gdjEud2VpZ2h0ID9cbiAgICAgIHYwLmluZGV4IC0gdjEuaW5kZXggOlxuICAgICAgdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIHdyYXBCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgZm9yIChpID0gMCwgaWxlbiA9IChib3hlcyB8fCBbXSkubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgYm94ID0gYm94ZXNbaV07XG4gICAgKHtwb3NpdGlvbjogcG9zLCBvcHRpb25zOiB7c3RhY2ssIHN0YWNrV2VpZ2h0ID0gMX19ID0gYm94KTtcbiAgICBsYXlvdXRCb3hlcy5wdXNoKHtcbiAgICAgIGluZGV4OiBpLFxuICAgICAgYm94LFxuICAgICAgcG9zLFxuICAgICAgaG9yaXpvbnRhbDogYm94LmlzSG9yaXpvbnRhbCgpLFxuICAgICAgd2VpZ2h0OiBib3gud2VpZ2h0LFxuICAgICAgc3RhY2s6IHN0YWNrICYmIChwb3MgKyBzdGFjayksXG4gICAgICBzdGFja1dlaWdodFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBsYXlvdXRCb3hlcztcbn1cbmZ1bmN0aW9uIGJ1aWxkU3RhY2tzKGxheW91dHMpIHtcbiAgY29uc3Qgc3RhY2tzID0ge307XG4gIGZvciAoY29uc3Qgd3JhcCBvZiBsYXlvdXRzKSB7XG4gICAgY29uc3Qge3N0YWNrLCBwb3MsIHN0YWNrV2VpZ2h0fSA9IHdyYXA7XG4gICAgaWYgKCFzdGFjayB8fCAhU1RBVElDX1BPU0lUSU9OUy5pbmNsdWRlcyhwb3MpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgX3N0YWNrID0gc3RhY2tzW3N0YWNrXSB8fCAoc3RhY2tzW3N0YWNrXSA9IHtjb3VudDogMCwgcGxhY2VkOiAwLCB3ZWlnaHQ6IDAsIHNpemU6IDB9KTtcbiAgICBfc3RhY2suY291bnQrKztcbiAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICB9XG4gIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBzZXRMYXlvdXREaW1zKGxheW91dHMsIHBhcmFtcykge1xuICBjb25zdCBzdGFja3MgPSBidWlsZFN0YWNrcyhsYXlvdXRzKTtcbiAgY29uc3Qge3ZCb3hNYXhXaWR0aCwgaEJveE1heEhlaWdodH0gPSBwYXJhbXM7XG4gIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBsYXlvdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgIGxheW91dCA9IGxheW91dHNbaV07XG4gICAgY29uc3Qge2Z1bGxTaXplfSA9IGxheW91dC5ib3g7XG4gICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICBjb25zdCBmYWN0b3IgPSBzdGFjayAmJiBsYXlvdXQuc3RhY2tXZWlnaHQgLyBzdGFjay53ZWlnaHQ7XG4gICAgaWYgKGxheW91dC5ob3Jpem9udGFsKSB7XG4gICAgICBsYXlvdXQud2lkdGggPSBmYWN0b3IgPyBmYWN0b3IgKiB2Qm94TWF4V2lkdGggOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlV2lkdGg7XG4gICAgICBsYXlvdXQuaGVpZ2h0ID0gaEJveE1heEhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhY2tzO1xufVxuZnVuY3Rpb24gYnVpbGRMYXlvdXRCb3hlcyhib3hlcykge1xuICBjb25zdCBsYXlvdXRCb3hlcyA9IHdyYXBCb3hlcyhib3hlcyk7XG4gIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcih3cmFwID0+IHdyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gIGNvbnN0IGxlZnQgPSBzb3J0QnlXZWlnaHQoZmlsdGVyQnlQb3NpdGlvbihsYXlvdXRCb3hlcywgJ2xlZnQnKSwgdHJ1ZSk7XG4gIGNvbnN0IHJpZ2h0ID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdyaWdodCcpKTtcbiAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gIGNvbnN0IGJvdHRvbSA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnYm90dG9tJykpO1xuICBjb25zdCBjZW50ZXJIb3Jpem9udGFsID0gZmlsdGVyRHluYW1pY1Bvc2l0aW9uQnlBeGlzKGxheW91dEJveGVzLCAneCcpO1xuICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgcmV0dXJuIHtcbiAgICBmdWxsU2l6ZSxcbiAgICBsZWZ0QW5kVG9wOiBsZWZ0LmNvbmNhdCh0b3ApLFxuICAgIHJpZ2h0QW5kQm90dG9tOiByaWdodC5jb25jYXQoY2VudGVyVmVydGljYWwpLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKSxcbiAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICB2ZXJ0aWNhbDogbGVmdC5jb25jYXQocmlnaHQpLmNvbmNhdChjZW50ZXJWZXJ0aWNhbCksXG4gICAgaG9yaXpvbnRhbDogdG9wLmNvbmNhdChib3R0b20pLmNvbmNhdChjZW50ZXJIb3Jpem9udGFsKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCBhLCBiKSB7XG4gIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICBtYXhQYWRkaW5nLnRvcCA9IE1hdGgubWF4KG1heFBhZGRpbmcudG9wLCBib3hQYWRkaW5nLnRvcCk7XG4gIG1heFBhZGRpbmcubGVmdCA9IE1hdGgubWF4KG1heFBhZGRpbmcubGVmdCwgYm94UGFkZGluZy5sZWZ0KTtcbiAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICBtYXhQYWRkaW5nLnJpZ2h0ID0gTWF0aC5tYXgobWF4UGFkZGluZy5yaWdodCwgYm94UGFkZGluZy5yaWdodCk7XG59XG5mdW5jdGlvbiB1cGRhdGVEaW1zKGNoYXJ0QXJlYSwgcGFyYW1zLCBsYXlvdXQsIHN0YWNrcykge1xuICBjb25zdCB7cG9zLCBib3h9ID0gbGF5b3V0O1xuICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgIGlmIChsYXlvdXQuc2l6ZSkge1xuICAgICAgY2hhcnRBcmVhW3Bvc10gLT0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge3NpemU6IDAsIGNvdW50OiAxfTtcbiAgICBzdGFjay5zaXplID0gTWF0aC5tYXgoc3RhY2suc2l6ZSwgbGF5b3V0Lmhvcml6b250YWwgPyBib3guaGVpZ2h0IDogYm94LndpZHRoKTtcbiAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBsYXlvdXQuc2l6ZTtcbiAgfVxuICBpZiAoYm94LmdldFBhZGRpbmcpIHtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICB9XG4gIGNvbnN0IG5ld1dpZHRoID0gTWF0aC5tYXgoMCwgcGFyYW1zLm91dGVyV2lkdGggLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICdsZWZ0JywgJ3JpZ2h0JykpO1xuICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICBjb25zdCB3aWR0aENoYW5nZWQgPSBuZXdXaWR0aCAhPT0gY2hhcnRBcmVhLnc7XG4gIGNvbnN0IGhlaWdodENoYW5nZWQgPSBuZXdIZWlnaHQgIT09IGNoYXJ0QXJlYS5oO1xuICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICBjaGFydEFyZWEuaCA9IG5ld0hlaWdodDtcbiAgcmV0dXJuIGxheW91dC5ob3Jpem9udGFsXG4gICAgPyB7c2FtZTogd2lkdGhDaGFuZ2VkLCBvdGhlcjogaGVpZ2h0Q2hhbmdlZH1cbiAgICA6IHtzYW1lOiBoZWlnaHRDaGFuZ2VkLCBvdGhlcjogd2lkdGhDaGFuZ2VkfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZU1heFBhZGRpbmcoY2hhcnRBcmVhKSB7XG4gIGNvbnN0IG1heFBhZGRpbmcgPSBjaGFydEFyZWEubWF4UGFkZGluZztcbiAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgIGNvbnN0IGNoYW5nZSA9IE1hdGgubWF4KG1heFBhZGRpbmdbcG9zXSAtIGNoYXJ0QXJlYVtwb3NdLCAwKTtcbiAgICBjaGFydEFyZWFbcG9zXSArPSBjaGFuZ2U7XG4gICAgcmV0dXJuIGNoYW5nZTtcbiAgfVxuICBjaGFydEFyZWEueSArPSB1cGRhdGVQb3MoJ3RvcCcpO1xuICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgdXBkYXRlUG9zKCdyaWdodCcpO1xuICB1cGRhdGVQb3MoJ2JvdHRvbScpO1xufVxuZnVuY3Rpb24gZ2V0TWFyZ2lucyhob3Jpem9udGFsLCBjaGFydEFyZWEpIHtcbiAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICBmdW5jdGlvbiBtYXJnaW5Gb3JQb3NpdGlvbnMocG9zaXRpb25zKSB7XG4gICAgY29uc3QgbWFyZ2luID0ge2xlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMH07XG4gICAgcG9zaXRpb25zLmZvckVhY2goKHBvcykgPT4ge1xuICAgICAgbWFyZ2luW3Bvc10gPSBNYXRoLm1heChjaGFydEFyZWFbcG9zXSwgbWF4UGFkZGluZ1twb3NdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbWFyZ2luO1xuICB9XG4gIHJldHVybiBob3Jpem9udGFsXG4gICAgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoWydsZWZ0JywgJ3JpZ2h0J10pXG4gICAgOiBtYXJnaW5Gb3JQb3NpdGlvbnMoWyd0b3AnLCAnYm90dG9tJ10pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgcmVmaXRCb3hlcyA9IFtdO1xuICBsZXQgaSwgaWxlbiwgbGF5b3V0LCBib3gsIHJlZml0LCBjaGFuZ2VkO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gYm94ZXMubGVuZ3RoLCByZWZpdCA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYXlvdXQgPSBib3hlc1tpXTtcbiAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgIGJveC51cGRhdGUoXG4gICAgICBsYXlvdXQud2lkdGggfHwgY2hhcnRBcmVhLncsXG4gICAgICBsYXlvdXQuaGVpZ2h0IHx8IGNoYXJ0QXJlYS5oLFxuICAgICAgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKVxuICAgICk7XG4gICAgY29uc3Qge3NhbWUsIG90aGVyfSA9IHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKTtcbiAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkIHx8IG90aGVyO1xuICAgIGlmICghYm94LmZ1bGxTaXplKSB7XG4gICAgICByZWZpdEJveGVzLnB1c2gobGF5b3V0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlZml0ICYmIGZpdEJveGVzKHJlZml0Qm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHx8IGNoYW5nZWQ7XG59XG5mdW5jdGlvbiBzZXRCb3hEaW1zKGJveCwgbGVmdCwgdG9wLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGJveC50b3AgPSB0b3A7XG4gIGJveC5sZWZ0ID0gbGVmdDtcbiAgYm94LnJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICBib3gud2lkdGggPSB3aWR0aDtcbiAgYm94LmhlaWdodCA9IGhlaWdodDtcbn1cbmZ1bmN0aW9uIHBsYWNlQm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgbGV0IHt4LCB5fSA9IGNoYXJ0QXJlYTtcbiAgZm9yIChjb25zdCBsYXlvdXQgb2YgYm94ZXMpIHtcbiAgICBjb25zdCBib3ggPSBsYXlvdXQuYm94O1xuICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge2NvdW50OiAxLCBwbGFjZWQ6IDAsIHdlaWdodDogMX07XG4gICAgY29uc3Qgd2VpZ2h0ID0gKGxheW91dC5zdGFja1dlaWdodCAvIHN0YWNrLndlaWdodCkgfHwgMTtcbiAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gY2hhcnRBcmVhLncgKiB3ZWlnaHQ7XG4gICAgICBjb25zdCBoZWlnaHQgPSBzdGFjay5zaXplIHx8IGJveC5oZWlnaHQ7XG4gICAgICBpZiAoZGVmaW5lZChzdGFjay5zdGFydCkpIHtcbiAgICAgICAgeSA9IHN0YWNrLnN0YXJ0O1xuICAgICAgfVxuICAgICAgaWYgKGJveC5mdWxsU2l6ZSkge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRCb3hEaW1zKGJveCwgY2hhcnRBcmVhLmxlZnQgKyBzdGFjay5wbGFjZWQsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB5O1xuICAgICAgc3RhY2sucGxhY2VkICs9IHdpZHRoO1xuICAgICAgeSA9IGJveC5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICB4ID0gc3RhY2suc3RhcnQ7XG4gICAgICB9XG4gICAgICBpZiAoYm94LmZ1bGxTaXplKSB7XG4gICAgICAgIHNldEJveERpbXMoYm94LCB4LCB1c2VyUGFkZGluZy50b3AsIHdpZHRoLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSB1c2VyUGFkZGluZy5ib3R0b20gLSB1c2VyUGFkZGluZy50b3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgfVxuICB9XG4gIGNoYXJ0QXJlYS54ID0geDtcbiAgY2hhcnRBcmVhLnkgPSB5O1xufVxuZGVmYXVsdHMuc2V0KCdsYXlvdXQnLCB7XG4gIGF1dG9QYWRkaW5nOiB0cnVlLFxuICBwYWRkaW5nOiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH1cbn0pO1xudmFyIGxheW91dHMgPSB7XG4gIGFkZEJveChjaGFydCwgaXRlbSkge1xuICAgIGlmICghY2hhcnQuYm94ZXMpIHtcbiAgICAgIGNoYXJ0LmJveGVzID0gW107XG4gICAgfVxuICAgIGl0ZW0uZnVsbFNpemUgPSBpdGVtLmZ1bGxTaXplIHx8IGZhbHNlO1xuICAgIGl0ZW0ucG9zaXRpb24gPSBpdGVtLnBvc2l0aW9uIHx8ICd0b3AnO1xuICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICBpdGVtLl9sYXllcnMgPSBpdGVtLl9sYXllcnMgfHwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gW3tcbiAgICAgICAgejogMCxcbiAgICAgICAgZHJhdyhjaGFydEFyZWEpIHtcbiAgICAgICAgICBpdGVtLmRyYXcoY2hhcnRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfV07XG4gICAgfTtcbiAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICB9LFxuICByZW1vdmVCb3goY2hhcnQsIGxheW91dEl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGNoYXJ0LmJveGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9LFxuICBjb25maWd1cmUoY2hhcnQsIGl0ZW0sIG9wdGlvbnMpIHtcbiAgICBpdGVtLmZ1bGxTaXplID0gb3B0aW9ucy5mdWxsU2l6ZTtcbiAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICBpdGVtLndlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICB9LFxuICB1cGRhdGUoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICBpZiAoIWNoYXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgY29uc3QgYXZhaWxhYmxlV2lkdGggPSBNYXRoLm1heCh3aWR0aCAtIHBhZGRpbmcud2lkdGgsIDApO1xuICAgIGNvbnN0IGF2YWlsYWJsZUhlaWdodCA9IE1hdGgubWF4KGhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0LCAwKTtcbiAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgIGNvbnN0IHZlcnRpY2FsQm94ZXMgPSBib3hlcy52ZXJ0aWNhbDtcbiAgICBjb25zdCBob3Jpem9udGFsQm94ZXMgPSBib3hlcy5ob3Jpem9udGFsO1xuICAgIGVhY2goY2hhcnQuYm94ZXMsIGJveCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYm94LmJlZm9yZUxheW91dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHZpc2libGVWZXJ0aWNhbEJveENvdW50ID0gdmVydGljYWxCb3hlcy5yZWR1Y2UoKHRvdGFsLCB3cmFwKSA9PlxuICAgICAgd3JhcC5ib3gub3B0aW9ucyAmJiB3cmFwLmJveC5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlID8gdG90YWwgOiB0b3RhbCArIDEsIDApIHx8IDE7XG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICBvdXRlcldpZHRoOiB3aWR0aCxcbiAgICAgIG91dGVySGVpZ2h0OiBoZWlnaHQsXG4gICAgICBwYWRkaW5nLFxuICAgICAgYXZhaWxhYmxlV2lkdGgsXG4gICAgICBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB2Qm94TWF4V2lkdGg6IGF2YWlsYWJsZVdpZHRoIC8gMiAvIHZpc2libGVWZXJ0aWNhbEJveENvdW50LFxuICAgICAgaEJveE1heEhlaWdodDogYXZhaWxhYmxlSGVpZ2h0IC8gMlxuICAgIH0pO1xuICAgIGNvbnN0IG1heFBhZGRpbmcgPSBPYmplY3QuYXNzaWduKHt9LCBwYWRkaW5nKTtcbiAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIHRvUGFkZGluZyhtaW5QYWRkaW5nKSk7XG4gICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYXhQYWRkaW5nLFxuICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICB5OiBwYWRkaW5nLnRvcFxuICAgIH0sIHBhZGRpbmcpO1xuICAgIGNvbnN0IHN0YWNrcyA9IHNldExheW91dERpbXModmVydGljYWxCb3hlcy5jb25jYXQoaG9yaXpvbnRhbEJveGVzKSwgcGFyYW1zKTtcbiAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgaWYgKGZpdEJveGVzKGhvcml6b250YWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcykpIHtcbiAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgIH1cbiAgICBoYW5kbGVNYXhQYWRkaW5nKGNoYXJ0QXJlYSk7XG4gICAgcGxhY2VCb3hlcyhib3hlcy5sZWZ0QW5kVG9wLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICBjaGFydEFyZWEueSArPSBjaGFydEFyZWEuaDtcbiAgICBwbGFjZUJveGVzKGJveGVzLnJpZ2h0QW5kQm90dG9tLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKTtcbiAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53LFxuICAgIH07XG4gICAgZWFjaChib3hlcy5jaGFydEFyZWEsIChsYXlvdXQpID0+IHtcbiAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICBPYmplY3QuYXNzaWduKGJveCwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICAgIGJveC51cGRhdGUoY2hhcnRBcmVhLncsIGNoYXJ0QXJlYS5oLCB7bGVmdDogMCwgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwfSk7XG4gICAgfSk7XG4gIH1cbn07XG5cbmNsYXNzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XG4gIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHt9XG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIGdldE1heGltdW1TaXplKGVsZW1lbnQsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCB3aWR0aCB8fCBlbGVtZW50LndpZHRoKTtcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IE1hdGguZmxvb3Iod2lkdGggLyBhc3BlY3RSYXRpbykgOiBoZWlnaHQpXG4gICAgfTtcbiAgfVxuICBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgfVxufVxuXG5jbGFzcyBCYXNpY1BsYXRmb3JtIGV4dGVuZHMgQmFzZVBsYXRmb3JtIHtcbiAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgIHJldHVybiBpdGVtICYmIGl0ZW0uZ2V0Q29udGV4dCAmJiBpdGVtLmdldENvbnRleHQoJzJkJykgfHwgbnVsbDtcbiAgfVxuICB1cGRhdGVDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gIH1cbn1cblxuY29uc3QgRVhQQU5ET19LRVkgPSAnJGNoYXJ0anMnO1xuY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gIHRvdWNoc3RhcnQ6ICdtb3VzZWRvd24nLFxuICB0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICBwb2ludGVyZW50ZXI6ICdtb3VzZWVudGVyJyxcbiAgcG9pbnRlcmRvd246ICdtb3VzZWRvd24nLFxuICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gIHBvaW50ZXJ1cDogJ21vdXNldXAnLFxuICBwb2ludGVybGVhdmU6ICdtb3VzZW91dCcsXG4gIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gdmFsdWUgPT4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuZnVuY3Rpb24gaW5pdENhbnZhcyhjYW52YXMsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICBjb25zdCByZW5kZXJIZWlnaHQgPSBjYW52YXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgY29uc3QgcmVuZGVyV2lkdGggPSBjYW52YXMuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgIGluaXRpYWw6IHtcbiAgICAgIGhlaWdodDogcmVuZGVySGVpZ2h0LFxuICAgICAgd2lkdGg6IHJlbmRlcldpZHRoLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgaGVpZ2h0OiBzdHlsZS5oZWlnaHQsXG4gICAgICAgIHdpZHRoOiBzdHlsZS53aWR0aFxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgc3R5bGUuYm94U2l6aW5nID0gc3R5bGUuYm94U2l6aW5nIHx8ICdib3JkZXItYm94JztcbiAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVyV2lkdGgpKSB7XG4gICAgY29uc3QgZGlzcGxheVdpZHRoID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ3dpZHRoJyk7XG4gICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgfVxuICB9XG4gIGlmIChpc051bGxPckVtcHR5KHJlbmRlckhlaWdodCkpIHtcbiAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpc3BsYXlIZWlnaHQgPSByZWFkVXNlZFNpemUoY2FudmFzLCAnaGVpZ2h0Jyk7XG4gICAgICBpZiAoZGlzcGxheUhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FudmFzO1xufVxuY29uc3QgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCB0eXBlLCBsaXN0ZW5lcikge1xuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjaGFydC5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgZXZlbnRMaXN0ZW5lck9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICBjb25zdCB0eXBlID0gRVZFTlRfVFlQRVNbZXZlbnQudHlwZV0gfHwgZXZlbnQudHlwZTtcbiAgY29uc3Qge3gsIHl9ID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihldmVudCwgY2hhcnQpO1xuICByZXR1cm4ge1xuICAgIHR5cGUsXG4gICAgY2hhcnQsXG4gICAgbmF0aXZlOiBldmVudCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbCxcbiAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVMaXN0Q29udGFpbnMobm9kZUxpc3QsIGNhbnZhcykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3QpIHtcbiAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0cmlnZ2VyKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSk7XG4gIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICBsZXQgdHJpZ2dlciA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgdHJpZ2dlciA9IHRyaWdnZXIgfHwgbm9kZUxpc3RDb250YWlucyhlbnRyeS5yZW1vdmVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciAmJiAhbm9kZUxpc3RDb250YWlucyhlbnRyeS5hZGRlZE5vZGVzLCBjYW52YXMpO1xuICAgIH1cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG4gIH0pO1xuICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7Y2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlfSk7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICBjb25zdCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgaWYgKGRwciA9PT0gb2xkRGV2aWNlUGl4ZWxSYXRpbykge1xuICAgIHJldHVybjtcbiAgfVxuICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZm9yRWFjaCgocmVzaXplLCBjaGFydCkgPT4ge1xuICAgIGlmIChjaGFydC5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAhPT0gZHByKSB7XG4gICAgICByZXNpemUoKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGlzdGVuRGV2aWNlUGl4ZWxSYXRpb0NoYW5nZXMoY2hhcnQsIHJlc2l6ZSkge1xuICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIG9uV2luZG93UmVzaXplKTtcbiAgfVxuICBkcnBMaXN0ZW5pbmdDaGFydHMuc2V0KGNoYXJ0LCByZXNpemUpO1xufVxuZnVuY3Rpb24gdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCkge1xuICBkcnBMaXN0ZW5pbmdDaGFydHMuZGVsZXRlKGNoYXJ0KTtcbiAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZXNpemUgPSB0aHJvdHRsZWQoKHdpZHRoLCBoZWlnaHQpID0+IHtcbiAgICBjb25zdCB3ID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGxpc3RlbmVyKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfSwgd2luZG93KTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgIGNvbnN0IHdpZHRoID0gZW50cnkuY29udGVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZW50cnkuY29udGVudFJlY3QuaGVpZ2h0O1xuICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9KTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICBsaXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCwgcmVzaXplKTtcbiAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gcmVsZWFzZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBvYnNlcnZlcikge1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgaWYgKHR5cGUgPT09ICdyZXNpemUnKSB7XG4gICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5QW5kTGlzdGVuKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCkgPT4ge1xuICAgIGlmIChjaGFydC5jdHggIT09IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyKGZyb21OYXRpdmVFdmVudChldmVudCwgY2hhcnQpKTtcbiAgICB9XG4gIH0sIGNoYXJ0LCAoYXJncykgPT4ge1xuICAgIGNvbnN0IGV2ZW50ID0gYXJnc1swXTtcbiAgICByZXR1cm4gW2V2ZW50LCBldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZXTtcbiAgfSk7XG4gIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59XG5jbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHtcbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzID09PSBjYW52YXMpIHtcbiAgICAgIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbyk7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsID0gY2FudmFzW0VYUEFORE9fS0VZXS5pbml0aWFsO1xuICAgIFsnaGVpZ2h0JywgJ3dpZHRoJ10uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbml0aWFsW3Byb3BdO1xuICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGluaXRpYWwuc3R5bGUgfHwge307XG4gICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY2FudmFzLnN0eWxlW2tleV0gPSBzdHlsZVtrZXldO1xuICAgIH0pO1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICBkZWxldGUgY2FudmFzW0VYUEFORE9fS0VZXTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSk7XG4gICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IGNyZWF0ZVByb3h5QW5kTGlzdGVuO1xuICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihjaGFydCwgdHlwZSkge1xuICAgIGNvbnN0IHByb3hpZXMgPSBjaGFydC4kcHJveGllcyB8fCAoY2hhcnQuJHByb3hpZXMgPSB7fSk7XG4gICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgIGlmICghcHJveHkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZXIgPSBoYW5kbGVyc1t0eXBlXSB8fCByZW1vdmVMaXN0ZW5lcjtcbiAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgcHJveGllc1t0eXBlXSA9IHVuZGVmaW5lZDtcbiAgfVxuICBnZXREZXZpY2VQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgfVxuICBnZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgcmV0dXJuIGdldE1heGltdW1TaXplKGNhbnZhcywgd2lkdGgsIGhlaWdodCwgYXNwZWN0UmF0aW8pO1xuICB9XG4gIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RldGVjdFBsYXRmb3JtKGNhbnZhcykge1xuICBpZiAoIV9pc0RvbVN1cHBvcnRlZCgpIHx8ICh0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpKSB7XG4gICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gIH1cbiAgcmV0dXJuIERvbVBsYXRmb3JtO1xufVxuXG5jbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5faW5pdCA9IFtdO1xuICB9XG4gIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgaWYgKGhvb2sgPT09ICdiZWZvcmVJbml0Jykge1xuICAgICAgdGhpcy5faW5pdCA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB0cnVlKTtcbiAgICAgIHRoaXMuX25vdGlmeSh0aGlzLl9pbml0LCBjaGFydCwgJ2luc3RhbGwnKTtcbiAgICB9XG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncyk7XG4gICAgaWYgKGhvb2sgPT09ICdhZnRlckRlc3Ryb3knKSB7XG4gICAgICB0aGlzLl9ub3RpZnkoZGVzY3JpcHRvcnMsIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgdGhpcy5fbm90aWZ5KHRoaXMuX2luaXQsIGNoYXJ0LCAndW5pbnN0YWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IGRlc2NyaXB0b3Igb2YgZGVzY3JpcHRvcnMpIHtcbiAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgY29uc3QgcGFyYW1zID0gW2NoYXJ0LCBhcmdzLCBkZXNjcmlwdG9yLm9wdGlvbnNdO1xuICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbnZhbGlkYXRlKCkge1xuICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgX2Rlc2NyaXB0b3JzKGNoYXJ0KSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGUgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH1cbiAgX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCBhbGwpIHtcbiAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHZhbHVlT3JEZWZhdWx0KGNvbmZpZy5vcHRpb25zICYmIGNvbmZpZy5vcHRpb25zLnBsdWdpbnMsIHt9KTtcbiAgICBjb25zdCBwbHVnaW5zID0gYWxsUGx1Z2lucyhjb25maWcpO1xuICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgfVxuICBfbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KSB7XG4gICAgY29uc3QgcHJldmlvdXNEZXNjcmlwdG9ycyA9IHRoaXMuX29sZENhY2hlIHx8IFtdO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LnBsdWdpbi5pZCA9PT0geS5wbHVnaW4uaWQpKTtcbiAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgIHRoaXMuX25vdGlmeShkaWZmKGRlc2NyaXB0b3JzLCBwcmV2aW91c0Rlc2NyaXB0b3JzKSwgY2hhcnQsICdzdGFydCcpO1xuICB9XG59XG5mdW5jdGlvbiBhbGxQbHVnaW5zKGNvbmZpZykge1xuICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICBjb25zdCBwbHVnaW5zID0gW107XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWdpc3RyeS5wbHVnaW5zLml0ZW1zKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGx1Z2lucy5wdXNoKHJlZ2lzdHJ5LmdldFBsdWdpbihrZXlzW2ldKSk7XG4gIH1cbiAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsb2NhbC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBsdWdpbiA9IGxvY2FsW2ldO1xuICAgIGlmIChwbHVnaW5zLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICAgICAgbG9jYWxJZHNbcGx1Z2luLmlkXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB7cGx1Z2lucywgbG9jYWxJZHN9O1xufVxuZnVuY3Rpb24gZ2V0T3B0cyhvcHRpb25zLCBhbGwpIHtcbiAgaWYgKCFhbGwgJiYgb3B0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0LCB7cGx1Z2lucywgbG9jYWxJZHN9LCBvcHRpb25zLCBhbGwpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGNvbnN0IGNvbnRleHQgPSBjaGFydC5nZXRDb250ZXh0KCk7XG4gIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpIHtcbiAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICBjb25zdCBvcHRzID0gZ2V0T3B0cyhvcHRpb25zW2lkXSwgYWxsKTtcbiAgICBpZiAob3B0cyA9PT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgIHBsdWdpbixcbiAgICAgIG9wdGlvbnM6IHBsdWdpbk9wdHMoY2hhcnQuY29uZmlnLCB7cGx1Z2luLCBsb2NhbDogbG9jYWxJZHNbaWRdfSwgb3B0cywgY29udGV4dClcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGx1Z2luT3B0cyhjb25maWcsIHtwbHVnaW4sIGxvY2FsfSwgb3B0cywgY29udGV4dCkge1xuICBjb25zdCBrZXlzID0gY29uZmlnLnBsdWdpblNjb3BlS2V5cyhwbHVnaW4pO1xuICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICBpZiAobG9jYWwgJiYgcGx1Z2luLmRlZmF1bHRzKSB7XG4gICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gY29uZmlnLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgWycnXSwge1xuICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgIGluZGV4YWJsZTogZmFsc2UsXG4gICAgYWxsS2V5czogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhBeGlzKHR5cGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gIGNvbnN0IGRhdGFzZXRPcHRpb25zID0gKG9wdGlvbnMuZGF0YXNldHMgfHwge30pW3R5cGVdIHx8IHt9O1xuICByZXR1cm4gZGF0YXNldE9wdGlvbnMuaW5kZXhBeGlzIHx8IG9wdGlvbnMuaW5kZXhBeGlzIHx8IGRhdGFzZXREZWZhdWx0cy5pbmRleEF4aXMgfHwgJ3gnO1xufVxuZnVuY3Rpb24gZ2V0QXhpc0Zyb21EZWZhdWx0U2NhbGVJRChpZCwgaW5kZXhBeGlzKSB7XG4gIGxldCBheGlzID0gaWQ7XG4gIGlmIChpZCA9PT0gJ19pbmRleF8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcztcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ192YWx1ZV8nKSB7XG4gICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuZnVuY3Rpb24gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBpbmRleEF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICByZXR1cm4gJ3gnO1xuICB9XG4gIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgcmV0dXJuICd5JztcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKSB7XG4gIGlmIChpZCA9PT0gJ3gnIHx8IGlkID09PSAneScpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH1cbiAgcmV0dXJuIHNjYWxlT3B0aW9ucy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24oc2NhbGVPcHRpb25zLnBvc2l0aW9uKSB8fCBpZC5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNoYXJ0RGVmYXVsdHMgPSBvdmVycmlkZXNbY29uZmlnLnR5cGVdIHx8IHtzY2FsZXM6IHt9fTtcbiAgY29uc3QgY29uZmlnU2NhbGVzID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gIGNvbnN0IGNoYXJ0SW5kZXhBeGlzID0gZ2V0SW5kZXhBeGlzKGNvbmZpZy50eXBlLCBvcHRpb25zKTtcbiAgY29uc3QgZmlyc3RJRHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBzY2FsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goaWQgPT4ge1xuICAgIGNvbnN0IHNjYWxlQ29uZiA9IGNvbmZpZ1NjYWxlc1tpZF07XG4gICAgaWYgKCFpc09iamVjdChzY2FsZUNvbmYpKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihgSW52YWxpZCBzY2FsZSBjb25maWd1cmF0aW9uIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgaWYgKHNjYWxlQ29uZi5fcHJveHkpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYElnbm9yaW5nIHJlc29sdmVyIHBhc3NlZCBhcyBvcHRpb25zIGZvciBzY2FsZTogJHtpZH1gKTtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZik7XG4gICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgY29uc3QgZGVmYXVsdFNjYWxlT3B0aW9ucyA9IGNoYXJ0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIGZpcnN0SURzW2F4aXNdID0gZmlyc3RJRHNbYXhpc10gfHwgaWQ7XG4gICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW3theGlzfSwgc2NhbGVDb25mLCBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJZF1dKTtcbiAgfSk7XG4gIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goZGF0YXNldCA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCBjb25maWcudHlwZTtcbiAgICBjb25zdCBpbmRleEF4aXMgPSBkYXRhc2V0LmluZGV4QXhpcyB8fCBnZXRJbmRleEF4aXModHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBkYXRhc2V0RGVmYXVsdHMuc2NhbGVzIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKGRlZmF1bHRTY2FsZU9wdGlvbnMpLmZvckVhY2goZGVmYXVsdElEID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSBnZXRBeGlzRnJvbURlZmF1bHRTY2FsZUlEKGRlZmF1bHRJRCwgaW5kZXhBeGlzKTtcbiAgICAgIGNvbnN0IGlkID0gZGF0YXNldFtheGlzICsgJ0F4aXNJRCddIHx8IGZpcnN0SURzW2F4aXNdIHx8IGF4aXM7XG4gICAgICBzY2FsZXNbaWRdID0gc2NhbGVzW2lkXSB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgbWVyZ2VJZihzY2FsZXNbaWRdLCBbe2F4aXN9LCBjb25maWdTY2FsZXNbaWRdLCBkZWZhdWx0U2NhbGVPcHRpb25zW2RlZmF1bHRJRF1dKTtcbiAgICB9KTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKHNjYWxlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgbWVyZ2VJZihzY2FsZSwgW2RlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSwgZGVmYXVsdHMuc2NhbGVdKTtcbiAgfSk7XG4gIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zIHx8IChjb25maWcub3B0aW9ucyA9IHt9KTtcbiAgb3B0aW9ucy5wbHVnaW5zID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICBkYXRhID0gZGF0YSB8fCB7fTtcbiAgZGF0YS5kYXRhc2V0cyA9IGRhdGEuZGF0YXNldHMgfHwgW107XG4gIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gaW5pdENvbmZpZyhjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgcmV0dXJuIGNvbmZpZztcbn1cbmNvbnN0IGtleUNhY2hlID0gbmV3IE1hcCgpO1xuY29uc3Qga2V5c0NhY2hlZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIGNhY2hlZEtleXMoY2FjaGVLZXksIGdlbmVyYXRlKSB7XG4gIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgaWYgKCFrZXlzKSB7XG4gICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAga2V5Q2FjaGUuc2V0KGNhY2hlS2V5LCBrZXlzKTtcbiAgICBrZXlzQ2FjaGVkLmFkZChrZXlzKTtcbiAgfVxuICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSkgPT4ge1xuICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gIGlmIChvcHRzICE9PSB1bmRlZmluZWQpIHtcbiAgICBzZXQuYWRkKG9wdHMpO1xuICB9XG59O1xuY2xhc3MgQ29uZmlnIHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gaW5pdENvbmZpZyhjb25maWcpO1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgcGxhdGZvcm0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbGF0Zm9ybTtcbiAgfVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLnR5cGU7XG4gIH1cbiAgc2V0IHR5cGUodHlwZSkge1xuICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uZmlnLmRhdGE7XG4gIH1cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2NvbmZpZy5kYXRhID0gaW5pdERhdGEoZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICB9XG4gIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICB0aGlzLl9jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5wbHVnaW5zO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgaW5pdE9wdGlvbnMoY29uZmlnKTtcbiAgfVxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMuX3Njb3BlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLl9yZXNvbHZlckNhY2hlLmNsZWFyKCk7XG4gIH1cbiAgZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgIHJldHVybiBjYWNoZWRLZXlzKGRhdGFzZXRUeXBlLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBkYXRhc2V0QW5pbWF0aW9uU2NvcGVLZXlzKGRhdGFzZXRUeXBlLCB0cmFuc2l0aW9uKSB7XG4gICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsXG4gICAgICAoKSA9PiBbXG4gICAgICAgIFtcbiAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgYHRyYW5zaXRpb25zLiR7dHJhbnNpdGlvbn1gLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgICAnJ1xuICAgICAgICBdXG4gICAgICBdKTtcbiAgfVxuICBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHtkYXRhc2V0VHlwZX0tJHtlbGVtZW50VHlwZX1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9LmVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgYGRhdGFzZXRzLiR7ZGF0YXNldFR5cGV9YCxcbiAgICAgICAgYGVsZW1lbnRzLiR7ZWxlbWVudFR5cGV9YCxcbiAgICAgICAgJydcbiAgICAgIF1dKTtcbiAgfVxuICBwbHVnaW5TY29wZUtleXMocGx1Z2luKSB7XG4gICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZTtcbiAgICByZXR1cm4gY2FjaGVkS2V5cyhgJHt0eXBlfS1wbHVnaW4tJHtpZH1gLFxuICAgICAgKCkgPT4gW1tcbiAgICAgICAgYHBsdWdpbnMuJHtpZH1gLFxuICAgICAgICAuLi5wbHVnaW4uYWRkaXRpb25hbE9wdGlvblNjb3BlcyB8fCBbXSxcbiAgICAgIF1dKTtcbiAgfVxuICBfY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSkge1xuICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICBsZXQgY2FjaGUgPSBfc2NvcGVDYWNoZS5nZXQobWFpblNjb3BlKTtcbiAgICBpZiAoIWNhY2hlIHx8IHJlc2V0Q2FjaGUpIHtcbiAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgX3Njb3BlQ2FjaGUuc2V0KG1haW5TY29wZSwgY2FjaGUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbiAgZ2V0T3B0aW9uU2NvcGVzKG1haW5TY29wZSwga2V5TGlzdHMsIHJlc2V0Q2FjaGUpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgdHlwZX0gPSB0aGlzO1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fY2FjaGVkU2NvcGVzKG1haW5TY29wZSwgcmVzZXRDYWNoZSk7XG4gICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICBpZiAoY2FjaGVkKSB7XG4gICAgICByZXR1cm4gY2FjaGVkO1xuICAgIH1cbiAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAga2V5TGlzdHMuZm9yRWFjaChrZXlzID0+IHtcbiAgICAgIGlmIChtYWluU2NvcGUpIHtcbiAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBtYWluU2NvcGUsIGtleSkpO1xuICAgICAgfVxuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3Blcywgb3B0aW9ucywga2V5KSk7XG4gICAgICBrZXlzLmZvckVhY2goa2V5ID0+IGFkZElmRm91bmQoc2NvcGVzLCBvdmVycmlkZXNbdHlwZV0gfHwge30sIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVmYXVsdHMsIGtleSkpO1xuICAgICAga2V5cy5mb3JFYWNoKGtleSA9PiBhZGRJZkZvdW5kKHNjb3BlcywgZGVzY3JpcHRvcnMsIGtleSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGFycmF5ID0gQXJyYXkuZnJvbShzY29wZXMpO1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGFycmF5LnB1c2goT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgfVxuICAgIGlmIChrZXlzQ2FjaGVkLmhhcyhrZXlMaXN0cykpIHtcbiAgICAgIGNhY2hlLnNldChrZXlMaXN0cywgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbiAgY2hhcnRPcHRpb25TY29wZXMoKSB7XG4gICAgY29uc3Qge29wdGlvbnMsIHR5cGV9ID0gdGhpcztcbiAgICByZXR1cm4gW1xuICAgICAgb3B0aW9ucyxcbiAgICAgIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSxcbiAgICAgIGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdIHx8IHt9LFxuICAgICAge3R5cGV9LFxuICAgICAgZGVmYXVsdHMsXG4gICAgICBkZXNjcmlwdG9yc1xuICAgIF07XG4gIH1cbiAgcmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyA9IFsnJ10pIHtcbiAgICBjb25zdCByZXN1bHQgPSB7JHNoYXJlZDogdHJ1ZX07XG4gICAgY29uc3Qge3Jlc29sdmVyLCBzdWJQcmVmaXhlc30gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICBsZXQgb3B0aW9ucyA9IHJlc29sdmVyO1xuICAgIGlmIChuZWVkQ29udGV4dChyZXNvbHZlciwgbmFtZXMpKSB7XG4gICAgICByZXN1bHQuJHNoYXJlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dCA9IGlzRnVuY3Rpb24oY29udGV4dCkgPyBjb250ZXh0KCkgOiBjb250ZXh0O1xuICAgICAgY29uc3Qgc3ViUmVzb2x2ZXIgPSB0aGlzLmNyZWF0ZVJlc29sdmVyKHNjb3BlcywgY29udGV4dCwgc3ViUHJlZml4ZXMpO1xuICAgICAgb3B0aW9ucyA9IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCBzdWJSZXNvbHZlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcykge1xuICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gWycnXSwgZGVzY3JpcHRvckRlZmF1bHRzKSB7XG4gICAgY29uc3Qge3Jlc29sdmVyfSA9IGdldFJlc29sdmVyKHRoaXMuX3Jlc29sdmVyQ2FjaGUsIHNjb3BlcywgcHJlZml4ZXMpO1xuICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KVxuICAgICAgPyBfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgY29udGV4dCwgdW5kZWZpbmVkLCBkZXNjcmlwdG9yRGVmYXVsdHMpXG4gICAgICA6IHJlc29sdmVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gIGxldCBjYWNoZSA9IHJlc29sdmVyQ2FjaGUuZ2V0KHNjb3Blcyk7XG4gIGlmICghY2FjaGUpIHtcbiAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgfVxuICBjb25zdCBjYWNoZUtleSA9IHByZWZpeGVzLmpvaW4oKTtcbiAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghY2FjaGVkKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgY2FjaGVkID0ge1xuICAgICAgcmVzb2x2ZXIsXG4gICAgICBzdWJQcmVmaXhlczogcHJlZml4ZXMuZmlsdGVyKHAgPT4gIXAudG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnaG92ZXInKSlcbiAgICB9O1xuICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgfVxuICByZXR1cm4gY2FjaGVkO1xufVxuY29uc3QgaGFzRnVuY3Rpb24gPSB2YWx1ZSA9PiBpc09iamVjdCh2YWx1ZSlcbiAgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYyB8fCBpc0Z1bmN0aW9uKHZhbHVlW2tleV0pLCBmYWxzZSk7XG5mdW5jdGlvbiBuZWVkQ29udGV4dChwcm94eSwgbmFtZXMpIHtcbiAgY29uc3Qge2lzU2NyaXB0YWJsZSwgaXNJbmRleGFibGV9ID0gX2Rlc2NyaXB0b3JzKHByb3h5KTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIG5hbWVzKSB7XG4gICAgY29uc3Qgc2NyaXB0YWJsZSA9IGlzU2NyaXB0YWJsZShwcm9wKTtcbiAgICBjb25zdCBpbmRleGFibGUgPSBpc0luZGV4YWJsZShwcm9wKTtcbiAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgaWYgKChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpKVxuICAgICAgfHwgKGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjkuMVwiO1xuXG5jb25zdCBLTk9XTl9QT1NJVElPTlMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjaGFydEFyZWEnXTtcbmZ1bmN0aW9uIHBvc2l0aW9uSXNIb3Jpem9udGFsKHBvc2l0aW9uLCBheGlzKSB7XG4gIHJldHVybiBwb3NpdGlvbiA9PT0gJ3RvcCcgfHwgcG9zaXRpb24gPT09ICdib3R0b20nIHx8IChLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jyk7XG59XG5mdW5jdGlvbiBjb21wYXJlMkxldmVsKGwxLCBsMikge1xuICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiBhW2wxXSA9PT0gYltsMV1cbiAgICAgID8gYVtsMl0gLSBiW2wyXVxuICAgICAgOiBhW2wxXSAtIGJbbDFdO1xuICB9O1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25zQ29tcGxldGUoY29udGV4dCkge1xuICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJSZW5kZXInKTtcbiAgY2FsbGJhY2soYW5pbWF0aW9uT3B0aW9ucyAmJiBhbmltYXRpb25PcHRpb25zLm9uQ29tcGxldGUsIFtjb250ZXh0XSwgY2hhcnQpO1xufVxuZnVuY3Rpb24gb25BbmltYXRpb25Qcm9ncmVzcyhjb250ZXh0KSB7XG4gIGNvbnN0IGNoYXJ0ID0gY29udGV4dC5jaGFydDtcbiAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICBjYWxsYmFjayhhbmltYXRpb25PcHRpb25zICYmIGFuaW1hdGlvbk9wdGlvbnMub25Qcm9ncmVzcywgW2NvbnRleHRdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBnZXRDYW52YXMoaXRlbSkge1xuICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgaXRlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pO1xuICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICBpdGVtID0gaXRlbVswXTtcbiAgfVxuICBpZiAoaXRlbSAmJiBpdGVtLmNhbnZhcykge1xuICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cbmNvbnN0IGluc3RhbmNlcyA9IHt9O1xuY29uc3QgZ2V0Q2hhcnQgPSAoa2V5KSA9PiB7XG4gIGNvbnN0IGNhbnZhcyA9IGdldENhbnZhcyhrZXkpO1xuICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYykgPT4gYy5jYW52YXMgPT09IGNhbnZhcykucG9wKCk7XG59O1xuZnVuY3Rpb24gbW92ZU51bWVyaWNLZXlzKG9iaiwgc3RhcnQsIG1vdmUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCBpbnRLZXkgPSAra2V5O1xuICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgb2JqW2ludEtleSArIG1vdmVdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICBpZiAoIWluQ2hhcnRBcmVhIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0NsaWNrKSB7XG4gICAgcmV0dXJuIGxhc3RFdmVudDtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIENoYXJ0IHtcbiAgY29uc3RydWN0b3IoaXRlbSwgdXNlckNvbmZpZykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnID0gbmV3IENvbmZpZyh1c2VyQ29uZmlnKTtcbiAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hhcnQgPSBnZXRDaGFydChpbml0aWFsQ2FudmFzKTtcbiAgICBpZiAoZXhpc3RpbmdDaGFydCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FudmFzIGlzIGFscmVhZHkgaW4gdXNlLiBDaGFydCB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmlkICsgJ1xcJycgK1xuXHRcdFx0XHQnIG11c3QgYmUgZGVzdHJveWVkIGJlZm9yZSB0aGUgY2FudmFzIHdpdGggSUQgXFwnJyArIGV4aXN0aW5nQ2hhcnQuY2FudmFzLmlkICsgJ1xcJyBjYW4gYmUgcmV1c2VkLidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICB0aGlzLnBsYXRmb3JtID0gbmV3IChjb25maWcucGxhdGZvcm0gfHwgX2RldGVjdFBsYXRmb3JtKGluaXRpYWxDYW52YXMpKSgpO1xuICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMucGxhdGZvcm0uYWNxdWlyZUNvbnRleHQoaW5pdGlhbENhbnZhcywgb3B0aW9ucy5hc3BlY3RSYXRpbyk7XG4gICAgY29uc3QgY2FudmFzID0gY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcztcbiAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCB3aWR0aCA9IGNhbnZhcyAmJiBjYW52YXMud2lkdGg7XG4gICAgdGhpcy5pZCA9IHVpZCgpO1xuICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5fYXNwZWN0UmF0aW8gPSB0aGlzLmFzcGVjdFJhdGlvO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX21ldGFzZXRzID0gW107XG4gICAgdGhpcy5fc3RhY2tzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnRBcmVhID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgIHRoaXMuX2xhc3RFdmVudCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gW107XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLl9wbHVnaW5zID0gbmV3IFBsdWdpblNlcnZpY2UoKTtcbiAgICB0aGlzLiRwcm94aWVzID0ge307XG4gICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kb1Jlc2l6ZSA9IGRlYm91bmNlKG1vZGUgPT4gdGhpcy51cGRhdGUobW9kZSksIG9wdGlvbnMucmVzaXplRGVsYXkgfHwgMCk7XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dCB8fCAhY2FudmFzKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFydDogY2FuJ3QgYWNxdWlyZSBjb250ZXh0IGZyb20gdGhlIGdpdmVuIGl0ZW1cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgYW5pbWF0b3IubGlzdGVuKHRoaXMsICdwcm9ncmVzcycsIG9uQW5pbWF0aW9uUHJvZ3Jlc3MpO1xuICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGFzcGVjdFJhdGlvKCkge1xuICAgIGNvbnN0IHtvcHRpb25zOiB7YXNwZWN0UmF0aW8sIG1haW50YWluQXNwZWN0UmF0aW99LCB3aWR0aCwgaGVpZ2h0LCBfYXNwZWN0UmF0aW99ID0gdGhpcztcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYXNwZWN0UmF0aW8pKSB7XG4gICAgICByZXR1cm4gYXNwZWN0UmF0aW87XG4gICAgfVxuICAgIGlmIChtYWludGFpbkFzcGVjdFJhdGlvICYmIF9hc3BlY3RSYXRpbykge1xuICAgICAgcmV0dXJuIF9hc3BlY3RSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgfVxuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZGF0YTtcbiAgfVxuICBzZXQgZGF0YShkYXRhKSB7XG4gICAgdGhpcy5jb25maWcuZGF0YSA9IGRhdGE7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gIH1cbiAgc2V0IG9wdGlvbnMob3B0aW9ucykge1xuICAgIHRoaXMuY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG4gIF9pbml0aWFsaXplKCkge1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlSW5pdCcpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0aW5hU2NhbGUodGhpcywgdGhpcy5vcHRpb25zLmRldmljZVBpeGVsUmF0aW8pO1xuICAgIH1cbiAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVySW5pdCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGNsZWFyQ2FudmFzKHRoaXMuY2FudmFzLCB0aGlzLmN0eCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICBhbmltYXRvci5zdG9wKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSB7d2lkdGgsIGhlaWdodH07XG4gICAgfVxuICB9XG4gIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSBvcHRpb25zLm1haW50YWluQXNwZWN0UmF0aW8gJiYgdGhpcy5hc3BlY3RSYXRpbztcbiAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICBjb25zdCBuZXdSYXRpbyA9IG9wdGlvbnMuZGV2aWNlUGl4ZWxSYXRpbyB8fCB0aGlzLnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICBjb25zdCBtb2RlID0gdGhpcy53aWR0aCA/ICdyZXNpemUnIDogJ2F0dGFjaCc7XG4gICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdTaXplLmhlaWdodDtcbiAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdyZXNpemUnLCB7c2l6ZTogbmV3U2l6ZX0pO1xuICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFt0aGlzLCBuZXdTaXplXSwgdGhpcyk7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHtcbiAgICAgIGlmICh0aGlzLl9kb1Jlc2l6ZShtb2RlKSkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qgc2NhbGVzT3B0aW9ucyA9IG9wdGlvbnMuc2NhbGVzIHx8IHt9O1xuICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpID0+IHtcbiAgICAgIGF4aXNPcHRpb25zLmlkID0gYXhpc0lEO1xuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBzY2FsZU9wdHMgPSBvcHRpb25zLnNjYWxlcztcbiAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICBjb25zdCB1cGRhdGVkID0gT2JqZWN0LmtleXMoc2NhbGVzKS5yZWR1Y2UoKG9iaiwgaWQpID0+IHtcbiAgICAgIG9ialtpZF0gPSBmYWxzZTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGlmIChzY2FsZU9wdHMpIHtcbiAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KFxuICAgICAgICBPYmplY3Qua2V5cyhzY2FsZU9wdHMpLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICBjb25zdCBzY2FsZU9wdGlvbnMgPSBzY2FsZU9wdHNbaWRdO1xuICAgICAgICAgIGNvbnN0IGF4aXMgPSBkZXRlcm1pbmVBeGlzKGlkLCBzY2FsZU9wdGlvbnMpO1xuICAgICAgICAgIGNvbnN0IGlzUmFkaWFsID0gYXhpcyA9PT0gJ3InO1xuICAgICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGF4aXMgPT09ICd4JztcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb3B0aW9uczogc2NhbGVPcHRpb25zLFxuICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICBkdHlwZTogaXNSYWRpYWwgPyAncmFkaWFsTGluZWFyJyA6IGlzSG9yaXpvbnRhbCA/ICdjYXRlZ29yeScgOiAnbGluZWFyJ1xuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgICBlYWNoKGl0ZW1zLCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3Qgc2NhbGVPcHRpb25zID0gaXRlbS5vcHRpb25zO1xuICAgICAgY29uc3QgaWQgPSBzY2FsZU9wdGlvbnMuaWQ7XG4gICAgICBjb25zdCBheGlzID0gZGV0ZXJtaW5lQXhpcyhpZCwgc2NhbGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IHNjYWxlVHlwZSA9IHZhbHVlT3JEZWZhdWx0KHNjYWxlT3B0aW9ucy50eXBlLCBpdGVtLmR0eXBlKTtcbiAgICAgIGlmIChzY2FsZU9wdGlvbnMucG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbklzSG9yaXpvbnRhbChzY2FsZU9wdGlvbnMucG9zaXRpb24sIGF4aXMpICE9PSBwb3NpdGlvbklzSG9yaXpvbnRhbChpdGVtLmRwb3NpdGlvbikpIHtcbiAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICB9XG4gICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICBzY2FsZSA9IHNjYWxlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzY2FsZUNsYXNzID0gcmVnaXN0cnkuZ2V0U2NhbGUoc2NhbGVUeXBlKTtcbiAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgaWQsXG4gICAgICAgICAgdHlwZTogc2NhbGVUeXBlLFxuICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgY2hhcnQ6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHNjYWxlc1tzY2FsZS5pZF0gPSBzY2FsZTtcbiAgICAgIH1cbiAgICAgIHNjYWxlLmluaXQoc2NhbGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgICBlYWNoKHVwZGF0ZWQsIChoYXNVcGRhdGVkLCBpZCkgPT4ge1xuICAgICAgaWYgKCFoYXNVcGRhdGVkKSB7XG4gICAgICAgIGRlbGV0ZSBzY2FsZXNbaWRdO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpID0+IHtcbiAgICAgIGxheW91dHMuY29uZmlndXJlKHRoaXMsIHNjYWxlLCBzY2FsZS5vcHRpb25zKTtcbiAgICAgIGxheW91dHMuYWRkQm94KHRoaXMsIHNjYWxlKTtcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBjb25zdCBudW1EYXRhID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgIG1ldGFzZXRzLnNvcnQoKGEsIGIpID0+IGEuaW5kZXggLSBiLmluZGV4KTtcbiAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgIGZvciAobGV0IGkgPSBudW1EYXRhOyBpIDwgbnVtTWV0YTsgKytpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuX3NvcnRlZE1ldGFzZXRzID0gbWV0YXNldHMuc2xpY2UoMCkuc29ydChjb21wYXJlMkxldmVsKCdvcmRlcicsICdpbmRleCcpKTtcbiAgfVxuICBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgY29uc3Qge19tZXRhc2V0czogbWV0YXNldHMsIGRhdGE6IHtkYXRhc2V0c319ID0gdGhpcztcbiAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgIH1cbiAgICBtZXRhc2V0cy5mb3JFYWNoKChtZXRhLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcih4ID0+IHggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9kZXN0cm95RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGJ1aWxkT3JVcGRhdGVDb250cm9sbGVycygpIHtcbiAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IFtdO1xuICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIHRoaXMuX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGRhdGFzZXRzW2ldO1xuICAgICAgbGV0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgY29uc3QgdHlwZSA9IGRhdGFzZXQudHlwZSB8fCB0aGlzLmNvbmZpZy50eXBlO1xuICAgICAgaWYgKG1ldGEudHlwZSAmJiBtZXRhLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIH1cbiAgICAgIG1ldGEudHlwZSA9IHR5cGU7XG4gICAgICBtZXRhLmluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgbWV0YS5vcmRlciA9IGRhdGFzZXQub3JkZXIgfHwgMDtcbiAgICAgIG1ldGEuaW5kZXggPSBpO1xuICAgICAgbWV0YS5sYWJlbCA9ICcnICsgZGF0YXNldC5sYWJlbDtcbiAgICAgIG1ldGEudmlzaWJsZSA9IHRoaXMuaXNEYXRhc2V0VmlzaWJsZShpKTtcbiAgICAgIGlmIChtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgbWV0YS5jb250cm9sbGVyLnVwZGF0ZUluZGV4KGkpO1xuICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQ29udHJvbGxlckNsYXNzID0gcmVnaXN0cnkuZ2V0Q29udHJvbGxlcih0eXBlKTtcbiAgICAgICAgY29uc3Qge2RhdGFzZXRFbGVtZW50VHlwZSwgZGF0YUVsZW1lbnRUeXBlfSA9IGRlZmF1bHRzLmRhdGFzZXRzW3R5cGVdO1xuICAgICAgICBPYmplY3QuYXNzaWduKENvbnRyb2xsZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICAgICAgICBkYXRhRWxlbWVudFR5cGU6IHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YUVsZW1lbnRUeXBlKSxcbiAgICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGRhdGFzZXRFbGVtZW50VHlwZSAmJiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFzZXRFbGVtZW50VHlwZSlcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgIG5ld0NvbnRyb2xsZXJzLnB1c2gobWV0YS5jb250cm9sbGVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlTWV0YXNldHMoKTtcbiAgICByZXR1cm4gbmV3Q29udHJvbGxlcnM7XG4gIH1cbiAgX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgZWFjaCh0aGlzLmRhdGEuZGF0YXNldHMsIChkYXRhc2V0LCBkYXRhc2V0SW5kZXgpID0+IHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KS5jb250cm9sbGVyLnJlc2V0KCk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5fcmVzZXRFbGVtZW50cygpO1xuICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgfVxuICB1cGRhdGUobW9kZSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY29uZmlnO1xuICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihjb25maWcuY2hhcnRPcHRpb25TY29wZXMoKSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGNvbnN0IGFuaW1zRGlzYWJsZWQgPSB0aGlzLl9hbmltYXRpb25zRGlzYWJsZWQgPSAhb3B0aW9ucy5hbmltYXRpb247XG4gICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgdGhpcy5fY2hlY2tFdmVudEJpbmRpbmdzKCk7XG4gICAgdGhpcy5fdXBkYXRlSGlkZGVuSW5kaWNlcygpO1xuICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZVVwZGF0ZScsIHttb2RlLCBjYW5jZWxhYmxlOiB0cnVlfSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gdGhpcy5idWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUVsZW1lbnRzVXBkYXRlJyk7XG4gICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgICAgY29uc3Qge2NvbnRyb2xsZXJ9ID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGNvbnN0IHJlc2V0ID0gIWFuaW1zRGlzYWJsZWQgJiYgbmV3Q29udHJvbGxlcnMuaW5kZXhPZihjb250cm9sbGVyKSA9PT0gLTE7XG4gICAgICBjb250cm9sbGVyLmJ1aWxkT3JVcGRhdGVFbGVtZW50cyhyZXNldCk7XG4gICAgICBtaW5QYWRkaW5nID0gTWF0aC5tYXgoK2NvbnRyb2xsZXIuZ2V0TWF4T3ZlcmZsb3coKSwgbWluUGFkZGluZyk7XG4gICAgfVxuICAgIG1pblBhZGRpbmcgPSB0aGlzLl9taW5QYWRkaW5nID0gb3B0aW9ucy5sYXlvdXQuYXV0b1BhZGRpbmcgPyBtaW5QYWRkaW5nIDogMDtcbiAgICB0aGlzLl91cGRhdGVMYXlvdXQobWluUGFkZGluZyk7XG4gICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlRGF0YXNldHMobW9kZSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHttb2RlfSk7XG4gICAgdGhpcy5fbGF5ZXJzLnNvcnQoY29tcGFyZTJMZXZlbCgneicsICdfaWR4JykpO1xuICAgIGNvbnN0IHtfYWN0aXZlLCBfbGFzdEV2ZW50fSA9IHRoaXM7XG4gICAgaWYgKF9sYXN0RXZlbnQpIHtcbiAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihfbGFzdEV2ZW50LCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKF9hY3RpdmUubGVuZ3RoKSB7XG4gICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhfYWN0aXZlLCBfYWN0aXZlLCB0cnVlKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuICBfdXBkYXRlU2NhbGVzKCkge1xuICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSkgPT4ge1xuICAgICAgbGF5b3V0cy5yZW1vdmVCb3godGhpcywgc2NhbGUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgIHRoaXMuYnVpbGRPclVwZGF0ZVNjYWxlcygpO1xuICB9XG4gIF9jaGVja0V2ZW50QmluZGluZ3MoKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0V2ZW50cyA9IG5ldyBTZXQoT2JqZWN0LmtleXModGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgY29uc3QgbmV3RXZlbnRzID0gbmV3IFNldChvcHRpb25zLmV2ZW50cyk7XG4gICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUhpZGRlbkluZGljZXMoKSB7XG4gICAgY29uc3Qge19oaWRkZW5JbmRpY2VzfSA9IHRoaXM7XG4gICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHx8IFtdO1xuICAgIGZvciAoY29uc3Qge21ldGhvZCwgc3RhcnQsIGNvdW50fSBvZiBjaGFuZ2VzKSB7XG4gICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgfVxuICB9XG4gIF9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB7XG4gICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgaWYgKCFfZGF0YUNoYW5nZXMgfHwgIV9kYXRhQ2hhbmdlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhc2V0Q291bnQgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgIGNvbnN0IG1ha2VTZXQgPSAoaWR4KSA9PiBuZXcgU2V0KFxuICAgICAgX2RhdGFDaGFuZ2VzXG4gICAgICAgIC5maWx0ZXIoYyA9PiBjWzBdID09PSBpZHgpXG4gICAgICAgIC5tYXAoKGMsIGkpID0+IGkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpXG4gICAgKTtcbiAgICBjb25zdCBjaGFuZ2VTZXQgPSBtYWtlU2V0KDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZGF0YXNldENvdW50OyBpKyspIHtcbiAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbShjaGFuZ2VTZXQpXG4gICAgICAubWFwKGMgPT4gYy5zcGxpdCgnLCcpKVxuICAgICAgLm1hcChhID0+ICh7bWV0aG9kOiBhWzFdLCBzdGFydDogK2FbMl0sIGNvdW50OiArYVszXX0pKTtcbiAgfVxuICBfdXBkYXRlTGF5b3V0KG1pblBhZGRpbmcpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVMYXlvdXQnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXlvdXRzLnVwZGF0ZSh0aGlzLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgbWluUGFkZGluZyk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIGVhY2godGhpcy5ib3hlcywgKGJveCkgPT4ge1xuICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChib3guY29uZmlndXJlKSB7XG4gICAgICAgIGJveC5jb25maWd1cmUoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKC4uLmJveC5fbGF5ZXJzKCkpO1xuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgaXRlbS5faWR4ID0gaW5kZXg7XG4gICAgfSk7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0cyhtb2RlKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNVcGRhdGUnLCB7bW9kZSwgY2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtkYXRhc2V0SW5kZXg6IGl9KSA6IG1vZGUpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNVcGRhdGUnLCB7bW9kZX0pO1xuICB9XG4gIF91cGRhdGVEYXRhc2V0KGluZGV4LCBtb2RlKSB7XG4gICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IGFyZ3MgPSB7bWV0YSwgaW5kZXgsIG1vZGUsIGNhbmNlbGFibGU6IHRydWV9O1xuICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURhdGFzZXRVcGRhdGUnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLl91cGRhdGUobW9kZSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlUmVuZGVyJywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGFuaW1hdG9yLmhhcyh0aGlzKSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWQgJiYgIWFuaW1hdG9yLnJ1bm5pbmcodGhpcykpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhdygpO1xuICAgICAgb25BbmltYXRpb25zQ29tcGxldGUoe2NoYXJ0OiB0aGlzfSk7XG4gICAgfVxuICB9XG4gIGRyYXcoKSB7XG4gICAgbGV0IGk7XG4gICAgaWYgKHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcpIHtcbiAgICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXc7XG4gICAgICB0aGlzLl9yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLl9yZXNpemVCZWZvcmVEcmF3ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEcmF3Jywge2NhbmNlbGFibGU6IHRydWV9KSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLl9kcmF3RGF0YXNldHMoKTtcbiAgICBmb3IgKDsgaSA8IGxheWVycy5sZW5ndGg7ICsraSkge1xuICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRHJhdycpO1xuICB9XG4gIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fc29ydGVkTWV0YXNldHM7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGksIGlsZW47XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgY29uc3QgbWV0YSA9IG1ldGFzZXRzW2ldO1xuICAgICAgaWYgKCFmaWx0ZXJWaXNpYmxlIHx8IG1ldGEudmlzaWJsZSkge1xuICAgICAgICByZXN1bHQucHVzaChtZXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTb3J0ZWREYXRhc2V0TWV0YXModHJ1ZSk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0cygpIHtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c0RyYXcnLCB7Y2FuY2VsYWJsZTogdHJ1ZX0pID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgIGZvciAobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGhpcy5fZHJhd0RhdGFzZXQobWV0YXNldHNbaV0pO1xuICAgIH1cbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldHNEcmF3Jyk7XG4gIH1cbiAgX2RyYXdEYXRhc2V0KG1ldGEpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjbGlwID0gbWV0YS5fY2xpcDtcbiAgICBjb25zdCB1c2VDbGlwID0gIWNsaXAuZGlzYWJsZWQ7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuY2hhcnRBcmVhO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBtZXRhLFxuICAgICAgaW5kZXg6IG1ldGEuaW5kZXgsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0RHJhdycsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgY2xpcEFyZWEoY3R4LCB7XG4gICAgICAgIGxlZnQ6IGNsaXAubGVmdCA9PT0gZmFsc2UgPyAwIDogYXJlYS5sZWZ0IC0gY2xpcC5sZWZ0LFxuICAgICAgICByaWdodDogY2xpcC5yaWdodCA9PT0gZmFsc2UgPyB0aGlzLndpZHRoIDogYXJlYS5yaWdodCArIGNsaXAucmlnaHQsXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gY2xpcC50b3AsXG4gICAgICAgIGJvdHRvbTogY2xpcC5ib3R0b20gPT09IGZhbHNlID8gdGhpcy5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIGNsaXAuYm90dG9tXG4gICAgICB9KTtcbiAgICB9XG4gICAgbWV0YS5jb250cm9sbGVyLmRyYXcoKTtcbiAgICBpZiAodXNlQ2xpcCkge1xuICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgIH1cbiAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgfVxuICBpc1BvaW50SW5BcmVhKHBvaW50KSB7XG4gICAgcmV0dXJuIF9pc1BvaW50SW5BcmVhKHBvaW50LCB0aGlzLmNoYXJ0QXJlYSwgdGhpcy5fbWluUGFkZGluZyk7XG4gIH1cbiAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3QgbWV0aG9kID0gSW50ZXJhY3Rpb24ubW9kZXNbbW9kZV07XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBtZXRob2QodGhpcywgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgY29uc3QgbWV0YXNldHMgPSB0aGlzLl9tZXRhc2V0cztcbiAgICBsZXQgbWV0YSA9IG1ldGFzZXRzLmZpbHRlcih4ID0+IHggJiYgeC5fZGF0YXNldCA9PT0gZGF0YXNldCkucG9wKCk7XG4gICAgaWYgKCFtZXRhKSB7XG4gICAgICBtZXRhID0ge1xuICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbCxcbiAgICAgICAgaGlkZGVuOiBudWxsLFxuICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICB5QXhpc0lEOiBudWxsLFxuICAgICAgICBvcmRlcjogZGF0YXNldCAmJiBkYXRhc2V0Lm9yZGVyIHx8IDAsXG4gICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgIF9kYXRhc2V0OiBkYXRhc2V0LFxuICAgICAgICBfcGFyc2VkOiBbXSxcbiAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsLCB7Y2hhcnQ6IHRoaXMsIHR5cGU6ICdjaGFydCd9KSk7XG4gIH1cbiAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkubGVuZ3RoO1xuICB9XG4gIGlzRGF0YXNldFZpc2libGUoZGF0YXNldEluZGV4KSB7XG4gICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIGlmICghZGF0YXNldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIHJldHVybiB0eXBlb2YgbWV0YS5oaWRkZW4gPT09ICdib29sZWFuJyA/ICFtZXRhLmhpZGRlbiA6ICFkYXRhc2V0LmhpZGRlbjtcbiAgfVxuICBzZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIG1ldGEuaGlkZGVuID0gIXZpc2libGU7XG4gIH1cbiAgdG9nZ2xlRGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgfVxuICBnZXREYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgIHJldHVybiAhdGhpcy5faGlkZGVuSW5kaWNlc1tpbmRleF07XG4gIH1cbiAgX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICBjb25zdCBtb2RlID0gdmlzaWJsZSA/ICdzaG93JyA6ICdoaWRlJztcbiAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgIGlmIChkZWZpbmVkKGRhdGFJbmRleCkpIHtcbiAgICAgIG1ldGEuZGF0YVtkYXRhSW5kZXhdLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXREYXRhc2V0VmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIHZpc2libGUpO1xuICAgICAgYW5pbXMudXBkYXRlKG1ldGEsIHt2aXNpYmxlfSk7XG4gICAgICB0aGlzLnVwZGF0ZSgoY3R4KSA9PiBjdHguZGF0YXNldEluZGV4ID09PSBkYXRhc2V0SW5kZXggPyBtb2RlIDogdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgaGlkZShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCkge1xuICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIGZhbHNlKTtcbiAgfVxuICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgdHJ1ZSk7XG4gIH1cbiAgX2Rlc3Ryb3lEYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICBpZiAobWV0YSAmJiBtZXRhLmNvbnRyb2xsZXIpIHtcbiAgICAgIG1ldGEuY29udHJvbGxlci5fZGVzdHJveSgpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgfVxuICBfc3RvcCgpIHtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICB0aGlzLnN0b3AoKTtcbiAgICBhbmltYXRvci5yZW1vdmUodGhpcyk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRoaXMuZGF0YS5kYXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICBjb25zdCB7Y2FudmFzLCBjdHh9ID0gdGhpcztcbiAgICB0aGlzLl9zdG9wKCk7XG4gICAgdGhpcy5jb25maWcuY2xlYXJDYWNoZSgpO1xuICAgIGlmIChjYW52YXMpIHtcbiAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCk7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbGVhc2VDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgICB0aGlzLmN0eCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMubm90aWZ5UGx1Z2lucygnZGVzdHJveScpO1xuICAgIGRlbGV0ZSBpbnN0YW5jZXNbdGhpcy5pZF07XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRlc3Ryb3knKTtcbiAgfVxuICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKC4uLmFyZ3MpO1xuICB9XG4gIGJpbmRFdmVudHMoKSB7XG4gICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgdGhpcy5iaW5kUmVzcG9uc2l2ZUV2ZW50cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYmluZFVzZXJFdmVudHMoKSB7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICBjb25zdCBfYWRkID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBwbGF0Zm9ybS5hZGRFdmVudExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIGxpc3RlbmVyc1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAoZSwgeCwgeSkgPT4ge1xuICAgICAgZS5vZmZzZXRYID0geDtcbiAgICAgIGUub2Zmc2V0WSA9IHk7XG4gICAgICB0aGlzLl9ldmVudEhhbmRsZXIoZSk7XG4gICAgfTtcbiAgICBlYWNoKHRoaXMub3B0aW9ucy5ldmVudHMsICh0eXBlKSA9PiBfYWRkKHR5cGUsIGxpc3RlbmVyKSk7XG4gIH1cbiAgYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0aGlzLnBsYXRmb3JtO1xuICAgIGNvbnN0IF9hZGQgPSAodHlwZSwgbGlzdGVuZXIpID0+IHtcbiAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlID0gKHR5cGUsIGxpc3RlbmVyKSA9PiB7XG4gICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgIHBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW3R5cGVdO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGRldGFjaGVkO1xuICAgIGNvbnN0IGF0dGFjaGVkID0gKCkgPT4ge1xuICAgICAgX3JlbW92ZSgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgdGhpcy5hdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgX2FkZCgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgX2FkZCgnZGV0YWNoJywgZGV0YWNoZWQpO1xuICAgIH07XG4gICAgZGV0YWNoZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICBfcmVtb3ZlKCdyZXNpemUnLCBsaXN0ZW5lcik7XG4gICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICB0aGlzLl9yZXNpemUoMCwgMCk7XG4gICAgICBfYWRkKCdhdHRhY2gnLCBhdHRhY2hlZCk7XG4gICAgfTtcbiAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgIGF0dGFjaGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRldGFjaGVkKCk7XG4gICAgfVxuICB9XG4gIHVuYmluZEV2ZW50cygpIHtcbiAgICBlYWNoKHRoaXMuX2xpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIGVhY2godGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycywgKGxpc3RlbmVyLCB0eXBlKSA9PiB7XG4gICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IHByZWZpeCA9IGVuYWJsZWQgPyAnc2V0JyA6ICdyZW1vdmUnO1xuICAgIGxldCBtZXRhLCBpdGVtLCBpLCBpbGVuO1xuICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXJbcHJlZml4ICsgJ0hvdmVyU3R5bGUnXShpdGVtLmVsZW1lbnQsIGl0ZW0uZGF0YXNldEluZGV4LCBpdGVtLmluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICBlbGVtZW50OiBtZXRhLmRhdGFbaW5kZXhdLFxuICAgICAgICBpbmRleCxcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9sYXN0RXZlbnQgPSBudWxsO1xuICAgICAgdGhpcy5fdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICB9XG4gIH1cbiAgbm90aWZ5UGx1Z2lucyhob29rLCBhcmdzLCBmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5ub3RpZnkodGhpcywgaG9vaywgYXJncywgZmlsdGVyKTtcbiAgfVxuICBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICBjb25zdCBob3Zlck9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuaG92ZXI7XG4gICAgY29uc3QgZGlmZiA9IChhLCBiKSA9PiBhLmZpbHRlcih4ID0+ICFiLnNvbWUoeSA9PiB4LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgIGNvbnN0IGRlYWN0aXZhdGVkID0gZGlmZihsYXN0QWN0aXZlLCBhY3RpdmUpO1xuICAgIGNvbnN0IGFjdGl2YXRlZCA9IHJlcGxheSA/IGFjdGl2ZSA6IGRpZmYoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhY3RpdmF0ZWQubGVuZ3RoICYmIGhvdmVyT3B0aW9ucy5tb2RlKSB7XG4gICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoYWN0aXZhdGVkLCBob3Zlck9wdGlvbnMubW9kZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIF9ldmVudEhhbmRsZXIoZSwgcmVwbGF5KSB7XG4gICAgY29uc3QgYXJncyA9IHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgcmVwbGF5LFxuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIGluQ2hhcnRBcmVhOiB0aGlzLmlzUG9pbnRJbkFyZWEoZSlcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50RmlsdGVyID0gKHBsdWdpbikgPT4gKHBsdWdpbi5vcHRpb25zLmV2ZW50cyB8fCB0aGlzLm9wdGlvbnMuZXZlbnRzKS5pbmNsdWRlcyhlLm5hdGl2ZS50eXBlKTtcbiAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgYXJncy5pbkNoYXJ0QXJlYSk7XG4gICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckV2ZW50JywgYXJncywgZXZlbnRGaWx0ZXIpO1xuICAgIGlmIChjaGFuZ2VkIHx8IGFyZ3MuY2hhbmdlZCkge1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgX2hhbmRsZUV2ZW50KGUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCB7X2FjdGl2ZTogbGFzdEFjdGl2ZSA9IFtdLCBvcHRpb25zfSA9IHRoaXM7XG4gICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IHJlcGxheTtcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3QgaXNDbGljayA9IF9pc0NsaWNrRXZlbnQoZSk7XG4gICAgY29uc3QgbGFzdEV2ZW50ID0gZGV0ZXJtaW5lTGFzdEV2ZW50KGUsIHRoaXMuX2xhc3RFdmVudCwgaW5DaGFydEFyZWEsIGlzQ2xpY2spO1xuICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW2UsIGFjdGl2ZSwgdGhpc10sIHRoaXMpO1xuICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgY2FsbGJhY2sob3B0aW9ucy5vbkNsaWNrLCBbZSwgYWN0aXZlLCB0aGlzXSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICB9XG4gICAgdGhpcy5fbGFzdEV2ZW50ID0gbGFzdEV2ZW50O1xuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIF9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c0F0RXZlbnRGb3JNb2RlKGUsIGhvdmVyT3B0aW9ucy5tb2RlLCBob3Zlck9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG59XG5jb25zdCBpbnZhbGlkYXRlUGx1Z2lucyA9ICgpID0+IGVhY2goQ2hhcnQuaW5zdGFuY2VzLCAoY2hhcnQpID0+IGNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG5jb25zdCBlbnVtZXJhYmxlID0gdHJ1ZTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENoYXJ0LCB7XG4gIGRlZmF1bHRzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZGVmYXVsdHNcbiAgfSxcbiAgaW5zdGFuY2VzOiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogaW5zdGFuY2VzXG4gIH0sXG4gIG92ZXJyaWRlczoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IG92ZXJyaWRlc1xuICB9LFxuICByZWdpc3RyeToge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6IHJlZ2lzdHJ5XG4gIH0sXG4gIHZlcnNpb246IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiB2ZXJzaW9uXG4gIH0sXG4gIGdldENoYXJ0OiB7XG4gICAgZW51bWVyYWJsZSxcbiAgICB2YWx1ZTogZ2V0Q2hhcnRcbiAgfSxcbiAgcmVnaXN0ZXI6IHtcbiAgICBlbnVtZXJhYmxlLFxuICAgIHZhbHVlOiAoLi4uaXRlbXMpID0+IHtcbiAgICAgIHJlZ2lzdHJ5LmFkZCguLi5pdGVtcyk7XG4gICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3Rlcjoge1xuICAgIGVudW1lcmFibGUsXG4gICAgdmFsdWU6ICguLi5pdGVtcykgPT4ge1xuICAgICAgcmVnaXN0cnkucmVtb3ZlKC4uLml0ZW1zKTtcbiAgICAgIGludmFsaWRhdGVQbHVnaW5zKCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gY2xpcEFyYyhjdHgsIGVsZW1lbnQsIGVuZEFuZ2xlKSB7XG4gIGNvbnN0IHtzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgeCwgeSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzfSA9IGVsZW1lbnQ7XG4gIGxldCBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gb3V0ZXJSYWRpdXM7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgaWYgKGlubmVyUmFkaXVzID4gcGl4ZWxNYXJnaW4pIHtcbiAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgKyBhbmdsZU1hcmdpbiwgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguYXJjKHgsIHksIHBpeGVsTWFyZ2luLCBlbmRBbmdsZSArIEhBTEZfUEksIHN0YXJ0QW5nbGUgLSBIQUxGX1BJKTtcbiAgfVxuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiB0b1JhZGl1c0Nvcm5lcnModmFsdWUpIHtcbiAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbJ291dGVyU3RhcnQnLCAnb3V0ZXJFbmQnLCAnaW5uZXJTdGFydCcsICdpbm5lckVuZCddKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgY29uc3QgbyA9IHRvUmFkaXVzQ29ybmVycyhhcmMub3B0aW9ucy5ib3JkZXJSYWRpdXMpO1xuICBjb25zdCBoYWxmVGhpY2tuZXNzID0gKG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMpIC8gMjtcbiAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBvdXRlckFyY0xpbWl0ID0gKG91dGVyUmFkaXVzIC0gTWF0aC5taW4oaGFsZlRoaWNrbmVzcywgdmFsKSkgKiBhbmdsZURlbHRhIC8gMjtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gIH07XG4gIHJldHVybiB7XG4gICAgb3V0ZXJTdGFydDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlclN0YXJ0KSxcbiAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgaW5uZXJTdGFydDogX2xpbWl0VmFsdWUoby5pbm5lclN0YXJ0LCAwLCBpbm5lckxpbWl0KSxcbiAgICBpbm5lckVuZDogX2xpbWl0VmFsdWUoby5pbm5lckVuZCwgMCwgaW5uZXJMaW1pdCksXG4gIH07XG59XG5mdW5jdGlvbiByVGhldGFUb1hZKHIsIHRoZXRhLCB4LCB5KSB7XG4gIHJldHVybiB7XG4gICAgeDogeCArIHIgKiBNYXRoLmNvcyh0aGV0YSksXG4gICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSksXG4gIH07XG59XG5mdW5jdGlvbiBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmQsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlOiBzdGFydCwgcGl4ZWxNYXJnaW4sIGlubmVyUmFkaXVzOiBpbm5lclJ9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzICsgc3BhY2luZyArIG9mZnNldCAtIHBpeGVsTWFyZ2luLCAwKTtcbiAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgbGV0IHNwYWNpbmdPZmZzZXQgPSAwO1xuICBjb25zdCBhbHBoYSA9IGVuZCAtIHN0YXJ0O1xuICBpZiAoc3BhY2luZykge1xuICAgIGNvbnN0IG5vU3BhY2luZ0lubmVyUmFkaXVzID0gaW5uZXJSID4gMCA/IGlubmVyUiAtIHNwYWNpbmcgOiAwO1xuICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICBjb25zdCBhdk5vZ1NwYWNpbmdSYWRpdXMgPSAobm9TcGFjaW5nSW5uZXJSYWRpdXMgKyBub1NwYWNpbmdPdXRlclJhZGl1cykgLyAyO1xuICAgIGNvbnN0IGFkanVzdGVkQW5nbGUgPSBhdk5vZ1NwYWNpbmdSYWRpdXMgIT09IDAgPyAoYWxwaGEgKiBhdk5vZ1NwYWNpbmdSYWRpdXMpIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgc3BhY2luZ09mZnNldCA9IChhbHBoYSAtIGFkanVzdGVkQW5nbGUpIC8gMjtcbiAgfVxuICBjb25zdCBiZXRhID0gTWF0aC5tYXgoMC4wMDEsIGFscGhhICogb3V0ZXJSYWRpdXMgLSBvZmZzZXQgLyBQSSkgLyBvdXRlclJhZGl1cztcbiAgY29uc3QgYW5nbGVPZmZzZXQgPSAoYWxwaGEgLSBiZXRhKSAvIDI7XG4gIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgY29uc3QgZW5kQW5nbGUgPSBlbmQgLSBhbmdsZU9mZnNldCAtIHNwYWNpbmdPZmZzZXQ7XG4gIGNvbnN0IHtvdXRlclN0YXJ0LCBvdXRlckVuZCwgaW5uZXJTdGFydCwgaW5uZXJFbmR9ID0gcGFyc2VCb3JkZXJSYWRpdXMkMShlbGVtZW50LCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgY29uc3Qgb3V0ZXJFbmRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJFbmQ7XG4gIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlID0gc3RhcnRBbmdsZSArIG91dGVyU3RhcnQgLyBvdXRlclN0YXJ0QWRqdXN0ZWRSYWRpdXM7XG4gIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyU3RhcnQ7XG4gIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMgPSBpbm5lclJhZGl1cyArIGlubmVyRW5kO1xuICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICBjb25zdCBpbm5lckVuZEFkanVzdGVkQW5nbGUgPSBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJFbmRBZGp1c3RlZFJhZGl1cztcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBpZiAoY2lyY3VsYXIpIHtcbiAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlKTtcbiAgICBpZiAob3V0ZXJFbmQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShvdXRlckVuZEFkanVzdGVkUmFkaXVzLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJFbmQsIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSwgZW5kQW5nbGUgKyBIQUxGX1BJKTtcbiAgICB9XG4gICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA0LngsIHA0LnkpO1xuICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICB9XG4gICAgY3R4LmFyYyh4LCB5LCBpbm5lclJhZGl1cywgZW5kQW5nbGUgLSAoaW5uZXJFbmQgLyBpbm5lclJhZGl1cyksIHN0YXJ0QW5nbGUgKyAoaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSwgdHJ1ZSk7XG4gICAgaWYgKGlubmVyU3RhcnQgPiAwKSB7XG4gICAgICBjb25zdCBwQ2VudGVyID0gclRoZXRhVG9YWShpbm5lclN0YXJ0QWRqdXN0ZWRSYWRpdXMsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIGlubmVyU3RhcnQsIGlubmVyU3RhcnRBZGp1c3RlZEFuZ2xlICsgTWF0aC5QSSwgc3RhcnRBbmdsZSAtIEhBTEZfUEkpO1xuICAgIH1cbiAgICBjb25zdCBwOCA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBzdGFydEFuZ2xlLCB4LCB5KTtcbiAgICBjdHgubGluZVRvKHA4LngsIHA4LnkpO1xuICAgIGlmIChvdXRlclN0YXJ0ID4gMCkge1xuICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBvdXRlclN0YXJ0LCBzdGFydEFuZ2xlIC0gSEFMRl9QSSwgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyU3RhcnRZID0gTWF0aC5zaW4ob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgIGN0eC5saW5lVG8ob3V0ZXJTdGFydFgsIG91dGVyU3RhcnRZKTtcbiAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgIGNvbnN0IG91dGVyRW5kWSA9IE1hdGguc2luKG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgKiBvdXRlclJhZGl1cyArIHk7XG4gICAgY3R4LmxpbmVUbyhvdXRlckVuZFgsIG91dGVyRW5kWSk7XG4gIH1cbiAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpIHtcbiAgY29uc3Qge2Z1bGxDaXJjbGVzLCBzdGFydEFuZ2xlLCBjaXJjdW1mZXJlbmNlfSA9IGVsZW1lbnQ7XG4gIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gIGlmIChmdWxsQ2lyY2xlcykge1xuICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIHN0YXJ0QW5nbGUgKyBUQVUsIGNpcmN1bGFyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaXJjbGVzOyArK2kpIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICAgIGlmICghaXNOYU4oY2lyY3VtZmVyZW5jZSkpIHtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UgJSBUQVU7XG4gICAgICBpZiAoY2lyY3VtZmVyZW5jZSAlIFRBVSA9PT0gMCkge1xuICAgICAgICBlbmRBbmdsZSArPSBUQVU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5maWxsKCk7XG4gIHJldHVybiBlbmRBbmdsZTtcbn1cbmZ1bmN0aW9uIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKSB7XG4gIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBwaXhlbE1hcmdpbiwgZnVsbENpcmNsZXN9ID0gZWxlbWVudDtcbiAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heChlbGVtZW50Lm91dGVyUmFkaXVzIC0gcGl4ZWxNYXJnaW4sIDApO1xuICBjb25zdCBpbm5lclJhZGl1cyA9IGVsZW1lbnQuaW5uZXJSYWRpdXMgKyBwaXhlbE1hcmdpbjtcbiAgbGV0IGk7XG4gIGlmIChpbm5lcikge1xuICAgIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBzdGFydEFuZ2xlICsgVEFVKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIHN0YXJ0QW5nbGUgKyBUQVUsIHN0YXJ0QW5nbGUsIHRydWUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxuICBjdHguYmVnaW5QYXRoKCk7XG4gIGN0eC5hcmMoeCwgeSwgb3V0ZXJSYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBUQVUpO1xuICBmb3IgKGkgPSAwOyBpIDwgZnVsbENpcmNsZXM7ICsraSkge1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfVxufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgZW5kQW5nbGUsIGNpcmN1bGFyKSB7XG4gIGNvbnN0IHtvcHRpb25zfSA9IGVsZW1lbnQ7XG4gIGNvbnN0IHtib3JkZXJXaWR0aCwgYm9yZGVySm9pblN0eWxlfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcbiAgaWYgKCFib3JkZXJXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyV2lkdGggKiAyO1xuICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICB9IGVsc2Uge1xuICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICBjdHgubGluZUpvaW4gPSBib3JkZXJKb2luU3R5bGUgfHwgJ2JldmVsJztcbiAgfVxuICBpZiAoZWxlbWVudC5mdWxsQ2lyY2xlcykge1xuICAgIGRyYXdGdWxsQ2lyY2xlQm9yZGVycyhjdHgsIGVsZW1lbnQsIGlubmVyKTtcbiAgfVxuICBpZiAoaW5uZXIpIHtcbiAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICB9XG4gIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gIGN0eC5zdHJva2UoKTtcbn1cbmNsYXNzIEFyY0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jaXJjdW1mZXJlbmNlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZEFuZ2xlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBpeGVsTWFyZ2luID0gMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gMDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoY2hhcnRYLCBjaGFydFksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgY29uc3Qge2FuZ2xlLCBkaXN0YW5jZX0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge3g6IGNoYXJ0WCwgeTogY2hhcnRZfSk7XG4gICAgY29uc3Qge3N0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNpcmN1bWZlcmVuY2V9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAnZW5kQW5nbGUnLFxuICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICBjb25zdCByQWRqdXN0ID0gdGhpcy5vcHRpb25zLnNwYWNpbmcgLyAyO1xuICAgIGNvbnN0IF9jaXJjdW1mZXJlbmNlID0gdmFsdWVPckRlZmF1bHQoY2lyY3VtZmVyZW5jZSwgZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICBjb25zdCBiZXR3ZWVuQW5nbGVzID0gX2NpcmN1bWZlcmVuY2UgPj0gVEFVIHx8IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICBjb25zdCB3aXRoaW5SYWRpdXMgPSBfaXNCZXR3ZWVuKGRpc3RhbmNlLCBpbm5lclJhZGl1cyArIHJBZGp1c3QsIG91dGVyUmFkaXVzICsgckFkanVzdCk7XG4gICAgcmV0dXJuIChiZXR3ZWVuQW5nbGVzICYmIHdpdGhpblJhZGl1cyk7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgJ3gnLFxuICAgICAgJ3knLFxuICAgICAgJ3N0YXJ0QW5nbGUnLFxuICAgICAgJ2VuZEFuZ2xlJyxcbiAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIGNvbnN0IHtvZmZzZXQsIHNwYWNpbmd9ID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGhhbGZBbmdsZSA9IChzdGFydEFuZ2xlICsgZW5kQW5nbGUpIC8gMjtcbiAgICBjb25zdCBoYWxmUmFkaXVzID0gKGlubmVyUmFkaXVzICsgb3V0ZXJSYWRpdXMgKyBzcGFjaW5nICsgb2Zmc2V0KSAvIDI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgIH07XG4gIH1cbiAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtvcHRpb25zLCBjaXJjdW1mZXJlbmNlfSA9IHRoaXM7XG4gICAgY29uc3Qgb2Zmc2V0ID0gKG9wdGlvbnMub2Zmc2V0IHx8IDApIC8gMjtcbiAgICBjb25zdCBzcGFjaW5nID0gKG9wdGlvbnMuc3BhY2luZyB8fCAwKSAvIDI7XG4gICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgIHRoaXMucGl4ZWxNYXJnaW4gPSAob3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJykgPyAwLjMzIDogMDtcbiAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlID09PSAwIHx8IHRoaXMuaW5uZXJSYWRpdXMgPCAwIHx8IHRoaXMub3V0ZXJSYWRpdXMgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHJhZGl1c09mZnNldCA9IDA7XG4gICAgaWYgKG9mZnNldCkge1xuICAgICAgcmFkaXVzT2Zmc2V0ID0gb2Zmc2V0IC8gMjtcbiAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICBjdHgudHJhbnNsYXRlKE1hdGguY29zKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQsIE1hdGguc2luKGhhbGZBbmdsZSkgKiByYWRpdXNPZmZzZXQpO1xuICAgICAgaWYgKHRoaXMuY2lyY3VtZmVyZW5jZSA+PSBQSSkge1xuICAgICAgICByYWRpdXNPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGNvbnN0IGVuZEFuZ2xlID0gZHJhd0FyYyhjdHgsIHRoaXMsIHJhZGl1c09mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpO1xuICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuQXJjRWxlbWVudC5pZCA9ICdhcmMnO1xuQXJjRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQWxpZ246ICdjZW50ZXInLFxuICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgYm9yZGVyUmFkaXVzOiAwLFxuICBib3JkZXJXaWR0aDogMixcbiAgb2Zmc2V0OiAwLFxuICBzcGFjaW5nOiAwLFxuICBhbmdsZTogdW5kZWZpbmVkLFxuICBjaXJjdWxhcjogdHJ1ZSxcbn07XG5BcmNFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbn07XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyQ2FwU3R5bGUsIG9wdGlvbnMuYm9yZGVyQ2FwU3R5bGUpO1xuICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyRGFzaCwgb3B0aW9ucy5ib3JkZXJEYXNoKSk7XG4gIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckpvaW5TdHlsZSwgb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUpO1xuICBjdHgubGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVyV2lkdGgsIG9wdGlvbnMuYm9yZGVyV2lkdGgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbmZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5zdGVwcGVkKSB7XG4gICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICB9XG4gIGlmIChvcHRpb25zLnRlbnNpb24gfHwgb3B0aW9ucy5jdWJpY0ludGVycG9sYXRpb25Nb2RlID09PSAnbW9ub3RvbmUnKSB7XG4gICAgcmV0dXJuIF9iZXppZXJDdXJ2ZVRvO1xuICB9XG4gIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3Qge3N0YXJ0OiBwYXJhbXNTdGFydCA9IDAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxfSA9IHBhcmFtcztcbiAgY29uc3Qge3N0YXJ0OiBzZWdtZW50U3RhcnQsIGVuZDogc2VnbWVudEVuZH0gPSBzZWdtZW50O1xuICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHBhcmFtc1N0YXJ0LCBzZWdtZW50U3RhcnQpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICBjb25zdCBvdXRzaWRlID0gcGFyYW1zU3RhcnQgPCBzZWdtZW50U3RhcnQgJiYgcGFyYW1zRW5kIDwgc2VnbWVudFN0YXJ0IHx8IHBhcmFtc1N0YXJ0ID4gc2VnbWVudEVuZCAmJiBwYXJhbXNFbmQgPiBzZWdtZW50RW5kO1xuICByZXR1cm4ge1xuICAgIGNvdW50LFxuICAgIHN0YXJ0LFxuICAgIGxvb3A6IHNlZ21lbnQubG9vcCxcbiAgICBpbGVuOiBlbmQgPCBzdGFydCAmJiAhb3V0c2lkZSA/IGNvdW50ICsgZW5kIC0gc3RhcnQgOiBlbmQgLSBzdGFydFxuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNlZ21lbnQoY3R4LCBsaW5lLCBzZWdtZW50LCBwYXJhbXMpIHtcbiAgY29uc3Qge3BvaW50cywgb3B0aW9uc30gPSBsaW5lO1xuICBjb25zdCB7Y291bnQsIHN0YXJ0LCBsb29wLCBpbGVufSA9IHBhdGhWYXJzKHBvaW50cywgc2VnbWVudCwgcGFyYW1zKTtcbiAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gIGxldCB7bW92ZSA9IHRydWUsIHJldmVyc2V9ID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgaSwgcG9pbnQsIHByZXY7XG4gIGZvciAoaSA9IDA7IGkgPD0gaWxlbjsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbKHN0YXJ0ICsgKHJldmVyc2UgPyBpbGVuIC0gaSA6IGkpKSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtb3ZlKSB7XG4gICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgbW92ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gICAgfVxuICAgIHByZXYgPSBwb2ludDtcbiAgfVxuICBpZiAobG9vcCkge1xuICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICBsaW5lTWV0aG9kKGN0eCwgcHJldiwgcG9pbnQsIHJldmVyc2UsIG9wdGlvbnMuc3RlcHBlZCk7XG4gIH1cbiAgcmV0dXJuICEhbG9vcDtcbn1cbmZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qge2NvdW50LCBzdGFydCwgaWxlbn0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIGNvbnN0IHttb3ZlID0gdHJ1ZSwgcmV2ZXJzZX0gPSBwYXJhbXMgfHwge307XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgcHJldlgsIG1pblksIG1heFksIGxhc3RZO1xuICBjb25zdCBwb2ludEluZGV4ID0gKGluZGV4KSA9PiAoc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpbmRleCA6IGluZGV4KSkgJSBjb3VudDtcbiAgY29uc3QgZHJhd1ggPSAoKSA9PiB7XG4gICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgfVxuICB9O1xuICBpZiAobW92ZSkge1xuICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8PSBpbGVuOyArK2kpIHtcbiAgICBwb2ludCA9IHBvaW50c1twb2ludEluZGV4KGkpXTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHggPSBwb2ludC54O1xuICAgIGNvbnN0IHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgIG1heFkgPSB5O1xuICAgICAgfVxuICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgeCkgLyArK2NvdW50WDtcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1goKTtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgIGNvdW50WCA9IDA7XG4gICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgfVxuICAgIGxhc3RZID0geTtcbiAgfVxuICBkcmF3WCgpO1xufVxuZnVuY3Rpb24gX2dldFNlZ21lbnRNZXRob2QobGluZSkge1xuICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBib3JkZXJEYXNoID0gb3B0cy5ib3JkZXJEYXNoICYmIG9wdHMuYm9yZGVyRGFzaC5sZW5ndGg7XG4gIGNvbnN0IHVzZUZhc3RQYXRoID0gIWxpbmUuX2RlY2ltYXRlZCAmJiAhbGluZS5fbG9vcCAmJiAhb3B0cy50ZW5zaW9uICYmIG9wdHMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSAhPT0gJ21vbm90b25lJyAmJiAhb3B0cy5zdGVwcGVkICYmICFib3JkZXJEYXNoO1xuICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbmZ1bmN0aW9uIF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgIHJldHVybiBfc3RlcHBlZEludGVycG9sYXRpb247XG4gIH1cbiAgaWYgKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpIHtcbiAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gIH1cbiAgcmV0dXJuIF9wb2ludEluTGluZTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICBpZiAoIXBhdGgpIHtcbiAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICBpZiAobGluZS5wYXRoKHBhdGgsIHN0YXJ0LCBjb3VudCkpIHtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgY3R4LnN0cm9rZShwYXRoKTtcbn1cbmZ1bmN0aW9uIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge3NlZ21lbnRzLCBvcHRpb25zfSA9IGxpbmU7XG4gIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZChsaW5lKTtcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgaWYgKHNlZ21lbnRNZXRob2QoY3R4LCBsaW5lLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KSkge1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmNvbnN0IHVzZVBhdGgyRCA9IHR5cGVvZiBQYXRoMkQgPT09ICdmdW5jdGlvbic7XG5mdW5jdGlvbiBkcmF3KGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgc3Ryb2tlUGF0aFdpdGhDYWNoZShjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH0gZWxzZSB7XG4gICAgc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCk7XG4gIH1cbn1cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2xvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZnVsbExvb3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9wb2ludHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fc2VnbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2RhdGFzZXRJbmRleCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY2ZnKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZUNvbnRyb2xQb2ludHMoY2hhcnRBcmVhLCBpbmRleEF4aXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICgob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykgJiYgIW9wdGlvbnMuc3RlcHBlZCAmJiAhdGhpcy5fcG9pbnRzVXBkYXRlZCkge1xuICAgICAgY29uc3QgbG9vcCA9IG9wdGlvbnMuc3BhbkdhcHMgPyB0aGlzLl9sb29wIDogdGhpcy5fZnVsbExvb3A7XG4gICAgICBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyh0aGlzLl9wb2ludHMsIG9wdGlvbnMsIGNoYXJ0QXJlYSwgbG9vcCwgaW5kZXhBeGlzKTtcbiAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcbiAgICBkZWxldGUgdGhpcy5fc2VnbWVudHM7XG4gICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgdGhpcy5fcG9pbnRzVXBkYXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBwb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgfVxuICBnZXQgc2VnbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlZ21lbnRzIHx8ICh0aGlzLl9zZWdtZW50cyA9IF9jb21wdXRlU2VnbWVudHModGhpcywgdGhpcy5vcHRpb25zLnNlZ21lbnQpKTtcbiAgfVxuICBmaXJzdCgpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICB9XG4gIGxhc3QoKSB7XG4gICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgIGNvbnN0IGNvdW50ID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHJldHVybiBjb3VudCAmJiBwb2ludHNbc2VnbWVudHNbY291bnQgLSAxXS5lbmRdO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBfYm91bmRTZWdtZW50cyh0aGlzLCB7cHJvcGVydHksIHN0YXJ0OiB2YWx1ZSwgZW5kOiB2YWx1ZX0pO1xuICAgIGlmICghc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IF9pbnRlcnBvbGF0ZSA9IF9nZXRJbnRlcnBvbGF0aW9uTWV0aG9kKG9wdGlvbnMpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnRzW2ldO1xuICAgICAgY29uc3QgcDEgPSBwb2ludHNbc3RhcnRdO1xuICAgICAgY29uc3QgcDIgPSBwb2ludHNbZW5kXTtcbiAgICAgIGlmIChwMSA9PT0gcDIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocDEpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA9PT0gMSA/IHJlc3VsdFswXSA6IHJlc3VsdDtcbiAgfVxuICBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICByZXR1cm4gc2VnbWVudE1ldGhvZChjdHgsIHRoaXMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gIH1cbiAgcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cztcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgICBjb3VudCA9IGNvdW50IHx8ICh0aGlzLnBvaW50cy5sZW5ndGggLSBzdGFydCk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7c3RhcnQsIGVuZDogc3RhcnQgKyBjb3VudCAtIDF9KTtcbiAgICB9XG4gICAgcmV0dXJuICEhbG9vcDtcbiAgfVxuICBkcmF3KGN0eCwgY2hhcnRBcmVhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuICAgIGlmIChwb2ludHMubGVuZ3RoICYmIG9wdGlvbnMuYm9yZGVyV2lkdGgpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBkcmF3KGN0eCwgdGhpcywgc3RhcnQsIGNvdW50KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuTGluZUVsZW1lbnQuaWQgPSAnbGluZSc7XG5MaW5lRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgYm9yZGVyRGFzaDogW10sXG4gIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgYm9yZGVyV2lkdGg6IDMsXG4gIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICBmaWxsOiBmYWxzZSxcbiAgc3BhbkdhcHM6IGZhbHNlLFxuICBzdGVwcGVkOiBmYWxzZSxcbiAgdGVuc2lvbjogMCxcbn07XG5MaW5lRWxlbWVudC5kZWZhdWx0Um91dGVzID0ge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICdiYWNrZ3JvdW5kQ29sb3InLFxuICBib3JkZXJDb2xvcjogJ2JvcmRlckNvbG9yJ1xufTtcbkxpbmVFbGVtZW50LmRlc2NyaXB0b3JzID0ge1xuICBfc2NyaXB0YWJsZTogdHJ1ZSxcbiAgX2luZGV4YWJsZTogKG5hbWUpID0+IG5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCcsXG59O1xuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICBjb25zdCBvcHRpb25zID0gZWwub3B0aW9ucztcbiAgY29uc3Qge1theGlzXTogdmFsdWV9ID0gZWwuZ2V0UHJvcHMoW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgcmV0dXJuIChNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzKTtcbn1cbmNsYXNzIFBvaW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnBhcnNlZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zdG9wID0gdW5kZWZpbmVkO1xuICAgIGlmIChjZmcpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICB9XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4gKChNYXRoLnBvdyhtb3VzZVggLSB4LCAyKSArIE1hdGgucG93KG1vdXNlWSAtIHksIDIpKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWCwgJ3gnLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBnZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qge3gsIHl9ID0gdGhpcy5nZXRQcm9wcyhbJ3gnLCAneSddLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge3gsIHl9O1xuICB9XG4gIHNpemUob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIHJhZGl1cyAmJiBvcHRpb25zLmhvdmVyUmFkaXVzIHx8IDApO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gcmFkaXVzICYmIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMDtcbiAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gIH1cbiAgZHJhdyhjdHgsIGFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgIGRyYXdQb2ludChjdHgsIG9wdGlvbnMsIHRoaXMueCwgdGhpcy55KTtcbiAgfVxuICBnZXRSYW5nZSgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xuICB9XG59XG5Qb2ludEVsZW1lbnQuaWQgPSAncG9pbnQnO1xuUG9pbnRFbGVtZW50LmRlZmF1bHRzID0ge1xuICBib3JkZXJXaWR0aDogMSxcbiAgaGl0UmFkaXVzOiAxLFxuICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICBob3ZlclJhZGl1czogNCxcbiAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gIHJhZGl1czogMyxcbiAgcm90YXRpb246IDBcbn07XG5Qb2ludEVsZW1lbnQuZGVmYXVsdFJvdXRlcyA9IHtcbiAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbn07XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qge3gsIHksIGJhc2UsIHdpZHRoLCBoZWlnaHR9ID0gYmFyLmdldFByb3BzKFsneCcsICd5JywgJ2Jhc2UnLCAnd2lkdGgnLCAnaGVpZ2h0J10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICBsZXQgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBoYWxmO1xuICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICBoYWxmID0gaGVpZ2h0IC8gMjtcbiAgICBsZWZ0ID0gTWF0aC5taW4oeCwgYmFzZSk7XG4gICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICB0b3AgPSB5IC0gaGFsZjtcbiAgICBib3R0b20gPSB5ICsgaGFsZjtcbiAgfSBlbHNlIHtcbiAgICBoYWxmID0gd2lkdGggLyAyO1xuICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICByaWdodCA9IHggKyBoYWxmO1xuICAgIHRvcCA9IE1hdGgubWluKHksIGJhc2UpO1xuICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICB9XG4gIHJldHVybiB7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfTtcbn1cbmZ1bmN0aW9uIHNraXBPckxpbWl0KHNraXAsIHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gc2tpcCA/IDAgOiBfbGltaXRWYWx1ZSh2YWx1ZSwgbWluLCBtYXgpO1xufVxuZnVuY3Rpb24gcGFyc2VCb3JkZXJXaWR0aChiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBvID0gdG9UUkJMKHZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICB0OiBza2lwT3JMaW1pdChza2lwLnRvcCwgby50b3AsIDAsIG1heEgpLFxuICAgIHI6IHNraXBPckxpbWl0KHNraXAucmlnaHQsIG8ucmlnaHQsIDAsIG1heFcpLFxuICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgbDogc2tpcE9yTGltaXQoc2tpcC5sZWZ0LCBvLmxlZnQsIDAsIG1heFcpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgY29uc3Qge2VuYWJsZUJvcmRlclJhZGl1c30gPSBiYXIuZ2V0UHJvcHMoWydlbmFibGVCb3JkZXJSYWRpdXMnXSk7XG4gIGNvbnN0IHZhbHVlID0gYmFyLm9wdGlvbnMuYm9yZGVyUmFkaXVzO1xuICBjb25zdCBvID0gdG9UUkJMQ29ybmVycyh2YWx1ZSk7XG4gIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgY29uc3Qgc2tpcCA9IGJhci5ib3JkZXJTa2lwcGVkO1xuICBjb25zdCBlbmFibGVCb3JkZXIgPSBlbmFibGVCb3JkZXJSYWRpdXMgfHwgaXNPYmplY3QodmFsdWUpO1xuICByZXR1cm4ge1xuICAgIHRvcExlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5sZWZ0LCBvLnRvcExlZnQsIDAsIG1heFIpLFxuICAgIHRvcFJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAucmlnaHQsIG8udG9wUmlnaHQsIDAsIG1heFIpLFxuICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgIGJvdHRvbVJpZ2h0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAuYm90dG9tIHx8IHNraXAucmlnaHQsIG8uYm90dG9tUmlnaHQsIDAsIG1heFIpXG4gIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICBjb25zdCBib3VuZHMgPSBnZXRCYXJCb3VuZHMoYmFyKTtcbiAgY29uc3Qgd2lkdGggPSBib3VuZHMucmlnaHQgLSBib3VuZHMubGVmdDtcbiAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gIGNvbnN0IGJvcmRlciA9IHBhcnNlQm9yZGVyV2lkdGgoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICBjb25zdCByYWRpdXMgPSBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gIHJldHVybiB7XG4gICAgb3V0ZXI6IHtcbiAgICAgIHg6IGJvdW5kcy5sZWZ0LFxuICAgICAgeTogYm91bmRzLnRvcCxcbiAgICAgIHc6IHdpZHRoLFxuICAgICAgaDogaGVpZ2h0LFxuICAgICAgcmFkaXVzXG4gICAgfSxcbiAgICBpbm5lcjoge1xuICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICByYWRpdXM6IHtcbiAgICAgICAgdG9wTGVmdDogTWF0aC5tYXgoMCwgcmFkaXVzLnRvcExlZnQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLmwpKSxcbiAgICAgICAgdG9wUmlnaHQ6IE1hdGgubWF4KDAsIHJhZGl1cy50b3BSaWdodCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIucikpLFxuICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICBib3R0b21SaWdodDogTWF0aC5tYXgoMCwgcmFkaXVzLmJvdHRvbVJpZ2h0IC0gTWF0aC5tYXgoYm9yZGVyLmIsIGJvcmRlci5yKSksXG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gaW5SYW5nZShiYXIsIHgsIHksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICBjb25zdCBza2lwWSA9IHkgPT09IG51bGw7XG4gIGNvbnN0IHNraXBCb3RoID0gc2tpcFggJiYgc2tpcFk7XG4gIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gIHJldHVybiBib3VuZHNcblx0XHQmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSlcblx0XHQmJiAoc2tpcFkgfHwgX2lzQmV0d2Vlbih5LCBib3VuZHMudG9wLCBib3VuZHMuYm90dG9tKSk7XG59XG5mdW5jdGlvbiBoYXNSYWRpdXMocmFkaXVzKSB7XG4gIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuZnVuY3Rpb24gYWRkTm9ybWFsUmVjdFBhdGgoY3R4LCByZWN0KSB7XG4gIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICBjb25zdCB4ID0gcmVjdC54ICE9PSByZWZSZWN0LnggPyAtYW1vdW50IDogMDtcbiAgY29uc3QgeSA9IHJlY3QueSAhPT0gcmVmUmVjdC55ID8gLWFtb3VudCA6IDA7XG4gIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gIGNvbnN0IGggPSAocmVjdC55ICsgcmVjdC5oICE9PSByZWZSZWN0LnkgKyByZWZSZWN0LmggPyBhbW91bnQgOiAwKSAtIHk7XG4gIHJldHVybiB7XG4gICAgeDogcmVjdC54ICsgeCxcbiAgICB5OiByZWN0LnkgKyB5LFxuICAgIHc6IHJlY3QudyArIHcsXG4gICAgaDogcmVjdC5oICsgaCxcbiAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gIH07XG59XG5jbGFzcyBCYXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKGNmZykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgIH1cbiAgfVxuICBkcmF3KGN0eCkge1xuICAgIGNvbnN0IHtpbmZsYXRlQW1vdW50LCBvcHRpb25zOiB7Ym9yZGVyQ29sb3IsIGJhY2tncm91bmRDb2xvcn19ID0gdGhpcztcbiAgICBjb25zdCB7aW5uZXIsIG91dGVyfSA9IGJvdW5kaW5nUmVjdHModGhpcyk7XG4gICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKG91dGVyLncgIT09IGlubmVyLncgfHwgb3V0ZXIuaCAhPT0gaW5uZXIuaCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgYWRkUmVjdFBhdGgoY3R4LCBpbmZsYXRlUmVjdChvdXRlciwgaW5mbGF0ZUFtb3VudCwgaW5uZXIpKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCAtaW5mbGF0ZUFtb3VudCwgb3V0ZXIpKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgIGN0eC5maWxsKCdldmVub2RkJyk7XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KGlubmVyLCBpbmZsYXRlQW1vdW50KSk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG1vdXNlWCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgfVxuICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICB9XG4gIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIHJldHVybiBpblJhbmdlKHRoaXMsIG51bGwsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gIH1cbiAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IHt4LCB5LCBiYXNlLCBob3Jpem9udGFsfSA9IHRoaXMuZ2V0UHJvcHMoWyd4JywgJ3knLCAnYmFzZScsICdob3Jpem9udGFsJ10sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgIH07XG4gIH1cbiAgZ2V0UmFuZ2UoYXhpcykge1xuICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgfVxufVxuQmFyRWxlbWVudC5pZCA9ICdiYXInO1xuQmFyRWxlbWVudC5kZWZhdWx0cyA9IHtcbiAgYm9yZGVyU2tpcHBlZDogJ3N0YXJ0JyxcbiAgYm9yZGVyV2lkdGg6IDAsXG4gIGJvcmRlclJhZGl1czogMCxcbiAgaW5mbGF0ZUFtb3VudDogJ2F1dG8nLFxuICBwb2ludFN0eWxlOiB1bmRlZmluZWRcbn07XG5CYXJFbGVtZW50LmRlZmF1bHRSb3V0ZXMgPSB7XG4gIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG59O1xuXG52YXIgZWxlbWVudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5fX3Byb3RvX186IG51bGwsXG5BcmNFbGVtZW50OiBBcmNFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50XG59KTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuICBjb25zdCBzYW1wbGVzID0gb3B0aW9ucy5zYW1wbGVzIHx8IGF2YWlsYWJsZVdpZHRoO1xuICBpZiAoc2FtcGxlcyA+PSBjb3VudCkge1xuICAgIHJldHVybiBkYXRhLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgfVxuICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgY29uc3QgYnVja2V0V2lkdGggPSAoY291bnQgLSAyKSAvIChzYW1wbGVzIC0gMik7XG4gIGxldCBzYW1wbGVkSW5kZXggPSAwO1xuICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICBsZXQgYSA9IHN0YXJ0O1xuICBsZXQgaSwgbWF4QXJlYVBvaW50LCBtYXhBcmVhLCBhcmVhLCBuZXh0QTtcbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gIGZvciAoaSA9IDA7IGkgPCBzYW1wbGVzIC0gMjsgaSsrKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBhdmdZID0gMDtcbiAgICBsZXQgajtcbiAgICBjb25zdCBhdmdSYW5nZVN0YXJ0ID0gTWF0aC5mbG9vcigoaSArIDEpICogYnVja2V0V2lkdGgpICsgMSArIHN0YXJ0O1xuICAgIGNvbnN0IGF2Z1JhbmdlRW5kID0gTWF0aC5taW4oTWF0aC5mbG9vcigoaSArIDIpICogYnVja2V0V2lkdGgpICsgMSwgY291bnQpICsgc3RhcnQ7XG4gICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgZm9yIChqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspIHtcbiAgICAgIGF2Z1ggKz0gZGF0YVtqXS54O1xuICAgICAgYXZnWSArPSBkYXRhW2pdLnk7XG4gICAgfVxuICAgIGF2Z1ggLz0gYXZnUmFuZ2VMZW5ndGg7XG4gICAgYXZnWSAvPSBhdmdSYW5nZUxlbmd0aDtcbiAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgY29uc3QgcmFuZ2VUbyA9IE1hdGgubWluKE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEsIGNvdW50KSArIHN0YXJ0O1xuICAgIGNvbnN0IHt4OiBwb2ludEF4LCB5OiBwb2ludEF5fSA9IGRhdGFbYV07XG4gICAgbWF4QXJlYSA9IGFyZWEgPSAtMTtcbiAgICBmb3IgKGogPSByYW5nZU9mZnM7IGogPCByYW5nZVRvOyBqKyspIHtcbiAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicyhcbiAgICAgICAgKHBvaW50QXggLSBhdmdYKSAqIChkYXRhW2pdLnkgLSBwb2ludEF5KSAtXG4gICAgICAgIChwb2ludEF4IC0gZGF0YVtqXS54KSAqIChhdmdZIC0gcG9pbnRBeSlcbiAgICAgICk7XG4gICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgbWF4QXJlYSA9IGFyZWE7XG4gICAgICAgIG1heEFyZWFQb2ludCA9IGRhdGFbal07XG4gICAgICAgIG5leHRBID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IG1heEFyZWFQb2ludDtcbiAgICBhID0gbmV4dEE7XG4gIH1cbiAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbZW5kSW5kZXhdO1xuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gIGxldCBhdmdYID0gMDtcbiAgbGV0IGNvdW50WCA9IDA7XG4gIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgY29uc3QgZGVjaW1hdGVkID0gW107XG4gIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBjb3VudCAtIDE7XG4gIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICBjb25zdCB4TWF4ID0gZGF0YVtlbmRJbmRleF0ueDtcbiAgY29uc3QgZHggPSB4TWF4IC0geE1pbjtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpIHtcbiAgICBwb2ludCA9IGRhdGFbaV07XG4gICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgIHkgPSBwb2ludC55O1xuICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IHk7XG4gICAgICAgIG1pbkluZGV4ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgIG1heEluZGV4ID0gaTtcbiAgICAgIH1cbiAgICAgIGF2Z1ggPSAoY291bnRYICogYXZnWCArIHBvaW50LngpIC8gKytjb3VudFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgxID0gTWF0aC5taW4obWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgY29uc3QgaW50ZXJtZWRpYXRlSW5kZXgyID0gTWF0aC5tYXgobWluSW5kZXgsIG1heEluZGV4KTtcbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgxXSxcbiAgICAgICAgICAgIHg6IGF2Z1gsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MiAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDIgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICBkZWNpbWF0ZWQucHVzaChkYXRhW2xhc3RJbmRleF0pO1xuICAgICAgfVxuICAgICAgZGVjaW1hdGVkLnB1c2gocG9pbnQpO1xuICAgICAgcHJldlggPSB0cnVuY1g7XG4gICAgICBjb3VudFggPSAwO1xuICAgICAgbWluWSA9IG1heFkgPSB5O1xuICAgICAgbWluSW5kZXggPSBtYXhJbmRleCA9IHN0YXJ0SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpIHtcbiAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0Ll9kYXRhO1xuICAgIGRlbGV0ZSBkYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge3ZhbHVlOiBkYXRhfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpID0+IHtcbiAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgY291bnQ7XG4gIGNvbnN0IHtpU2NhbGV9ID0gbWV0YTtcbiAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWluKS5sbywgMCwgcG9pbnRDb3VudCAtIDEpO1xuICB9XG4gIGlmIChtYXhEZWZpbmVkKSB7XG4gICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICB9XG4gIHJldHVybiB7c3RhcnQsIGNvdW50fTtcbn1cbnZhciBwbHVnaW5fZGVjaW1hdGlvbiA9IHtcbiAgaWQ6ICdkZWNpbWF0aW9uJyxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGdvcml0aG06ICdtaW4tbWF4JyxcbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgfSxcbiAgYmVmb3JlRWxlbWVudHNVcGRhdGU6IChjaGFydCwgYXJncywgb3B0aW9ucykgPT4ge1xuICAgIGlmICghb3B0aW9ucy5lbmFibGVkKSB7XG4gICAgICBjbGVhbkRlY2ltYXRlZERhdGEoY2hhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCwgZGF0YXNldEluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7X2RhdGEsIGluZGV4QXhpc30gPSBkYXRhc2V0O1xuICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgaWYgKHJlc29sdmUoW2luZGV4QXhpcywgY2hhcnQub3B0aW9ucy5pbmRleEF4aXNdKSA9PT0gJ3knKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB4QXhpcyA9IGNoYXJ0LnNjYWxlc1ttZXRhLnhBeGlzSURdO1xuICAgICAgaWYgKHhBeGlzLnR5cGUgIT09ICdsaW5lYXInICYmIHhBeGlzLnR5cGUgIT09ICd0aW1lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY2hhcnQub3B0aW9ucy5wYXJzaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB7c3RhcnQsIGNvdW50fSA9IGdldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHNTaW1wbGlmaWVkKG1ldGEsIGRhdGEpO1xuICAgICAgY29uc3QgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgNCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgaWYgKGNvdW50IDw9IHRocmVzaG9sZCkge1xuICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bGxPclVuZGVmKF9kYXRhKSkge1xuICAgICAgICBkYXRhc2V0Ll9kYXRhID0gZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhdGFzZXQsICdkYXRhJywge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVjaW1hdGVkO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhID0gZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbGV0IGRlY2ltYXRlZDtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5hbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaW4tbWF4JzpcbiAgICAgICAgZGVjaW1hdGVkID0gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlY2ltYXRpb24gYWxnb3JpdGhtICcke29wdGlvbnMuYWxnb3JpdGhtfSdgKTtcbiAgICAgIH1cbiAgICAgIGRhdGFzZXQuX2RlY2ltYXRlZCA9IGRlY2ltYXRlZDtcbiAgICB9KTtcbiAgfSxcbiAgZGVzdHJveShjaGFydCkge1xuICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IHRwb2ludHMgPSB0YXJnZXQucG9pbnRzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBsZXQge3N0YXJ0LCBlbmR9ID0gc2VnbWVudDtcbiAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKTtcbiAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICBpZiAoIXRhcmdldC5zZWdtZW50cykge1xuICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgdGFyZ2V0OiBib3VuZHMsXG4gICAgICAgIHN0YXJ0OiBwb2ludHNbc3RhcnRdLFxuICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRTZWdtZW50cyA9IF9ib3VuZFNlZ21lbnRzKHRhcmdldCwgYm91bmRzKTtcbiAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cykge1xuICAgICAgY29uc3Qgc3ViQm91bmRzID0gX2dldEJvdW5kcyhwcm9wZXJ0eSwgdHBvaW50c1t0Z3Quc3RhcnRdLCB0cG9pbnRzW3RndC5lbmRdLCB0Z3QubG9vcCk7XG4gICAgICBjb25zdCBmaWxsU291cmNlcyA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBzdWJCb3VuZHMpO1xuICAgICAgZm9yIChjb25zdCBmaWxsU291cmNlIG9mIGZpbGxTb3VyY2VzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZTogZmlsbFNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQ6IHRndCxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICBbcHJvcGVydHldOiBfZ2V0RWRnZShib3VuZHMsIHN1YkJvdW5kcywgJ2VuZCcsIE1hdGgubWluKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIF9nZXRCb3VuZHMocHJvcGVydHksIGZpcnN0LCBsYXN0LCBsb29wKSB7XG4gIGlmIChsb29wKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBzdGFydCA9IGZpcnN0W3Byb3BlcnR5XTtcbiAgbGV0IGVuZCA9IGxhc3RbcHJvcGVydHldO1xuICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICBzdGFydCA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gICAgZW5kID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gIH1cbiAgcmV0dXJuIHtwcm9wZXJ0eSwgc3RhcnQsIGVuZH07XG59XG5mdW5jdGlvbiBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKSB7XG4gIGNvbnN0IHt4ID0gbnVsbCwgeSA9IG51bGx9ID0gYm91bmRhcnkgfHwge307XG4gIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGxpbmUuc2VnbWVudHMuZm9yRWFjaCgoe3N0YXJ0LCBlbmR9KSA9PiB7XG4gICAgZW5kID0gX2ZpbmRTZWdtZW50RW5kKHN0YXJ0LCBlbmQsIGxpbmVQb2ludHMpO1xuICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdCA9IGxpbmVQb2ludHNbZW5kXTtcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgcG9pbnRzLnB1c2goe3g6IGZpcnN0LngsIHl9KTtcbiAgICAgIHBvaW50cy5wdXNoKHt4OiBsYXN0LngsIHl9KTtcbiAgICB9IGVsc2UgaWYgKHggIT09IG51bGwpIHtcbiAgICAgIHBvaW50cy5wdXNoKHt4LCB5OiBmaXJzdC55fSk7XG4gICAgICBwb2ludHMucHVzaCh7eCwgeTogbGFzdC55fSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgZm9yICg7ZW5kID4gc3RhcnQ7IGVuZC0tKSB7XG4gICAgY29uc3QgcG9pbnQgPSBwb2ludHNbZW5kXTtcbiAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmQ7XG59XG5mdW5jdGlvbiBfZ2V0RWRnZShhLCBiLCBwcm9wLCBmbikge1xuICBpZiAoYSAmJiBiKSB7XG4gICAgcmV0dXJuIGZuKGFbcHJvcF0sIGJbcHJvcF0pO1xuICB9XG4gIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICBsZXQgcG9pbnRzID0gW107XG4gIGxldCBfbG9vcCA9IGZhbHNlO1xuICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICBfbG9vcCA9IHRydWU7XG4gICAgcG9pbnRzID0gYm91bmRhcnk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnRzID0gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSk7XG4gIH1cbiAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgIHBvaW50cyxcbiAgICBvcHRpb25zOiB7dGVuc2lvbjogMH0sXG4gICAgX2xvb3AsXG4gICAgX2Z1bGxMb29wOiBfbG9vcFxuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICByZXR1cm4gc291cmNlICYmIHNvdXJjZS5maWxsICE9PSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gX3Jlc29sdmVUYXJnZXQoc291cmNlcywgaW5kZXgsIHByb3BhZ2F0ZSkge1xuICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgY29uc3QgdmlzaXRlZCA9IFtpbmRleF07XG4gIGxldCB0YXJnZXQ7XG4gIGlmICghcHJvcGFnYXRlKSB7XG4gICAgcmV0dXJuIGZpbGw7XG4gIH1cbiAgd2hpbGUgKGZpbGwgIT09IGZhbHNlICYmIHZpc2l0ZWQuaW5kZXhPZihmaWxsKSA9PT0gLTEpIHtcbiAgICBpZiAoIWlzTnVtYmVyRmluaXRlKGZpbGwpKSB7XG4gICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgdGFyZ2V0ID0gc291cmNlc1tmaWxsXTtcbiAgICBpZiAoIXRhcmdldCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnZpc2libGUpIHtcbiAgICAgIHJldHVybiBmaWxsO1xuICAgIH1cbiAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgZmlsbCA9IHRhcmdldC5maWxsO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gIH1cbiAgbGV0IHRhcmdldCA9IHBhcnNlRmxvYXQoZmlsbCk7XG4gIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgcmV0dXJuIGRlY29kZVRhcmdldEluZGV4KGZpbGxbMF0sIGluZGV4LCB0YXJnZXQsIGNvdW50KTtcbiAgfVxuICByZXR1cm4gWydvcmlnaW4nLCAnc3RhcnQnLCAnZW5kJywgJ3N0YWNrJywgJ3NoYXBlJ10uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICBpZiAoZmlyc3RDaCA9PT0gJy0nIHx8IGZpcnN0Q2ggPT09ICcrJykge1xuICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICB9XG4gIGlmICh0YXJnZXQgPT09IGluZGV4IHx8IHRhcmdldCA8IDAgfHwgdGFyZ2V0ID49IGNvdW50KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfZ2V0VGFyZ2V0UGl4ZWwoZmlsbCwgc2NhbGUpIHtcbiAgbGV0IHBpeGVsID0gbnVsbDtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgfSBlbHNlIGlmIChmaWxsID09PSAnZW5kJykge1xuICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGZpbGwpKSB7XG4gICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICB9IGVsc2UgaWYgKHNjYWxlLmdldEJhc2VQaXhlbCkge1xuICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gIH1cbiAgcmV0dXJuIHBpeGVsO1xufVxuZnVuY3Rpb24gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydFZhbHVlKSB7XG4gIGxldCB2YWx1ZTtcbiAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICB2YWx1ZSA9IHN0YXJ0VmFsdWU7XG4gIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICB2YWx1ZSA9IHNjYWxlLm9wdGlvbnMucmV2ZXJzZSA/IHNjYWxlLm1pbiA6IHNjYWxlLm1heDtcbiAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgIHZhbHVlID0gZmlsbC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IHNjYWxlLmdldEJhc2VWYWx1ZSgpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBsaW5lLm9wdGlvbnM7XG4gIGNvbnN0IGZpbGxPcHRpb24gPSBvcHRpb25zLmZpbGw7XG4gIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG4gIGlmIChmaWxsID09PSB1bmRlZmluZWQpIHtcbiAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBpZiAoZmlsbCA9PT0gZmFsc2UgfHwgZmlsbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnb3JpZ2luJztcbiAgfVxuICByZXR1cm4gZmlsbDtcbn1cblxuZnVuY3Rpb24gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUsIGluZGV4LCBsaW5lfSA9IHNvdXJjZTtcbiAgY29uc3QgcG9pbnRzID0gW107XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gIGNvbnN0IGxpbmVzQmVsb3cgPSBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCk7XG4gIGxpbmVzQmVsb3cucHVzaChfY3JlYXRlQm91bmRhcnlMaW5lKHt4OiBudWxsLCB5OiBzY2FsZS5ib3R0b219LCBsaW5lKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgZm9yIChsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKykge1xuICAgICAgYWRkUG9pbnRzQmVsb3cocG9pbnRzLCBzb3VyY2VQb2ludHNbal0sIGxpbmVzQmVsb3cpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IExpbmVFbGVtZW50KHtwb2ludHMsIG9wdGlvbnM6IHt9fSk7XG59XG5mdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICBjb25zdCBiZWxvdyA9IFtdO1xuICBjb25zdCBtZXRhcyA9IHNjYWxlLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCdsaW5lJyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWV0YXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBtZXRhID0gbWV0YXNbaV07XG4gICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFtZXRhLmhpZGRlbikge1xuICAgICAgYmVsb3cudW5zaGlmdChtZXRhLmRhdGFzZXQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYmVsb3c7XG59XG5mdW5jdGlvbiBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50LCBsaW5lc0JlbG93KSB7XG4gIGNvbnN0IHBvc3Rwb25lZCA9IFtdO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzQmVsb3cubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsaW5lID0gbGluZXNCZWxvd1tqXTtcbiAgICBjb25zdCB7Zmlyc3QsIGxhc3QsIHBvaW50fSA9IGZpbmRQb2ludChsaW5lLCBzb3VyY2VQb2ludCwgJ3gnKTtcbiAgICBpZiAoIXBvaW50IHx8IChmaXJzdCAmJiBsYXN0KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmaXJzdCkge1xuICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMucHVzaChwb2ludCk7XG4gICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBvaW50cy5wdXNoKC4uLnBvc3Rwb25lZCk7XG59XG5mdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gIGNvbnN0IHBvaW50ID0gbGluZS5pbnRlcnBvbGF0ZShzb3VyY2VQb2ludCwgcHJvcGVydHkpO1xuICBpZiAoIXBvaW50KSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gIGNvbnN0IHNlZ21lbnRzID0gbGluZS5zZWdtZW50cztcbiAgY29uc3QgbGluZVBvaW50cyA9IGxpbmUucG9pbnRzO1xuICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgbGV0IGxhc3QgPSBmYWxzZTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBjb25zdCBmaXJzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LnN0YXJ0XVtwcm9wZXJ0eV07XG4gICAgY29uc3QgbGFzdFZhbHVlID0gbGluZVBvaW50c1tzZWdtZW50LmVuZF1bcHJvcGVydHldO1xuICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtmaXJzdCwgbGFzdCwgcG9pbnR9O1xufVxuXG5jbGFzcyBzaW1wbGVBcmMge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy54ID0gb3B0cy54O1xuICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICB0aGlzLnJhZGl1cyA9IG9wdHMucmFkaXVzO1xuICB9XG4gIHBhdGhTZWdtZW50KGN0eCwgYm91bmRzLCBvcHRzKSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7c3RhcnQ6IDAsIGVuZDogVEFVfTtcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgYm91bmRzLmVuZCwgYm91bmRzLnN0YXJ0LCB0cnVlKTtcbiAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICB9XG4gIGludGVycG9sYXRlKHBvaW50KSB7XG4gICAgY29uc3Qge3gsIHksIHJhZGl1c30gPSB0aGlzO1xuICAgIGNvbnN0IGFuZ2xlID0gcG9pbnQuYW5nbGU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgYW5nbGVcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gIGNvbnN0IHtjaGFydCwgZmlsbCwgbGluZX0gPSBzb3VyY2U7XG4gIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgIHJldHVybiBnZXRMaW5lQnlJbmRleChjaGFydCwgZmlsbCk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzdGFjaycpIHtcbiAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gIH1cbiAgaWYgKGZpbGwgPT09ICdzaGFwZScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuICBpZiAoYm91bmRhcnkgaW5zdGFuY2VvZiBzaW1wbGVBcmMpIHtcbiAgICByZXR1cm4gYm91bmRhcnk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVCb3VuZGFyeUxpbmUoYm91bmRhcnksIGxpbmUpO1xufVxuZnVuY3Rpb24gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGluZGV4KSB7XG4gIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpbmRleCk7XG4gIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICByZXR1cm4gdmlzaWJsZSA/IG1ldGEuZGF0YXNldCA6IG51bGw7XG59XG5mdW5jdGlvbiBjb21wdXRlQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHNjYWxlID0gc291cmNlLnNjYWxlIHx8IHt9O1xuICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVDaXJjdWxhckJvdW5kYXJ5KHNvdXJjZSk7XG4gIH1cbiAgcmV0dXJuIGNvbXB1dGVMaW5lYXJCb3VuZGFyeShzb3VyY2UpO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSkge1xuICBjb25zdCB7c2NhbGUgPSB7fSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcbiAgaWYgKGlzTnVtYmVyRmluaXRlKHBpeGVsKSkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogaG9yaXpvbnRhbCA/IHBpeGVsIDogbnVsbCxcbiAgICAgIHk6IGhvcml6b250YWwgPyBudWxsIDogcGl4ZWxcbiAgICB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gIGNvbnN0IHtzY2FsZSwgZmlsbH0gPSBzb3VyY2U7XG4gIGNvbnN0IG9wdGlvbnMgPSBzY2FsZS5vcHRpb25zO1xuICBjb25zdCBsZW5ndGggPSBzY2FsZS5nZXRMYWJlbHMoKS5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICBjb25zdCB2YWx1ZSA9IF9nZXRUYXJnZXRWYWx1ZShmaWxsLCBzY2FsZSwgc3RhcnQpO1xuICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgIGNvbnN0IGNlbnRlciA9IHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSgwLCBzdGFydCk7XG4gICAgcmV0dXJuIG5ldyBzaW1wbGVBcmMoe1xuICAgICAgeDogY2VudGVyLngsXG4gICAgICB5OiBjZW50ZXIueSxcbiAgICAgIHJhZGl1czogc2NhbGUuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpXG4gICAgfSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kcmF3ZmlsbChjdHgsIHNvdXJjZSwgYXJlYSkge1xuICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gIGNvbnN0IHtsaW5lLCBzY2FsZSwgYXhpc30gPSBzb3VyY2U7XG4gIGNvbnN0IGxpbmVPcHRzID0gbGluZS5vcHRpb25zO1xuICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgY29uc3QgY29sb3IgPSBsaW5lT3B0cy5iYWNrZ3JvdW5kQ29sb3I7XG4gIGNvbnN0IHthYm92ZSA9IGNvbG9yLCBiZWxvdyA9IGNvbG9yfSA9IGZpbGxPcHRpb24gfHwge307XG4gIGlmICh0YXJnZXQgJiYgbGluZS5wb2ludHMubGVuZ3RoKSB7XG4gICAgY2xpcEFyZWEoY3R4LCBhcmVhKTtcbiAgICBkb0ZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBhYm92ZSwgYmVsb3csIGFyZWEsIHNjYWxlLCBheGlzfSk7XG4gICAgdW5jbGlwQXJlYShjdHgpO1xuICB9XG59XG5mdW5jdGlvbiBkb0ZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgYWJvdmUsIGJlbG93LCBhcmVhLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHByb3BlcnR5ID0gbGluZS5fbG9vcCA/ICdhbmdsZScgOiBjZmcuYXhpcztcbiAgY3R4LnNhdmUoKTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBhcmVhLnRvcCk7XG4gICAgZmlsbChjdHgsIHtsaW5lLCB0YXJnZXQsIGNvbG9yOiBhYm92ZSwgc2NhbGUsIHByb3BlcnR5fSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS5ib3R0b20pO1xuICB9XG4gIGZpbGwoY3R4LCB7bGluZSwgdGFyZ2V0LCBjb2xvcjogYmVsb3csIHNjYWxlLCBwcm9wZXJ0eX0pO1xuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gY2xpcFZlcnRpY2FsKGN0eCwgdGFyZ2V0LCBjbGlwWSkge1xuICBjb25zdCB7c2VnbWVudHMsIHBvaW50c30gPSB0YXJnZXQ7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuICBjdHguYmVnaW5QYXRoKCk7XG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGNvbnN0IHtzdGFydCwgZW5kfSA9IHNlZ21lbnQ7XG4gICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgY29uc3QgbGFzdFBvaW50ID0gcG9pbnRzW19maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpXTtcbiAgICBpZiAoZmlyc3QpIHtcbiAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgIH1cbiAgICBsaW5lTG9vcCA9ICEhdGFyZ2V0LnBhdGhTZWdtZW50KGN0eCwgc2VnbWVudCwge21vdmU6IGxpbmVMb29wfSk7XG4gICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5saW5lVG8obGFzdFBvaW50LngsIGNsaXBZKTtcbiAgICB9XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIGZpbGwoY3R4LCBjZmcpIHtcbiAgY29uc3Qge2xpbmUsIHRhcmdldCwgcHJvcGVydHksIGNvbG9yLCBzY2FsZX0gPSBjZmc7XG4gIGNvbnN0IHNlZ21lbnRzID0gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpO1xuICBmb3IgKGNvbnN0IHtzb3VyY2U6IHNyYywgdGFyZ2V0OiB0Z3QsIHN0YXJ0LCBlbmR9IG9mIHNlZ21lbnRzKSB7XG4gICAgY29uc3Qge3N0eWxlOiB7YmFja2dyb3VuZENvbG9yID0gY29sb3J9ID0ge319ID0gc3JjO1xuICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY29uc3QgbGluZUxvb3AgPSAhIWxpbmUucGF0aFNlZ21lbnQoY3R4LCBzcmMpO1xuICAgIGxldCBsb29wO1xuICAgIGlmIChub3RTaGFwZSkge1xuICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVycG9sYXRlZExpbmVUbyhjdHgsIHRhcmdldCwgZW5kLCBwcm9wZXJ0eSk7XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXRMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCB0Z3QsIHttb3ZlOiBsaW5lTG9vcCwgcmV2ZXJzZTogdHJ1ZX0pO1xuICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBzdGFydCwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwobG9vcCA/ICdldmVub2RkJyA6ICdub256ZXJvJyk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufVxuZnVuY3Rpb24gY2xpcEJvdW5kcyhjdHgsIHNjYWxlLCBib3VuZHMpIHtcbiAgY29uc3Qge3RvcCwgYm90dG9tfSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydCwgZW5kfSA9IGJvdW5kcyB8fCB7fTtcbiAgaWYgKHByb3BlcnR5ID09PSAneCcpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LnJlY3Qoc3RhcnQsIHRvcCwgZW5kIC0gc3RhcnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgY29uc3QgaW50ZXJwb2xhdGVkUG9pbnQgPSB0YXJnZXQuaW50ZXJwb2xhdGUocG9pbnQsIHByb3BlcnR5KTtcbiAgaWYgKGludGVycG9sYXRlZFBvaW50KSB7XG4gICAgY3R4LmxpbmVUbyhpbnRlcnBvbGF0ZWRQb2ludC54LCBpbnRlcnBvbGF0ZWRQb2ludC55KTtcbiAgfVxufVxuXG52YXIgaW5kZXggPSB7XG4gIGlkOiAnZmlsbGVyJyxcbiAgYWZ0ZXJEYXRhc2V0c1VwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjb3VudCA9IChjaGFydC5kYXRhLmRhdGFzZXRzIHx8IFtdKS5sZW5ndGg7XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgIG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgIGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICBzb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKGxpbmUgJiYgbGluZS5vcHRpb25zICYmIGxpbmUgaW5zdGFuY2VvZiBMaW5lRWxlbWVudCkge1xuICAgICAgICBzb3VyY2UgPSB7XG4gICAgICAgICAgdmlzaWJsZTogY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSxcbiAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICBmaWxsOiBfZGVjb2RlRmlsbChsaW5lLCBpLCBjb3VudCksXG4gICAgICAgICAgY2hhcnQsXG4gICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgIHNjYWxlOiBtZXRhLnZTY2FsZSxcbiAgICAgICAgICBsaW5lLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc291cmNlLmZpbGwgPSBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpLCBvcHRpb25zLnByb3BhZ2F0ZSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVEcmF3KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgY29uc3QgYXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBmb3IgKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IG1ldGFzZXRzW2ldLiRmaWxsZXI7XG4gICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBhcmVhKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJlZm9yZURhdGFzZXRzRHJhdyhjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCk7XG4gICAgZm9yIChsZXQgaSA9IG1ldGFzZXRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgaWYgKF9zaG91bGRBcHBseUZpbGwoc291cmNlKSkge1xuICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBiZWZvcmVEYXRhc2V0RHJhdyhjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNvdXJjZSA9IGFyZ3MubWV0YS4kZmlsbGVyO1xuICAgIGlmICghX3Nob3VsZEFwcGx5RmlsbChzb3VyY2UpIHx8IG9wdGlvbnMuZHJhd1RpbWUgIT09ICdiZWZvcmVEYXRhc2V0RHJhdycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX2RyYXdmaWxsKGNoYXJ0LmN0eCwgc291cmNlLCBjaGFydC5jaGFydEFyZWEpO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICBkcmF3VGltZTogJ2JlZm9yZURhdGFzZXREcmF3J1xuICB9XG59O1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpID0+IHtcbiAgbGV0IHtib3hIZWlnaHQgPSBmb250U2l6ZSwgYm94V2lkdGggPSBmb250U2l6ZX0gPSBsYWJlbE9wdHM7XG4gIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgIGJveEhlaWdodCA9IE1hdGgubWluKGJveEhlaWdodCwgZm9udFNpemUpO1xuICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYm94V2lkdGgsXG4gICAgYm94SGVpZ2h0LFxuICAgIGl0ZW1IZWlnaHQ6IE1hdGgubWF4KGZvbnRTaXplLCBib3hIZWlnaHQpXG4gIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKSA9PiBhICE9PSBudWxsICYmIGIgIT09IG51bGwgJiYgYS5kYXRhc2V0SW5kZXggPT09IGIuZGF0YXNldEluZGV4ICYmIGEuaW5kZXggPT09IGIuaW5kZXg7XG5jbGFzcyBMZWdlbmQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9hZGRlZCA9IGZhbHNlO1xuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IG51bGw7XG4gICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY29sdW1uU2l6ZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubWF4V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy53ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgfVxuICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgIHRoaXMubWF4V2lkdGggPSBtYXhXaWR0aDtcbiAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucztcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcbiAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgdGhpcy5maXQoKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgdGhpcy50b3AgPSB0aGlzLl9tYXJnaW5zLnRvcDtcbiAgICAgIHRoaXMuYm90dG9tID0gdGhpcy5oZWlnaHQ7XG4gICAgfVxuICB9XG4gIGJ1aWxkTGFiZWxzKCkge1xuICAgIGNvbnN0IGxhYmVsT3B0cyA9IHRoaXMub3B0aW9ucy5sYWJlbHMgfHwge307XG4gICAgbGV0IGxlZ2VuZEl0ZW1zID0gY2FsbGJhY2sobGFiZWxPcHRzLmdlbmVyYXRlTGFiZWxzLCBbdGhpcy5jaGFydF0sIHRoaXMpIHx8IFtdO1xuICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gbGFiZWxPcHRzLmZpbHRlcihpdGVtLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICB9XG4gICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpID0+IGxhYmVsT3B0cy5zb3J0KGEsIGIsIHRoaXMuY2hhcnQuZGF0YSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5sZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zO1xuICB9XG4gIGZpdCgpIHtcbiAgICBjb25zdCB7b3B0aW9ucywgY3R4fSA9IHRoaXM7XG4gICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsT3B0cyA9IG9wdGlvbnMubGFiZWxzO1xuICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgY29uc3QgZm9udFNpemUgPSBsYWJlbEZvbnQuc2l6ZTtcbiAgICBjb25zdCB0aXRsZUhlaWdodCA9IHRoaXMuX2NvbXB1dGVUaXRsZUhlaWdodCgpO1xuICAgIGNvbnN0IHtib3hXaWR0aCwgaXRlbUhlaWdodH0gPSBnZXRCb3hTaXplKGxhYmVsT3B0cywgZm9udFNpemUpO1xuICAgIGxldCB3aWR0aCwgaGVpZ2h0O1xuICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgd2lkdGggPSB0aGlzLm1heFdpZHRoO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5fZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgIHdpZHRoID0gdGhpcy5fZml0Q29scyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgIH1cbiAgICB0aGlzLndpZHRoID0gTWF0aC5taW4od2lkdGgsIG9wdGlvbnMubWF4V2lkdGggfHwgdGhpcy5tYXhXaWR0aCk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgfVxuICBfZml0Um93cyh0aXRsZUhlaWdodCwgZm9udFNpemUsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSB7XG4gICAgY29uc3Qge2N0eCwgbWF4V2lkdGgsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gWzBdO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICBsZXQgdG90YWxIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBsZXQgcm93ID0gLTE7XG4gICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICBsaW5lV2lkdGhzW2xpbmVXaWR0aHMubGVuZ3RoIC0gKGkgPiAwID8gMCA6IDEpXSA9IDA7XG4gICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICByb3crKztcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQ6IDAsIHRvcCwgcm93LCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRvdGFsSGVpZ2h0O1xuICB9XG4gIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBmb250U2l6ZSwgYm94V2lkdGgsIGl0ZW1IZWlnaHQpIHtcbiAgICBjb25zdCB7Y3R4LCBtYXhIZWlnaHQsIG9wdGlvbnM6IHtsYWJlbHM6IHtwYWRkaW5nfX19ID0gdGhpcztcbiAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICBjb25zdCBjb2x1bW5TaXplcyA9IHRoaXMuY29sdW1uU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBoZWlnaHRMaW1pdCA9IG1heEhlaWdodCAtIHRpdGxlSGVpZ2h0O1xuICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICBsZXQgY3VycmVudENvbFdpZHRoID0gMDtcbiAgICBsZXQgY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCBjb2wgPSAwO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY29uc3QgaXRlbVdpZHRoID0gYm94V2lkdGggKyAoZm9udFNpemUgLyAyKSArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgaWYgKGkgPiAwICYmIGN1cnJlbnRDb2xIZWlnaHQgKyBpdGVtSGVpZ2h0ICsgMiAqIHBhZGRpbmcgPiBoZWlnaHRMaW1pdCkge1xuICAgICAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe3dpZHRoOiBjdXJyZW50Q29sV2lkdGgsIGhlaWdodDogY3VycmVudENvbEhlaWdodH0pO1xuICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIGNvbCsrO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgIH1cbiAgICAgIGhpdGJveGVzW2ldID0ge2xlZnQsIHRvcDogY3VycmVudENvbEhlaWdodCwgY29sLCB3aWR0aDogaXRlbVdpZHRoLCBoZWlnaHQ6IGl0ZW1IZWlnaHR9O1xuICAgICAgY3VycmVudENvbFdpZHRoID0gTWF0aC5tYXgoY3VycmVudENvbFdpZHRoLCBpdGVtV2lkdGgpO1xuICAgICAgY3VycmVudENvbEhlaWdodCArPSBpdGVtSGVpZ2h0ICsgcGFkZGluZztcbiAgICB9KTtcbiAgICB0b3RhbFdpZHRoICs9IGN1cnJlbnRDb2xXaWR0aDtcbiAgICBjb2x1bW5TaXplcy5wdXNoKHt3aWR0aDogY3VycmVudENvbFdpZHRoLCBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHR9KTtcbiAgICByZXR1cm4gdG90YWxXaWR0aDtcbiAgfVxuICBhZGp1c3RIaXRCb3hlcygpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgY29uc3Qge2xlZ2VuZEhpdEJveGVzOiBoaXRib3hlcywgb3B0aW9uczoge2FsaWduLCBsYWJlbHM6IHtwYWRkaW5nfSwgcnRsfX0gPSB0aGlzO1xuICAgIGNvbnN0IHJ0bEhlbHBlciA9IGdldFJ0bEFkYXB0ZXIocnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICBsZXQgcm93ID0gMDtcbiAgICAgIGxldCBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgcm93ID0gaGl0Ym94LnJvdztcbiAgICAgICAgICBsZWZ0ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSB0aGlzLmxpbmVXaWR0aHNbcm93XSk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChsZWZ0KSwgaGl0Ym94LndpZHRoKTtcbiAgICAgICAgbGVmdCArPSBoaXRib3gud2lkdGggKyBwYWRkaW5nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY29sID0gMDtcbiAgICAgIGxldCB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICBmb3IgKGNvbnN0IGhpdGJveCBvZiBoaXRib3hlcykge1xuICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgY29sID0gaGl0Ym94LmNvbDtcbiAgICAgICAgICB0b3AgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy50b3AgKyB0aXRsZUhlaWdodCArIHBhZGRpbmcsIHRoaXMuYm90dG9tIC0gdGhpcy5jb2x1bW5TaXplc1tjb2xdLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgaGl0Ym94LmxlZnQgKz0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgaGl0Ym94LmxlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueChoaXRib3gubGVmdCksIGhpdGJveC53aWR0aCk7XG4gICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNIb3Jpem9udGFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgZHJhdygpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgY2xpcEFyZWEoY3R4LCB0aGlzKTtcbiAgICAgIHRoaXMuX2RyYXcoKTtcbiAgICAgIHVuY2xpcEFyZWEoY3R4KTtcbiAgICB9XG4gIH1cbiAgX2RyYXcoKSB7XG4gICAgY29uc3Qge29wdGlvbnM6IG9wdHMsIGNvbHVtblNpemVzLCBsaW5lV2lkdGhzLCBjdHh9ID0gdGhpcztcbiAgICBjb25zdCB7YWxpZ24sIGxhYmVsczogbGFiZWxPcHRzfSA9IG9wdHM7XG4gICAgY29uc3QgZGVmYXVsdENvbG9yID0gZGVmYXVsdHMuY29sb3I7XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBsYWJlbEZvbnQgPSB0b0ZvbnQobGFiZWxPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHtjb2xvcjogZm9udENvbG9yLCBwYWRkaW5nfSA9IGxhYmVsT3B0cztcbiAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IGZvbnRTaXplIC8gMjtcbiAgICBsZXQgY3Vyc29yO1xuICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oJ2xlZnQnKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICBjdHguZm9udCA9IGxhYmVsRm9udC5zdHJpbmc7XG4gICAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHQsIGl0ZW1IZWlnaHR9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICBjb25zdCBkcmF3TGVnZW5kQm94ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgaWYgKGlzTmFOKGJveFdpZHRoKSB8fCBib3hXaWR0aCA8PSAwIHx8IGlzTmFOKGJveEhlaWdodCkgfHwgYm94SGVpZ2h0IDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbGluZVdpZHRoID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lV2lkdGgsIDEpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uZmlsbFN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVDYXAsICdidXR0Jyk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVEYXNoT2Zmc2V0LCAwKTtcbiAgICAgIGN0eC5saW5lSm9pbiA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZUpvaW4sICdtaXRlcicpO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0uc3Ryb2tlU3R5bGUsIGRlZmF1bHRDb2xvcik7XG4gICAgICBjdHguc2V0TGluZURhc2godmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaCwgW10pKTtcbiAgICAgIGlmIChsYWJlbE9wdHMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICByYWRpdXM6IGJveEhlaWdodCAqIE1hdGguU1FSVDIgLyAyLFxuICAgICAgICAgIHBvaW50U3R5bGU6IGxlZ2VuZEl0ZW0ucG9pbnRTdHlsZSxcbiAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICBib3JkZXJXaWR0aDogbGluZVdpZHRoXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNlbnRlclggPSBydGxIZWxwZXIueFBsdXMoeCwgYm94V2lkdGggLyAyKTtcbiAgICAgICAgY29uc3QgY2VudGVyWSA9IHkgKyBoYWxmRm9udFNpemU7XG4gICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHlCb3hUb3AgPSB5ICsgTWF0aC5tYXgoKGZvbnRTaXplIC0gYm94SGVpZ2h0KSAvIDIsIDApO1xuICAgICAgICBjb25zdCB4Qm94TGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHgsIGJveFdpZHRoKTtcbiAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgaWYgKE9iamVjdC52YWx1ZXMoYm9yZGVyUmFkaXVzKS5zb21lKHYgPT4gdiAhPT0gMCkpIHtcbiAgICAgICAgICBhZGRSb3VuZGVkUmVjdFBhdGgoY3R4LCB7XG4gICAgICAgICAgICB4OiB4Qm94TGVmdCxcbiAgICAgICAgICAgIHk6IHlCb3hUb3AsXG4gICAgICAgICAgICB3OiBib3hXaWR0aCxcbiAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5yZWN0KHhCb3hMZWZ0LCB5Qm94VG9wLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICBpZiAobGluZVdpZHRoICE9PSAwKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH07XG4gICAgY29uc3QgZmlsbFRleHQgPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICByZW5kZXJUZXh0KGN0eCwgbGVnZW5kSXRlbS50ZXh0LCB4LCB5ICsgKGl0ZW1IZWlnaHQgLyAyKSwgbGFiZWxGb250LCB7XG4gICAgICAgIHN0cmlrZXRocm91Z2g6IGxlZ2VuZEl0ZW0uaGlkZGVuLFxuICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgIHk6IHRoaXMudG9wICsgcGFkZGluZyArIHRpdGxlSGVpZ2h0LFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJzb3IgPSB7XG4gICAgICAgIHg6IHRoaXMubGVmdCArIHBhZGRpbmcsXG4gICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICBsaW5lOiAwXG4gICAgICB9O1xuICAgIH1cbiAgICBvdmVycmlkZVRleHREaXJlY3Rpb24odGhpcy5jdHgsIG9wdHMudGV4dERpcmVjdGlvbik7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSkgPT4ge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGVnZW5kSXRlbS5mb250Q29sb3IgfHwgZm9udENvbG9yO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yIHx8IGZvbnRDb2xvcjtcbiAgICAgIGNvbnN0IHRleHRXaWR0aCA9IGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgY29uc3QgdGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihsZWdlbmRJdGVtLnRleHRBbGlnbiB8fCAobGVnZW5kSXRlbS50ZXh0QWxpZ24gPSBsYWJlbE9wdHMudGV4dEFsaWduKSk7XG4gICAgICBjb25zdCB3aWR0aCA9IGJveFdpZHRoICsgaGFsZkZvbnRTaXplICsgdGV4dFdpZHRoO1xuICAgICAgbGV0IHggPSBjdXJzb3IueDtcbiAgICAgIGxldCB5ID0gY3Vyc29yLnk7XG4gICAgICBydGxIZWxwZXIuc2V0V2lkdGgodGhpcy53aWR0aCk7XG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChpID4gMCAmJiB4ICsgd2lkdGggKyBwYWRkaW5nID4gdGhpcy5yaWdodCkge1xuICAgICAgICAgIHkgPSBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgeCA9IGN1cnNvci54ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMubGVmdCArIHBhZGRpbmcsIHRoaXMucmlnaHQgLSBsaW5lV2lkdGhzW2N1cnNvci5saW5lXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICB4ID0gY3Vyc29yLnggPSB4ICsgY29sdW1uU2l6ZXNbY3Vyc29yLmxpbmVdLndpZHRoICsgcGFkZGluZztcbiAgICAgICAgY3Vyc29yLmxpbmUrKztcbiAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcbiAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICBjdXJzb3IueCArPSB3aWR0aCArIHBhZGRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJzb3IueSArPSBsaW5lSGVpZ2h0O1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICB9XG4gIGRyYXdUaXRsZSgpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KHRpdGxlT3B0cy5mb250KTtcbiAgICBjb25zdCB0aXRsZVBhZGRpbmcgPSB0b1BhZGRpbmcodGl0bGVPcHRzLnBhZGRpbmcpO1xuICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHRpdGxlT3B0cy5wb3NpdGlvbjtcbiAgICBjb25zdCBoYWxmRm9udFNpemUgPSB0aXRsZUZvbnQuc2l6ZSAvIDI7XG4gICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgIGxldCB5O1xuICAgIGxldCBsZWZ0ID0gdGhpcy5sZWZ0O1xuICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoLi4udGhpcy5saW5lV2lkdGhzKTtcbiAgICAgIHkgPSB0aGlzLnRvcCArIHRvcFBhZGRpbmdQbHVzSGFsZkZvbnRTaXplO1xuICAgICAgbGVmdCA9IF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIGxlZnQsIHRoaXMucmlnaHQgLSBtYXhXaWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IHRoaXMuY29sdW1uU2l6ZXMucmVkdWNlKChhY2MsIHNpemUpID0+IE1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgfVxuICAgIGNvbnN0IHggPSBfYWxpZ25TdGFydEVuZChwb3NpdGlvbiwgbGVmdCwgbGVmdCArIG1heFdpZHRoKTtcbiAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gdGl0bGVPcHRzLmNvbG9yO1xuICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgY3R4LmZvbnQgPSB0aXRsZUZvbnQuc3RyaW5nO1xuICAgIHJlbmRlclRleHQoY3R4LCB0aXRsZU9wdHMudGV4dCwgeCwgeSwgdGl0bGVGb250KTtcbiAgfVxuICBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgIGNvbnN0IHRpdGxlT3B0cyA9IHRoaXMub3B0aW9ucy50aXRsZTtcbiAgICBjb25zdCB0aXRsZUZvbnQgPSB0b0ZvbnQodGl0bGVPcHRzLmZvbnQpO1xuICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgcmV0dXJuIHRpdGxlT3B0cy5kaXNwbGF5ID8gdGl0bGVGb250LmxpbmVIZWlnaHQgKyB0aXRsZVBhZGRpbmcuaGVpZ2h0IDogMDtcbiAgfVxuICBfZ2V0TGVnZW5kSXRlbUF0KHgsIHkpIHtcbiAgICBsZXQgaSwgaGl0Qm94LCBsaDtcbiAgICBpZiAoX2lzQmV0d2Vlbih4LCB0aGlzLmxlZnQsIHRoaXMucmlnaHQpXG4gICAgICAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsaC5sZW5ndGg7ICsraSkge1xuICAgICAgICBoaXRCb3ggPSBsaFtpXTtcbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgaGl0Qm94LmxlZnQsIGhpdEJveC5sZWZ0ICsgaGl0Qm94LndpZHRoKVxuICAgICAgICAgICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGVnZW5kSXRlbXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgaWYgKCFpc0xpc3RlbmVkKGUudHlwZSwgb3B0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaG92ZXJlZEl0ZW0gPSB0aGlzLl9nZXRMZWdlbmRJdGVtQXQoZS54LCBlLnkpO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLl9ob3ZlcmVkSXRlbTtcbiAgICAgIGNvbnN0IHNhbWVJdGVtID0gaXRlbXNFcXVhbChwcmV2aW91cywgaG92ZXJlZEl0ZW0pO1xuICAgICAgaWYgKHByZXZpb3VzICYmICFzYW1lSXRlbSkge1xuICAgICAgICBjYWxsYmFjayhvcHRzLm9uTGVhdmUsIFtlLCBwcmV2aW91cywgdGhpc10sIHRoaXMpO1xuICAgICAgfVxuICAgICAgdGhpcy5faG92ZXJlZEl0ZW0gPSBob3ZlcmVkSXRlbTtcbiAgICAgIGlmIChob3ZlcmVkSXRlbSAmJiAhc2FtZUl0ZW0pIHtcbiAgICAgICAgY2FsbGJhY2sob3B0cy5vbkhvdmVyLCBbZSwgaG92ZXJlZEl0ZW0sIHRoaXNdLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtlLCBob3ZlcmVkSXRlbSwgdGhpc10sIHRoaXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaXNMaXN0ZW5lZCh0eXBlLCBvcHRzKSB7XG4gIGlmICgodHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgdHlwZSA9PT0gJ21vdXNlb3V0JykgJiYgKG9wdHMub25Ib3ZlciB8fCBvcHRzLm9uTGVhdmUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIHBsdWdpbl9sZWdlbmQgPSB7XG4gIGlkOiAnbGVnZW5kJyxcbiAgX2VsZW1lbnQ6IExlZ2VuZCxcbiAgc3RhcnQoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kID0gbmV3IExlZ2VuZCh7Y3R4OiBjaGFydC5jdHgsIG9wdGlvbnMsIGNoYXJ0fSk7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIGxlZ2VuZCwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIGxlZ2VuZCk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgY2hhcnQubGVnZW5kKTtcbiAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgIGxlZ2VuZC5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgYWZ0ZXJVcGRhdGUoY2hhcnQpIHtcbiAgICBjb25zdCBsZWdlbmQgPSBjaGFydC5sZWdlbmQ7XG4gICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgbGVnZW5kLmFkanVzdEhpdEJveGVzKCk7XG4gIH0sXG4gIGFmdGVyRXZlbnQoY2hhcnQsIGFyZ3MpIHtcbiAgICBpZiAoIWFyZ3MucmVwbGF5KSB7XG4gICAgICBjaGFydC5sZWdlbmQuaGFuZGxlRXZlbnQoYXJncy5ldmVudCk7XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGRpc3BsYXk6IHRydWUsXG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICByZXZlcnNlOiBmYWxzZSxcbiAgICB3ZWlnaHQ6IDEwMDAsXG4gICAgb25DbGljayhlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGVnZW5kSXRlbS5kYXRhc2V0SW5kZXg7XG4gICAgICBjb25zdCBjaSA9IGxlZ2VuZC5jaGFydDtcbiAgICAgIGlmIChjaS5pc0RhdGFzZXRWaXNpYmxlKGluZGV4KSkge1xuICAgICAgICBjaS5oaWRlKGluZGV4KTtcbiAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2kuc2hvdyhpbmRleCk7XG4gICAgICAgIGxlZ2VuZEl0ZW0uaGlkZGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkhvdmVyOiBudWxsLFxuICAgIG9uTGVhdmU6IG51bGwsXG4gICAgbGFiZWxzOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBib3hXaWR0aDogNDAsXG4gICAgICBwYWRkaW5nOiAxMCxcbiAgICAgIGdlbmVyYXRlTGFiZWxzKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgY29uc3Qge2xhYmVsczoge3VzZVBvaW50U3R5bGUsIHBvaW50U3R5bGUsIHRleHRBbGlnbiwgY29sb3J9fSA9IGNoYXJ0LmxlZ2VuZC5vcHRpb25zO1xuICAgICAgICByZXR1cm4gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpLm1hcCgobWV0YSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHRvUGFkZGluZyhzdHlsZS5ib3JkZXJXaWR0aCk7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLFxuICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgaGlkZGVuOiAhbWV0YS52aXNpYmxlLFxuICAgICAgICAgICAgbGluZUNhcDogc3R5bGUuYm9yZGVyQ2FwU3R5bGUsXG4gICAgICAgICAgICBsaW5lRGFzaDogc3R5bGUuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGxpbmVEYXNoT2Zmc2V0OiBzdHlsZS5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgbGluZUpvaW46IHN0eWxlLmJvcmRlckpvaW5TdHlsZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogKGJvcmRlcldpZHRoLndpZHRoICsgYm9yZGVyV2lkdGguaGVpZ2h0KSAvIDQsXG4gICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlIHx8IHN0eWxlLnBvaW50U3R5bGUsXG4gICAgICAgICAgICByb3RhdGlvbjogc3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbiB8fCBzdHlsZS50ZXh0QWxpZ24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IG1ldGEuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICBjb2xvcjogKGN0eCkgPT4gY3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgIHBvc2l0aW9uOiAnY2VudGVyJyxcbiAgICAgIHRleHQ6ICcnLFxuICAgIH1cbiAgfSxcbiAgZGVzY3JpcHRvcnM6IHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFuYW1lLnN0YXJ0c1dpdGgoJ29uJyksXG4gICAgbGFiZWxzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogKG5hbWUpID0+ICFbJ2dlbmVyYXRlTGFiZWxzJywgJ2ZpbHRlcicsICdzb3J0J10uaW5jbHVkZXMobmFtZSksXG4gICAgfVxuICB9LFxufTtcblxuY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZy5vcHRpb25zO1xuICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudG9wID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnJpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICB9XG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0KSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICB0aGlzLmxlZnQgPSAwO1xuICAgIHRoaXMudG9wID0gMDtcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5yaWdodCA9IHRoaXMuYm90dG9tID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSBtYXhXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuYm90dG9tID0gbWF4SGVpZ2h0O1xuICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgIHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcob3B0cy5wYWRkaW5nKTtcbiAgICBjb25zdCB0ZXh0U2l6ZSA9IGxpbmVDb3VudCAqIHRvRm9udChvcHRzLmZvbnQpLmxpbmVIZWlnaHQgKyB0aGlzLl9wYWRkaW5nLmhlaWdodDtcbiAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aWR0aCA9IHRleHRTaXplO1xuICAgIH1cbiAgfVxuICBpc0hvcml6b250YWwoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uO1xuICAgIHJldHVybiBwb3MgPT09ICd0b3AnIHx8IHBvcyA9PT0gJ2JvdHRvbSc7XG4gIH1cbiAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgIGNvbnN0IHt0b3AsIGxlZnQsIGJvdHRvbSwgcmlnaHQsIG9wdGlvbnN9ID0gdGhpcztcbiAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICBsZXQgbWF4V2lkdGgsIHRpdGxlWCwgdGl0bGVZO1xuICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIC0wLjU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRvcCwgYm90dG9tKTtcbiAgICAgICAgcm90YXRpb24gPSBQSSAqIDAuNTtcbiAgICAgIH1cbiAgICAgIG1heFdpZHRoID0gYm90dG9tIC0gdG9wO1xuICAgIH1cbiAgICByZXR1cm4ge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259O1xuICB9XG4gIGRyYXcoKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoIW9wdHMuZGlzcGxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBmb250T3B0cy5saW5lSGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IGxpbmVIZWlnaHQgLyAyICsgdGhpcy5fcGFkZGluZy50b3A7XG4gICAgY29uc3Qge3RpdGxlWCwgdGl0bGVZLCBtYXhXaWR0aCwgcm90YXRpb259ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICByZW5kZXJUZXh0KGN0eCwgb3B0cy50ZXh0LCAwLCAwLCBmb250T3B0cywge1xuICAgICAgY29sb3I6IG9wdHMuY29sb3IsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduOiBfdG9MZWZ0UmlnaHRDZW50ZXIob3B0cy5hbGlnbiksXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnLFxuICAgICAgdHJhbnNsYXRpb246IFt0aXRsZVgsIHRpdGxlWV0sXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVRpdGxlKGNoYXJ0LCB0aXRsZU9wdHMpIHtcbiAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgIGN0eDogY2hhcnQuY3R4LFxuICAgIG9wdGlvbnM6IHRpdGxlT3B0cyxcbiAgICBjaGFydFxuICB9KTtcbiAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCB0aXRsZU9wdHMpO1xuICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICBjaGFydC50aXRsZUJsb2NrID0gdGl0bGU7XG59XG52YXIgcGx1Z2luX3RpdGxlID0ge1xuICBpZDogJ3RpdGxlJyxcbiAgX2VsZW1lbnQ6IFRpdGxlLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjcmVhdGVUaXRsZShjaGFydCwgb3B0aW9ucyk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBjb25zdCB0aXRsZUJsb2NrID0gY2hhcnQudGl0bGVCbG9jaztcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgdGl0bGVCbG9jayk7XG4gICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gIH0sXG4gIGJlZm9yZVVwZGF0ZShjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICB0aXRsZS5vcHRpb25zID0gb3B0aW9ucztcbiAgfSxcbiAgZGVmYXVsdHM6IHtcbiAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgZGlzcGxheTogZmFsc2UsXG4gICAgZm9udDoge1xuICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgfSxcbiAgICBmdWxsU2l6ZTogdHJ1ZSxcbiAgICBwYWRkaW5nOiAxMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAyMDAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgbWFwID0gbmV3IFdlYWtNYXAoKTtcbnZhciBwbHVnaW5fc3VidGl0bGUgPSB7XG4gIGlkOiAnc3VidGl0bGUnLFxuICBzdGFydChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IG5ldyBUaXRsZSh7XG4gICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgbGF5b3V0cy5hZGRCb3goY2hhcnQsIHRpdGxlKTtcbiAgICBtYXAuc2V0KGNoYXJ0LCB0aXRsZSk7XG4gIH0sXG4gIHN0b3AoY2hhcnQpIHtcbiAgICBsYXlvdXRzLnJlbW92ZUJveChjaGFydCwgbWFwLmdldChjaGFydCkpO1xuICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgdGl0bGUsIG9wdGlvbnMpO1xuICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICBmb250OiB7XG4gICAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIH0sXG4gICAgZnVsbFNpemU6IHRydWUsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgdGV4dDogJycsXG4gICAgd2VpZ2h0OiAxNTAwXG4gIH0sXG4gIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICBjb2xvcjogJ2NvbG9yJ1xuICB9LFxuICBkZXNjcmlwdG9yczoge1xuICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9LFxufTtcblxuY29uc3QgcG9zaXRpb25lcnMgPSB7XG4gIGF2ZXJhZ2UoaXRlbXMpIHtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaSwgbGVuO1xuICAgIGxldCB4ID0gMDtcbiAgICBsZXQgeSA9IDA7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29uc3QgZWwgPSBpdGVtc1tpXS5lbGVtZW50O1xuICAgICAgaWYgKGVsICYmIGVsLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY29uc3QgcG9zID0gZWwudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgIHggKz0gcG9zLng7XG4gICAgICAgIHkgKz0gcG9zLnk7XG4gICAgICAgICsrY291bnQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiB4IC8gY291bnQsXG4gICAgICB5OiB5IC8gY291bnRcbiAgICB9O1xuICB9LFxuICBuZWFyZXN0KGl0ZW1zLCBldmVudFBvc2l0aW9uKSB7XG4gICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHggPSBldmVudFBvc2l0aW9uLng7XG4gICAgbGV0IHkgPSBldmVudFBvc2l0aW9uLnk7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBpLCBsZW4sIG5lYXJlc3RFbGVtZW50O1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbC5nZXRDZW50ZXJQb2ludCgpO1xuICAgICAgICBjb25zdCBkID0gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGV2ZW50UG9zaXRpb24sIGNlbnRlcik7XG4gICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICBtaW5EaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgbmVhcmVzdEVsZW1lbnQgPSBlbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICB4ID0gdHAueDtcbiAgICAgIHkgPSB0cC55O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG59O1xuZnVuY3Rpb24gcHVzaE9yQ29uY2F0KGJhc2UsIHRvUHVzaCkge1xuICBpZiAodG9QdXNoKSB7XG4gICAgaWYgKGlzQXJyYXkodG9QdXNoKSkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoYmFzZSwgdG9QdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBiYXNlO1xufVxuZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgaWYgKCh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpICYmIHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBJdGVtKGNoYXJ0LCBpdGVtKSB7XG4gIGNvbnN0IHtlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4fSA9IGl0ZW07XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBjaGFydC5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXI7XG4gIGNvbnN0IHtsYWJlbCwgdmFsdWV9ID0gY29udHJvbGxlci5nZXRMYWJlbEFuZFZhbHVlKGluZGV4KTtcbiAgcmV0dXJuIHtcbiAgICBjaGFydCxcbiAgICBsYWJlbCxcbiAgICBwYXJzZWQ6IGNvbnRyb2xsZXIuZ2V0UGFyc2VkKGluZGV4KSxcbiAgICByYXc6IGNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS5kYXRhW2luZGV4XSxcbiAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgZGF0YXNldDogY29udHJvbGxlci5nZXREYXRhc2V0KCksXG4gICAgZGF0YUluZGV4OiBpbmRleCxcbiAgICBkYXRhc2V0SW5kZXgsXG4gICAgZWxlbWVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VG9vbHRpcFNpemUodG9vbHRpcCwgb3B0aW9ucykge1xuICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgY29uc3Qge2JvZHksIGZvb3RlciwgdGl0bGV9ID0gdG9vbHRpcDtcbiAgY29uc3Qge2JveFdpZHRoLCBib3hIZWlnaHR9ID0gb3B0aW9ucztcbiAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gIGNvbnN0IGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gIGNvbnN0IGZvb3RlckxpbmVDb3VudCA9IGZvb3Rlci5sZW5ndGg7XG4gIGNvbnN0IGJvZHlMaW5lSXRlbUNvdW50ID0gYm9keS5sZW5ndGg7XG4gIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgbGV0IGhlaWdodCA9IHBhZGRpbmcuaGVpZ2h0O1xuICBsZXQgd2lkdGggPSAwO1xuICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSkgPT4gY291bnQgKyBib2R5SXRlbS5iZWZvcmUubGVuZ3RoICsgYm9keUl0ZW0ubGluZXMubGVuZ3RoICsgYm9keUl0ZW0uYWZ0ZXIubGVuZ3RoLCAwKTtcbiAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gIGlmICh0aXRsZUxpbmVDb3VudCkge1xuICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrICh0aXRsZUxpbmVDb3VudCAtIDEpICogb3B0aW9ucy50aXRsZVNwYWNpbmdcblx0XHRcdCsgb3B0aW9ucy50aXRsZU1hcmdpbkJvdHRvbTtcbiAgfVxuICBpZiAoY29tYmluZWRCb2R5TGVuZ3RoKSB7XG4gICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBoZWlnaHQgKz0gYm9keUxpbmVJdGVtQ291bnQgKiBib2R5TGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodFxuXHRcdFx0KyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gMSkgKiBvcHRpb25zLmJvZHlTcGFjaW5nO1xuICB9XG4gIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICBoZWlnaHQgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3Bcblx0XHRcdCsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0XG5cdFx0XHQrIChmb290ZXJMaW5lQ291bnQgLSAxKSAqIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgfVxuICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgY29uc3QgbWF4TGluZVdpZHRoID0gZnVuY3Rpb24obGluZSkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gIH07XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLnRpdGxlLCBtYXhMaW5lV2lkdGgpO1xuICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgd2lkdGhQYWRkaW5nID0gb3B0aW9ucy5kaXNwbGF5Q29sb3JzID8gKGJveFdpZHRoICsgMiArIG9wdGlvbnMuYm94UGFkZGluZykgOiAwO1xuICBlYWNoKGJvZHksIChib2R5SXRlbSkgPT4ge1xuICAgIGVhY2goYm9keUl0ZW0uYmVmb3JlLCBtYXhMaW5lV2lkdGgpO1xuICAgIGVhY2goYm9keUl0ZW0ubGluZXMsIG1heExpbmVXaWR0aCk7XG4gICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgfSk7XG4gIHdpZHRoUGFkZGluZyA9IDA7XG4gIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gIGVhY2godG9vbHRpcC5mb290ZXIsIG1heExpbmVXaWR0aCk7XG4gIGN0eC5yZXN0b3JlKCk7XG4gIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gIHJldHVybiB7d2lkdGgsIGhlaWdodH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgY29uc3Qge3ksIGhlaWdodH0gPSBzaXplO1xuICBpZiAoeSA8IGhlaWdodCAvIDIpIHtcbiAgICByZXR1cm4gJ3RvcCc7XG4gIH0gZWxzZSBpZiAoeSA+IChjaGFydC5oZWlnaHQgLSBoZWlnaHQgLyAyKSkge1xuICAgIHJldHVybiAnYm90dG9tJztcbiAgfVxuICByZXR1cm4gJ2NlbnRlcic7XG59XG5mdW5jdGlvbiBkb2VzTm90Rml0V2l0aEFsaWduKHhBbGlnbiwgY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3Qge3gsIHdpZHRofSA9IHNpemU7XG4gIGNvbnN0IGNhcmV0ID0gb3B0aW9ucy5jYXJldFNpemUgKyBvcHRpb25zLmNhcmV0UGFkZGluZztcbiAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoeEFsaWduID09PSAncmlnaHQnICYmIHggLSB3aWR0aCAtIGNhcmV0IDwgMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVYQWxpZ24oY2hhcnQsIG9wdGlvbnMsIHNpemUsIHlBbGlnbikge1xuICBjb25zdCB7eCwgd2lkdGh9ID0gc2l6ZTtcbiAgY29uc3Qge3dpZHRoOiBjaGFydFdpZHRoLCBjaGFydEFyZWE6IHtsZWZ0LCByaWdodH19ID0gY2hhcnQ7XG4gIGxldCB4QWxpZ24gPSAnY2VudGVyJztcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4QWxpZ24gPSB4IDw9IChsZWZ0ICsgcmlnaHQpIC8gMiA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH0gZWxzZSBpZiAoeCA8PSB3aWR0aCAvIDIpIHtcbiAgICB4QWxpZ24gPSAnbGVmdCc7XG4gIH0gZWxzZSBpZiAoeCA+PSBjaGFydFdpZHRoIC0gd2lkdGggLyAyKSB7XG4gICAgeEFsaWduID0gJ3JpZ2h0JztcbiAgfVxuICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgIHhBbGlnbiA9ICdjZW50ZXInO1xuICB9XG4gIHJldHVybiB4QWxpZ247XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgY29uc3QgeUFsaWduID0gc2l6ZS55QWxpZ24gfHwgb3B0aW9ucy55QWxpZ24gfHwgZGV0ZXJtaW5lWUFsaWduKGNoYXJ0LCBzaXplKTtcbiAgcmV0dXJuIHtcbiAgICB4QWxpZ246IHNpemUueEFsaWduIHx8IG9wdGlvbnMueEFsaWduIHx8IGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSxcbiAgICB5QWxpZ25cbiAgfTtcbn1cbmZ1bmN0aW9uIGFsaWduWChzaXplLCB4QWxpZ24pIHtcbiAgbGV0IHt4LCB3aWR0aH0gPSBzaXplO1xuICBpZiAoeEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgeCAtPSB3aWR0aDtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKSB7XG4gIGxldCB7eSwgaGVpZ2h0fSA9IHNpemU7XG4gIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgeSArPSBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSAtPSBoZWlnaHQgKyBwYWRkaW5nQW5kU2l6ZTtcbiAgfSBlbHNlIHtcbiAgICB5IC09IChoZWlnaHQgLyAyKTtcbiAgfVxuICByZXR1cm4geTtcbn1cbmZ1bmN0aW9uIGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBzaXplLCBhbGlnbm1lbnQsIGNoYXJ0KSB7XG4gIGNvbnN0IHtjYXJldFNpemUsIGNhcmV0UGFkZGluZywgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gIGNvbnN0IHt4QWxpZ24sIHlBbGlnbn0gPSBhbGlnbm1lbnQ7XG4gIGNvbnN0IHBhZGRpbmdBbmRTaXplID0gY2FyZXRTaXplICsgY2FyZXRQYWRkaW5nO1xuICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgbGV0IHggPSBhbGlnblgoc2l6ZSwgeEFsaWduKTtcbiAgY29uc3QgeSA9IGFsaWduWShzaXplLCB5QWxpZ24sIHBhZGRpbmdBbmRTaXplKTtcbiAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgIHggKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHggLT0gcGFkZGluZ0FuZFNpemU7XG4gICAgfVxuICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiBfbGltaXRWYWx1ZSh4LCAwLCBjaGFydC53aWR0aCAtIHNpemUud2lkdGgpLFxuICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0QWxpZ25lZFgodG9vbHRpcCwgYWxpZ24sIG9wdGlvbnMpIHtcbiAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInXG4gICAgPyB0b29sdGlwLnggKyB0b29sdGlwLndpZHRoIC8gMlxuICAgIDogYWxpZ24gPT09ICdyaWdodCdcbiAgICAgID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAtIHBhZGRpbmcucmlnaHRcbiAgICAgIDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuZnVuY3Rpb24gZ2V0QmVmb3JlQWZ0ZXJCb2R5TGluZXMoY2FsbGJhY2spIHtcbiAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgdG9vbHRpcCxcbiAgICB0b29sdGlwSXRlbXMsXG4gICAgdHlwZTogJ3Rvb2x0aXAnXG4gIH0pO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KSB7XG4gIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICByZXR1cm4gb3ZlcnJpZGUgPyBjYWxsYmFja3Mub3ZlcnJpZGUob3ZlcnJpZGUpIDogY2FsbGJhY2tzO1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgdGhpcy5fYWN0aXZlID0gW107XG4gICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gW107XG4gICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuY2hhcnQgPSBjb25maWcuY2hhcnQgfHwgY29uZmlnLl9jaGFydDtcbiAgICB0aGlzLl9jaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdW5kZWZpbmVkO1xuICAgIHRoaXMudGl0bGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmFmdGVyQm9keSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnhBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnlBbGlnbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFggPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jYXJldFkgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxhYmVsUG9pbnRTdHlsZXMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gIH1cbiAgX3Jlc29sdmVBbmltYXRpb25zKCkge1xuICAgIGNvbnN0IGNhY2hlZCA9IHRoaXMuX2NhY2hlZEFuaW1hdGlvbnM7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3Qgb3B0cyA9IG9wdGlvbnMuZW5hYmxlZCAmJiBjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAmJiBvcHRpb25zLmFuaW1hdGlvbnM7XG4gICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKHRoaXMuY2hhcnQsIG9wdHMpO1xuICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgfVxuICBnZXRDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLiRjb250ZXh0IHx8XG5cdFx0XHQodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgfVxuICBnZXRUaXRsZShjb250ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gY2FsbGJhY2tzLmJlZm9yZVRpdGxlLmFwcGx5KHRoaXMsIFtjb250ZXh0XSk7XG4gICAgY29uc3QgdGl0bGUgPSBjYWxsYmFja3MudGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBjb25zdCBhZnRlclRpdGxlID0gY2FsbGJhY2tzLmFmdGVyVGl0bGUuYXBwbHkodGhpcywgW2NvbnRleHRdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVUaXRsZSkpO1xuICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKHRpdGxlKSk7XG4gICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBnZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5iZWZvcmVCb2R5LmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKSk7XG4gIH1cbiAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Y2FsbGJhY2tzfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUl0ZW1zID0gW107XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBib2R5SXRlbSA9IHtcbiAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICBhZnRlcjogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhjYWxsYmFja3MsIGNvbnRleHQpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmJlZm9yZSwgc3BsaXROZXdsaW5lcyhzY29wZWQuYmVmb3JlTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBzY29wZWQubGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBwdXNoT3JDb25jYXQoYm9keUl0ZW0uYWZ0ZXIsIHNwbGl0TmV3bGluZXMoc2NvcGVkLmFmdGVyTGFiZWwuY2FsbCh0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgYm9keUl0ZW1zLnB1c2goYm9keUl0ZW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBib2R5SXRlbXM7XG4gIH1cbiAgZ2V0QWZ0ZXJCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhvcHRpb25zLmNhbGxiYWNrcy5hZnRlckJvZHkuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pKTtcbiAgfVxuICBnZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge2NhbGxiYWNrc30gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJlZm9yZUZvb3RlciA9IGNhbGxiYWNrcy5iZWZvcmVGb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGZvb3RlciA9IGNhbGxiYWNrcy5mb290ZXIuYXBwbHkodGhpcywgW3Rvb2x0aXBJdGVtc10pO1xuICAgIGNvbnN0IGFmdGVyRm9vdGVyID0gY2FsbGJhY2tzLmFmdGVyRm9vdGVyLmFwcGx5KHRoaXMsIFt0b29sdGlwSXRlbXNdKTtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhiZWZvcmVGb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhhZnRlckZvb3RlcikpO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5jaGFydC5kYXRhO1xuICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlcyA9IFtdO1xuICAgIGNvbnN0IGxhYmVsVGV4dENvbG9ycyA9IFtdO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBsZXQgaSwgbGVuO1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGFjdGl2ZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbHRlcikge1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLmZpbHRlcigoZWxlbWVudCwgaW5kZXgsIGFycmF5KSA9PiBvcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuaXRlbVNvcnQpIHtcbiAgICAgIHRvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcy5zb3J0KChhLCBiKSA9PiBvcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICB9XG4gICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICBsYWJlbENvbG9ycy5wdXNoKHNjb3BlZC5sYWJlbENvbG9yLmNhbGwodGhpcywgY29udGV4dCkpO1xuICAgICAgbGFiZWxQb2ludFN0eWxlcy5wdXNoKHNjb3BlZC5sYWJlbFBvaW50U3R5bGUuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgICBsYWJlbFRleHRDb2xvcnMucHVzaChzY29wZWQubGFiZWxUZXh0Q29sb3IuY2FsbCh0aGlzLCBjb250ZXh0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5sYWJlbENvbG9ycyA9IGxhYmVsQ29sb3JzO1xuICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgdGhpcy5sYWJlbFRleHRDb2xvcnMgPSBsYWJlbFRleHRDb2xvcnM7XG4gICAgdGhpcy5kYXRhUG9pbnRzID0gdG9vbHRpcEl0ZW1zO1xuICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gIH1cbiAgdXBkYXRlKGNoYW5nZWQsIHJlcGxheSkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgIGxldCBwcm9wZXJ0aWVzO1xuICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG4gICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG4gICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICB4OiBiYWNrZ3JvdW5kUG9pbnQueCxcbiAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgIHdpZHRoOiBzaXplLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgIGNhcmV0WTogcG9zaXRpb24ueVxuICAgICAgfTtcbiAgICB9XG4gICAgdGhpcy5fdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zO1xuICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlZCAmJiBvcHRpb25zLmV4dGVybmFsKSB7XG4gICAgICBvcHRpb25zLmV4dGVybmFsLmNhbGwodGhpcywge2NoYXJ0OiB0aGlzLmNoYXJ0LCB0b29sdGlwOiB0aGlzLCByZXBsYXl9KTtcbiAgICB9XG4gIH1cbiAgZHJhd0NhcmV0KHRvb2x0aXBQb2ludCwgY3R4LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2FyZXRQb3NpdGlvbiA9IHRoaXMuZ2V0Q2FyZXRQb3NpdGlvbih0b29sdGlwUG9pbnQsIHNpemUsIG9wdGlvbnMpO1xuICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgY3R4LmxpbmVUbyhjYXJldFBvc2l0aW9uLngyLCBjYXJldFBvc2l0aW9uLnkyKTtcbiAgICBjdHgubGluZVRvKGNhcmV0UG9zaXRpb24ueDMsIGNhcmV0UG9zaXRpb24ueTMpO1xuICB9XG4gIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge3hBbGlnbiwgeUFsaWdufSA9IHRoaXM7XG4gICAgY29uc3Qge2NhcmV0U2l6ZSwgY29ybmVyUmFkaXVzfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge3RvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodH0gPSB0b1RSQkxDb3JuZXJzKGNvcm5lclJhZGl1cyk7XG4gICAgY29uc3Qge3g6IHB0WCwgeTogcHRZfSA9IHRvb2x0aXBQb2ludDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSBzaXplO1xuICAgIGxldCB4MSwgeDIsIHgzLCB5MSwgeTIsIHkzO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICB5MiA9IHB0WSArIChoZWlnaHQgLyAyKTtcbiAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICB4MSA9IHB0WDtcbiAgICAgICAgeDIgPSB4MSAtIGNhcmV0U2l6ZTtcbiAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeTMgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHgxID0gcHRYICsgd2lkdGg7XG4gICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgIHkxID0geTIgLSBjYXJldFNpemU7XG4gICAgICAgIHkzID0geTIgKyBjYXJldFNpemU7XG4gICAgICB9XG4gICAgICB4MyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIChjYXJldFNpemUpO1xuICAgICAgfSBlbHNlIGlmICh4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeDIgPSBwdFggKyB3aWR0aCAtIE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgLSBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgfVxuICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgeTEgPSBwdFk7XG4gICAgICAgIHkyID0geTEgLSBjYXJldFNpemU7XG4gICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgIHgzID0geDIgKyBjYXJldFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5MSA9IHB0WSArIGhlaWdodDtcbiAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDEgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgeDMgPSB4MiAtIGNhcmV0U2l6ZTtcbiAgICAgIH1cbiAgICAgIHkzID0geTE7XG4gICAgfVxuICAgIHJldHVybiB7eDEsIHgyLCB4MywgeTEsIHkyLCB5M307XG4gIH1cbiAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMudGl0bGU7XG4gICAgY29uc3QgbGVuZ3RoID0gdGl0bGUubGVuZ3RoO1xuICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICBpZiAobGVuZ3RoKSB7XG4gICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgICAgcHQueCA9IGdldEFsaWduZWRYKHRoaXMsIG9wdGlvbnMudGl0bGVBbGlnbiwgb3B0aW9ucyk7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLnRpdGxlQWxpZ24pO1xuICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICAgIHRpdGxlU3BhY2luZyA9IG9wdGlvbnMudGl0bGVTcGFjaW5nO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMudGl0bGVDb2xvcjtcbiAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQodGl0bGVbaV0sIHJ0bEhlbHBlci54KHB0LngpLCBwdC55ICsgdGl0bGVGb250LmxpbmVIZWlnaHQgLyAyKTtcbiAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsYWJlbENvbG9ycyA9IHRoaXMubGFiZWxDb2xvcnNbaV07XG4gICAgY29uc3QgbGFiZWxQb2ludFN0eWxlID0gdGhpcy5sYWJlbFBvaW50U3R5bGVzW2ldO1xuICAgIGNvbnN0IHtib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICBjb25zdCBydGxDb2xvclggPSBydGxIZWxwZXIueChjb2xvclgpO1xuICAgIGNvbnN0IHlPZmZTZXQgPSBib3hIZWlnaHQgPCBib2R5Rm9udC5saW5lSGVpZ2h0ID8gKGJvZHlGb250LmxpbmVIZWlnaHQgLSBib3hIZWlnaHQpIC8gMiA6IDA7XG4gICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgaWYgKG9wdGlvbnMudXNlUG9pbnRTdHlsZSkge1xuICAgICAgY29uc3QgZHJhd09wdGlvbnMgPSB7XG4gICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICBwb2ludFN0eWxlOiBsYWJlbFBvaW50U3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgcm90YXRpb246IGxhYmVsUG9pbnRTdHlsZS5yb3RhdGlvbixcbiAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgIH07XG4gICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gaXNPYmplY3QobGFiZWxDb2xvcnMuYm9yZGVyV2lkdGgpID8gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhsYWJlbENvbG9ycy5ib3JkZXJXaWR0aCkpIDogKGxhYmVsQ29sb3JzLmJvcmRlcldpZHRoIHx8IDEpO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvcnMuYm9yZGVyQ29sb3I7XG4gICAgICBjdHguc2V0TGluZURhc2gobGFiZWxDb2xvcnMuYm9yZGVyRGFzaCB8fCBbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsYWJlbENvbG9ycy5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoIC0gYm94UGFkZGluZyk7XG4gICAgICBjb25zdCBpbm5lclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxIZWxwZXIueFBsdXMocnRsQ29sb3JYLCAxKSwgYm94V2lkdGggLSBib3hQYWRkaW5nIC0gMik7XG4gICAgICBjb25zdCBib3JkZXJSYWRpdXMgPSB0b1RSQkxDb3JuZXJzKGxhYmVsQ29sb3JzLmJvcmRlclJhZGl1cyk7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLm11bHRpS2V5QmFja2dyb3VuZDtcbiAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgIHg6IG91dGVyWCxcbiAgICAgICAgICB5OiBjb2xvclksXG4gICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzLFxuICAgICAgICB9KTtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvcnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBpbm5lclgsXG4gICAgICAgICAgeTogY29sb3JZICsgMSxcbiAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgaDogYm94SGVpZ2h0IC0gMixcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2VSZWN0KG91dGVyWCwgY29sb3JZLCBib3hXaWR0aCwgYm94SGVpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3JzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KGlubmVyWCwgY29sb3JZICsgMSwgYm94V2lkdGggLSAyLCBib3hIZWlnaHQgLSAyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMubGFiZWxUZXh0Q29sb3JzW2ldO1xuICB9XG4gIGRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7Ym9keX0gPSB0aGlzO1xuICAgIGNvbnN0IHtib2R5U3BhY2luZywgYm9keUFsaWduLCBkaXNwbGF5Q29sb3JzLCBib3hIZWlnaHQsIGJveFdpZHRoLCBib3hQYWRkaW5nfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgbGV0IGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdGlvbnMucnRsLCB0aGlzLngsIHRoaXMud2lkdGgpO1xuICAgIGNvbnN0IGZpbGxMaW5lT2ZUZXh0ID0gZnVuY3Rpb24obGluZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KGxpbmUsIHJ0bEhlbHBlci54KHB0LnggKyB4TGluZVBhZGRpbmcpLCBwdC55ICsgYm9keUxpbmVIZWlnaHQgLyAyKTtcbiAgICAgIHB0LnkgKz0gYm9keUxpbmVIZWlnaHQgKyBib2R5U3BhY2luZztcbiAgICB9O1xuICAgIGNvbnN0IGJvZHlBbGlnbkZvckNhbGN1bGF0aW9uID0gcnRsSGVscGVyLnRleHRBbGlnbihib2R5QWxpZ24pO1xuICAgIGxldCBib2R5SXRlbSwgdGV4dENvbG9yLCBsaW5lcywgaSwgaiwgaWxlbiwgamxlbjtcbiAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBjdHguZm9udCA9IGJvZHlGb250LnN0cmluZztcbiAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJvZHlDb2xvcjtcbiAgICBlYWNoKHRoaXMuYmVmb3JlQm9keSwgZmlsbExpbmVPZlRleHQpO1xuICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCdcbiAgICAgID8gYm9keUFsaWduID09PSAnY2VudGVyJyA/IChib3hXaWR0aCAvIDIgKyBib3hQYWRkaW5nKSA6IChib3hXaWR0aCArIDIgKyBib3hQYWRkaW5nKVxuICAgICAgOiAwO1xuICAgIGZvciAoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgYm9keUl0ZW0gPSBib2R5W2ldO1xuICAgICAgdGV4dENvbG9yID0gdGhpcy5sYWJlbFRleHRDb2xvcnNbaV07XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dENvbG9yO1xuICAgICAgZWFjaChib2R5SXRlbS5iZWZvcmUsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgIGxpbmVzID0gYm9keUl0ZW0ubGluZXM7XG4gICAgICBpZiAoZGlzcGxheUNvbG9ycyAmJiBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0NvbG9yQm94KGN0eCwgcHQsIGksIHJ0bEhlbHBlciwgb3B0aW9ucyk7XG4gICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBsaW5lcy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICB9XG4gICAgICBlYWNoKGJvZHlJdGVtLmFmdGVyLCBmaWxsTGluZU9mVGV4dCk7XG4gICAgfVxuICAgIHhMaW5lUGFkZGluZyA9IDA7XG4gICAgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICBwdC55IC09IGJvZHlTcGFjaW5nO1xuICB9XG4gIGRyYXdGb290ZXIocHQsIGN0eCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgIGNvbnN0IGxlbmd0aCA9IGZvb3Rlci5sZW5ndGg7XG4gICAgbGV0IGZvb3RlckZvbnQsIGk7XG4gICAgaWYgKGxlbmd0aCkge1xuICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG4gICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICBwdC55ICs9IGZvb3RlckZvbnQubGluZUhlaWdodCArIG9wdGlvbnMuZm9vdGVyU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZHJhd0JhY2tncm91bmQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7eEFsaWduLCB5QWxpZ259ID0gdGhpcztcbiAgICBjb25zdCB7eCwgeX0gPSBwdDtcbiAgICBjb25zdCB7d2lkdGgsIGhlaWdodH0gPSB0b29sdGlwU2l6ZTtcbiAgICBjb25zdCB7dG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0fSA9IHRvVFJCTENvcm5lcnMob3B0aW9ucy5jb3JuZXJSYWRpdXMpO1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRpb25zLmJvcmRlcldpZHRoO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHggKyB0b3BMZWZ0LCB5KTtcbiAgICBpZiAoeUFsaWduID09PSAndG9wJykge1xuICAgICAgdGhpcy5kcmF3Q2FyZXQocHQsIGN0eCwgdG9vbHRpcFNpemUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHRvcFJpZ2h0LCB5KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHRvcFJpZ2h0KTtcbiAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSBib3R0b21SaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJvdHRvbUxlZnQpO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInICYmIHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8oeCwgeSArIHRvcExlZnQpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyB0b3BMZWZ0LCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4LmZpbGwoKTtcbiAgICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUFuaW1hdGlvblRhcmdldChvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICBjb25zdCBhbmltWCA9IGFuaW1zICYmIGFuaW1zLng7XG4gICAgY29uc3QgYW5pbVkgPSBhbmltcyAmJiBhbmltcy55O1xuICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgdGhpcy5fc2l6ZSk7XG4gICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSk7XG4gICAgICBjb25zdCBwb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgY2hhcnQpO1xuICAgICAgaWYgKGFuaW1YLl90byAhPT0gcG9pbnQueCB8fCBhbmltWS5fdG8gIT09IHBvaW50LnkpIHtcbiAgICAgICAgdGhpcy54QWxpZ24gPSBhbGlnbm1lbnQueEFsaWduO1xuICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgIHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgIHRoaXMuY2FyZXRZID0gcG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoKS51cGRhdGUodGhpcywgcG9pbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfd2lsbFJlbmRlcigpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wYWNpdHk7XG4gIH1cbiAgZHJhdyhjdHgpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgIGxldCBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuICAgIGlmICghb3BhY2l0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucyk7XG4gICAgY29uc3QgdG9vbHRpcFNpemUgPSB7XG4gICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHB0ID0ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55XG4gICAgfTtcbiAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRpb25zLnBhZGRpbmcpO1xuICAgIGNvbnN0IGhhc1Rvb2x0aXBDb250ZW50ID0gdGhpcy50aXRsZS5sZW5ndGggfHwgdGhpcy5iZWZvcmVCb2R5Lmxlbmd0aCB8fCB0aGlzLmJvZHkubGVuZ3RoIHx8IHRoaXMuYWZ0ZXJCb2R5Lmxlbmd0aCB8fCB0aGlzLmZvb3Rlci5sZW5ndGg7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgfVxuICBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cywgZXZlbnRQb3NpdGlvbikge1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7ZGF0YXNldEluZGV4LCBpbmRleH0pID0+IHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICBpZiAoIW1ldGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBhIGRhdGFzZXQgYXQgaW5kZXggJyArIGRhdGFzZXRJbmRleCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnQ6IG1ldGEuZGF0YVtpbmRleF0sXG4gICAgICAgIGluZGV4LFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBjaGFuZ2VkID0gIV9lbGVtZW50c0VxdWFsKGxhc3RBY3RpdmUsIGFjdGl2ZSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgaWYgKGNoYW5nZWQgfHwgcG9zaXRpb25DaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gZXZlbnRQb3NpdGlvbjtcbiAgICAgIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cyA9IHRydWU7XG4gICAgICB0aGlzLnVwZGF0ZSh0cnVlKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICBpZiAocmVwbGF5ICYmIHRoaXMuX2lnbm9yZVJlcGxheUV2ZW50cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGxhc3RBY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwgW107XG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG4gICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSk7XG4gICAgY29uc3QgY2hhbmdlZCA9IHJlcGxheSB8fCAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKSB8fCBwb3NpdGlvbkNoYW5nZWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0ge1xuICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICB5OiBlLnlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSwgcmVwbGF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG4gIH1cbiAgX2dldEFjdGl2ZUVsZW1lbnRzKGUsIGxhc3RBY3RpdmUsIHJlcGxheSwgaW5DaGFydEFyZWEpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZW91dCcpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgcmV0dXJuIGxhc3RBY3RpdmU7XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuY2hhcnQuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBvcHRpb25zLm1vZGUsIG9wdGlvbnMsIHJlcGxheSk7XG4gICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgYWN0aXZlLnJldmVyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfVxuICBfcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZSkge1xuICAgIGNvbnN0IHtjYXJldFgsIGNhcmV0WSwgb3B0aW9uc30gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgIHJldHVybiBwb3NpdGlvbiAhPT0gZmFsc2UgJiYgKGNhcmV0WCAhPT0gcG9zaXRpb24ueCB8fCBjYXJldFkgIT09IHBvc2l0aW9uLnkpO1xuICB9XG59XG5Ub29sdGlwLnBvc2l0aW9uZXJzID0gcG9zaXRpb25lcnM7XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gIGlkOiAndG9vbHRpcCcsXG4gIF9lbGVtZW50OiBUb29sdGlwLFxuICBwb3NpdGlvbmVycyxcbiAgYWZ0ZXJJbml0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICBjaGFydC50b29sdGlwID0gbmV3IFRvb2x0aXAoe2NoYXJ0LCBvcHRpb25zfSk7XG4gICAgfVxuICB9LFxuICBiZWZvcmVVcGRhdGUoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICB9XG4gIH0sXG4gIHJlc2V0KGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgIGlmIChjaGFydC50b29sdGlwKSB7XG4gICAgICBjaGFydC50b29sdGlwLmluaXRpYWxpemUob3B0aW9ucyk7XG4gICAgfVxuICB9LFxuICBhZnRlckRyYXcoY2hhcnQpIHtcbiAgICBjb25zdCB0b29sdGlwID0gY2hhcnQudG9vbHRpcDtcbiAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgIHRvb2x0aXBcbiAgICAgIH07XG4gICAgICBpZiAoY2hhcnQubm90aWZ5UGx1Z2lucygnYmVmb3JlVG9vbHRpcERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdG9vbHRpcC5kcmF3KGNoYXJ0LmN0eCk7XG4gICAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclRvb2x0aXBEcmF3JywgYXJncyk7XG4gICAgfVxuICB9LFxuICBhZnRlckV2ZW50KGNoYXJ0LCBhcmdzKSB7XG4gICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgIGNvbnN0IHVzZUZpbmFsUG9zaXRpb24gPSBhcmdzLnJlcGxheTtcbiAgICAgIGlmIChjaGFydC50b29sdGlwLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQsIHVzZUZpbmFsUG9zaXRpb24sIGFyZ3MuaW5DaGFydEFyZWEpKSB7XG4gICAgICAgIGFyZ3MuY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkZWZhdWx0czoge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgZXh0ZXJuYWw6IG51bGwsXG4gICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuOCknLFxuICAgIHRpdGxlQ29sb3I6ICcjZmZmJyxcbiAgICB0aXRsZUZvbnQ6IHtcbiAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgIH0sXG4gICAgdGl0bGVTcGFjaW5nOiAyLFxuICAgIHRpdGxlTWFyZ2luQm90dG9tOiA2LFxuICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICBib2R5Q29sb3I6ICcjZmZmJyxcbiAgICBib2R5U3BhY2luZzogMixcbiAgICBib2R5Rm9udDoge1xuICAgIH0sXG4gICAgYm9keUFsaWduOiAnbGVmdCcsXG4gICAgZm9vdGVyQ29sb3I6ICcjZmZmJyxcbiAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgIGZvb3Rlck1hcmdpblRvcDogNixcbiAgICBmb290ZXJGb250OiB7XG4gICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICB9LFxuICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgcGFkZGluZzogNixcbiAgICBjYXJldFBhZGRpbmc6IDIsXG4gICAgY2FyZXRTaXplOiA1LFxuICAgIGNvcm5lclJhZGl1czogNixcbiAgICBib3hIZWlnaHQ6IChjdHgsIG9wdHMpID0+IG9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICBib3hXaWR0aDogKGN0eCwgb3B0cykgPT4gb3B0cy5ib2R5Rm9udC5zaXplLFxuICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgIGRpc3BsYXlDb2xvcnM6IHRydWUsXG4gICAgYm94UGFkZGluZzogMCxcbiAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgIGJvcmRlcldpZHRoOiAwLFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgZHVyYXRpb246IDQwMCxcbiAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgfSxcbiAgICBhbmltYXRpb25zOiB7XG4gICAgICBudW1iZXJzOiB7XG4gICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICBwcm9wZXJ0aWVzOiBbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnY2FyZXRYJywgJ2NhcmV0WSddLFxuICAgICAgfSxcbiAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgfVxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBiZWZvcmVUaXRsZTogbm9vcCxcbiAgICAgIHRpdGxlKHRvb2x0aXBJdGVtcykge1xuICAgICAgICBpZiAodG9vbHRpcEl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgIGNvbnN0IGxhYmVscyA9IGl0ZW0uY2hhcnQuZGF0YS5sYWJlbHM7XG4gICAgICAgICAgY29uc3QgbGFiZWxDb3VudCA9IGxhYmVscyA/IGxhYmVscy5sZW5ndGggOiAwO1xuICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS5kYXRhc2V0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubGFiZWw7XG4gICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbHNbaXRlbS5kYXRhSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9LFxuICAgICAgYWZ0ZXJUaXRsZTogbm9vcCxcbiAgICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVMYWJlbDogbm9vcCxcbiAgICAgIGxhYmVsKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgcmV0dXJuIHRvb2x0aXBJdGVtLmxhYmVsICsgJzogJyArIHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlIHx8IHRvb2x0aXBJdGVtLmZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsYWJlbCA9IHRvb2x0aXBJdGVtLmRhdGFzZXQubGFiZWwgfHwgJyc7XG4gICAgICAgIGlmIChsYWJlbCkge1xuICAgICAgICAgIGxhYmVsICs9ICc6ICc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b29sdGlwSXRlbS5mb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKHZhbHVlKSkge1xuICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgIH0sXG4gICAgICBsYWJlbENvbG9yKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICB9LFxuICAgICAgbGFiZWxQb2ludFN0eWxlKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcG9pbnRTdHlsZTogb3B0aW9ucy5wb2ludFN0eWxlLFxuICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGFmdGVyTGFiZWw6IG5vb3AsXG4gICAgICBhZnRlckJvZHk6IG5vb3AsXG4gICAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgICBmb290ZXI6IG5vb3AsXG4gICAgICBhZnRlckZvb3Rlcjogbm9vcFxuICAgIH1cbiAgfSxcbiAgZGVmYXVsdFJvdXRlczoge1xuICAgIGJvZHlGb250OiAnZm9udCcsXG4gICAgZm9vdGVyRm9udDogJ2ZvbnQnLFxuICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gIH0sXG4gIGRlc2NyaXB0b3JzOiB7XG4gICAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiBuYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgX2luZGV4YWJsZTogZmFsc2UsXG4gICAgY2FsbGJhY2tzOiB7XG4gICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICB9LFxuICAgIGFuaW1hdGlvbjoge1xuICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgIH0sXG4gICAgYW5pbWF0aW9uczoge1xuICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH1cbiAgfSxcbiAgYWRkaXRpb25hbE9wdGlvblNjb3BlczogWydpbnRlcmFjdGlvbiddXG59O1xuXG52YXIgcGx1Z2lucyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkRlY2ltYXRpb246IHBsdWdpbl9kZWNpbWF0aW9uLFxuRmlsbGVyOiBpbmRleCxcbkxlZ2VuZDogcGx1Z2luX2xlZ2VuZCxcblN1YlRpdGxlOiBwbHVnaW5fc3VidGl0bGUsXG5UaXRsZTogcGx1Z2luX3RpdGxlLFxuVG9vbHRpcDogcGx1Z2luX3Rvb2x0aXBcbn0pO1xuXG5jb25zdCBhZGRJZlN0cmluZyA9IChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSA9PiB7XG4gIGlmICh0eXBlb2YgcmF3ID09PSAnc3RyaW5nJykge1xuICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgYWRkZWRMYWJlbHMudW5zaGlmdCh7aW5kZXgsIGxhYmVsOiByYXd9KTtcbiAgfSBlbHNlIGlmIChpc05hTihyYXcpKSB7XG4gICAgaW5kZXggPSBudWxsO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gIGNvbnN0IGZpcnN0ID0gbGFiZWxzLmluZGV4T2YocmF3KTtcbiAgaWYgKGZpcnN0ID09PSAtMSkge1xuICAgIHJldHVybiBhZGRJZlN0cmluZyhsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKTtcbiAgfVxuICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gIHJldHVybiBmaXJzdCAhPT0gbGFzdCA/IGluZGV4IDogZmlyc3Q7XG59XG5jb25zdCB2YWxpZEluZGV4ID0gKGluZGV4LCBtYXgpID0+IGluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gIH1cbiAgaW5pdChzY2FsZU9wdGlvbnMpIHtcbiAgICBjb25zdCBhZGRlZCA9IHRoaXMuX2FkZGVkTGFiZWxzO1xuICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICBmb3IgKGNvbnN0IHtpbmRleCwgbGFiZWx9IG9mIGFkZGVkKSB7XG4gICAgICAgIGlmIChsYWJlbHNbaW5kZXhdID09PSBsYWJlbCkge1xuICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hZGRlZExhYmVscyA9IFtdO1xuICAgIH1cbiAgICBzdXBlci5pbml0KHNjYWxlT3B0aW9ucyk7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4XG4gICAgICA6IGZpbmRPckFkZExhYmVsKGxhYmVscywgcmF3LCB2YWx1ZU9yRGVmYXVsdChpbmRleCwgcmF3KSwgdGhpcy5fYWRkZWRMYWJlbHMpO1xuICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgbWluID0gMDtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCkge1xuICAgICAgICBtYXggPSB0aGlzLmdldExhYmVscygpLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGxldCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGxhYmVscyA9IChtaW4gPT09IDAgJiYgbWF4ID09PSBsYWJlbHMubGVuZ3RoIC0gMSkgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcbiAgICB0aGlzLl92YWx1ZVJhbmdlID0gTWF0aC5tYXgobGFiZWxzLmxlbmd0aCAtIChvZmZzZXQgPyAwIDogMSksIDEpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB0aGlzLm1pbiAtIChvZmZzZXQgPyAwLjUgOiAwKTtcbiAgICBmb3IgKGxldCB2YWx1ZSA9IG1pbjsgdmFsdWUgPD0gbWF4OyB2YWx1ZSsrKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZX0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgaWYgKHZhbHVlID49IDAgJiYgdmFsdWUgPCBsYWJlbHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAoIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSAhdGhpcy5fcmV2ZXJzZVBpeGVscztcbiAgICB9XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyc2UodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBOYU4gOiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCgodmFsdWUgLSB0aGlzLl9zdGFydFZhbHVlKSAvIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGlja3MubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fc3RhcnRWYWx1ZSArIHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAqIHRoaXMuX3ZhbHVlUmFuZ2UpO1xuICB9XG4gIGdldEJhc2VQaXhlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b207XG4gIH1cbn1cbkNhdGVnb3J5U2NhbGUuaWQgPSAnY2F0ZWdvcnknO1xuQ2F0ZWdvcnlTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogQ2F0ZWdvcnlTY2FsZS5wcm90b3R5cGUuZ2V0TGFiZWxGb3JWYWx1ZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzJDEoZ2VuZXJhdGlvbk9wdGlvbnMsIGRhdGFSYW5nZSkge1xuICBjb25zdCB0aWNrcyA9IFtdO1xuICBjb25zdCBNSU5fU1BBQ0lORyA9IDFlLTE0O1xuICBjb25zdCB7Ym91bmRzLCBzdGVwLCBtaW4sIG1heCwgcHJlY2lzaW9uLCBjb3VudCwgbWF4VGlja3MsIG1heERpZ2l0cywgaW5jbHVkZUJvdW5kc30gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgY29uc3QgdW5pdCA9IHN0ZXAgfHwgMTtcbiAgY29uc3QgbWF4U3BhY2VzID0gbWF4VGlja3MgLSAxO1xuICBjb25zdCB7bWluOiBybWluLCBtYXg6IHJtYXh9ID0gZGF0YVJhbmdlO1xuICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgY29uc3QgbWF4RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKG1heCk7XG4gIGNvbnN0IGNvdW50RGVmaW5lZCA9ICFpc051bGxPclVuZGVmKGNvdW50KTtcbiAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gIGxldCBzcGFjaW5nID0gbmljZU51bSgocm1heCAtIHJtaW4pIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICBsZXQgZmFjdG9yLCBuaWNlTWluLCBuaWNlTWF4LCBudW1TcGFjZXM7XG4gIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICByZXR1cm4gW3t2YWx1ZTogcm1pbn0sIHt2YWx1ZTogcm1heH1dO1xuICB9XG4gIG51bVNwYWNlcyA9IE1hdGguY2VpbChybWF4IC8gc3BhY2luZykgLSBNYXRoLmZsb29yKHJtaW4gLyBzcGFjaW5nKTtcbiAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgIHNwYWNpbmcgPSBuaWNlTnVtKG51bVNwYWNlcyAqIHNwYWNpbmcgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKHByZWNpc2lvbikpIHtcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcgKiBmYWN0b3IpIC8gZmFjdG9yO1xuICB9XG4gIGlmIChib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgIG5pY2VNYXggPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpICogc3BhY2luZztcbiAgfSBlbHNlIHtcbiAgICBuaWNlTWluID0gcm1pbjtcbiAgICBuaWNlTWF4ID0gcm1heDtcbiAgfVxuICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKE1hdGgubWluKChtYXggLSBtaW4pIC8gc3BhY2luZywgbWF4VGlja3MpKTtcbiAgICBzcGFjaW5nID0gKG1heCAtIG1pbikgLyBudW1TcGFjZXM7XG4gICAgbmljZU1pbiA9IG1pbjtcbiAgICBuaWNlTWF4ID0gbWF4O1xuICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgIG5pY2VNaW4gPSBtaW5EZWZpbmVkID8gbWluIDogbmljZU1pbjtcbiAgICBuaWNlTWF4ID0gbWF4RGVmaW5lZCA/IG1heCA6IG5pY2VNYXg7XG4gICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgIHNwYWNpbmcgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gbnVtU3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIG51bVNwYWNlcyA9IChuaWNlTWF4IC0gbmljZU1pbikgLyBzcGFjaW5nO1xuICAgIGlmIChhbG1vc3RFcXVhbHMobnVtU3BhY2VzLCBNYXRoLnJvdW5kKG51bVNwYWNlcyksIHNwYWNpbmcgLyAxMDAwKSkge1xuICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChudW1TcGFjZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZGVjaW1hbFBsYWNlcyA9IE1hdGgubWF4KFxuICAgIF9kZWNpbWFsUGxhY2VzKHNwYWNpbmcpLFxuICAgIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pXG4gICk7XG4gIGZhY3RvciA9IE1hdGgucG93KDEwLCBpc051bGxPclVuZGVmKHByZWNpc2lvbikgPyBkZWNpbWFsUGxhY2VzIDogcHJlY2lzaW9uKTtcbiAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gIG5pY2VNYXggPSBNYXRoLnJvdW5kKG5pY2VNYXggKiBmYWN0b3IpIC8gZmFjdG9yO1xuICBsZXQgaiA9IDA7XG4gIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgaWYgKGluY2x1ZGVCb3VuZHMgJiYgbmljZU1pbiAhPT0gbWluKSB7XG4gICAgICB0aWNrcy5wdXNoKHt2YWx1ZTogbWlufSk7XG4gICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAoYWxtb3N0RXF1YWxzKE1hdGgucm91bmQoKG5pY2VNaW4gKyBqICogc3BhY2luZykgKiBmYWN0b3IpIC8gZmFjdG9yLCBtaW4sIHJlbGF0aXZlTGFiZWxTaXplKG1pbiwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuaWNlTWluIDwgbWluKSB7XG4gICAgICBqKys7XG4gICAgfVxuICB9XG4gIGZvciAoOyBqIDwgbnVtU3BhY2VzOyArK2opIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3J9KTtcbiAgfVxuICBpZiAobWF4RGVmaW5lZCAmJiBpbmNsdWRlQm91bmRzICYmIG5pY2VNYXggIT09IG1heCkge1xuICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzLnB1c2goe3ZhbHVlOiBtYXh9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgdGlja3MucHVzaCh7dmFsdWU6IG5pY2VNYXh9KTtcbiAgfVxuICByZXR1cm4gdGlja3M7XG59XG5mdW5jdGlvbiByZWxhdGl2ZUxhYmVsU2l6ZSh2YWx1ZSwgbWluU3BhY2luZywge2hvcml6b250YWwsIG1pblJvdGF0aW9ufSkge1xuICBjb25zdCByYWQgPSB0b1JhZGlhbnMobWluUm90YXRpb24pO1xuICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4ocmFkKSA6IE1hdGguY29zKHJhZCkpIHx8IDAuMDAxO1xuICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gIHJldHVybiBNYXRoLm1pbihtaW5TcGFjaW5nIC8gcmF0aW8sIGxlbmd0aCk7XG59XG5jbGFzcyBMaW5lYXJTY2FsZUJhc2UgZXh0ZW5kcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKGNmZyk7XG4gICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9zdGFydFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICB9XG4gIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgcmF3ID09PSAnbnVtYmVyJyB8fCByYXcgaW5zdGFuY2VvZiBOdW1iZXIpICYmICFpc0Zpbml0ZSgrcmF3KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiArcmF3O1xuICB9XG4gIGhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKSB7XG4gICAgY29uc3Qge2JlZ2luQXRaZXJvfSA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQge21pbiwgbWF4fSA9IHRoaXM7XG4gICAgY29uc3Qgc2V0TWluID0gdiA9PiAobWluID0gbWluRGVmaW5lZCA/IG1pbiA6IHYpO1xuICAgIGNvbnN0IHNldE1heCA9IHYgPT4gKG1heCA9IG1heERlZmluZWQgPyBtYXggOiB2KTtcbiAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgIHNldE1heCgwKTtcbiAgICAgIH0gZWxzZSBpZiAobWluU2lnbiA+IDAgJiYgbWF4U2lnbiA+IDApIHtcbiAgICAgICAgc2V0TWluKDApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgIGxldCBvZmZzZXQgPSAxO1xuICAgICAgaWYgKG1heCA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCBtaW4gPD0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5hYnMobWF4ICogMC4wNSk7XG4gICAgICB9XG4gICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcbiAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgc2V0TWluKG1pbiAtIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluID0gbWluO1xuICAgIHRoaXMubWF4ID0gbWF4O1xuICB9XG4gIGdldFRpY2tMaW1pdCgpIHtcbiAgICBjb25zdCB0aWNrT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBsZXQge21heFRpY2tzTGltaXQsIHN0ZXBTaXplfSA9IHRpY2tPcHRzO1xuICAgIGxldCBtYXhUaWNrcztcbiAgICBpZiAoc3RlcFNpemUpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5jZWlsKHRoaXMubWF4IC8gc3RlcFNpemUpIC0gTWF0aC5mbG9vcih0aGlzLm1pbiAvIHN0ZXBTaXplKSArIDE7XG4gICAgICBpZiAobWF4VGlja3MgPiAxMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihgc2NhbGVzLiR7dGhpcy5pZH0udGlja3Muc3RlcFNpemU6ICR7c3RlcFNpemV9IHdvdWxkIHJlc3VsdCBnZW5lcmF0aW5nIHVwIHRvICR7bWF4VGlja3N9IHRpY2tzLiBMaW1pdGluZyB0byAxMDAwLmApO1xuICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFRpY2tzID0gdGhpcy5jb21wdXRlVGlja0xpbWl0KCk7XG4gICAgICBtYXhUaWNrc0xpbWl0ID0gbWF4VGlja3NMaW1pdCB8fCAxMTtcbiAgICB9XG4gICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgIH1cbiAgICByZXR1cm4gbWF4VGlja3M7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICB9XG4gIGJ1aWxkVGlja3MoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBjb25zdCB0aWNrT3B0cyA9IG9wdHMudGlja3M7XG4gICAgbGV0IG1heFRpY2tzID0gdGhpcy5nZXRUaWNrTGltaXQoKTtcbiAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICBjb25zdCBudW1lcmljR2VuZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAgIG1heFRpY2tzLFxuICAgICAgYm91bmRzOiBvcHRzLmJvdW5kcyxcbiAgICAgIG1pbjogb3B0cy5taW4sXG4gICAgICBtYXg6IG9wdHMubWF4LFxuICAgICAgcHJlY2lzaW9uOiB0aWNrT3B0cy5wcmVjaXNpb24sXG4gICAgICBzdGVwOiB0aWNrT3B0cy5zdGVwU2l6ZSxcbiAgICAgIGNvdW50OiB0aWNrT3B0cy5jb3VudCxcbiAgICAgIG1heERpZ2l0czogdGhpcy5fbWF4RGlnaXRzKCksXG4gICAgICBob3Jpem9udGFsOiB0aGlzLmlzSG9yaXpvbnRhbCgpLFxuICAgICAgbWluUm90YXRpb246IHRpY2tPcHRzLm1pblJvdGF0aW9uIHx8IDAsXG4gICAgICBpbmNsdWRlQm91bmRzOiB0aWNrT3B0cy5pbmNsdWRlQm91bmRzICE9PSBmYWxzZVxuICAgIH07XG4gICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICBjb25zdCB0aWNrcyA9IGdlbmVyYXRlVGlja3MkMShudW1lcmljR2VuZXJhdG9yT3B0aW9ucywgZGF0YVJhbmdlKTtcbiAgICBpZiAob3B0cy5ib3VuZHMgPT09ICd0aWNrcycpIHtcbiAgICAgIF9zZXRNaW5BbmRNYXhCeUtleSh0aWNrcywgdGhpcywgJ3ZhbHVlJyk7XG4gICAgfVxuICAgIGlmIChvcHRzLnJldmVyc2UpIHtcbiAgICAgIHRpY2tzLnJldmVyc2UoKTtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1heDtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5taW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgIHRoaXMuZW5kID0gdGhpcy5tYXg7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbiAgfVxuICBjb25maWd1cmUoKSB7XG4gICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgIGxldCBzdGFydCA9IHRoaXMubWluO1xuICAgIGxldCBlbmQgPSB0aGlzLm1heDtcbiAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IChlbmQgLSBzdGFydCkgLyBNYXRoLm1heCh0aWNrcy5sZW5ndGggLSAxLCAxKSAvIDI7XG4gICAgICBzdGFydCAtPSBvZmZzZXQ7XG4gICAgICBlbmQgKz0gb2Zmc2V0O1xuICAgIH1cbiAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgdGhpcy5fZW5kVmFsdWUgPSBlbmQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGVuZCAtIHN0YXJ0O1xuICB9XG4gIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHZhbHVlLCB0aGlzLmNoYXJ0Lm9wdGlvbnMubG9jYWxlLCB0aGlzLm9wdGlvbnMudGlja3MuZm9ybWF0KTtcbiAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IG1pbiA6IDA7XG4gICAgdGhpcy5tYXggPSBpc051bWJlckZpbml0ZShtYXgpID8gbWF4IDogMTtcbiAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgfVxuICBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluUm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5vcHRpb25zLnRpY2tzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCByYXRpbyA9IChob3Jpem9udGFsID8gTWF0aC5zaW4obWluUm90YXRpb24pIDogTWF0aC5jb3MobWluUm90YXRpb24pKSB8fCAwLjAwMTtcbiAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgcmV0dXJuIE1hdGguY2VpbChsZW5ndGggLyBNYXRoLm1pbig0MCwgdGlja0ZvbnQubGluZUhlaWdodCAvIHJhdGlvKSk7XG4gIH1cbiAgZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbiAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgIHJldHVybiB0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZTtcbiAgfVxufVxuTGluZWFyU2NhbGUuaWQgPSAnbGluZWFyJztcbkxpbmVhclNjYWxlLmRlZmF1bHRzID0ge1xuICB0aWNrczoge1xuICAgIGNhbGxiYWNrOiBUaWNrcy5mb3JtYXR0ZXJzLm51bWVyaWNcbiAgfVxufTtcblxuZnVuY3Rpb24gaXNNYWpvcih0aWNrVmFsKSB7XG4gIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyAoTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAodGlja1ZhbCkpKSk7XG4gIHJldHVybiByZW1haW4gPT09IDE7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVRpY2tzKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgY29uc3QgZW5kRXhwID0gTWF0aC5mbG9vcihsb2cxMChkYXRhUmFuZ2UubWF4KSk7XG4gIGNvbnN0IGVuZFNpZ25pZmljYW5kID0gTWF0aC5jZWlsKGRhdGFSYW5nZS5tYXggLyBNYXRoLnBvdygxMCwgZW5kRXhwKSk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGxldCB0aWNrVmFsID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5wb3coMTAsIE1hdGguZmxvb3IobG9nMTAoZGF0YVJhbmdlLm1pbikpKSk7XG4gIGxldCBleHAgPSBNYXRoLmZsb29yKGxvZzEwKHRpY2tWYWwpKTtcbiAgbGV0IHNpZ25pZmljYW5kID0gTWF0aC5mbG9vcih0aWNrVmFsIC8gTWF0aC5wb3coMTAsIGV4cCkpO1xuICBsZXQgcHJlY2lzaW9uID0gZXhwIDwgMCA/IE1hdGgucG93KDEwLCBNYXRoLmFicyhleHApKSA6IDE7XG4gIGRvIHtcbiAgICB0aWNrcy5wdXNoKHt2YWx1ZTogdGlja1ZhbCwgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgICArK3NpZ25pZmljYW5kO1xuICAgIGlmIChzaWduaWZpY2FuZCA9PT0gMTApIHtcbiAgICAgIHNpZ25pZmljYW5kID0gMTtcbiAgICAgICsrZXhwO1xuICAgICAgcHJlY2lzaW9uID0gZXhwID49IDAgPyAxIDogcHJlY2lzaW9uO1xuICAgIH1cbiAgICB0aWNrVmFsID0gTWF0aC5yb3VuZChzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgfSB3aGlsZSAoZXhwIDwgZW5kRXhwIHx8IChleHAgPT09IGVuZEV4cCAmJiBzaWduaWZpY2FuZCA8IGVuZFNpZ25pZmljYW5kKSk7XG4gIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdGlja1ZhbCk7XG4gIHRpY2tzLnB1c2goe3ZhbHVlOiBsYXN0VGljaywgbWFqb3I6IGlzTWFqb3IodGlja1ZhbCl9KTtcbiAgcmV0dXJuIHRpY2tzO1xufVxuY2xhc3MgTG9nYXJpdGhtaWNTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnN0YXJ0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gIH1cbiAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbcmF3LCBpbmRleF0pO1xuICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gaXNOdW1iZXJGaW5pdGUodmFsdWUpICYmIHZhbHVlID4gMCA/IHZhbHVlIDogbnVsbDtcbiAgfVxuICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgIGNvbnN0IHttaW4sIG1heH0gPSB0aGlzLmdldE1pbk1heCh0cnVlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBNYXRoLm1heCgwLCBtaW4pIDogbnVsbDtcbiAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJlZ2luQXRaZXJvKSB7XG4gICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICBjb25zdCB7bWluRGVmaW5lZCwgbWF4RGVmaW5lZH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICBsZXQgbWluID0gdGhpcy5taW47XG4gICAgbGV0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHNldE1pbiA9IHYgPT4gKG1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2KTtcbiAgICBjb25zdCBzZXRNYXggPSB2ID0+IChtYXggPSBtYXhEZWZpbmVkID8gbWF4IDogdik7XG4gICAgY29uc3QgZXhwID0gKHYsIG0pID0+IE1hdGgucG93KDEwLCBNYXRoLmZsb29yKGxvZzEwKHYpKSArIG0pO1xuICAgIGlmIChtaW4gPT09IG1heCkge1xuICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgc2V0TWF4KDEwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgICAgICBzZXRNYXgoZXhwKG1heCwgKzEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICBzZXRNaW4oZXhwKG1heCwgLTEpKTtcbiAgICB9XG4gICAgaWYgKG1heCA8PSAwKSB7XG4gICAgICBzZXRNYXgoZXhwKG1pbiwgKzEpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiBtaW4gPT09IGV4cCh0aGlzLm1pbiwgMCkpIHtcbiAgICAgIHNldE1pbihleHAobWluLCAtMSkpO1xuICAgIH1cbiAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICB0aGlzLm1heCA9IG1heDtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZ2VuZXJhdGlvbk9wdGlvbnMgPSB7XG4gICAgICBtaW46IHRoaXMuX3VzZXJNaW4sXG4gICAgICBtYXg6IHRoaXMuX3VzZXJNYXhcbiAgICB9O1xuICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG4gICAgaWYgKG9wdHMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICBfc2V0TWluQW5kTWF4QnlLZXkodGlja3MsIHRoaXMsICd2YWx1ZScpO1xuICAgIH1cbiAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5taW47XG4gICAgICB0aGlzLmVuZCA9IHRoaXMubWF4O1xuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcwJ1xuICAgICAgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICB9XG4gIGNvbmZpZ3VyZSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMubWluO1xuICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSBsb2cxMChzdGFydCk7XG4gICAgdGhpcy5fdmFsdWVSYW5nZSA9IGxvZzEwKHRoaXMubWF4KSAtIGxvZzEwKHN0YXJ0KTtcbiAgfVxuICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yRGVjaW1hbCh2YWx1ZSA9PT0gdGhpcy5taW5cbiAgICAgID8gMFxuICAgICAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKTtcbiAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gIH1cbn1cbkxvZ2FyaXRobWljU2NhbGUuaWQgPSAnbG9nYXJpdGhtaWMnO1xuTG9nYXJpdGhtaWNTY2FsZS5kZWZhdWx0cyA9IHtcbiAgdGlja3M6IHtcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KG9wdHMpIHtcbiAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKHRpY2tPcHRzLmJhY2tkcm9wUGFkZGluZyk7XG4gICAgcmV0dXJuIHZhbHVlT3JEZWZhdWx0KHRpY2tPcHRzLmZvbnQgJiYgdGlja09wdHMuZm9udC5zaXplLCBkZWZhdWx0cy5mb250LnNpemUpICsgcGFkZGluZy5oZWlnaHQ7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgbGFiZWwgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsIDogW2xhYmVsXTtcbiAgcmV0dXJuIHtcbiAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgIGg6IGxhYmVsLmxlbmd0aCAqIGZvbnQubGluZUhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gIGlmIChhbmdsZSA9PT0gbWluIHx8IGFuZ2xlID09PSBtYXgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IHBvcyAtIChzaXplIC8gMiksXG4gICAgICBlbmQ6IHBvcyArIChzaXplIC8gMilcbiAgICB9O1xuICB9IGVsc2UgaWYgKGFuZ2xlIDwgbWluIHx8IGFuZ2xlID4gbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgZW5kOiBwb3NcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHBvcyxcbiAgICBlbmQ6IHBvcyArIHNpemVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZpdFdpdGhQb2ludExhYmVscyhzY2FsZSkge1xuICBjb25zdCBvcmlnID0ge1xuICAgIGw6IHNjYWxlLmxlZnQgKyBzY2FsZS5fcGFkZGluZy5sZWZ0LFxuICAgIHI6IHNjYWxlLnJpZ2h0IC0gc2NhbGUuX3BhZGRpbmcucmlnaHQsXG4gICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgIGI6IHNjYWxlLmJvdHRvbSAtIHNjYWxlLl9wYWRkaW5nLmJvdHRvbVxuICB9O1xuICBjb25zdCBsaW1pdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcmlnKTtcbiAgY29uc3QgbGFiZWxTaXplcyA9IFtdO1xuICBjb25zdCBwYWRkaW5nID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBwb2ludExhYmVsT3B0cyA9IHNjYWxlLm9wdGlvbnMucG9pbnRMYWJlbHM7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZUNvdW50OyBpKyspIHtcbiAgICBjb25zdCBvcHRzID0gcG9pbnRMYWJlbE9wdHMuc2V0Q29udGV4dChzY2FsZS5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgcGFkZGluZ1tpXSA9IG9wdHMucGFkZGluZztcbiAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHMuZm9udCk7XG4gICAgY29uc3QgdGV4dFNpemUgPSBtZWFzdXJlTGFiZWxTaXplKHNjYWxlLmN0eCwgcGxGb250LCBzY2FsZS5fcG9pbnRMYWJlbHNbaV0pO1xuICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICBjb25zdCBhbmdsZVJhZGlhbnMgPSBfbm9ybWFsaXplQW5nbGUoc2NhbGUuZ2V0SW5kZXhBbmdsZShpKSArIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgY29uc3QgYW5nbGUgPSBNYXRoLnJvdW5kKHRvRGVncmVlcyhhbmdsZVJhZGlhbnMpKTtcbiAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgY29uc3QgdkxpbWl0cyA9IGRldGVybWluZUxpbWl0cyhhbmdsZSwgcG9pbnRQb3NpdGlvbi55LCB0ZXh0U2l6ZS5oLCA5MCwgMjcwKTtcbiAgICB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZVJhZGlhbnMsIGhMaW1pdHMsIHZMaW1pdHMpO1xuICB9XG4gIHNjYWxlLnNldENlbnRlclBvaW50KFxuICAgIG9yaWcubCAtIGxpbWl0cy5sLFxuICAgIGxpbWl0cy5yIC0gb3JpZy5yLFxuICAgIG9yaWcudCAtIGxpbWl0cy50LFxuICAgIGxpbWl0cy5iIC0gb3JpZy5iXG4gICk7XG4gIHNjYWxlLl9wb2ludExhYmVsSXRlbXMgPSBidWlsZFBvaW50TGFiZWxJdGVtcyhzY2FsZSwgbGFiZWxTaXplcywgcGFkZGluZyk7XG59XG5mdW5jdGlvbiB1cGRhdGVMaW1pdHMobGltaXRzLCBvcmlnLCBhbmdsZSwgaExpbWl0cywgdkxpbWl0cykge1xuICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICBjb25zdCBjb3MgPSBNYXRoLmFicyhNYXRoLmNvcyhhbmdsZSkpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKGhMaW1pdHMuc3RhcnQgPCBvcmlnLmwpIHtcbiAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgIGxpbWl0cy5sID0gTWF0aC5taW4obGltaXRzLmwsIG9yaWcubCAtIHgpO1xuICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgeCA9IChoTGltaXRzLmVuZCAtIG9yaWcucikgLyBzaW47XG4gICAgbGltaXRzLnIgPSBNYXRoLm1heChsaW1pdHMuciwgb3JpZy5yICsgeCk7XG4gIH1cbiAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICB5ID0gKG9yaWcudCAtIHZMaW1pdHMuc3RhcnQpIC8gY29zO1xuICAgIGxpbWl0cy50ID0gTWF0aC5taW4obGltaXRzLnQsIG9yaWcudCAtIHkpO1xuICB9IGVsc2UgaWYgKHZMaW1pdHMuZW5kID4gb3JpZy5iKSB7XG4gICAgeSA9ICh2TGltaXRzLmVuZCAtIG9yaWcuYikgLyBjb3M7XG4gICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkUG9pbnRMYWJlbEl0ZW1zKHNjYWxlLCBsYWJlbFNpemVzLCBwYWRkaW5nKSB7XG4gIGNvbnN0IGl0ZW1zID0gW107XG4gIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICBjb25zdCBvcHRzID0gc2NhbGUub3B0aW9ucztcbiAgY29uc3QgZXh0cmEgPSBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykgLyAyO1xuICBjb25zdCBvdXRlckRpc3RhbmNlID0gc2NhbGUuZHJhd2luZ0FyZWE7XG4gIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IG9wdHMucG9pbnRMYWJlbHMuY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlQ291bnQ7IGkrKykge1xuICAgIGNvbnN0IHBvaW50TGFiZWxQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgb3V0ZXJEaXN0YW5jZSArIGV4dHJhICsgcGFkZGluZ1tpXSwgYWRkaXRpb25hbEFuZ2xlKTtcbiAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKF9ub3JtYWxpemVBbmdsZShwb2ludExhYmVsUG9zaXRpb24uYW5nbGUgKyBIQUxGX1BJKSkpO1xuICAgIGNvbnN0IHNpemUgPSBsYWJlbFNpemVzW2ldO1xuICAgIGNvbnN0IHkgPSB5Rm9yQW5nbGUocG9pbnRMYWJlbFBvc2l0aW9uLnksIHNpemUuaCwgYW5nbGUpO1xuICAgIGNvbnN0IHRleHRBbGlnbiA9IGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKTtcbiAgICBjb25zdCBsZWZ0ID0gbGVmdEZvclRleHRBbGlnbihwb2ludExhYmVsUG9zaXRpb24ueCwgc2l6ZS53LCB0ZXh0QWxpZ24pO1xuICAgIGl0ZW1zLnB1c2goe1xuICAgICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgICB5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgbGVmdCxcbiAgICAgIHRvcDogeSxcbiAgICAgIHJpZ2h0OiBsZWZ0ICsgc2l6ZS53LFxuICAgICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGl0ZW1zO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpIHtcbiAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICByZXR1cm4gJ2NlbnRlcic7XG4gIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICByZXR1cm4gJ2xlZnQnO1xuICB9XG4gIHJldHVybiAncmlnaHQnO1xufVxuZnVuY3Rpb24gbGVmdEZvclRleHRBbGlnbih4LCB3LCBhbGlnbikge1xuICBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHc7XG4gIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgeCAtPSAodyAvIDIpO1xuICB9XG4gIHJldHVybiB4O1xufVxuZnVuY3Rpb24geUZvckFuZ2xlKHksIGgsIGFuZ2xlKSB7XG4gIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgIHkgLT0gKGggLyAyKTtcbiAgfSBlbHNlIGlmIChhbmdsZSA+IDI3MCB8fCBhbmdsZSA8IDkwKSB7XG4gICAgeSAtPSBoO1xuICB9XG4gIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHgsIG9wdGlvbnM6IHtwb2ludExhYmVsc319ID0gc2NhbGU7XG4gIGZvciAobGV0IGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICBjb25zdCB7eCwgeSwgdGV4dEFsaWduLCBsZWZ0LCB0b3AsIHJpZ2h0LCBib3R0b219ID0gc2NhbGUuX3BvaW50TGFiZWxJdGVtc1tpXTtcbiAgICBjb25zdCB7YmFja2Ryb3BDb2xvcn0gPSBvcHRzQXRJbmRleDtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYoYmFja2Ryb3BDb2xvcikpIHtcbiAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0c0F0SW5kZXguYm9yZGVyUmFkaXVzKTtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZHJvcENvbG9yO1xuICAgICAgY29uc3QgYmFja2Ryb3BMZWZ0ID0gbGVmdCAtIHBhZGRpbmcubGVmdDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgICBjb25zdCBiYWNrZHJvcFdpZHRoID0gcmlnaHQgLSBsZWZ0ICsgcGFkZGluZy53aWR0aDtcbiAgICAgIGNvbnN0IGJhY2tkcm9wSGVpZ2h0ID0gYm90dG9tIC0gdG9wICsgcGFkZGluZy5oZWlnaHQ7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUodiA9PiB2ICE9PSAwKSkge1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICB4OiBiYWNrZHJvcExlZnQsXG4gICAgICAgICAgeTogYmFja2Ryb3BUb3AsXG4gICAgICAgICAgdzogYmFja2Ryb3BXaWR0aCxcbiAgICAgICAgICBoOiBiYWNrZHJvcEhlaWdodCxcbiAgICAgICAgICByYWRpdXM6IGJvcmRlclJhZGl1cyxcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUZXh0KFxuICAgICAgY3R4LFxuICAgICAgc2NhbGUuX3BvaW50TGFiZWxzW2ldLFxuICAgICAgeCxcbiAgICAgIHkgKyAocGxGb250LmxpbmVIZWlnaHQgLyAyKSxcbiAgICAgIHBsRm9udCxcbiAgICAgIHtcbiAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGhSYWRpdXNMaW5lKHNjYWxlLCByYWRpdXMsIGNpcmN1bGFyLCBsYWJlbENvdW50KSB7XG4gIGNvbnN0IHtjdHh9ID0gc2NhbGU7XG4gIGlmIChjaXJjdWxhcikge1xuICAgIGN0eC5hcmMoc2NhbGUueENlbnRlciwgc2NhbGUueUNlbnRlciwgcmFkaXVzLCAwLCBUQVUpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbigwLCByYWRpdXMpO1xuICAgIGN0eC5tb3ZlVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGFiZWxDb3VudDsgaSsrKSB7XG4gICAgICBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCByYWRpdXMpO1xuICAgICAgY3R4LmxpbmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3UmFkaXVzTGluZShzY2FsZSwgZ3JpZExpbmVPcHRzLCByYWRpdXMsIGxhYmVsQ291bnQpIHtcbiAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICBjb25zdCBjaXJjdWxhciA9IGdyaWRMaW5lT3B0cy5jaXJjdWxhcjtcbiAgY29uc3Qge2NvbG9yLCBsaW5lV2lkdGh9ID0gZ3JpZExpbmVPcHRzO1xuICBpZiAoKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCkgfHwgIWNvbG9yIHx8ICFsaW5lV2lkdGggfHwgcmFkaXVzIDwgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjdHguc2F2ZSgpO1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgY3R4LnNldExpbmVEYXNoKGdyaWRMaW5lT3B0cy5ib3JkZXJEYXNoKTtcbiAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZ3JpZExpbmVPcHRzLmJvcmRlckRhc2hPZmZzZXQ7XG4gIGN0eC5iZWdpblBhdGgoKTtcbiAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICBjdHguY2xvc2VQYXRoKCk7XG4gIGN0eC5zdHJva2UoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gIHJldHVybiBjcmVhdGVDb250ZXh0KHBhcmVudCwge1xuICAgIGxhYmVsLFxuICAgIGluZGV4LFxuICAgIHR5cGU6ICdwb2ludExhYmVsJ1xuICB9KTtcbn1cbmNsYXNzIFJhZGlhbExpbmVhclNjYWxlIGV4dGVuZHMgTGluZWFyU2NhbGVCYXNlIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoY2ZnKTtcbiAgICB0aGlzLnhDZW50ZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy55Q2VudGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSBbXTtcbiAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgfVxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKGdldFRpY2tCYWNrZHJvcEhlaWdodCh0aGlzLm9wdGlvbnMpIC8gMik7XG4gICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICBjb25zdCBoID0gdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodCAtIHBhZGRpbmcuaGVpZ2h0O1xuICAgIHRoaXMueENlbnRlciA9IE1hdGguZmxvb3IodGhpcy5sZWZ0ICsgdyAvIDIgKyBwYWRkaW5nLmxlZnQpO1xuICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICB0aGlzLmRyYXdpbmdBcmVhID0gTWF0aC5mbG9vcihNYXRoLm1pbih3LCBoKSAvIDIpO1xuICB9XG4gIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgY29uc3Qge21pbiwgbWF4fSA9IHRoaXMuZ2V0TWluTWF4KGZhbHNlKTtcbiAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgJiYgIWlzTmFOKG1pbikgPyBtaW4gOiAwO1xuICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG4gICAgdGhpcy5oYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCk7XG4gIH1cbiAgY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gIH1cbiAgZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5nZW5lcmF0ZVRpY2tMYWJlbHMuY2FsbCh0aGlzLCB0aWNrcyk7XG4gICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpXG4gICAgICAubWFwKCh2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFt2YWx1ZSwgaW5kZXhdLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGxhYmVsIHx8IGxhYmVsID09PSAwID8gbGFiZWwgOiAnJztcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKCh2LCBpKSA9PiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgfVxuICBmaXQoKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldENlbnRlclBvaW50KDAsIDAsIDAsIDApO1xuICAgIH1cbiAgfVxuICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgIHRoaXMueENlbnRlciArPSBNYXRoLmZsb29yKChsZWZ0TW92ZW1lbnQgLSByaWdodE1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMueUNlbnRlciArPSBNYXRoLmZsb29yKCh0b3BNb3ZlbWVudCAtIGJvdHRvbU1vdmVtZW50KSAvIDIpO1xuICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gIH1cbiAgZ2V0SW5kZXhBbmdsZShpbmRleCkge1xuICAgIGNvbnN0IGFuZ2xlTXVsdGlwbGllciA9IFRBVSAvICh0aGlzLl9wb2ludExhYmVscy5sZW5ndGggfHwgMSk7XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG4gICAgcmV0dXJuIF9ub3JtYWxpemVBbmdsZShpbmRleCAqIGFuZ2xlTXVsdGlwbGllciArIHRvUmFkaWFucyhzdGFydEFuZ2xlKSk7XG4gIH1cbiAgZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNjYWxpbmdGYWN0b3IgPSB0aGlzLmRyYXdpbmdBcmVhIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIHJldHVybiAodmFsdWUgLSB0aGlzLm1pbikgKiBzY2FsaW5nRmFjdG9yO1xuICB9XG4gIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgaWYgKGlzTnVsbE9yVW5kZWYoZGlzdGFuY2UpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMucmV2ZXJzZSA/IHRoaXMubWF4IC0gc2NhbGVkRGlzdGFuY2UgOiB0aGlzLm1pbiArIHNjYWxlZERpc3RhbmNlO1xuICB9XG4gIGdldFBvaW50TGFiZWxDb250ZXh0KGluZGV4KSB7XG4gICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICBpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IHBvaW50TGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgcG9pbnRMYWJlbCA9IHBvaW50TGFiZWxzW2luZGV4XTtcbiAgICAgIHJldHVybiBjcmVhdGVQb2ludExhYmVsQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHBvaW50TGFiZWwpO1xuICAgIH1cbiAgfVxuICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICBjb25zdCBhbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZShpbmRleCkgLSBIQUxGX1BJICsgYWRkaXRpb25hbEFuZ2xlO1xuICAgIHJldHVybiB7XG4gICAgICB4OiBNYXRoLmNvcyhhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnhDZW50ZXIsXG4gICAgICB5OiBNYXRoLnNpbihhbmdsZSkgKiBkaXN0YW5jZUZyb21DZW50ZXIgKyB0aGlzLnlDZW50ZXIsXG4gICAgICBhbmdsZVxuICAgIH07XG4gIH1cbiAgZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFBvaW50UG9zaXRpb24oaW5kZXgsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodmFsdWUpKTtcbiAgfVxuICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaW5kZXggfHwgMCwgdGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gIH1cbiAgZ2V0UG9pbnRMYWJlbFBvc2l0aW9uKGluZGV4KSB7XG4gICAgY29uc3Qge2xlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbX0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgIHJldHVybiB7XG4gICAgICBsZWZ0LFxuICAgICAgdG9wLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgfTtcbiAgfVxuICBkcmF3QmFja2dyb3VuZCgpIHtcbiAgICBjb25zdCB7YmFja2dyb3VuZENvbG9yLCBncmlkOiB7Y2lyY3VsYXJ9fSA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBwYXRoUmFkaXVzTGluZSh0aGlzLCB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuX2VuZFZhbHVlKSwgY2lyY3VsYXIsIHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG4gIGRyYXdHcmlkKCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3Qge2FuZ2xlTGluZXMsIGdyaWR9ID0gb3B0cztcbiAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGxldCBpLCBvZmZzZXQsIHBvc2l0aW9uO1xuICAgIGlmIChvcHRzLnBvaW50TGFiZWxzLmRpc3BsYXkpIHtcbiAgICAgIGRyYXdQb2ludExhYmVscyh0aGlzLCBsYWJlbENvdW50KTtcbiAgICB9XG4gICAgaWYgKGdyaWQuZGlzcGxheSkge1xuICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCkgPT4ge1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gZ3JpZC5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpbmRleCAtIDEpKTtcbiAgICAgICAgICBkcmF3UmFkaXVzTGluZSh0aGlzLCBvcHRzQXRJbmRleCwgb2Zmc2V0LCBsYWJlbENvdW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUxpbmVzLmRpc3BsYXkpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBmb3IgKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBhbmdsZUxpbmVzLnNldENvbnRleHQodGhpcy5nZXRQb2ludExhYmVsQ29udGV4dChpKSk7XG4gICAgICAgIGNvbnN0IHtjb2xvciwgbGluZVdpZHRofSA9IG9wdHNBdEluZGV4O1xuICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBvcHRzQXRJbmRleC5ib3JkZXJEYXNoT2Zmc2V0O1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKG9wdHMudGlja3MucmV2ZXJzZSA/IHRoaXMubWluIDogdGhpcy5tYXgpO1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5tb3ZlVG8odGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBkcmF3Qm9yZGVyKCkge31cbiAgZHJhd0xhYmVscygpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAoIXRpY2tPcHRzLmRpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICBsZXQgb2Zmc2V0LCB3aWR0aDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgIGN0eC5yb3RhdGUoc3RhcnRBbmdsZSk7XG4gICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB0aGlzLnRpY2tzLmZvckVhY2goKHRpY2ssIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPT09IDAgJiYgIW9wdHMucmV2ZXJzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgIGN0eC5mb250ID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aWNrLmxhYmVsKS53aWR0aDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0c0F0SW5kZXguYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgIC13aWR0aCAvIDIgLSBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgLW9mZnNldCAtIHRpY2tGb250LnNpemUgLyAyIC0gcGFkZGluZy50b3AsXG4gICAgICAgICAgd2lkdGggKyBwYWRkaW5nLndpZHRoLFxuICAgICAgICAgIHRpY2tGb250LnNpemUgKyBwYWRkaW5nLmhlaWdodFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgIGNvbG9yOiBvcHRzQXRJbmRleC5jb2xvcixcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZHJhd1RpdGxlKCkge31cbn1cblJhZGlhbExpbmVhclNjYWxlLmlkID0gJ3JhZGlhbExpbmVhcic7XG5SYWRpYWxMaW5lYXJTY2FsZS5kZWZhdWx0cyA9IHtcbiAgZGlzcGxheTogdHJ1ZSxcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgcG9zaXRpb246ICdjaGFydEFyZWEnLFxuICBhbmdsZUxpbmVzOiB7XG4gICAgZGlzcGxheTogdHJ1ZSxcbiAgICBsaW5lV2lkdGg6IDEsXG4gICAgYm9yZGVyRGFzaDogW10sXG4gICAgYm9yZGVyRGFzaE9mZnNldDogMC4wXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICBjaXJjdWxhcjogZmFsc2VcbiAgfSxcbiAgc3RhcnRBbmdsZTogMCxcbiAgdGlja3M6IHtcbiAgICBzaG93TGFiZWxCYWNrZHJvcDogdHJ1ZSxcbiAgICBjYWxsYmFjazogVGlja3MuZm9ybWF0dGVycy5udW1lcmljXG4gIH0sXG4gIHBvaW50TGFiZWxzOiB7XG4gICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuICAgIGJhY2tkcm9wUGFkZGluZzogMixcbiAgICBkaXNwbGF5OiB0cnVlLFxuICAgIGZvbnQ6IHtcbiAgICAgIHNpemU6IDEwXG4gICAgfSxcbiAgICBjYWxsYmFjayhsYWJlbCkge1xuICAgICAgcmV0dXJuIGxhYmVsO1xuICAgIH0sXG4gICAgcGFkZGluZzogNSxcbiAgICBjZW50ZXJQb2ludExhYmVsczogZmFsc2VcbiAgfVxufTtcblJhZGlhbExpbmVhclNjYWxlLmRlZmF1bHRSb3V0ZXMgPSB7XG4gICdhbmdsZUxpbmVzLmNvbG9yJzogJ2JvcmRlckNvbG9yJyxcbiAgJ3BvaW50TGFiZWxzLmNvbG9yJzogJ2NvbG9yJyxcbiAgJ3RpY2tzLmNvbG9yJzogJ2NvbG9yJ1xufTtcblJhZGlhbExpbmVhclNjYWxlLmRlc2NyaXB0b3JzID0ge1xuICBhbmdsZUxpbmVzOiB7XG4gICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgfVxufTtcblxuY29uc3QgSU5URVJWQUxTID0ge1xuICBtaWxsaXNlY29uZDoge2NvbW1vbjogdHJ1ZSwgc2l6ZTogMSwgc3RlcHM6IDEwMDB9LFxuICBzZWNvbmQ6IHtjb21tb246IHRydWUsIHNpemU6IDEwMDAsIHN0ZXBzOiA2MH0sXG4gIG1pbnV0ZToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogNjAwMDAsIHN0ZXBzOiA2MH0sXG4gIGhvdXI6IHtjb21tb246IHRydWUsIHNpemU6IDM2MDAwMDAsIHN0ZXBzOiAyNH0sXG4gIGRheToge2NvbW1vbjogdHJ1ZSwgc2l6ZTogODY0MDAwMDAsIHN0ZXBzOiAzMH0sXG4gIHdlZWs6IHtjb21tb246IGZhbHNlLCBzaXplOiA2MDQ4MDAwMDAsIHN0ZXBzOiA0fSxcbiAgbW9udGg6IHtjb21tb246IHRydWUsIHNpemU6IDIuNjI4ZTksIHN0ZXBzOiAxMn0sXG4gIHF1YXJ0ZXI6IHtjb21tb246IGZhbHNlLCBzaXplOiA3Ljg4NGU5LCBzdGVwczogNH0sXG4gIHllYXI6IHtjb21tb246IHRydWUsIHNpemU6IDMuMTU0ZTEwfVxufTtcbmNvbnN0IFVOSVRTID0gKE9iamVjdC5rZXlzKElOVEVSVkFMUykpO1xuZnVuY3Rpb24gc29ydGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gcGFyc2Uoc2NhbGUsIGlucHV0KSB7XG4gIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGFkYXB0ZXIgPSBzY2FsZS5fYWRhcHRlcjtcbiAgY29uc3Qge3BhcnNlciwgcm91bmQsIGlzb1dlZWtkYXl9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgbGV0IHZhbHVlID0gaW5wdXQ7XG4gIGlmICh0eXBlb2YgcGFyc2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFsdWUgPSBwYXJzZXIodmFsdWUpO1xuICB9XG4gIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgdmFsdWUgPSB0eXBlb2YgcGFyc2VyID09PSAnc3RyaW5nJ1xuICAgICAgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpXG4gICAgICA6IGFkYXB0ZXIucGFyc2UodmFsdWUpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyb3VuZCkge1xuICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSlcbiAgICAgID8gYWRhcHRlci5zdGFydE9mKHZhbHVlLCAnaXNvV2VlaycsIGlzb1dlZWtkYXkpXG4gICAgICA6IGFkYXB0ZXIuc3RhcnRPZih2YWx1ZSwgcm91bmQpO1xuICB9XG4gIHJldHVybiArdmFsdWU7XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICBjb25zdCBpbGVuID0gVU5JVFMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpIHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgY29uc3QgZmFjdG9yID0gaW50ZXJ2YWwuc3RlcHMgPyBpbnRlcnZhbC5zdGVwcyA6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgIGlmIChpbnRlcnZhbC5jb21tb24gJiYgTWF0aC5jZWlsKChtYXggLSBtaW4pIC8gKGZhY3RvciAqIGludGVydmFsLnNpemUpKSA8PSBjYXBhY2l0eSkge1xuICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gVU5JVFNbaWxlbiAtIDFdO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lVW5pdEZvckZvcm1hdHRpbmcoc2NhbGUsIG51bVRpY2tzLCBtaW5Vbml0LCBtaW4sIG1heCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pIHtcbiAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgaWYgKElOVEVSVkFMU1t1bml0XS5jb21tb24gJiYgc2NhbGUuX2FkYXB0ZXIuZGlmZihtYXgsIG1pbiwgdW5pdCkgPj0gbnVtVGlja3MgLSAxKSB7XG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVNYWpvclVuaXQodW5pdCkge1xuICBmb3IgKGxldCBpID0gVU5JVFMuaW5kZXhPZih1bml0KSArIDEsIGlsZW4gPSBVTklUUy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBpZiAoSU5URVJWQUxTW1VOSVRTW2ldXS5jb21tb24pIHtcbiAgICAgIHJldHVybiBVTklUU1tpXTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgaWYgKCF0aW1lc3RhbXBzKSB7XG4gICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgY29uc3Qge2xvLCBoaX0gPSBfbG9va3VwKHRpbWVzdGFtcHMsIHRpbWUpO1xuICAgIGNvbnN0IHRpbWVzdGFtcCA9IHRpbWVzdGFtcHNbbG9dID49IHRpbWUgPyB0aW1lc3RhbXBzW2xvXSA6IHRpbWVzdGFtcHNbaGldO1xuICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICBjb25zdCBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YodGlja3NbMF0udmFsdWUsIG1ham9yVW5pdCk7XG4gIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgbGV0IG1ham9yLCBpbmRleDtcbiAgZm9yIChtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSkge1xuICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdGlja3NbaW5kZXhdLm1ham9yID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuZnVuY3Rpb24gdGlja3NGcm9tVGltZXN0YW1wcyhzY2FsZSwgdmFsdWVzLCBtYWpvclVuaXQpIHtcbiAgY29uc3QgdGlja3MgPSBbXTtcbiAgY29uc3QgbWFwID0ge307XG4gIGNvbnN0IGlsZW4gPSB2YWx1ZXMubGVuZ3RoO1xuICBsZXQgaSwgdmFsdWU7XG4gIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICBtYXBbdmFsdWVdID0gaTtcbiAgICB0aWNrcy5wdXNoKHtcbiAgICAgIHZhbHVlLFxuICAgICAgbWFqb3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIChpbGVuID09PSAwIHx8ICFtYWpvclVuaXQpID8gdGlja3MgOiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpO1xufVxuY2xhc3MgVGltZVNjYWxlIGV4dGVuZHMgU2NhbGUge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcbiAgICB0aGlzLl9jYWNoZSA9IHtcbiAgICAgIGRhdGE6IFtdLFxuICAgICAgbGFiZWxzOiBbXSxcbiAgICAgIGFsbDogW11cbiAgICB9O1xuICAgIHRoaXMuX3VuaXQgPSAnZGF5JztcbiAgICB0aGlzLl9tYWpvclVuaXQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fb2Zmc2V0cyA9IHt9O1xuICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJzZU9wdHMgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdChzY2FsZU9wdHMsIG9wdHMpIHtcbiAgICBjb25zdCB0aW1lID0gc2NhbGVPcHRzLnRpbWUgfHwgKHNjYWxlT3B0cy50aW1lID0ge30pO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyID0gbmV3IGFkYXB0ZXJzLl9kYXRlKHNjYWxlT3B0cy5hZGFwdGVycy5kYXRlKTtcbiAgICBhZGFwdGVyLmluaXQob3B0cyk7XG4gICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgdGhpcy5fcGFyc2VPcHRzID0ge1xuICAgICAgcGFyc2VyOiB0aW1lLnBhcnNlcixcbiAgICAgIHJvdW5kOiB0aW1lLnJvdW5kLFxuICAgICAgaXNvV2Vla2RheTogdGltZS5pc29XZWVrZGF5XG4gICAgfTtcbiAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgdGhpcy5fbm9ybWFsaXplZCA9IG9wdHMubm9ybWFsaXplZDtcbiAgfVxuICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlKHRoaXMsIHJhdyk7XG4gIH1cbiAgYmVmb3JlTGF5b3V0KCkge1xuICAgIHN1cGVyLmJlZm9yZUxheW91dCgpO1xuICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBsYWJlbHM6IFtdLFxuICAgICAgYWxsOiBbXVxuICAgIH07XG4gIH1cbiAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgIGNvbnN0IHVuaXQgPSBvcHRpb25zLnRpbWUudW5pdCB8fCAnZGF5JztcbiAgICBsZXQge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgIGZ1bmN0aW9uIF9hcHBseUJvdW5kcyhib3VuZHMpIHtcbiAgICAgIGlmICghbWluRGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1pbikpIHtcbiAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBib3VuZHMubWluKTtcbiAgICAgIH1cbiAgICAgIGlmICghbWF4RGVmaW5lZCAmJiAhaXNOYU4oYm91bmRzLm1heCkpIHtcbiAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFtaW5EZWZpbmVkIHx8ICFtYXhEZWZpbmVkKSB7XG4gICAgICBfYXBwbHlCb3VuZHModGhpcy5fZ2V0TGFiZWxCb3VuZHMoKSk7XG4gICAgICBpZiAob3B0aW9ucy5ib3VuZHMgIT09ICd0aWNrcycgfHwgb3B0aW9ucy50aWNrcy5zb3VyY2UgIT09ICdsYWJlbHMnKSB7XG4gICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLmdldE1pbk1heChmYWxzZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICBtYXggPSBpc051bWJlckZpbml0ZShtYXgpICYmICFpc05hTihtYXgpID8gbWF4IDogK2FkYXB0ZXIuZW5kT2YoRGF0ZS5ub3coKSwgdW5pdCkgKyAxO1xuICAgIHRoaXMubWluID0gTWF0aC5taW4obWluLCBtYXggLSAxKTtcbiAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gIH1cbiAgX2dldExhYmVsQm91bmRzKCkge1xuICAgIGNvbnN0IGFyciA9IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCk7XG4gICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBsZXQgbWF4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgICBtaW4gPSBhcnJbMF07XG4gICAgICBtYXggPSBhcnJbYXJyLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4ge21pbiwgbWF4fTtcbiAgfVxuICBidWlsZFRpY2tzKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgdGltZU9wdHMgPSBvcHRpb25zLnRpbWU7XG4gICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IHRpbWVzdGFtcHMgPSB0aWNrT3B0cy5zb3VyY2UgPT09ICdsYWJlbHMnID8gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKSA6IHRoaXMuX2dlbmVyYXRlKCk7XG4gICAgaWYgKG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLm1pbiA9IHRoaXMuX3VzZXJNaW4gfHwgdGltZXN0YW1wc1swXTtcbiAgICAgIHRoaXMubWF4ID0gdGhpcy5fdXNlck1heCB8fCB0aW1lc3RhbXBzW3RpbWVzdGFtcHMubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGNvbnN0IG1pbiA9IHRoaXMubWluO1xuICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgIHRoaXMuX3VuaXQgPSB0aW1lT3B0cy51bml0IHx8ICh0aWNrT3B0cy5hdXRvU2tpcFxuICAgICAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKVxuICAgICAgOiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyh0aGlzLCB0aWNrcy5sZW5ndGgsIHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCkpO1xuICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZFxuICAgICAgOiBkZXRlcm1pbmVNYWpvclVuaXQodGhpcy5fdW5pdCk7XG4gICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICB9XG4gIGFmdGVyQXV0b1NraXAoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXRBZnRlckF1dG9za2lwKSB7XG4gICAgICB0aGlzLmluaXRPZmZzZXRzKHRoaXMudGlja3MubWFwKHRpY2sgPT4gK3RpY2sudmFsdWUpKTtcbiAgICB9XG4gIH1cbiAgaW5pdE9mZnNldHModGltZXN0YW1wcykge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IDA7XG4gICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgIGlmICh0aGlzLm9wdGlvbnMub2Zmc2V0ICYmIHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICBmaXJzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbMF0pO1xuICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSAodGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1sxXSkgLSBmaXJzdCkgLyAyO1xuICAgICAgfVxuICAgICAgbGFzdCA9IHRoaXMuZ2V0RGVjaW1hbEZvclZhbHVlKHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAodGltZXN0YW1wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZW5kID0gbGFzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBsaW1pdCA9IHRpbWVzdGFtcHMubGVuZ3RoIDwgMyA/IDAuNSA6IDAuMjU7XG4gICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgIGVuZCA9IF9saW1pdFZhbHVlKGVuZCwgMCwgbGltaXQpO1xuICAgIHRoaXMuX29mZnNldHMgPSB7c3RhcnQsIGVuZCwgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZCl9O1xuICB9XG4gIF9nZW5lcmF0ZSgpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICBjb25zdCBtYXggPSB0aGlzLm1heDtcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIGNvbnN0IHRpbWVPcHRzID0gb3B0aW9ucy50aW1lO1xuICAgIGNvbnN0IG1pbm9yID0gdGltZU9wdHMudW5pdCB8fCBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIG1pbiwgbWF4LCB0aGlzLl9nZXRMYWJlbENhcGFjaXR5KG1pbikpO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQodGltZU9wdHMuc3RlcFNpemUsIDEpO1xuICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgIGNvbnN0IGhhc1dlZWtkYXkgPSBpc051bWJlcih3ZWVrZGF5KSB8fCB3ZWVrZGF5ID09PSB0cnVlO1xuICAgIGNvbnN0IHRpY2tzID0ge307XG4gICAgbGV0IGZpcnN0ID0gbWluO1xuICAgIGxldCB0aW1lLCBjb3VudDtcbiAgICBpZiAoaGFzV2Vla2RheSkge1xuICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCAnaXNvV2VlaycsIHdlZWtkYXkpO1xuICAgIH1cbiAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsIGhhc1dlZWtkYXkgPyAnZGF5JyA6IG1pbm9yKTtcbiAgICBpZiAoYWRhcHRlci5kaWZmKG1heCwgbWluLCBtaW5vcikgPiAxMDAwMDAgKiBzdGVwU2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1pbiArICcgYW5kICcgKyBtYXggKyAnIGFyZSB0b28gZmFyIGFwYXJ0IHdpdGggc3RlcFNpemUgb2YgJyArIHN0ZXBTaXplICsgJyAnICsgbWlub3IpO1xuICAgIH1cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gb3B0aW9ucy50aWNrcy5zb3VyY2UgPT09ICdkYXRhJyAmJiB0aGlzLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgZm9yICh0aW1lID0gZmlyc3QsIGNvdW50ID0gMDsgdGltZSA8IG1heDsgdGltZSA9ICthZGFwdGVyLmFkZCh0aW1lLCBzdGVwU2l6ZSwgbWlub3IpLCBjb3VudCsrKSB7XG4gICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICB9XG4gICAgaWYgKHRpbWUgPT09IG1heCB8fCBvcHRpb25zLmJvdW5kcyA9PT0gJ3RpY2tzJyB8fCBjb3VudCA9PT0gMSkge1xuICAgICAgYWRkVGljayh0aWNrcywgdGltZSwgdGltZXN0YW1wcyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aWNrcykuc29ydCgoYSwgYikgPT4gYSAtIGIpLm1hcCh4ID0+ICt4KTtcbiAgfVxuICBnZXRMYWJlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgY29uc3QgdGltZU9wdHMgPSB0aGlzLm9wdGlvbnMudGltZTtcbiAgICBpZiAodGltZU9wdHMudG9vbHRpcEZvcm1hdCkge1xuICAgICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy50b29sdGlwRm9ybWF0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXB0ZXIuZm9ybWF0KHZhbHVlLCB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cy5kYXRldGltZSk7XG4gIH1cbiAgX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICBjb25zdCBtYWpvclVuaXQgPSB0aGlzLl9tYWpvclVuaXQ7XG4gICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgY29uc3QgbWFqb3JGb3JtYXQgPSBtYWpvclVuaXQgJiYgZm9ybWF0c1ttYWpvclVuaXRdO1xuICAgIGNvbnN0IHRpY2sgPSB0aWNrc1tpbmRleF07XG4gICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgIHJldHVybiBmb3JtYXR0ZXIgPyBjYWxsYmFjayhmb3JtYXR0ZXIsIFtsYWJlbCwgaW5kZXgsIHRpY2tzXSwgdGhpcykgOiBsYWJlbDtcbiAgfVxuICBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICBsZXQgaSwgaWxlbiwgdGljaztcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdGlja3MubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB0aWNrID0gdGlja3NbaV07XG4gICAgICB0aWNrLmxhYmVsID0gdGhpcy5fdGlja0Zvcm1hdEZ1bmN0aW9uKHRpY2sudmFsdWUsIGksIHRpY2tzKTtcbiAgICB9XG4gIH1cbiAgZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogKHZhbHVlIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pO1xuICB9XG4gIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKChvZmZzZXRzLnN0YXJ0ICsgcG9zKSAqIG9mZnNldHMuZmFjdG9yKTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpIC8gb2Zmc2V0cy5mYWN0b3IgLSBvZmZzZXRzLmVuZDtcbiAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH1cbiAgX2dldExhYmVsU2l6ZShsYWJlbCkge1xuICAgIGNvbnN0IHRpY2tzT3B0cyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICBjb25zdCBhbmdsZSA9IHRvUmFkaWFucyh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGlja3NPcHRzLm1heFJvdGF0aW9uIDogdGlja3NPcHRzLm1pblJvdGF0aW9uKTtcbiAgICBjb25zdCBjb3NSb3RhdGlvbiA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICBjb25zdCB0aWNrRm9udFNpemUgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKDApLnNpemU7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6ICh0aWNrTGFiZWxXaWR0aCAqIGNvc1JvdGF0aW9uKSArICh0aWNrRm9udFNpemUgKiBzaW5Sb3RhdGlvbiksXG4gICAgICBoOiAodGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbikgKyAodGlja0ZvbnRTaXplICogY29zUm90YXRpb24pXG4gICAgfTtcbiAgfVxuICBfZ2V0TGFiZWxDYXBhY2l0eShleGFtcGxlVGltZSkge1xuICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgY29uc3QgZGlzcGxheUZvcm1hdHMgPSB0aW1lT3B0cy5kaXNwbGF5Rm9ybWF0cztcbiAgICBjb25zdCBmb3JtYXQgPSBkaXNwbGF5Rm9ybWF0c1t0aW1lT3B0cy51bml0XSB8fCBkaXNwbGF5Rm9ybWF0cy5taWxsaXNlY29uZDtcbiAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW2V4YW1wbGVUaW1lXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICBjb25zdCBzaXplID0gdGhpcy5fZ2V0TGFiZWxTaXplKGV4YW1wbGVMYWJlbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBNYXRoLmZsb29yKHRoaXMuaXNIb3Jpem9udGFsKCkgPyB0aGlzLndpZHRoIC8gc2l6ZS53IDogdGhpcy5oZWlnaHQgLyBzaXplLmgpIC0gMTtcbiAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICB9XG4gIGdldERhdGFUaW1lc3RhbXBzKCkge1xuICAgIGxldCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuZGF0YSB8fCBbXTtcbiAgICBsZXQgaSwgaWxlbjtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICBpZiAodGhpcy5fbm9ybWFsaXplZCAmJiBtZXRhcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAodGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdGltZXN0YW1wcyA9IHRpbWVzdGFtcHMuY29uY2F0KG1ldGFzW2ldLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcykpO1xuICB9XG4gIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUubGFiZWxzIHx8IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHRpbWVzdGFtcHMucHVzaChwYXJzZSh0aGlzLCBsYWJlbHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9jYWNoZS5sYWJlbHMgPSB0aGlzLl9ub3JtYWxpemVkID8gdGltZXN0YW1wcyA6IHRoaXMubm9ybWFsaXplKHRpbWVzdGFtcHMpKTtcbiAgfVxuICBub3JtYWxpemUodmFsdWVzKSB7XG4gICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgfVxufVxuVGltZVNjYWxlLmlkID0gJ3RpbWUnO1xuVGltZVNjYWxlLmRlZmF1bHRzID0ge1xuICBib3VuZHM6ICdkYXRhJyxcbiAgYWRhcHRlcnM6IHt9LFxuICB0aW1lOiB7XG4gICAgcGFyc2VyOiBmYWxzZSxcbiAgICB1bml0OiBmYWxzZSxcbiAgICByb3VuZDogZmFsc2UsXG4gICAgaXNvV2Vla2RheTogZmFsc2UsXG4gICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICBkaXNwbGF5Rm9ybWF0czoge31cbiAgfSxcbiAgdGlja3M6IHtcbiAgICBzb3VyY2U6ICdhdXRvJyxcbiAgICBtYWpvcjoge1xuICAgICAgZW5hYmxlZDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gIGlmIChyZXZlcnNlKSB7XG4gICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICdwb3MnLCB2YWwpKTtcbiAgICB9XG4gICAgKHtwb3M6IHByZXZTb3VyY2UsIHRpbWU6IHByZXZUYXJnZXR9ID0gdGFibGVbbG9dKTtcbiAgICAoe3BvczogbmV4dFNvdXJjZSwgdGltZTogbmV4dFRhcmdldH0gPSB0YWJsZVtoaV0pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAoe2xvLCBoaX0gPSBfbG9va3VwQnlLZXkodGFibGUsICd0aW1lJywgdmFsKSk7XG4gICAgfVxuICAgICh7dGltZTogcHJldlNvdXJjZSwgcG9zOiBwcmV2VGFyZ2V0fSA9IHRhYmxlW2xvXSk7XG4gICAgKHt0aW1lOiBuZXh0U291cmNlLCBwb3M6IG5leHRUYXJnZXR9ID0gdGFibGVbaGldKTtcbiAgfVxuICBjb25zdCBzcGFuID0gbmV4dFNvdXJjZSAtIHByZXZTb3VyY2U7XG4gIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgdGhpcy5fbWluUG9zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3RhYmxlUmFuZ2UgPSB1bmRlZmluZWQ7XG4gIH1cbiAgaW5pdE9mZnNldHMoKSB7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy5fdGFibGUgPSB0aGlzLmJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcyk7XG4gICAgdGhpcy5fbWluUG9zID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWluKTtcbiAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICBzdXBlci5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgfVxuICBidWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpIHtcbiAgICBjb25zdCB7bWluLCBtYXh9ID0gdGhpcztcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgbGV0IGksIGlsZW4sIHByZXYsIGN1cnIsIG5leHQ7XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHRpbWVzdGFtcHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICBpdGVtcy5wdXNoKGN1cnIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAge3RpbWU6IG1pbiwgcG9zOiAwfSxcbiAgICAgICAge3RpbWU6IG1heCwgcG9zOiAxfVxuICAgICAgXTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbmV4dCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgIHByZXYgPSBpdGVtc1tpIC0gMV07XG4gICAgICBjdXJyID0gaXRlbXNbaV07XG4gICAgICBpZiAoTWF0aC5yb3VuZCgobmV4dCArIHByZXYpIC8gMikgIT09IGN1cnIpIHtcbiAgICAgICAgdGFibGUucHVzaCh7dGltZTogY3VyciwgcG9zOiBpIC8gKGlsZW4gLSAxKX0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFibGU7XG4gIH1cbiAgX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICBsZXQgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmFsbCB8fCBbXTtcbiAgICBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aW1lc3RhbXBzO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXN0YW1wcyA9IGRhdGEubGVuZ3RoID8gZGF0YSA6IGxhYmVsO1xuICAgIH1cbiAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgfVxuICBnZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgfVxuICBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgY29uc3Qgb2Zmc2V0cyA9IHRoaXMuX29mZnNldHM7XG4gICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCBkZWNpbWFsICogdGhpcy5fdGFibGVSYW5nZSArIHRoaXMuX21pblBvcywgdHJ1ZSk7XG4gIH1cbn1cblRpbWVTZXJpZXNTY2FsZS5pZCA9ICd0aW1lc2VyaWVzJztcblRpbWVTZXJpZXNTY2FsZS5kZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gIGNvbnRyb2xsZXJzLFxuICBlbGVtZW50cyxcbiAgcGx1Z2lucyxcbiAgc2NhbGVzLFxuXTtcblxuZXhwb3J0IHsgQW5pbWF0aW9uLCBBbmltYXRpb25zLCBBcmNFbGVtZW50LCBCYXJDb250cm9sbGVyLCBCYXJFbGVtZW50LCBCYXNlUGxhdGZvcm0sIEJhc2ljUGxhdGZvcm0sIEJ1YmJsZUNvbnRyb2xsZXIsIENhdGVnb3J5U2NhbGUsIENoYXJ0LCBEYXRhc2V0Q29udHJvbGxlciwgcGx1Z2luX2RlY2ltYXRpb24gYXMgRGVjaW1hdGlvbiwgRG9tUGxhdGZvcm0sIERvdWdobnV0Q29udHJvbGxlciwgRWxlbWVudCwgaW5kZXggYXMgRmlsbGVyLCBJbnRlcmFjdGlvbiwgcGx1Z2luX2xlZ2VuZCBhcyBMZWdlbmQsIExpbmVDb250cm9sbGVyLCBMaW5lRWxlbWVudCwgTGluZWFyU2NhbGUsIExvZ2FyaXRobWljU2NhbGUsIFBpZUNvbnRyb2xsZXIsIFBvaW50RWxlbWVudCwgUG9sYXJBcmVhQ29udHJvbGxlciwgUmFkYXJDb250cm9sbGVyLCBSYWRpYWxMaW5lYXJTY2FsZSwgU2NhbGUsIFNjYXR0ZXJDb250cm9sbGVyLCBwbHVnaW5fc3VidGl0bGUgYXMgU3ViVGl0bGUsIFRpY2tzLCBUaW1lU2NhbGUsIFRpbWVTZXJpZXNTY2FsZSwgcGx1Z2luX3RpdGxlIGFzIFRpdGxlLCBwbHVnaW5fdG9vbHRpcCBhcyBUb29sdGlwLCBhZGFwdGVycyBhcyBfYWRhcHRlcnMsIF9kZXRlY3RQbGF0Zm9ybSwgYW5pbWF0b3IsIGNvbnRyb2xsZXJzLCBlbGVtZW50cywgbGF5b3V0cywgcGx1Z2lucywgcmVnaXN0ZXJhYmxlcywgcmVnaXN0cnksIHNjYWxlcyB9O1xuIl0sIm5hbWVzIjpbInIiLCJyZXF1ZXN0QW5pbUZyYW1lIiwiYSIsInJlc29sdmUiLCJlIiwiZWZmZWN0cyIsImMiLCJjb2xvciIsImQiLCJkZWZhdWx0cyIsImkiLCJpc09iamVjdCIsImIiLCJpc0FycmF5IiwidiIsInZhbHVlT3JEZWZhdWx0IiwidSIsInVubGlzdGVuQXJyYXlFdmVudHMiLCJsIiwibGlzdGVuQXJyYXlFdmVudHMiLCJmIiwicmVzb2x2ZU9iamVjdEtleSIsImciLCJpc051bWJlckZpbml0ZSIsImgiLCJjcmVhdGVDb250ZXh0IiwiaiIsImRlZmluZWQiLCJzIiwic2lnbiIsImsiLCJpc051bGxPclVuZGVmIiwiXyIsIl9hcnJheVVuaXF1ZSIsInQiLCJ0b1JhZGlhbnMiLCJtIiwidG9QZXJjZW50YWdlIiwibiIsInRvRGltZW5zaW9uIiwiVCIsIlRBVSIsIm8iLCJmb3JtYXROdW1iZXIiLCJwIiwiX2FuZ2xlQmV0d2VlbiIsIkgiLCJIQUxGX1BJIiwiUCIsIlBJIiwicSIsIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwidyIsIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCJ4IiwiaXNOdW1iZXIiLCJ5IiwiX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIiwieiIsImxvZzEwIiwiQSIsIl9mYWN0b3JpemUiLCJCIiwiZmluaXRlT3JEZWZhdWx0IiwiQyIsImNhbGxiYWNrIiwiRCIsIl9hZGRHcmFjZSIsIkUiLCJfbGltaXRWYWx1ZSIsIkYiLCJ0b0RlZ3JlZXMiLCJHIiwiX21lYXN1cmVUZXh0IiwiSSIsIl9pbnQxNlJhbmdlIiwiSiIsIl9hbGlnblBpeGVsIiwiSyIsInRvUGFkZGluZyIsIkwiLCJjbGlwQXJlYSIsIk0iLCJyZW5kZXJUZXh0IiwiTiIsInVuY2xpcEFyZWEiLCJPIiwidG9Gb250IiwiUSIsImVhY2giLCJSIiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiUyIsIl9hbGlnblN0YXJ0RW5kIiwiVSIsIm92ZXJyaWRlcyIsIlYiLCJtZXJnZSIsIlciLCJfY2FwaXRhbGl6ZSIsIlgiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiWSIsIl9ybG9va3VwQnlLZXkiLCJaIiwiX2xvb2t1cEJ5S2V5IiwiJCIsIl9pc1BvaW50SW5BcmVhIiwiYTAiLCJnZXRBbmdsZUZyb21Qb2ludCIsImExIiwiZ2V0TWF4aW11bVNpemUiLCJhMiIsIl9nZXRQYXJlbnROb2RlIiwiYTMiLCJyZWFkVXNlZFNpemUiLCJhNCIsInRocm90dGxlZCIsImE1Iiwic3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyIsImE2IiwiX2lzRG9tU3VwcG9ydGVkIiwiYTciLCJkZXNjcmlwdG9ycyIsImE4IiwiaXNGdW5jdGlvbiIsImE5IiwiX2F0dGFjaENvbnRleHQiLCJhYSIsIl9jcmVhdGVSZXNvbHZlciIsImFiIiwiX2Rlc2NyaXB0b3JzIiwiYWMiLCJtZXJnZUlmIiwiYWQiLCJ1aWQiLCJhZSIsImRlYm91bmNlIiwiYWYiLCJyZXRpbmFTY2FsZSIsImFnIiwiY2xlYXJDYW52YXMiLCJhaCIsInNldHNFcXVhbCIsImFpIiwiX2VsZW1lbnRzRXF1YWwiLCJhaiIsIl9pc0NsaWNrRXZlbnQiLCJhayIsIl9pc0JldHdlZW4iLCJhbCIsIl9yZWFkVmFsdWVUb1Byb3BzIiwiYW0iLCJfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cyIsImFuIiwiX2NvbXB1dGVTZWdtZW50cyIsImFvIiwiX2JvdW5kU2VnbWVudHMiLCJhcCIsIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsImFxIiwiX2JlemllckludGVycG9sYXRpb24iLCJhciIsIl9wb2ludEluTGluZSIsImFzIiwiX3N0ZXBwZWRMaW5lVG8iLCJhdCIsIl9iZXppZXJDdXJ2ZVRvIiwiYXUiLCJkcmF3UG9pbnQiLCJhdiIsImFkZFJvdW5kZWRSZWN0UGF0aCIsImF3IiwidG9UUkJMIiwiYXgiLCJ0b1RSQkxDb3JuZXJzIiwiYXkiLCJfYm91bmRTZWdtZW50IiwiYXoiLCJfbm9ybWFsaXplQW5nbGUiLCJhQSIsImdldFJ0bEFkYXB0ZXIiLCJhQiIsIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsImFDIiwiX3RleHRYIiwiYUQiLCJyZXN0b3JlVGV4dERpcmVjdGlvbiIsImFFIiwiZHJhd1BvaW50TGVnZW5kIiwiYUYiLCJub29wIiwiYUciLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJhSCIsIl9zZXRNaW5BbmRNYXhCeUtleSIsImFJIiwibmljZU51bSIsImFKIiwiYWxtb3N0V2hvbGUiLCJhSyIsImFsbW9zdEVxdWFscyIsImFMIiwiX2RlY2ltYWxQbGFjZXMiLCJhTSIsIl9sb25nZXN0VGV4dCIsImFOIiwiX2ZpbHRlckJldHdlZW4iLCJhTyIsIl9sb29rdXAiLCJBbmltYXRvciIsImNvbnN0cnVjdG9yIiwiX3JlcXVlc3QiLCJfY2hhcnRzIiwiTWFwIiwiX3J1bm5pbmciLCJfbGFzdERhdGUiLCJ1bmRlZmluZWQiLCJfbm90aWZ5IiwiY2hhcnQiLCJhbmltcyIsImRhdGUiLCJ0eXBlIiwiY2FsbGJhY2tzIiwibGlzdGVuZXJzIiwibnVtU3RlcHMiLCJkdXJhdGlvbiIsImZvckVhY2giLCJmbiIsImluaXRpYWwiLCJjdXJyZW50U3RlcCIsIk1hdGgiLCJtaW4iLCJzdGFydCIsIl9yZWZyZXNoIiwiY2FsbCIsIndpbmRvdyIsIl91cGRhdGUiLCJEYXRlIiwibm93IiwicmVtYWluaW5nIiwicnVubmluZyIsIml0ZW1zIiwibGVuZ3RoIiwiZHJhdyIsIml0ZW0iLCJfYWN0aXZlIiwiX3RvdGFsIiwidGljayIsInBvcCIsIl9nZXRBbmltcyIsImNoYXJ0cyIsImdldCIsImNvbXBsZXRlIiwicHJvZ3Jlc3MiLCJzZXQiLCJsaXN0ZW4iLCJldmVudCIsImNiIiwicHVzaCIsImFkZCIsImhhcyIsInJlZHVjZSIsImFjYyIsImN1ciIsIm1heCIsIl9kdXJhdGlvbiIsInN0b3AiLCJjYW5jZWwiLCJyZW1vdmUiLCJkZWxldGUiLCJhbmltYXRvciIsInRyYW5zcGFyZW50IiwiaW50ZXJwb2xhdG9ycyIsImJvb2xlYW4iLCJmcm9tIiwidG8iLCJmYWN0b3IiLCJjMCIsImMxIiwidmFsaWQiLCJtaXgiLCJoZXhTdHJpbmciLCJudW1iZXIiLCJBbmltYXRpb24iLCJjZmciLCJ0YXJnZXQiLCJwcm9wIiwiY3VycmVudFZhbHVlIiwiX2ZuIiwiX2Vhc2luZyIsImVhc2luZyIsImxpbmVhciIsIl9zdGFydCIsImZsb29yIiwiZGVsYXkiLCJfbG9vcCIsImxvb3AiLCJfdGFyZ2V0IiwiX3Byb3AiLCJfZnJvbSIsIl90byIsIl9wcm9taXNlcyIsImFjdGl2ZSIsInVwZGF0ZSIsImVsYXBzZWQiLCJyZW1haW4iLCJ3YWl0IiwicHJvbWlzZXMiLCJQcm9taXNlIiwicmVzIiwicmVqIiwicmVzb2x2ZWQiLCJtZXRob2QiLCJudW1iZXJzIiwiY29sb3JzIiwiYW5pbWF0aW9uT3B0aW9ucyIsIk9iamVjdCIsImtleXMiLCJhbmltYXRpb24iLCJkZXNjcmliZSIsIl9mYWxsYmFjayIsIl9pbmRleGFibGUiLCJfc2NyaXB0YWJsZSIsIm5hbWUiLCJwcm9wZXJ0aWVzIiwicmVzaXplIiwic2hvdyIsImFuaW1hdGlvbnMiLCJ2aXNpYmxlIiwiaGlkZSIsIkFuaW1hdGlvbnMiLCJjb25maWciLCJfY2hhcnQiLCJfcHJvcGVydGllcyIsImNvbmZpZ3VyZSIsImFuaW1hdGVkUHJvcHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwia2V5Iiwib3B0aW9uIiwiX2FuaW1hdGVPcHRpb25zIiwidmFsdWVzIiwibmV3T3B0aW9ucyIsIm9wdGlvbnMiLCJyZXNvbHZlVGFyZ2V0T3B0aW9ucyIsIl9jcmVhdGVBbmltYXRpb25zIiwiJHNoYXJlZCIsImF3YWl0QWxsIiwiJGFuaW1hdGlvbnMiLCJ0aGVuIiwicHJvcHMiLCJjaGFyQXQiLCJ2YWx1ZSIsInNpemUiLCJhc3NpZ24iLCJhbmltIiwiYWxsIiwic2NhbGVDbGlwIiwic2NhbGUiLCJhbGxvd2VkT3ZlcmZsb3ciLCJvcHRzIiwicmV2ZXJzZSIsImVuZCIsImRlZmF1bHRDbGlwIiwieFNjYWxlIiwieVNjYWxlIiwidG9wIiwicmlnaHQiLCJib3R0b20iLCJsZWZ0IiwidG9DbGlwIiwiZGlzYWJsZWQiLCJnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyIsImZpbHRlclZpc2libGUiLCJtZXRhc2V0cyIsIl9nZXRTb3J0ZWREYXRhc2V0TWV0YXMiLCJpbGVuIiwiaW5kZXgiLCJhcHBseVN0YWNrIiwic3RhY2siLCJkc0luZGV4Iiwic2luZ2xlTW9kZSIsIm1vZGUiLCJkYXRhc2V0SW5kZXgiLCJvdGhlclZhbHVlIiwiY29udmVydE9iamVjdERhdGFUb0FycmF5IiwiZGF0YSIsImFkYXRhIiwiQXJyYXkiLCJpc1N0YWNrZWQiLCJtZXRhIiwic3RhY2tlZCIsImdldFN0YWNrS2V5IiwiaW5kZXhTY2FsZSIsInZhbHVlU2NhbGUiLCJpZCIsImdldFVzZXJCb3VuZHMiLCJtaW5EZWZpbmVkIiwibWF4RGVmaW5lZCIsIk51bWJlciIsIk5FR0FUSVZFX0lORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJnZXRPckNyZWF0ZVN0YWNrIiwic3RhY2tzIiwic3RhY2tLZXkiLCJpbmRleFZhbHVlIiwic3ViU3RhY2siLCJnZXRMYXN0SW5kZXhJblN0YWNrIiwidlNjYWxlIiwicG9zaXRpdmUiLCJnZXRNYXRjaGluZ1Zpc2libGVNZXRhcyIsInVwZGF0ZVN0YWNrcyIsImNvbnRyb2xsZXIiLCJwYXJzZWQiLCJfY2FjaGVkTWV0YSIsIl9zdGFja3MiLCJpU2NhbGUiLCJpQXhpcyIsImF4aXMiLCJ2QXhpcyIsIml0ZW1TdGFja3MiLCJfdG9wIiwiX2JvdHRvbSIsImdldEZpcnN0U2NhbGVJZCIsInNjYWxlcyIsImZpbHRlciIsInNoaWZ0IiwiY3JlYXRlRGF0YXNldENvbnRleHQiLCJwYXJlbnQiLCJkYXRhc2V0IiwiY3JlYXRlRGF0YUNvbnRleHQiLCJlbGVtZW50IiwiZGF0YUluZGV4IiwicmF3IiwiY2xlYXJTdGFja3MiLCJfcGFyc2VkIiwiaXNEaXJlY3RVcGRhdGVNb2RlIiwiY2xvbmVJZk5vdFNoYXJlZCIsImNhY2hlZCIsInNoYXJlZCIsImNyZWF0ZVN0YWNrIiwiY2FuU3RhY2siLCJoaWRkZW4iLCJfc3RhY2tlZCIsIkRhdGFzZXRDb250cm9sbGVyIiwiX2N0eCIsImN0eCIsIl9jYWNoZWREYXRhT3B0cyIsImdldE1ldGEiLCJfdHlwZSIsIl9wYXJzaW5nIiwiX2RhdGEiLCJfb2JqZWN0RGF0YSIsIl9zaGFyZWRPcHRpb25zIiwiX2RyYXdTdGFydCIsIl9kcmF3Q291bnQiLCJlbmFibGVPcHRpb25TaGFyaW5nIiwic3VwcG9ydHNEZWNpbWF0aW9uIiwiJGNvbnRleHQiLCJfc3luY0xpc3QiLCJpbml0aWFsaXplIiwibGlua1NjYWxlcyIsImFkZEVsZW1lbnRzIiwidXBkYXRlSW5kZXgiLCJnZXREYXRhc2V0IiwiY2hvb3NlSWQiLCJ4aWQiLCJ4QXhpc0lEIiwieWlkIiwieUF4aXNJRCIsInJpZCIsInJBeGlzSUQiLCJpbmRleEF4aXMiLCJpaWQiLCJpQXhpc0lEIiwidmlkIiwidkF4aXNJRCIsImdldFNjYWxlRm9ySWQiLCJyU2NhbGUiLCJkYXRhc2V0cyIsImdldERhdGFzZXRNZXRhIiwic2NhbGVJRCIsIl9nZXRPdGhlclNjYWxlIiwicmVzZXQiLCJfZGVzdHJveSIsIl9kYXRhQ2hlY2siLCJpc0V4dGVuc2libGUiLCJkYXRhc2V0RWxlbWVudFR5cGUiLCJidWlsZE9yVXBkYXRlRWxlbWVudHMiLCJyZXNldE5ld0VsZW1lbnRzIiwic3RhY2tDaGFuZ2VkIiwib2xkU3RhY2tlZCIsIl9yZXN5bmNFbGVtZW50cyIsInNjb3BlS2V5cyIsImRhdGFzZXRTY29wZUtleXMiLCJzY29wZXMiLCJnZXRPcHRpb25TY29wZXMiLCJjcmVhdGVSZXNvbHZlciIsImdldENvbnRleHQiLCJwYXJzaW5nIiwicGFyc2UiLCJjb3VudCIsInNvcnRlZCIsIl9zb3J0ZWQiLCJwcmV2IiwicGFyc2VBcnJheURhdGEiLCJwYXJzZU9iamVjdERhdGEiLCJwYXJzZVByaW1pdGl2ZURhdGEiLCJpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiIsImxhYmVscyIsImdldExhYmVscyIsInNpbmdsZVNjYWxlIiwieEF4aXNLZXkiLCJ5QXhpc0tleSIsImdldFBhcnNlZCIsImdldERhdGFFbGVtZW50IiwidXBkYXRlUmFuZ2VGcm9tUGFyc2VkIiwicmFuZ2UiLCJwYXJzZWRWYWx1ZSIsIk5hTiIsImdldE1pbk1heCIsIm90aGVyU2NhbGUiLCJvdGhlck1pbiIsIm90aGVyTWF4IiwiX3NraXAiLCJnZXRBbGxQYXJzZWRWYWx1ZXMiLCJnZXRNYXhPdmVyZmxvdyIsImdldExhYmVsQW5kVmFsdWUiLCJsYWJlbCIsImdldExhYmVsRm9yVmFsdWUiLCJfY2xpcCIsImNsaXAiLCJlbGVtZW50cyIsImFyZWEiLCJjaGFydEFyZWEiLCJkcmF3QWN0aXZlRWxlbWVudHNPblRvcCIsImdldFN0eWxlIiwicmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyIsInJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMiLCJjb250ZXh0IiwiX3Jlc29sdmVFbGVtZW50T3B0aW9ucyIsImRhdGFFbGVtZW50VHlwZSIsImVsZW1lbnRUeXBlIiwiY2FjaGUiLCJjYWNoZUtleSIsInNoYXJpbmciLCJkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyIsInByZWZpeGVzIiwibmFtZXMiLCJyZXNvbHZlTmFtZWRPcHRpb25zIiwiZnJlZXplIiwiX3Jlc29sdmVBbmltYXRpb25zIiwidHJhbnNpdGlvbiIsImRhdGFzZXRBbmltYXRpb25TY29wZUtleXMiLCJfY2FjaGVhYmxlIiwiZ2V0U2hhcmVkT3B0aW9ucyIsImluY2x1ZGVPcHRpb25zIiwic2hhcmVkT3B0aW9ucyIsIl9hbmltYXRpb25zRGlzYWJsZWQiLCJfZ2V0U2hhcmVkT3B0aW9ucyIsImZpcnN0T3B0cyIsInByZXZpb3VzbHlTaGFyZWRPcHRpb25zIiwidXBkYXRlU2hhcmVkT3B0aW9ucyIsInVwZGF0ZUVsZW1lbnQiLCJfc2V0U3R5bGUiLCJyZW1vdmVIb3ZlclN0eWxlIiwic2V0SG92ZXJTdHlsZSIsIl9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSIsIl9zZXREYXRhc2V0SG92ZXJTdHlsZSIsImFyZzEiLCJhcmcyIiwibnVtTWV0YSIsIm51bURhdGEiLCJfaW5zZXJ0RWxlbWVudHMiLCJfcmVtb3ZlRWxlbWVudHMiLCJtb3ZlIiwiYXJyIiwidXBkYXRlRWxlbWVudHMiLCJyZW1vdmVkIiwic3BsaWNlIiwiX3N5bmMiLCJhcmdzIiwiX2RhdGFDaGFuZ2VzIiwiX29uRGF0YVB1c2giLCJhcmd1bWVudHMiLCJfb25EYXRhUG9wIiwiX29uRGF0YVNoaWZ0IiwiX29uRGF0YVNwbGljZSIsIm5ld0NvdW50IiwiX29uRGF0YVVuc2hpZnQiLCJwcm90b3R5cGUiLCJnZXRBbGxTY2FsZVZhbHVlcyIsIl9jYWNoZSIsIiRiYXIiLCJ2aXNpYmxlTWV0YXMiLCJjb25jYXQiLCJzb3J0IiwiY29tcHV0ZU1pblNhbXBsZVNpemUiLCJfbGVuZ3RoIiwiY3VyciIsInVwZGF0ZU1pbkFuZFByZXYiLCJhYnMiLCJnZXRQaXhlbEZvclZhbHVlIiwidGlja3MiLCJnZXRQaXhlbEZvclRpY2siLCJjb21wdXRlRml0Q2F0ZWdvcnlUcmFpdHMiLCJydWxlciIsInN0YWNrQ291bnQiLCJ0aGlja25lc3MiLCJiYXJUaGlja25lc3MiLCJyYXRpbyIsImNhdGVnb3J5UGVyY2VudGFnZSIsImJhclBlcmNlbnRhZ2UiLCJjaHVuayIsInBpeGVscyIsImNvbXB1dGVGbGV4Q2F0ZWdvcnlUcmFpdHMiLCJuZXh0IiwicGVyY2VudCIsInBhcnNlRmxvYXRCYXIiLCJlbnRyeSIsInN0YXJ0VmFsdWUiLCJlbmRWYWx1ZSIsImJhclN0YXJ0IiwiYmFyRW5kIiwiX2N1c3RvbSIsInBhcnNlVmFsdWUiLCJwYXJzZUFycmF5T3JQcmltaXRpdmUiLCJpc0Zsb2F0QmFyIiwiY3VzdG9tIiwiYmFyU2lnbiIsImFjdHVhbEJhc2UiLCJpc0hvcml6b250YWwiLCJib3JkZXJQcm9wcyIsImhvcml6b250YWwiLCJiYXNlIiwic2V0Qm9yZGVyU2tpcHBlZCIsImVkZ2UiLCJib3JkZXJTa2lwcGVkIiwiZW5hYmxlQm9yZGVyUmFkaXVzIiwicGFyc2VFZGdlIiwic3dhcCIsInN0YXJ0RW5kIiwib3JpZyIsInYxIiwidjIiLCJzZXRJbmZsYXRlQW1vdW50IiwiaW5mbGF0ZUFtb3VudCIsIkJhckNvbnRyb2xsZXIiLCJpQXhpc0tleSIsInZBeGlzS2V5Iiwib2JqIiwiYmFycyIsImdldEJhc2VQaXhlbCIsIl9nZXRSdWxlciIsInZwaXhlbHMiLCJoZWFkIiwiX2NhbGN1bGF0ZUJhclZhbHVlUGl4ZWxzIiwiaXBpeGVscyIsIl9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyIsImNlbnRlciIsImhlaWdodCIsIndpZHRoIiwiX2dldFN0YWNrcyIsImxhc3QiLCJncm91cGVkIiwic2tpcE51bGwiLCJ2YWwiLCJpc05hTiIsImluZGV4T2YiLCJfZ2V0U3RhY2tDb3VudCIsIl9nZXRTdGFja0luZGV4IiwiX3N0YXJ0UGl4ZWwiLCJfZW5kUGl4ZWwiLCJiYXNlVmFsdWUiLCJtaW5CYXJMZW5ndGgiLCJmbG9hdGluZyIsImdldERhdGFWaXNpYmlsaXR5Iiwic3RhcnRQaXhlbCIsImdldFBpeGVsRm9yRGVjaW1hbCIsImVuZFBpeGVsIiwiaGFsZkdyaWQiLCJnZXRMaW5lV2lkdGhGb3JWYWx1ZSIsIm1heEJhclRoaWNrbmVzcyIsIkluZmluaXR5Iiwic3RhY2tJbmRleCIsInJlY3RzIiwiX2luZGV4XyIsIm9mZnNldCIsImdyaWQiLCJfdmFsdWVfIiwiYmVnaW5BdFplcm8iLCJCdWJibGVDb250cm9sbGVyIiwicmFkaXVzIiwicG9pbnRzIiwicG9pbnQiLCJpUGl4ZWwiLCJ2UGl4ZWwiLCJza2lwIiwicGx1Z2lucyIsInRvb2x0aXAiLCJ0aXRsZSIsImdldFJhdGlvQW5kT2Zmc2V0Iiwicm90YXRpb24iLCJjaXJjdW1mZXJlbmNlIiwiY3V0b3V0IiwicmF0aW9YIiwicmF0aW9ZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJzdGFydFgiLCJjb3MiLCJzdGFydFkiLCJzaW4iLCJlbmRYIiwiZW5kWSIsImNhbGNNYXgiLCJhbmdsZSIsImNhbGNNaW4iLCJtYXhYIiwibWF4WSIsIm1pblgiLCJtaW5ZIiwiRG91Z2hudXRDb250cm9sbGVyIiwiaW5uZXJSYWRpdXMiLCJvdXRlclJhZGl1cyIsImdldHRlciIsIl9nZXRSb3RhdGlvbiIsIl9nZXRDaXJjdW1mZXJlbmNlIiwiX2dldFJvdGF0aW9uRXh0ZW50cyIsImlzRGF0YXNldFZpc2libGUiLCJhcmNzIiwic3BhY2luZyIsImdldE1heEJvcmRlcldpZHRoIiwiZ2V0TWF4T2Zmc2V0IiwibWF4U2l6ZSIsImNoYXJ0V2VpZ2h0IiwiX2dldFJpbmdXZWlnaHQiLCJtYXhXaWR0aCIsIm1heEhlaWdodCIsIm1heFJhZGl1cyIsInJhZGl1c0xlbmd0aCIsIl9nZXRWaXNpYmxlRGF0YXNldFdlaWdodFRvdGFsIiwidG90YWwiLCJjYWxjdWxhdGVUb3RhbCIsIl9nZXRSaW5nV2VpZ2h0T2Zmc2V0IiwiX2NpcmN1bWZlcmVuY2UiLCJhbmltYXRlUm90YXRlIiwiY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSIsImFuaW1hdGlvbk9wdHMiLCJjZW50ZXJYIiwiY2VudGVyWSIsImFuaW1hdGVTY2FsZSIsImFyYyIsIm1ldGFEYXRhIiwibG9jYWxlIiwiYm9yZGVyQWxpZ24iLCJib3JkZXJXaWR0aCIsImhvdmVyQm9yZGVyV2lkdGgiLCJob3Zlck9mZnNldCIsInJpbmdXZWlnaHRPZmZzZXQiLCJ3ZWlnaHQiLCJhc3BlY3RSYXRpbyIsImxlZ2VuZCIsImdlbmVyYXRlTGFiZWxzIiwicG9pbnRTdHlsZSIsIm1hcCIsInN0eWxlIiwidGV4dCIsImZpbGxTdHlsZSIsImJhY2tncm91bmRDb2xvciIsInN0cm9rZVN0eWxlIiwiYm9yZGVyQ29sb3IiLCJsaW5lV2lkdGgiLCJvbkNsaWNrIiwibGVnZW5kSXRlbSIsInRvZ2dsZURhdGFWaXNpYmlsaXR5IiwidG9vbHRpcEl0ZW0iLCJkYXRhTGFiZWwiLCJmb3JtYXR0ZWRWYWx1ZSIsInNsaWNlIiwiTGluZUNvbnRyb2xsZXIiLCJsaW5lIiwiX2RhdGFzZXQiLCJhbmltYXRpb25zRGlzYWJsZWQiLCJfZGF0YXNldEluZGV4IiwiX2RlY2ltYXRlZCIsInNob3dMaW5lIiwic2VnbWVudCIsImFuaW1hdGVkIiwic3BhbkdhcHMiLCJtYXhHYXBMZW5ndGgiLCJkaXJlY3RVcGRhdGUiLCJwcmV2UGFyc2VkIiwibnVsbERhdGEiLCJib3JkZXIiLCJmaXJzdFBvaW50IiwibGFzdFBvaW50IiwidXBkYXRlQ29udHJvbFBvaW50cyIsIlBvbGFyQXJlYUNvbnRyb2xsZXIiLCJiaW5kIiwiX3VwZGF0ZVJhZGl1cyIsIm1pblNpemUiLCJjdXRvdXRQZXJjZW50YWdlIiwiZ2V0VmlzaWJsZURhdGFzZXRDb3VudCIsInhDZW50ZXIiLCJ5Q2VudGVyIiwiZGF0YXNldFN0YXJ0QW5nbGUiLCJnZXRJbmRleEFuZ2xlIiwiZGVmYXVsdEFuZ2xlIiwiY291bnRWaXNpYmxlRWxlbWVudHMiLCJfY29tcHV0ZUFuZ2xlIiwiZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUiLCJhbmdsZUxpbmVzIiwiZGlzcGxheSIsImNpcmN1bGFyIiwicG9pbnRMYWJlbHMiLCJQaWVDb250cm9sbGVyIiwiUmFkYXJDb250cm9sbGVyIiwiX2Z1bGxMb29wIiwicG9pbnRQb3NpdGlvbiIsImdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZSIsImZpbGwiLCJFbGVtZW50IiwidG9vbHRpcFBvc2l0aW9uIiwidXNlRmluYWxQb3NpdGlvbiIsImdldFByb3BzIiwiaGFzVmFsdWUiLCJmaW5hbCIsInJldCIsImRlZmF1bHRSb3V0ZXMiLCJmb3JtYXR0ZXJzIiwibnVtZXJpYyIsInRpY2tWYWx1ZSIsIm5vdGF0aW9uIiwiZGVsdGEiLCJtYXhUaWNrIiwiY2FsY3VsYXRlRGVsdGEiLCJsb2dEZWx0YSIsIm51bURlY2ltYWwiLCJtaW5pbXVtRnJhY3Rpb25EaWdpdHMiLCJtYXhpbXVtRnJhY3Rpb25EaWdpdHMiLCJmb3JtYXQiLCJsb2dhcml0aG1pYyIsInBvdyIsIlRpY2tzIiwiYm91bmRzIiwiZ3JhY2UiLCJkcmF3Qm9yZGVyIiwiZHJhd09uQ2hhcnRBcmVhIiwiZHJhd1RpY2tzIiwidGlja0xlbmd0aCIsInRpY2tXaWR0aCIsInRpY2tDb2xvciIsImJvcmRlckRhc2giLCJib3JkZXJEYXNoT2Zmc2V0IiwicGFkZGluZyIsIm1pblJvdGF0aW9uIiwibWF4Um90YXRpb24iLCJtaXJyb3IiLCJ0ZXh0U3Ryb2tlV2lkdGgiLCJ0ZXh0U3Ryb2tlQ29sb3IiLCJhdXRvU2tpcCIsImF1dG9Ta2lwUGFkZGluZyIsImxhYmVsT2Zmc2V0IiwibWlub3IiLCJtYWpvciIsImFsaWduIiwiY3Jvc3NBbGlnbiIsInNob3dMYWJlbEJhY2tkcm9wIiwiYmFja2Ryb3BDb2xvciIsImJhY2tkcm9wUGFkZGluZyIsInJvdXRlIiwic3RhcnRzV2l0aCIsInRpY2tPcHRzIiwidGlja3NMaW1pdCIsIm1heFRpY2tzTGltaXQiLCJkZXRlcm1pbmVNYXhUaWNrcyIsIm1ham9ySW5kaWNlcyIsImVuYWJsZWQiLCJnZXRNYWpvckluZGljZXMiLCJudW1NYWpvckluZGljZXMiLCJmaXJzdCIsIm5ld1RpY2tzIiwic2tpcE1ham9ycyIsImNhbGN1bGF0ZVNwYWNpbmciLCJhdmdNYWpvclNwYWNpbmciLCJyb3VuZCIsIl90aWNrU2l6ZSIsIm1heFNjYWxlIiwibWF4Q2hhcnQiLCJfbWF4TGVuZ3RoIiwiZXZlbk1ham9yU3BhY2luZyIsImdldEV2ZW5TcGFjaW5nIiwiZmFjdG9ycyIsInJlc3VsdCIsImNlaWwiLCJtYWpvclN0YXJ0IiwibWFqb3JFbmQiLCJsZW4iLCJkaWZmIiwicmV2ZXJzZUFsaWduIiwib2Zmc2V0RnJvbUVkZ2UiLCJzYW1wbGUiLCJudW1JdGVtcyIsImluY3JlbWVudCIsImdldFBpeGVsRm9yR3JpZExpbmUiLCJvZmZzZXRHcmlkTGluZXMiLCJ2YWxpZEluZGV4IiwiZXBzaWxvbiIsImxpbmVWYWx1ZSIsImdhcmJhZ2VDb2xsZWN0IiwiY2FjaGVzIiwiZ2MiLCJnY0xlbiIsImdldFRpY2tNYXJrTGVuZ3RoIiwiZ2V0VGl0bGVIZWlnaHQiLCJmYWxsYmFjayIsImZvbnQiLCJsaW5lcyIsImxpbmVIZWlnaHQiLCJjcmVhdGVTY2FsZUNvbnRleHQiLCJjcmVhdGVUaWNrQ29udGV4dCIsInRpdGxlQWxpZ24iLCJwb3NpdGlvbiIsInRpdGxlQXJncyIsInRpdGxlWCIsInRpdGxlWSIsInBvc2l0aW9uQXhpc0lEIiwiU2NhbGUiLCJfbWFyZ2lucyIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJsYWJlbFJvdGF0aW9uIiwiX3JhbmdlIiwiX2dyaWRMaW5lSXRlbXMiLCJfbGFiZWxJdGVtcyIsIl9sYWJlbFNpemVzIiwiX2xvbmdlc3RUZXh0Q2FjaGUiLCJfcmV2ZXJzZVBpeGVscyIsIl91c2VyTWF4IiwiX3VzZXJNaW4iLCJfc3VnZ2VzdGVkTWF4IiwiX3N1Z2dlc3RlZE1pbiIsIl90aWNrc0xlbmd0aCIsIl9ib3JkZXJWYWx1ZSIsIl9kYXRhTGltaXRzQ2FjaGVkIiwiaW5pdCIsInNldENvbnRleHQiLCJzdWdnZXN0ZWRNaW4iLCJzdWdnZXN0ZWRNYXgiLCJtZXRhcyIsImdldFBhZGRpbmciLCJnZXRUaWNrcyIsInhMYWJlbHMiLCJ5TGFiZWxzIiwiYmVmb3JlTGF5b3V0IiwiYmVmb3JlVXBkYXRlIiwibWFyZ2lucyIsInNhbXBsZVNpemUiLCJiZWZvcmVTZXREaW1lbnNpb25zIiwic2V0RGltZW5zaW9ucyIsImFmdGVyU2V0RGltZW5zaW9ucyIsImJlZm9yZURhdGFMaW1pdHMiLCJkZXRlcm1pbmVEYXRhTGltaXRzIiwiYWZ0ZXJEYXRhTGltaXRzIiwiYmVmb3JlQnVpbGRUaWNrcyIsImJ1aWxkVGlja3MiLCJhZnRlckJ1aWxkVGlja3MiLCJzYW1wbGluZ0VuYWJsZWQiLCJfY29udmVydFRpY2tzVG9MYWJlbHMiLCJiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uIiwiY2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsImFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiIsInNvdXJjZSIsImFmdGVyQXV0b1NraXAiLCJiZWZvcmVGaXQiLCJmaXQiLCJhZnRlckZpdCIsImFmdGVyVXBkYXRlIiwicmV2ZXJzZVBpeGVscyIsIl9hbGlnblRvUGl4ZWxzIiwiYWxpZ25Ub1BpeGVscyIsIl9jYWxsSG9va3MiLCJub3RpZnlQbHVnaW5zIiwiYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uIiwiZ2VuZXJhdGVUaWNrTGFiZWxzIiwiYWZ0ZXJUaWNrVG9MYWJlbENvbnZlcnNpb24iLCJudW1UaWNrcyIsIm1heExhYmVsRGlhZ29uYWwiLCJfaXNWaXNpYmxlIiwibGFiZWxTaXplcyIsIl9nZXRMYWJlbFNpemVzIiwibWF4TGFiZWxXaWR0aCIsIndpZGVzdCIsIm1heExhYmVsSGVpZ2h0IiwiaGlnaGVzdCIsInNxcnQiLCJhc2luIiwidGl0bGVPcHRzIiwiZ3JpZE9wdHMiLCJ0aXRsZUhlaWdodCIsInRpY2tQYWRkaW5nIiwiYW5nbGVSYWRpYW5zIiwibGFiZWxIZWlnaHQiLCJsYWJlbFdpZHRoIiwiX2NhbGN1bGF0ZVBhZGRpbmciLCJfaGFuZGxlTWFyZ2lucyIsImlzUm90YXRlZCIsImxhYmVsc0JlbG93VGlja3MiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UmlnaHQiLCJpc0Z1bGxTaXplIiwiZnVsbFNpemUiLCJfY29tcHV0ZUxhYmVsU2l6ZXMiLCJ3aWR0aHMiLCJoZWlnaHRzIiwid2lkZXN0TGFiZWxTaXplIiwiaGlnaGVzdExhYmVsU2l6ZSIsImpsZW4iLCJ0aWNrRm9udCIsImZvbnRTdHJpbmciLCJuZXN0ZWRMYWJlbCIsIl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zIiwic3RyaW5nIiwidmFsdWVBdCIsImlkeCIsImdldFZhbHVlRm9yUGl4ZWwiLCJwaXhlbCIsImRlY2ltYWwiLCJnZXREZWNpbWFsRm9yUGl4ZWwiLCJnZXRCYXNlVmFsdWUiLCJvcHRpb25UaWNrcyIsInJvdCIsIl9jb21wdXRlR3JpZExpbmVJdGVtcyIsInRpY2tzTGVuZ3RoIiwidGwiLCJib3JkZXJPcHRzIiwiYXhpc1dpZHRoIiwiYXhpc0hhbGZXaWR0aCIsImFsaWduQm9yZGVyVmFsdWUiLCJib3JkZXJWYWx1ZSIsImFsaWduZWRMaW5lVmFsdWUiLCJ0eDEiLCJ0eTEiLCJ0eDIiLCJ0eTIiLCJ4MSIsInkxIiwieDIiLCJ5MiIsImxpbWl0Iiwic3RlcCIsIm9wdHNBdEluZGV4IiwibGluZUNvbG9yIiwidGlja0JvcmRlckRhc2giLCJ0aWNrQm9yZGVyRGFzaE9mZnNldCIsIl9jb21wdXRlTGFiZWxJdGVtcyIsInRpY2tBbmRQYWRkaW5nIiwiaFRpY2tBbmRQYWRkaW5nIiwidGV4dEFsaWduIiwibGluZUNvdW50IiwidGV4dE9mZnNldCIsInRleHRCYXNlbGluZSIsIl9nZXRYQXhpc0xhYmVsQWxpZ25tZW50IiwiX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQiLCJoYWxmQ291bnQiLCJzdHJva2VDb2xvciIsInN0cm9rZVdpZHRoIiwidGlja1RleHRBbGlnbiIsImJhY2tkcm9wIiwibGFiZWxQYWRkaW5nIiwidHJhbnNsYXRpb24iLCJfY29tcHV0ZUxhYmVsQXJlYSIsImRyYXdCYWNrZ3JvdW5kIiwic2F2ZSIsImZpbGxSZWN0IiwicmVzdG9yZSIsImZpbmRJbmRleCIsImRyYXdHcmlkIiwiZHJhd0xpbmUiLCJwMSIsInAyIiwic2V0TGluZURhc2giLCJsaW5lRGFzaE9mZnNldCIsImJlZ2luUGF0aCIsIm1vdmVUbyIsImxpbmVUbyIsInN0cm9rZSIsImxhc3RMaW5lV2lkdGgiLCJkcmF3TGFiZWxzIiwiZHJhd1RpdGxlIiwiX2xheWVycyIsInR6IiwiZ3oiLCJnZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzIiwiYXhpc0lEIiwiX21heERpZ2l0cyIsImZvbnRTaXplIiwiVHlwZWRSZWdpc3RyeSIsInNjb3BlIiwib3ZlcnJpZGUiLCJjcmVhdGUiLCJpc0ZvclR5cGUiLCJpc1Byb3RvdHlwZU9mIiwicmVnaXN0ZXIiLCJwcm90byIsImdldFByb3RvdHlwZU9mIiwicGFyZW50U2NvcGUiLCJpc0lDaGFydENvbXBvbmVudCIsIkVycm9yIiwicmVnaXN0ZXJEZWZhdWx0cyIsInVucmVnaXN0ZXIiLCJpdGVtRGVmYXVsdHMiLCJyb3V0ZURlZmF1bHRzIiwicm91dGVzIiwicHJvcGVydHkiLCJwcm9wZXJ0eVBhcnRzIiwic3BsaXQiLCJzb3VyY2VOYW1lIiwic291cmNlU2NvcGUiLCJqb2luIiwicGFydHMiLCJ0YXJnZXROYW1lIiwidGFyZ2V0U2NvcGUiLCJSZWdpc3RyeSIsImNvbnRyb2xsZXJzIiwiX3R5cGVkUmVnaXN0cmllcyIsIl9lYWNoIiwiYWRkQ29udHJvbGxlcnMiLCJhZGRQbHVnaW5zIiwiYWRkU2NhbGVzIiwiZ2V0Q29udHJvbGxlciIsIl9nZXQiLCJnZXRFbGVtZW50IiwiZ2V0UGx1Z2luIiwiZ2V0U2NhbGUiLCJyZW1vdmVDb250cm9sbGVycyIsInJlbW92ZUVsZW1lbnRzIiwicmVtb3ZlUGx1Z2lucyIsInJlbW92ZVNjYWxlcyIsInR5cGVkUmVnaXN0cnkiLCJhcmciLCJyZWciLCJfZ2V0UmVnaXN0cnlGb3JUeXBlIiwiX2V4ZWMiLCJpdGVtUmVnIiwicmVnaXN0cnkiLCJjb21wb25lbnQiLCJjYW1lbE1ldGhvZCIsIlNjYXR0ZXJDb250cm9sbGVyIiwiaW50ZXJhY3Rpb24iLCJfX3Byb3RvX18iLCJhYnN0cmFjdCIsIkRhdGVBZGFwdGVyIiwiY2hhcnRPcHRpb25zIiwiZm9ybWF0cyIsInRpbWVzdGFtcCIsImFtb3VudCIsInVuaXQiLCJzdGFydE9mIiwid2Vla2RheSIsImVuZE9mIiwibWVtYmVycyIsImFkYXB0ZXJzIiwiX2RhdGUiLCJiaW5hcnlTZWFyY2giLCJtZXRhc2V0IiwiaW50ZXJzZWN0IiwibG9va3VwTWV0aG9kIiwiZWwiLCJnZXRSYW5nZSIsImxvIiwiaGkiLCJldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMiLCJoYW5kbGVyIiwiZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzIiwidXNlWCIsInVzZVkiLCJwdDEiLCJwdDIiLCJkZWx0YVgiLCJkZWx0YVkiLCJnZXRJbnRlcnNlY3RJdGVtcyIsImluY2x1ZGVJbnZpc2libGUiLCJpc1BvaW50SW5BcmVhIiwiZXZhbHVhdGlvbkZ1bmMiLCJpblJhbmdlIiwiZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zIiwiZ2V0TmVhcmVzdENhcnRlc2lhbkl0ZW1zIiwiZGlzdGFuY2VNZXRyaWMiLCJtaW5EaXN0YW5jZSIsImdldENlbnRlclBvaW50IiwicG9pbnRJbkFyZWEiLCJkaXN0YW5jZSIsImdldE5lYXJlc3RJdGVtcyIsImdldEF4aXNJdGVtcyIsInJhbmdlTWV0aG9kIiwiaW50ZXJzZWN0c0l0ZW0iLCJJbnRlcmFjdGlvbiIsIm1vZGVzIiwibmVhcmVzdCIsIlNUQVRJQ19QT1NJVElPTlMiLCJmaWx0ZXJCeVBvc2l0aW9uIiwiYXJyYXkiLCJwb3MiLCJmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMiLCJib3giLCJzb3J0QnlXZWlnaHQiLCJ2MCIsIndyYXBCb3hlcyIsImJveGVzIiwibGF5b3V0Qm94ZXMiLCJzdGFja1dlaWdodCIsImJ1aWxkU3RhY2tzIiwibGF5b3V0cyIsIndyYXAiLCJpbmNsdWRlcyIsIl9zdGFjayIsInBsYWNlZCIsInNldExheW91dERpbXMiLCJwYXJhbXMiLCJ2Qm94TWF4V2lkdGgiLCJoQm94TWF4SGVpZ2h0IiwibGF5b3V0IiwiYXZhaWxhYmxlV2lkdGgiLCJhdmFpbGFibGVIZWlnaHQiLCJidWlsZExheW91dEJveGVzIiwiY2VudGVySG9yaXpvbnRhbCIsImNlbnRlclZlcnRpY2FsIiwibGVmdEFuZFRvcCIsInJpZ2h0QW5kQm90dG9tIiwidmVydGljYWwiLCJnZXRDb21iaW5lZE1heCIsIm1heFBhZGRpbmciLCJ1cGRhdGVNYXhQYWRkaW5nIiwiYm94UGFkZGluZyIsInVwZGF0ZURpbXMiLCJuZXdXaWR0aCIsIm91dGVyV2lkdGgiLCJuZXdIZWlnaHQiLCJvdXRlckhlaWdodCIsIndpZHRoQ2hhbmdlZCIsImhlaWdodENoYW5nZWQiLCJzYW1lIiwib3RoZXIiLCJoYW5kbGVNYXhQYWRkaW5nIiwidXBkYXRlUG9zIiwiY2hhbmdlIiwiZ2V0TWFyZ2lucyIsIm1hcmdpbkZvclBvc2l0aW9ucyIsInBvc2l0aW9ucyIsIm1hcmdpbiIsImZpdEJveGVzIiwicmVmaXRCb3hlcyIsInJlZml0IiwiY2hhbmdlZCIsInNldEJveERpbXMiLCJwbGFjZUJveGVzIiwidXNlclBhZGRpbmciLCJhdXRvUGFkZGluZyIsImFkZEJveCIsInJlbW92ZUJveCIsImxheW91dEl0ZW0iLCJtaW5QYWRkaW5nIiwidmVydGljYWxCb3hlcyIsImhvcml6b250YWxCb3hlcyIsInZpc2libGVWZXJ0aWNhbEJveENvdW50IiwiQmFzZVBsYXRmb3JtIiwiYWNxdWlyZUNvbnRleHQiLCJjYW52YXMiLCJyZWxlYXNlQ29udGV4dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJsaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJnZXREZXZpY2VQaXhlbFJhdGlvIiwiaXNBdHRhY2hlZCIsInVwZGF0ZUNvbmZpZyIsIkJhc2ljUGxhdGZvcm0iLCJFWFBBTkRPX0tFWSIsIkVWRU5UX1RZUEVTIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwicG9pbnRlcmVudGVyIiwicG9pbnRlcmRvd24iLCJwb2ludGVybW92ZSIsInBvaW50ZXJ1cCIsInBvaW50ZXJsZWF2ZSIsInBvaW50ZXJvdXQiLCJpc051bGxPckVtcHR5IiwiaW5pdENhbnZhcyIsInJlbmRlckhlaWdodCIsImdldEF0dHJpYnV0ZSIsInJlbmRlcldpZHRoIiwiYm94U2l6aW5nIiwiZGlzcGxheVdpZHRoIiwiZGlzcGxheUhlaWdodCIsImV2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZSIsImFkZExpc3RlbmVyIiwibm9kZSIsInJlbW92ZUxpc3RlbmVyIiwiZnJvbU5hdGl2ZUV2ZW50IiwibmF0aXZlIiwibm9kZUxpc3RDb250YWlucyIsIm5vZGVMaXN0IiwiY29udGFpbnMiLCJjcmVhdGVBdHRhY2hPYnNlcnZlciIsIm9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsImVudHJpZXMiLCJ0cmlnZ2VyIiwiYWRkZWROb2RlcyIsInJlbW92ZWROb2RlcyIsIm9ic2VydmUiLCJkb2N1bWVudCIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjcmVhdGVEZXRhY2hPYnNlcnZlciIsImRycExpc3RlbmluZ0NoYXJ0cyIsIm9sZERldmljZVBpeGVsUmF0aW8iLCJvbldpbmRvd1Jlc2l6ZSIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyIsImxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzIiwidW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyIsImNyZWF0ZVJlc2l6ZU9ic2VydmVyIiwiY29udGFpbmVyIiwiY2xpZW50V2lkdGgiLCJSZXNpemVPYnNlcnZlciIsImNvbnRlbnRSZWN0IiwicmVsZWFzZU9ic2VydmVyIiwiZGlzY29ubmVjdCIsImNyZWF0ZVByb3h5QW5kTGlzdGVuIiwicHJveHkiLCJEb21QbGF0Zm9ybSIsInJlbW92ZUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInByb3hpZXMiLCIkcHJveGllcyIsImhhbmRsZXJzIiwiYXR0YWNoIiwiZGV0YWNoIiwiaXNDb25uZWN0ZWQiLCJfZGV0ZWN0UGxhdGZvcm0iLCJPZmZzY3JlZW5DYW52YXMiLCJQbHVnaW5TZXJ2aWNlIiwiX2luaXQiLCJub3RpZnkiLCJob29rIiwiX2NyZWF0ZURlc2NyaXB0b3JzIiwiZGVzY3JpcHRvciIsInBsdWdpbiIsImNhbmNlbGFibGUiLCJpbnZhbGlkYXRlIiwiX29sZENhY2hlIiwiX25vdGlmeVN0YXRlQ2hhbmdlcyIsImFsbFBsdWdpbnMiLCJjcmVhdGVEZXNjcmlwdG9ycyIsInByZXZpb3VzRGVzY3JpcHRvcnMiLCJzb21lIiwibG9jYWxJZHMiLCJsb2NhbCIsImdldE9wdHMiLCJwbHVnaW5PcHRzIiwicGx1Z2luU2NvcGVLZXlzIiwic2NyaXB0YWJsZSIsImluZGV4YWJsZSIsImFsbEtleXMiLCJnZXRJbmRleEF4aXMiLCJkYXRhc2V0RGVmYXVsdHMiLCJkYXRhc2V0T3B0aW9ucyIsImdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQiLCJnZXREZWZhdWx0U2NhbGVJREZyb21BeGlzIiwiYXhpc0Zyb21Qb3NpdGlvbiIsImRldGVybWluZUF4aXMiLCJzY2FsZU9wdGlvbnMiLCJ0b0xvd2VyQ2FzZSIsIm1lcmdlU2NhbGVDb25maWciLCJjaGFydERlZmF1bHRzIiwiY29uZmlnU2NhbGVzIiwiY2hhcnRJbmRleEF4aXMiLCJmaXJzdElEcyIsInNjYWxlQ29uZiIsImNvbnNvbGUiLCJlcnJvciIsIl9wcm94eSIsIndhcm4iLCJkZWZhdWx0SWQiLCJkZWZhdWx0U2NhbGVPcHRpb25zIiwiZGVmYXVsdElEIiwiaW5pdE9wdGlvbnMiLCJpbml0RGF0YSIsImluaXRDb25maWciLCJrZXlDYWNoZSIsImtleXNDYWNoZWQiLCJTZXQiLCJjYWNoZWRLZXlzIiwiZ2VuZXJhdGUiLCJhZGRJZkZvdW5kIiwiQ29uZmlnIiwiX2NvbmZpZyIsIl9zY29wZUNhY2hlIiwiX3Jlc29sdmVyQ2FjaGUiLCJwbGF0Zm9ybSIsImNsZWFyQ2FjaGUiLCJjbGVhciIsImRhdGFzZXRUeXBlIiwiYWRkaXRpb25hbE9wdGlvblNjb3BlcyIsIl9jYWNoZWRTY29wZXMiLCJtYWluU2NvcGUiLCJyZXNldENhY2hlIiwia2V5TGlzdHMiLCJjaGFydE9wdGlvblNjb3BlcyIsInJlc29sdmVyIiwic3ViUHJlZml4ZXMiLCJnZXRSZXNvbHZlciIsIm5lZWRDb250ZXh0Iiwic3ViUmVzb2x2ZXIiLCJkZXNjcmlwdG9yRGVmYXVsdHMiLCJyZXNvbHZlckNhY2hlIiwiaGFzRnVuY3Rpb24iLCJpc1NjcmlwdGFibGUiLCJpc0luZGV4YWJsZSIsInZlcnNpb24iLCJLTk9XTl9QT1NJVElPTlMiLCJwb3NpdGlvbklzSG9yaXpvbnRhbCIsImNvbXBhcmUyTGV2ZWwiLCJsMSIsImwyIiwib25BbmltYXRpb25zQ29tcGxldGUiLCJvbkNvbXBsZXRlIiwib25BbmltYXRpb25Qcm9ncmVzcyIsIm9uUHJvZ3Jlc3MiLCJnZXRDYW52YXMiLCJnZXRFbGVtZW50QnlJZCIsImluc3RhbmNlcyIsImdldENoYXJ0IiwibW92ZU51bWVyaWNLZXlzIiwiaW50S2V5IiwiZGV0ZXJtaW5lTGFzdEV2ZW50IiwibGFzdEV2ZW50IiwiaW5DaGFydEFyZWEiLCJpc0NsaWNrIiwiQ2hhcnQiLCJ1c2VyQ29uZmlnIiwiaW5pdGlhbENhbnZhcyIsImV4aXN0aW5nQ2hhcnQiLCJfb3B0aW9ucyIsIl9hc3BlY3RSYXRpbyIsIl9tZXRhc2V0cyIsIl9sYXN0RXZlbnQiLCJfbGlzdGVuZXJzIiwiX3Jlc3BvbnNpdmVMaXN0ZW5lcnMiLCJfc29ydGVkTWV0YXNldHMiLCJfcGx1Z2lucyIsIl9oaWRkZW5JbmRpY2VzIiwiYXR0YWNoZWQiLCJfZG9SZXNpemUiLCJyZXNpemVEZWxheSIsIl9pbml0aWFsaXplIiwibWFpbnRhaW5Bc3BlY3RSYXRpbyIsInJlc3BvbnNpdmUiLCJiaW5kRXZlbnRzIiwiX3Jlc2l6ZSIsIl9yZXNpemVCZWZvcmVEcmF3IiwibmV3U2l6ZSIsIm5ld1JhdGlvIiwib25SZXNpemUiLCJyZW5kZXIiLCJlbnN1cmVTY2FsZXNIYXZlSURzIiwic2NhbGVzT3B0aW9ucyIsImF4aXNPcHRpb25zIiwiYnVpbGRPclVwZGF0ZVNjYWxlcyIsInNjYWxlT3B0cyIsInVwZGF0ZWQiLCJpc1JhZGlhbCIsImRwb3NpdGlvbiIsImR0eXBlIiwic2NhbGVUeXBlIiwic2NhbGVDbGFzcyIsImhhc1VwZGF0ZWQiLCJfdXBkYXRlTWV0YXNldHMiLCJfZGVzdHJveURhdGFzZXRNZXRhIiwiX3JlbW92ZVVucmVmZXJlbmNlZE1ldGFzZXRzIiwiYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzIiwibmV3Q29udHJvbGxlcnMiLCJvcmRlciIsIkNvbnRyb2xsZXJDbGFzcyIsIl9yZXNldEVsZW1lbnRzIiwiYW5pbXNEaXNhYmxlZCIsIl91cGRhdGVTY2FsZXMiLCJfY2hlY2tFdmVudEJpbmRpbmdzIiwiX3VwZGF0ZUhpZGRlbkluZGljZXMiLCJfbWluUGFkZGluZyIsIl91cGRhdGVMYXlvdXQiLCJfdXBkYXRlRGF0YXNldHMiLCJfZXZlbnRIYW5kbGVyIiwiX3VwZGF0ZUhvdmVyU3R5bGVzIiwiZXhpc3RpbmdFdmVudHMiLCJuZXdFdmVudHMiLCJldmVudHMiLCJ1bmJpbmRFdmVudHMiLCJjaGFuZ2VzIiwiX2dldFVuaWZvcm1EYXRhQ2hhbmdlcyIsImRhdGFzZXRDb3VudCIsIm1ha2VTZXQiLCJjaGFuZ2VTZXQiLCJub0FyZWEiLCJfaWR4IiwiX3VwZGF0ZURhdGFzZXQiLCJsYXllcnMiLCJfZHJhd0RhdGFzZXRzIiwiX2RyYXdEYXRhc2V0IiwidXNlQ2xpcCIsImdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUiLCJzZXREYXRhc2V0VmlzaWJpbGl0eSIsIl91cGRhdGVWaXNpYmlsaXR5IiwiX3N0b3AiLCJkZXN0cm95IiwidG9CYXNlNjRJbWFnZSIsInRvRGF0YVVSTCIsImJpbmRVc2VyRXZlbnRzIiwiYmluZFJlc3BvbnNpdmVFdmVudHMiLCJfYWRkIiwiX3JlbW92ZSIsImRldGFjaGVkIiwidXBkYXRlSG92ZXJTdHlsZSIsInByZWZpeCIsImdldEFjdGl2ZUVsZW1lbnRzIiwic2V0QWN0aXZlRWxlbWVudHMiLCJhY3RpdmVFbGVtZW50cyIsImxhc3RBY3RpdmUiLCJyZXBsYXkiLCJob3Zlck9wdGlvbnMiLCJob3ZlciIsImRlYWN0aXZhdGVkIiwiYWN0aXZhdGVkIiwiZXZlbnRGaWx0ZXIiLCJfaGFuZGxlRXZlbnQiLCJfZ2V0QWN0aXZlRWxlbWVudHMiLCJvbkhvdmVyIiwiaW52YWxpZGF0ZVBsdWdpbnMiLCJlbnVtZXJhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsImNsaXBBcmMiLCJwaXhlbE1hcmdpbiIsImFuZ2xlTWFyZ2luIiwiY2xvc2VQYXRoIiwidG9SYWRpdXNDb3JuZXJzIiwicGFyc2VCb3JkZXJSYWRpdXMkMSIsImFuZ2xlRGVsdGEiLCJib3JkZXJSYWRpdXMiLCJoYWxmVGhpY2tuZXNzIiwiaW5uZXJMaW1pdCIsImNvbXB1dGVPdXRlckxpbWl0Iiwib3V0ZXJBcmNMaW1pdCIsIm91dGVyU3RhcnQiLCJvdXRlckVuZCIsImlubmVyU3RhcnQiLCJpbm5lckVuZCIsInJUaGV0YVRvWFkiLCJ0aGV0YSIsInBhdGhBcmMiLCJpbm5lclIiLCJzcGFjaW5nT2Zmc2V0IiwiYWxwaGEiLCJub1NwYWNpbmdJbm5lclJhZGl1cyIsIm5vU3BhY2luZ091dGVyUmFkaXVzIiwiYXZOb2dTcGFjaW5nUmFkaXVzIiwiYWRqdXN0ZWRBbmdsZSIsImJldGEiLCJhbmdsZU9mZnNldCIsIm91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsIm91dGVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSIsIm91dGVyRW5kQWRqdXN0ZWRBbmdsZSIsImlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyIsImlubmVyRW5kQWRqdXN0ZWRSYWRpdXMiLCJpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSIsImlubmVyRW5kQWRqdXN0ZWRBbmdsZSIsInBDZW50ZXIiLCJwNCIsInA4Iiwib3V0ZXJTdGFydFgiLCJvdXRlclN0YXJ0WSIsIm91dGVyRW5kWCIsIm91dGVyRW5kWSIsImRyYXdBcmMiLCJmdWxsQ2lyY2xlcyIsImRyYXdGdWxsQ2lyY2xlQm9yZGVycyIsImlubmVyIiwiYm9yZGVySm9pblN0eWxlIiwibGluZUpvaW4iLCJBcmNFbGVtZW50IiwiY2hhcnRYIiwiY2hhcnRZIiwickFkanVzdCIsImJldHdlZW5BbmdsZXMiLCJ3aXRoaW5SYWRpdXMiLCJoYWxmQW5nbGUiLCJoYWxmUmFkaXVzIiwicmFkaXVzT2Zmc2V0IiwidHJhbnNsYXRlIiwic2V0U3R5bGUiLCJsaW5lQ2FwIiwiYm9yZGVyQ2FwU3R5bGUiLCJwcmV2aW91cyIsImdldExpbmVNZXRob2QiLCJzdGVwcGVkIiwidGVuc2lvbiIsImN1YmljSW50ZXJwb2xhdGlvbk1vZGUiLCJwYXRoVmFycyIsInBhcmFtc1N0YXJ0IiwicGFyYW1zRW5kIiwic2VnbWVudFN0YXJ0Iiwic2VnbWVudEVuZCIsIm91dHNpZGUiLCJwYXRoU2VnbWVudCIsImxpbmVNZXRob2QiLCJmYXN0UGF0aFNlZ21lbnQiLCJhdmdYIiwiY291bnRYIiwicHJldlgiLCJsYXN0WSIsInBvaW50SW5kZXgiLCJkcmF3WCIsInRydW5jWCIsIl9nZXRTZWdtZW50TWV0aG9kIiwidXNlRmFzdFBhdGgiLCJfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZCIsInN0cm9rZVBhdGhXaXRoQ2FjaGUiLCJwYXRoIiwiX3BhdGgiLCJQYXRoMkQiLCJzdHJva2VQYXRoRGlyZWN0Iiwic2VnbWVudHMiLCJzZWdtZW50TWV0aG9kIiwidXNlUGF0aDJEIiwiTGluZUVsZW1lbnQiLCJfcG9pbnRzIiwiX3NlZ21lbnRzIiwiX3BvaW50c1VwZGF0ZWQiLCJpbnRlcnBvbGF0ZSIsIl9pbnRlcnBvbGF0ZSIsImludGVycG9sYXRlZCIsImNhcEJlemllclBvaW50cyIsImluUmFuZ2UkMSIsImhpdFJhZGl1cyIsIlBvaW50RWxlbWVudCIsIm1vdXNlWCIsIm1vdXNlWSIsImluWFJhbmdlIiwiaW5ZUmFuZ2UiLCJob3ZlclJhZGl1cyIsImdldEJhckJvdW5kcyIsImJhciIsImhhbGYiLCJza2lwT3JMaW1pdCIsInBhcnNlQm9yZGVyV2lkdGgiLCJtYXhXIiwibWF4SCIsInBhcnNlQm9yZGVyUmFkaXVzIiwibWF4UiIsImVuYWJsZUJvcmRlciIsInRvcExlZnQiLCJ0b3BSaWdodCIsImJvdHRvbUxlZnQiLCJib3R0b21SaWdodCIsImJvdW5kaW5nUmVjdHMiLCJvdXRlciIsInNraXBYIiwic2tpcFkiLCJza2lwQm90aCIsImhhc1JhZGl1cyIsImFkZE5vcm1hbFJlY3RQYXRoIiwicmVjdCIsImluZmxhdGVSZWN0IiwicmVmUmVjdCIsIkJhckVsZW1lbnQiLCJhZGRSZWN0UGF0aCIsImx0dGJEZWNpbWF0aW9uIiwic2FtcGxlcyIsImRlY2ltYXRlZCIsImJ1Y2tldFdpZHRoIiwic2FtcGxlZEluZGV4IiwiZW5kSW5kZXgiLCJtYXhBcmVhUG9pbnQiLCJtYXhBcmVhIiwibmV4dEEiLCJhdmdZIiwiYXZnUmFuZ2VTdGFydCIsImF2Z1JhbmdlRW5kIiwiYXZnUmFuZ2VMZW5ndGgiLCJyYW5nZU9mZnMiLCJyYW5nZVRvIiwicG9pbnRBeCIsInBvaW50QXkiLCJtaW5NYXhEZWNpbWF0aW9uIiwibWluSW5kZXgiLCJtYXhJbmRleCIsInN0YXJ0SW5kZXgiLCJ4TWluIiwieE1heCIsImR4IiwibGFzdEluZGV4IiwiaW50ZXJtZWRpYXRlSW5kZXgxIiwiaW50ZXJtZWRpYXRlSW5kZXgyIiwiY2xlYW5EZWNpbWF0ZWREYXRhc2V0IiwiZGVmaW5lUHJvcGVydHkiLCJjbGVhbkRlY2ltYXRlZERhdGEiLCJnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZCIsInBvaW50Q291bnQiLCJwbHVnaW5fZGVjaW1hdGlvbiIsImFsZ29yaXRobSIsImJlZm9yZUVsZW1lbnRzVXBkYXRlIiwieEF4aXMiLCJ0aHJlc2hvbGQiLCJjb25maWd1cmFibGUiLCJ0cG9pbnRzIiwiX2ZpbmRTZWdtZW50RW5kIiwiX2dldEJvdW5kcyIsInRhcmdldFNlZ21lbnRzIiwidGd0Iiwic3ViQm91bmRzIiwiZmlsbFNvdXJjZXMiLCJmaWxsU291cmNlIiwiX2dldEVkZ2UiLCJfcG9pbnRzRnJvbVNlZ21lbnRzIiwiYm91bmRhcnkiLCJsaW5lUG9pbnRzIiwiX2NyZWF0ZUJvdW5kYXJ5TGluZSIsIl9zaG91bGRBcHBseUZpbGwiLCJfcmVzb2x2ZVRhcmdldCIsInNvdXJjZXMiLCJwcm9wYWdhdGUiLCJ2aXNpdGVkIiwiX2RlY29kZUZpbGwiLCJwYXJzZUZpbGxPcHRpb24iLCJwYXJzZUZsb2F0IiwiZGVjb2RlVGFyZ2V0SW5kZXgiLCJmaXJzdENoIiwiX2dldFRhcmdldFBpeGVsIiwiX2dldFRhcmdldFZhbHVlIiwiZmlsbE9wdGlvbiIsIl9idWlsZFN0YWNrTGluZSIsInNvdXJjZVBvaW50cyIsImxpbmVzQmVsb3ciLCJnZXRMaW5lc0JlbG93IiwiYWRkUG9pbnRzQmVsb3ciLCJiZWxvdyIsInVuc2hpZnQiLCJzb3VyY2VQb2ludCIsInBvc3Rwb25lZCIsImZpbmRQb2ludCIsInBvaW50VmFsdWUiLCJmaXJzdFZhbHVlIiwibGFzdFZhbHVlIiwic2ltcGxlQXJjIiwiX2dldFRhcmdldCIsImdldExpbmVCeUluZGV4IiwiY29tcHV0ZUJvdW5kYXJ5IiwiY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkiLCJjb21wdXRlTGluZWFyQm91bmRhcnkiLCJfZHJhd2ZpbGwiLCJsaW5lT3B0cyIsImFib3ZlIiwiZG9GaWxsIiwiY2xpcFZlcnRpY2FsIiwiY2xpcFkiLCJsaW5lTG9vcCIsInNyYyIsIm5vdFNoYXBlIiwiY2xpcEJvdW5kcyIsImludGVycG9sYXRlZExpbmVUbyIsInRhcmdldExvb3AiLCJpbnRlcnBvbGF0ZWRQb2ludCIsImFmdGVyRGF0YXNldHNVcGRhdGUiLCJfYXJncyIsIiRmaWxsZXIiLCJiZWZvcmVEcmF3IiwiZHJhd1RpbWUiLCJiZWZvcmVEYXRhc2V0c0RyYXciLCJiZWZvcmVEYXRhc2V0RHJhdyIsImdldEJveFNpemUiLCJsYWJlbE9wdHMiLCJib3hIZWlnaHQiLCJib3hXaWR0aCIsInVzZVBvaW50U3R5bGUiLCJwb2ludFN0eWxlV2lkdGgiLCJpdGVtSGVpZ2h0IiwiaXRlbXNFcXVhbCIsIkxlZ2VuZCIsIl9hZGRlZCIsImxlZ2VuZEhpdEJveGVzIiwiX2hvdmVyZWRJdGVtIiwiZG91Z2hudXRNb2RlIiwibGVnZW5kSXRlbXMiLCJjb2x1bW5TaXplcyIsImxpbmVXaWR0aHMiLCJidWlsZExhYmVscyIsImxhYmVsRm9udCIsIl9jb21wdXRlVGl0bGVIZWlnaHQiLCJfZml0Um93cyIsIl9maXRDb2xzIiwiaGl0Ym94ZXMiLCJ0b3RhbEhlaWdodCIsInJvdyIsIml0ZW1XaWR0aCIsIm1lYXN1cmVUZXh0IiwiaGVpZ2h0TGltaXQiLCJ0b3RhbFdpZHRoIiwiY3VycmVudENvbFdpZHRoIiwiY3VycmVudENvbEhlaWdodCIsImNvbCIsImFkanVzdEhpdEJveGVzIiwicnRsIiwicnRsSGVscGVyIiwiaGl0Ym94IiwibGVmdEZvckx0ciIsIl9kcmF3IiwiZGVmYXVsdENvbG9yIiwiZm9udENvbG9yIiwiaGFsZkZvbnRTaXplIiwiY3Vyc29yIiwiZHJhd0xlZ2VuZEJveCIsImxpbmVEYXNoIiwiZHJhd09wdGlvbnMiLCJTUVJUMiIsInhQbHVzIiwieUJveFRvcCIsInhCb3hMZWZ0IiwiZmlsbFRleHQiLCJzdHJpa2V0aHJvdWdoIiwidGV4dERpcmVjdGlvbiIsInRleHRXaWR0aCIsInNldFdpZHRoIiwicmVhbFgiLCJ0aXRsZUZvbnQiLCJ0aXRsZVBhZGRpbmciLCJ0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSIsIl9nZXRMZWdlbmRJdGVtQXQiLCJoaXRCb3giLCJsaCIsImhhbmRsZUV2ZW50IiwiaXNMaXN0ZW5lZCIsImhvdmVyZWRJdGVtIiwic2FtZUl0ZW0iLCJvbkxlYXZlIiwicGx1Z2luX2xlZ2VuZCIsIl9lbGVtZW50IiwiYWZ0ZXJFdmVudCIsImNpIiwiVGl0bGUiLCJfcGFkZGluZyIsInRleHRTaXplIiwiX2RyYXdBcmdzIiwiZm9udE9wdHMiLCJjcmVhdGVUaXRsZSIsInRpdGxlQmxvY2siLCJwbHVnaW5fdGl0bGUiLCJXZWFrTWFwIiwicGx1Z2luX3N1YnRpdGxlIiwicG9zaXRpb25lcnMiLCJhdmVyYWdlIiwiZXZlbnRQb3NpdGlvbiIsIm5lYXJlc3RFbGVtZW50IiwidHAiLCJwdXNoT3JDb25jYXQiLCJ0b1B1c2giLCJhcHBseSIsInNwbGl0TmV3bGluZXMiLCJzdHIiLCJTdHJpbmciLCJjcmVhdGVUb29sdGlwSXRlbSIsImdldFRvb2x0aXBTaXplIiwiYm9keSIsImZvb3RlciIsImJvZHlGb250IiwiZm9vdGVyRm9udCIsInRpdGxlTGluZUNvdW50IiwiZm9vdGVyTGluZUNvdW50IiwiYm9keUxpbmVJdGVtQ291bnQiLCJjb21iaW5lZEJvZHlMZW5ndGgiLCJib2R5SXRlbSIsImJlZm9yZSIsImFmdGVyIiwiYmVmb3JlQm9keSIsImFmdGVyQm9keSIsInRpdGxlU3BhY2luZyIsInRpdGxlTWFyZ2luQm90dG9tIiwiYm9keUxpbmVIZWlnaHQiLCJkaXNwbGF5Q29sb3JzIiwiYm9keVNwYWNpbmciLCJmb290ZXJNYXJnaW5Ub3AiLCJmb290ZXJTcGFjaW5nIiwid2lkdGhQYWRkaW5nIiwibWF4TGluZVdpZHRoIiwiZGV0ZXJtaW5lWUFsaWduIiwiZG9lc05vdEZpdFdpdGhBbGlnbiIsInhBbGlnbiIsImNhcmV0IiwiY2FyZXRTaXplIiwiY2FyZXRQYWRkaW5nIiwiZGV0ZXJtaW5lWEFsaWduIiwieUFsaWduIiwiY2hhcnRXaWR0aCIsImRldGVybWluZUFsaWdubWVudCIsImFsaWduWCIsImFsaWduWSIsInBhZGRpbmdBbmRTaXplIiwiZ2V0QmFja2dyb3VuZFBvaW50IiwiYWxpZ25tZW50IiwiY29ybmVyUmFkaXVzIiwiZ2V0QWxpZ25lZFgiLCJnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyIsImNyZWF0ZVRvb2x0aXBDb250ZXh0IiwidG9vbHRpcEl0ZW1zIiwib3ZlcnJpZGVDYWxsYmFja3MiLCJUb29sdGlwIiwib3BhY2l0eSIsIl9ldmVudFBvc2l0aW9uIiwiX3NpemUiLCJfY2FjaGVkQW5pbWF0aW9ucyIsIl90b29sdGlwSXRlbXMiLCJkYXRhUG9pbnRzIiwiY2FyZXRYIiwiY2FyZXRZIiwibGFiZWxDb2xvcnMiLCJsYWJlbFBvaW50U3R5bGVzIiwibGFiZWxUZXh0Q29sb3JzIiwiZ2V0VGl0bGUiLCJiZWZvcmVUaXRsZSIsImFmdGVyVGl0bGUiLCJnZXRCZWZvcmVCb2R5IiwiZ2V0Qm9keSIsImJvZHlJdGVtcyIsInNjb3BlZCIsImJlZm9yZUxhYmVsIiwiYWZ0ZXJMYWJlbCIsImdldEFmdGVyQm9keSIsImdldEZvb3RlciIsImJlZm9yZUZvb3RlciIsImFmdGVyRm9vdGVyIiwiX2NyZWF0ZUl0ZW1zIiwiaXRlbVNvcnQiLCJsYWJlbENvbG9yIiwibGFiZWxQb2ludFN0eWxlIiwibGFiZWxUZXh0Q29sb3IiLCJwb3NpdGlvbkFuZFNpemUiLCJiYWNrZ3JvdW5kUG9pbnQiLCJleHRlcm5hbCIsImRyYXdDYXJldCIsInRvb2x0aXBQb2ludCIsImNhcmV0UG9zaXRpb24iLCJnZXRDYXJldFBvc2l0aW9uIiwieDMiLCJ5MyIsInB0WCIsInB0WSIsInB0IiwidGl0bGVDb2xvciIsIl9kcmF3Q29sb3JCb3giLCJjb2xvclgiLCJydGxDb2xvclgiLCJ5T2ZmU2V0IiwiY29sb3JZIiwibXVsdGlLZXlCYWNrZ3JvdW5kIiwib3V0ZXJYIiwiaW5uZXJYIiwic3Ryb2tlUmVjdCIsImRyYXdCb2R5IiwiYm9keUFsaWduIiwieExpbmVQYWRkaW5nIiwiZmlsbExpbmVPZlRleHQiLCJib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiIsInRleHRDb2xvciIsImJvZHlDb2xvciIsImRyYXdGb290ZXIiLCJmb290ZXJBbGlnbiIsImZvb3RlckNvbG9yIiwidG9vbHRpcFNpemUiLCJxdWFkcmF0aWNDdXJ2ZVRvIiwiX3VwZGF0ZUFuaW1hdGlvblRhcmdldCIsImFuaW1YIiwiYW5pbVkiLCJfd2lsbFJlbmRlciIsImhhc1Rvb2x0aXBDb250ZW50IiwiZ2xvYmFsQWxwaGEiLCJwb3NpdGlvbkNoYW5nZWQiLCJfcG9zaXRpb25DaGFuZ2VkIiwiX2lnbm9yZVJlcGxheUV2ZW50cyIsInBsdWdpbl90b29sdGlwIiwiYWZ0ZXJJbml0IiwiYWZ0ZXJEcmF3IiwibGFiZWxDb3VudCIsIkRlY2ltYXRpb24iLCJGaWxsZXIiLCJTdWJUaXRsZSIsImFkZElmU3RyaW5nIiwiYWRkZWRMYWJlbHMiLCJmaW5kT3JBZGRMYWJlbCIsImxhc3RJbmRleE9mIiwiQ2F0ZWdvcnlTY2FsZSIsIl9zdGFydFZhbHVlIiwiX3ZhbHVlUmFuZ2UiLCJfYWRkZWRMYWJlbHMiLCJhZGRlZCIsImlzRmluaXRlIiwiZ2VuZXJhdGVUaWNrcyQxIiwiZ2VuZXJhdGlvbk9wdGlvbnMiLCJkYXRhUmFuZ2UiLCJNSU5fU1BBQ0lORyIsInByZWNpc2lvbiIsIm1heFRpY2tzIiwibWF4RGlnaXRzIiwiaW5jbHVkZUJvdW5kcyIsIm1heFNwYWNlcyIsInJtaW4iLCJybWF4IiwiY291bnREZWZpbmVkIiwibWluU3BhY2luZyIsIm5pY2VNaW4iLCJuaWNlTWF4IiwibnVtU3BhY2VzIiwiZGVjaW1hbFBsYWNlcyIsInJlbGF0aXZlTGFiZWxTaXplIiwicmFkIiwiTGluZWFyU2NhbGVCYXNlIiwiX2VuZFZhbHVlIiwiaGFuZGxlVGlja1JhbmdlT3B0aW9ucyIsInNldE1pbiIsInNldE1heCIsIm1pblNpZ24iLCJtYXhTaWduIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1JTl9TQUZFX0lOVEVHRVIiLCJnZXRUaWNrTGltaXQiLCJzdGVwU2l6ZSIsImNvbXB1dGVUaWNrTGltaXQiLCJudW1lcmljR2VuZXJhdG9yT3B0aW9ucyIsIkxpbmVhclNjYWxlIiwiaXNNYWpvciIsInRpY2tWYWwiLCJnZW5lcmF0ZVRpY2tzIiwiZW5kRXhwIiwiZW5kU2lnbmlmaWNhbmQiLCJleHAiLCJzaWduaWZpY2FuZCIsImxhc3RUaWNrIiwiTG9nYXJpdGhtaWNTY2FsZSIsIl96ZXJvIiwiZ2V0VGlja0JhY2tkcm9wSGVpZ2h0IiwibWVhc3VyZUxhYmVsU2l6ZSIsImRldGVybWluZUxpbWl0cyIsImZpdFdpdGhQb2ludExhYmVscyIsImxpbWl0cyIsInZhbHVlQ291bnQiLCJfcG9pbnRMYWJlbHMiLCJwb2ludExhYmVsT3B0cyIsImFkZGl0aW9uYWxBbmdsZSIsImNlbnRlclBvaW50TGFiZWxzIiwiZ2V0UG9pbnRMYWJlbENvbnRleHQiLCJnZXRQb2ludFBvc2l0aW9uIiwiZHJhd2luZ0FyZWEiLCJwbEZvbnQiLCJoTGltaXRzIiwidkxpbWl0cyIsInVwZGF0ZUxpbWl0cyIsInNldENlbnRlclBvaW50IiwiX3BvaW50TGFiZWxJdGVtcyIsImJ1aWxkUG9pbnRMYWJlbEl0ZW1zIiwiZXh0cmEiLCJvdXRlckRpc3RhbmNlIiwicG9pbnRMYWJlbFBvc2l0aW9uIiwieUZvckFuZ2xlIiwiZ2V0VGV4dEFsaWduRm9yQW5nbGUiLCJsZWZ0Rm9yVGV4dEFsaWduIiwiZHJhd1BvaW50TGFiZWxzIiwiYmFja2Ryb3BMZWZ0IiwiYmFja2Ryb3BUb3AiLCJiYWNrZHJvcFdpZHRoIiwiYmFja2Ryb3BIZWlnaHQiLCJwYXRoUmFkaXVzTGluZSIsImRyYXdSYWRpdXNMaW5lIiwiZ3JpZExpbmVPcHRzIiwiY3JlYXRlUG9pbnRMYWJlbENvbnRleHQiLCJSYWRpYWxMaW5lYXJTY2FsZSIsImxlZnRNb3ZlbWVudCIsInJpZ2h0TW92ZW1lbnQiLCJ0b3BNb3ZlbWVudCIsImJvdHRvbU1vdmVtZW50IiwiYW5nbGVNdWx0aXBsaWVyIiwic2NhbGluZ0ZhY3RvciIsImdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyIiwic2NhbGVkRGlzdGFuY2UiLCJwb2ludExhYmVsIiwiZGlzdGFuY2VGcm9tQ2VudGVyIiwiZ2V0QmFzZVBvc2l0aW9uIiwiZ2V0UG9pbnRMYWJlbFBvc2l0aW9uIiwicm90YXRlIiwiYW5pbWF0ZSIsIklOVEVSVkFMUyIsIm1pbGxpc2Vjb25kIiwiY29tbW9uIiwic3RlcHMiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwicXVhcnRlciIsInllYXIiLCJVTklUUyIsInNvcnRlciIsImlucHV0IiwiYWRhcHRlciIsIl9hZGFwdGVyIiwicGFyc2VyIiwiaXNvV2Vla2RheSIsIl9wYXJzZU9wdHMiLCJkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzIiwibWluVW5pdCIsImNhcGFjaXR5IiwiaW50ZXJ2YWwiLCJkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyIsImRldGVybWluZU1ham9yVW5pdCIsImFkZFRpY2siLCJ0aW1lIiwidGltZXN0YW1wcyIsInNldE1ham9yVGlja3MiLCJtYWpvclVuaXQiLCJ0aWNrc0Zyb21UaW1lc3RhbXBzIiwiVGltZVNjYWxlIiwiX3VuaXQiLCJfbWFqb3JVbml0IiwiX29mZnNldHMiLCJfbm9ybWFsaXplZCIsImRpc3BsYXlGb3JtYXRzIiwibm9ybWFsaXplZCIsIl9hcHBseUJvdW5kcyIsIl9nZXRMYWJlbEJvdW5kcyIsImdldExhYmVsVGltZXN0YW1wcyIsInRpbWVPcHRzIiwiX2dlbmVyYXRlIiwiX2dldExhYmVsQ2FwYWNpdHkiLCJpbml0T2Zmc2V0cyIsIm9mZnNldEFmdGVyQXV0b3NraXAiLCJnZXREZWNpbWFsRm9yVmFsdWUiLCJoYXNXZWVrZGF5IiwiZ2V0RGF0YVRpbWVzdGFtcHMiLCJ0b29sdGlwRm9ybWF0IiwiZGF0ZXRpbWUiLCJfdGlja0Zvcm1hdEZ1bmN0aW9uIiwibWlub3JGb3JtYXQiLCJtYWpvckZvcm1hdCIsImZvcm1hdHRlciIsIm9mZnNldHMiLCJfZ2V0TGFiZWxTaXplIiwidGlja3NPcHRzIiwidGlja0xhYmVsV2lkdGgiLCJjb3NSb3RhdGlvbiIsInNpblJvdGF0aW9uIiwidGlja0ZvbnRTaXplIiwiZXhhbXBsZVRpbWUiLCJleGFtcGxlTGFiZWwiLCJub3JtYWxpemUiLCJ0YWJsZSIsInByZXZTb3VyY2UiLCJuZXh0U291cmNlIiwicHJldlRhcmdldCIsIm5leHRUYXJnZXQiLCJzcGFuIiwiVGltZVNlcmllc1NjYWxlIiwiX3RhYmxlIiwiX21pblBvcyIsIl90YWJsZVJhbmdlIiwiX2dldFRpbWVzdGFtcHNGb3JUYWJsZSIsImJ1aWxkTG9va3VwVGFibGUiLCJyZWdpc3RlcmFibGVzIiwiX2FkYXB0ZXJzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chart.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.segment.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $: () => (/* binding */ _isPointInArea),\n/* harmony export */   A: () => (/* binding */ _factorize),\n/* harmony export */   B: () => (/* binding */ finiteOrDefault),\n/* harmony export */   C: () => (/* binding */ callback),\n/* harmony export */   D: () => (/* binding */ _addGrace),\n/* harmony export */   E: () => (/* binding */ _limitValue),\n/* harmony export */   F: () => (/* binding */ toDegrees),\n/* harmony export */   G: () => (/* binding */ _measureText),\n/* harmony export */   H: () => (/* binding */ HALF_PI),\n/* harmony export */   I: () => (/* binding */ _int16Range),\n/* harmony export */   J: () => (/* binding */ _alignPixel),\n/* harmony export */   K: () => (/* binding */ toPadding),\n/* harmony export */   L: () => (/* binding */ clipArea),\n/* harmony export */   M: () => (/* binding */ renderText),\n/* harmony export */   N: () => (/* binding */ unclipArea),\n/* harmony export */   O: () => (/* binding */ toFont),\n/* harmony export */   P: () => (/* binding */ PI),\n/* harmony export */   Q: () => (/* binding */ each),\n/* harmony export */   R: () => (/* binding */ _toLeftRightCenter),\n/* harmony export */   S: () => (/* binding */ _alignStartEnd),\n/* harmony export */   T: () => (/* binding */ TAU),\n/* harmony export */   U: () => (/* binding */ overrides),\n/* harmony export */   V: () => (/* binding */ merge),\n/* harmony export */   W: () => (/* binding */ _capitalize),\n/* harmony export */   X: () => (/* binding */ getRelativePosition),\n/* harmony export */   Y: () => (/* binding */ _rlookupByKey),\n/* harmony export */   Z: () => (/* binding */ _lookupByKey),\n/* harmony export */   _: () => (/* binding */ _arrayUnique),\n/* harmony export */   a: () => (/* binding */ resolve),\n/* harmony export */   a$: () => (/* binding */ toLineHeight),\n/* harmony export */   a0: () => (/* binding */ getAngleFromPoint),\n/* harmony export */   a1: () => (/* binding */ getMaximumSize),\n/* harmony export */   a2: () => (/* binding */ _getParentNode),\n/* harmony export */   a3: () => (/* binding */ readUsedSize),\n/* harmony export */   a4: () => (/* binding */ throttled),\n/* harmony export */   a5: () => (/* binding */ supportsEventListenerOptions),\n/* harmony export */   a6: () => (/* binding */ _isDomSupported),\n/* harmony export */   a7: () => (/* binding */ descriptors),\n/* harmony export */   a8: () => (/* binding */ isFunction),\n/* harmony export */   a9: () => (/* binding */ _attachContext),\n/* harmony export */   aA: () => (/* binding */ getRtlAdapter),\n/* harmony export */   aB: () => (/* binding */ overrideTextDirection),\n/* harmony export */   aC: () => (/* binding */ _textX),\n/* harmony export */   aD: () => (/* binding */ restoreTextDirection),\n/* harmony export */   aE: () => (/* binding */ drawPointLegend),\n/* harmony export */   aF: () => (/* binding */ noop),\n/* harmony export */   aG: () => (/* binding */ distanceBetweenPoints),\n/* harmony export */   aH: () => (/* binding */ _setMinAndMaxByKey),\n/* harmony export */   aI: () => (/* binding */ niceNum),\n/* harmony export */   aJ: () => (/* binding */ almostWhole),\n/* harmony export */   aK: () => (/* binding */ almostEquals),\n/* harmony export */   aL: () => (/* binding */ _decimalPlaces),\n/* harmony export */   aM: () => (/* binding */ _longestText),\n/* harmony export */   aN: () => (/* binding */ _filterBetween),\n/* harmony export */   aO: () => (/* binding */ _lookup),\n/* harmony export */   aP: () => (/* binding */ isPatternOrGradient),\n/* harmony export */   aQ: () => (/* binding */ getHoverColor),\n/* harmony export */   aR: () => (/* binding */ clone$1),\n/* harmony export */   aS: () => (/* binding */ _merger),\n/* harmony export */   aT: () => (/* binding */ _mergerIf),\n/* harmony export */   aU: () => (/* binding */ _deprecated),\n/* harmony export */   aV: () => (/* binding */ _splitKey),\n/* harmony export */   aW: () => (/* binding */ toFontString),\n/* harmony export */   aX: () => (/* binding */ splineCurve),\n/* harmony export */   aY: () => (/* binding */ splineCurveMonotone),\n/* harmony export */   aZ: () => (/* binding */ getStyle),\n/* harmony export */   a_: () => (/* binding */ fontString),\n/* harmony export */   aa: () => (/* binding */ _createResolver),\n/* harmony export */   ab: () => (/* binding */ _descriptors),\n/* harmony export */   ac: () => (/* binding */ mergeIf),\n/* harmony export */   ad: () => (/* binding */ uid),\n/* harmony export */   ae: () => (/* binding */ debounce),\n/* harmony export */   af: () => (/* binding */ retinaScale),\n/* harmony export */   ag: () => (/* binding */ clearCanvas),\n/* harmony export */   ah: () => (/* binding */ setsEqual),\n/* harmony export */   ai: () => (/* binding */ _elementsEqual),\n/* harmony export */   aj: () => (/* binding */ _isClickEvent),\n/* harmony export */   ak: () => (/* binding */ _isBetween),\n/* harmony export */   al: () => (/* binding */ _readValueToProps),\n/* harmony export */   am: () => (/* binding */ _updateBezierControlPoints),\n/* harmony export */   an: () => (/* binding */ _computeSegments),\n/* harmony export */   ao: () => (/* binding */ _boundSegments),\n/* harmony export */   ap: () => (/* binding */ _steppedInterpolation),\n/* harmony export */   aq: () => (/* binding */ _bezierInterpolation),\n/* harmony export */   ar: () => (/* binding */ _pointInLine),\n/* harmony export */   as: () => (/* binding */ _steppedLineTo),\n/* harmony export */   at: () => (/* binding */ _bezierCurveTo),\n/* harmony export */   au: () => (/* binding */ drawPoint),\n/* harmony export */   av: () => (/* binding */ addRoundedRectPath),\n/* harmony export */   aw: () => (/* binding */ toTRBL),\n/* harmony export */   ax: () => (/* binding */ toTRBLCorners),\n/* harmony export */   ay: () => (/* binding */ _boundSegment),\n/* harmony export */   az: () => (/* binding */ _normalizeAngle),\n/* harmony export */   b: () => (/* binding */ isArray),\n/* harmony export */   b0: () => (/* binding */ PITAU),\n/* harmony export */   b1: () => (/* binding */ INFINITY),\n/* harmony export */   b2: () => (/* binding */ RAD_PER_DEG),\n/* harmony export */   b3: () => (/* binding */ QUARTER_PI),\n/* harmony export */   b4: () => (/* binding */ TWO_THIRDS_PI),\n/* harmony export */   b5: () => (/* binding */ _angleDiff),\n/* harmony export */   c: () => (/* binding */ color),\n/* harmony export */   d: () => (/* binding */ defaults),\n/* harmony export */   e: () => (/* binding */ effects),\n/* harmony export */   f: () => (/* binding */ resolveObjectKey),\n/* harmony export */   g: () => (/* binding */ isNumberFinite),\n/* harmony export */   h: () => (/* binding */ createContext),\n/* harmony export */   i: () => (/* binding */ isObject),\n/* harmony export */   j: () => (/* binding */ defined),\n/* harmony export */   k: () => (/* binding */ isNullOrUndef),\n/* harmony export */   l: () => (/* binding */ listenArrayEvents),\n/* harmony export */   m: () => (/* binding */ toPercentage),\n/* harmony export */   n: () => (/* binding */ toDimension),\n/* harmony export */   o: () => (/* binding */ formatNumber),\n/* harmony export */   p: () => (/* binding */ _angleBetween),\n/* harmony export */   q: () => (/* binding */ _getStartAndCountOfVisiblePoints),\n/* harmony export */   r: () => (/* binding */ requestAnimFrame),\n/* harmony export */   s: () => (/* binding */ sign),\n/* harmony export */   t: () => (/* binding */ toRadians),\n/* harmony export */   u: () => (/* binding */ unlistenArrayEvents),\n/* harmony export */   v: () => (/* binding */ valueOrDefault),\n/* harmony export */   w: () => (/* binding */ _scaleRangesChanged),\n/* harmony export */   x: () => (/* binding */ isNumber),\n/* harmony export */   y: () => (/* binding */ _parseObjectDataRadialScale),\n/* harmony export */   z: () => (/* binding */ log10)\n/* harmony export */ });\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ function noop() {}\nconst uid = function() {\n    let id = 0;\n    return function() {\n        return id++;\n    };\n}();\nfunction isNullOrUndef(value) {\n    return value === null || typeof value === \"undefined\";\n}\nfunction isArray(value) {\n    if (Array.isArray && Array.isArray(value)) {\n        return true;\n    }\n    const type = Object.prototype.toString.call(value);\n    if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n        return true;\n    }\n    return false;\n}\nfunction isObject(value) {\n    return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\nconst isNumberFinite = (value)=>(typeof value === \"number\" || value instanceof Number) && isFinite(+value);\nfunction finiteOrDefault(value, defaultValue) {\n    return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n    return typeof value === \"undefined\" ? defaultValue : value;\n}\nconst toPercentage = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : value / dimension;\nconst toDimension = (value, dimension)=>typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\nfunction callback(fn, args, thisArg) {\n    if (fn && typeof fn.call === \"function\") {\n        return fn.apply(thisArg, args);\n    }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n    let i, len, keys;\n    if (isArray(loopable)) {\n        len = loopable.length;\n        if (reverse) {\n            for(i = len - 1; i >= 0; i--){\n                fn.call(thisArg, loopable[i], i);\n            }\n        } else {\n            for(i = 0; i < len; i++){\n                fn.call(thisArg, loopable[i], i);\n            }\n        }\n    } else if (isObject(loopable)) {\n        keys = Object.keys(loopable);\n        len = keys.length;\n        for(i = 0; i < len; i++){\n            fn.call(thisArg, loopable[keys[i]], keys[i]);\n        }\n    }\n}\nfunction _elementsEqual(a0, a1) {\n    let i, ilen, v0, v1;\n    if (!a0 || !a1 || a0.length !== a1.length) {\n        return false;\n    }\n    for(i = 0, ilen = a0.length; i < ilen; ++i){\n        v0 = a0[i];\n        v1 = a1[i];\n        if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction clone$1(source) {\n    if (isArray(source)) {\n        return source.map(clone$1);\n    }\n    if (isObject(source)) {\n        const target = Object.create(null);\n        const keys = Object.keys(source);\n        const klen = keys.length;\n        let k = 0;\n        for(; k < klen; ++k){\n            target[keys[k]] = clone$1(source[keys[k]]);\n        }\n        return target;\n    }\n    return source;\n}\nfunction isValidKey(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        merge(tval, sval, options);\n    } else {\n        target[key] = clone$1(sval);\n    }\n}\nfunction merge(target, source, options) {\n    const sources = isArray(source) ? source : [\n        source\n    ];\n    const ilen = sources.length;\n    if (!isObject(target)) {\n        return target;\n    }\n    options = options || {};\n    const merger = options.merger || _merger;\n    for(let i = 0; i < ilen; ++i){\n        source = sources[i];\n        if (!isObject(source)) {\n            continue;\n        }\n        const keys = Object.keys(source);\n        for(let k = 0, klen = keys.length; k < klen; ++k){\n            merger(keys[k], target, source, options);\n        }\n    }\n    return target;\n}\nfunction mergeIf(target, source) {\n    return merge(target, source, {\n        merger: _mergerIf\n    });\n}\nfunction _mergerIf(key, target, source) {\n    if (!isValidKey(key)) {\n        return;\n    }\n    const tval = target[key];\n    const sval = source[key];\n    if (isObject(tval) && isObject(sval)) {\n        mergeIf(tval, sval);\n    } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n        target[key] = clone$1(sval);\n    }\n}\nfunction _deprecated(scope, value, previous, current) {\n    if (value !== undefined) {\n        console.warn(scope + ': \"' + previous + '\" is deprecated. Please use \"' + current + '\" instead');\n    }\n}\nconst keyResolvers = {\n    \"\": (v)=>v,\n    x: (o)=>o.x,\n    y: (o)=>o.y\n};\nfunction resolveObjectKey(obj, key) {\n    const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n    return resolver(obj);\n}\nfunction _getKeyResolver(key) {\n    const keys = _splitKey(key);\n    return (obj)=>{\n        for (const k of keys){\n            if (k === \"\") {\n                break;\n            }\n            obj = obj && obj[k];\n        }\n        return obj;\n    };\n}\nfunction _splitKey(key) {\n    const parts = key.split(\".\");\n    const keys = [];\n    let tmp = \"\";\n    for (const part of parts){\n        tmp += part;\n        if (tmp.endsWith(\"\\\\\")) {\n            tmp = tmp.slice(0, -1) + \".\";\n        } else {\n            keys.push(tmp);\n            tmp = \"\";\n        }\n    }\n    return keys;\n}\nfunction _capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nconst defined = (value)=>typeof value !== \"undefined\";\nconst isFunction = (value)=>typeof value === \"function\";\nconst setsEqual = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a){\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n};\nfunction _isClickEvent(e) {\n    return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\nconst PI = Math.PI;\nconst TAU = 2 * PI;\nconst PITAU = TAU + PI;\nconst INFINITY = Number.POSITIVE_INFINITY;\nconst RAD_PER_DEG = PI / 180;\nconst HALF_PI = PI / 2;\nconst QUARTER_PI = PI / 4;\nconst TWO_THIRDS_PI = PI * 2 / 3;\nconst log10 = Math.log10;\nconst sign = Math.sign;\nfunction niceNum(range) {\n    const roundedRange = Math.round(range);\n    range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n    const niceRange = Math.pow(10, Math.floor(log10(range)));\n    const fraction = range / niceRange;\n    const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n    return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n    const result = [];\n    const sqrt = Math.sqrt(value);\n    let i;\n    for(i = 1; i < sqrt; i++){\n        if (value % i === 0) {\n            result.push(i);\n            result.push(value / i);\n        }\n    }\n    if (sqrt === (sqrt | 0)) {\n        result.push(sqrt);\n    }\n    result.sort((a, b)=>a - b).pop();\n    return result;\n}\nfunction isNumber(n) {\n    return !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostEquals(x, y, epsilon) {\n    return Math.abs(x - y) < epsilon;\n}\nfunction almostWhole(x, epsilon) {\n    const rounded = Math.round(x);\n    return rounded - epsilon <= x && rounded + epsilon >= x;\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n    let i, ilen, value;\n    for(i = 0, ilen = array.length; i < ilen; i++){\n        value = array[i][property];\n        if (!isNaN(value)) {\n            target.min = Math.min(target.min, value);\n            target.max = Math.max(target.max, value);\n        }\n    }\n}\nfunction toRadians(degrees) {\n    return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n    return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n    if (!isNumberFinite(x)) {\n        return;\n    }\n    let e = 1;\n    let p = 0;\n    while(Math.round(x * e) / e !== x){\n        e *= 10;\n        p++;\n    }\n    return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n    const distanceFromXCenter = anglePoint.x - centrePoint.x;\n    const distanceFromYCenter = anglePoint.y - centrePoint.y;\n    const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n    let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n    if (angle < -0.5 * PI) {\n        angle += TAU;\n    }\n    return {\n        angle,\n        distance: radialDistanceFromCenter\n    };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n    return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n    return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n    const a = _normalizeAngle(angle);\n    const s = _normalizeAngle(start);\n    const e = _normalizeAngle(end);\n    const angleToStart = _normalizeAngle(s - a);\n    const angleToEnd = _normalizeAngle(e - a);\n    const startToAngle = _normalizeAngle(a - s);\n    const endToAngle = _normalizeAngle(a - e);\n    return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\nfunction _limitValue(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n    return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n    return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n    cmp = cmp || ((index)=>table[index] < value);\n    let hi = table.length - 1;\n    let lo = 0;\n    let mid;\n    while(hi - lo > 1){\n        mid = lo + hi >> 1;\n        if (cmp(mid)) {\n            lo = mid;\n        } else {\n            hi = mid;\n        }\n    }\n    return {\n        lo,\n        hi\n    };\n}\nconst _lookupByKey = (table, key, value, last)=>_lookup(table, value, last ? (index)=>table[index][key] <= value : (index)=>table[index][key] < value);\nconst _rlookupByKey = (table, key, value)=>_lookup(table, value, (index)=>table[index][key] >= value);\nfunction _filterBetween(values, min, max) {\n    let start = 0;\n    let end = values.length;\n    while(start < end && values[start] < min){\n        start++;\n    }\n    while(end > start && values[end - 1] > max){\n        end--;\n    }\n    return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nconst arrayEvents = [\n    \"push\",\n    \"pop\",\n    \"shift\",\n    \"splice\",\n    \"unshift\"\n];\nfunction listenArrayEvents(array, listener) {\n    if (array._chartjs) {\n        array._chartjs.listeners.push(listener);\n        return;\n    }\n    Object.defineProperty(array, \"_chartjs\", {\n        configurable: true,\n        enumerable: false,\n        value: {\n            listeners: [\n                listener\n            ]\n        }\n    });\n    arrayEvents.forEach((key)=>{\n        const method = \"_onData\" + _capitalize(key);\n        const base = array[key];\n        Object.defineProperty(array, key, {\n            configurable: true,\n            enumerable: false,\n            value (...args) {\n                const res = base.apply(this, args);\n                array._chartjs.listeners.forEach((object)=>{\n                    if (typeof object[method] === \"function\") {\n                        object[method](...args);\n                    }\n                });\n                return res;\n            }\n        });\n    });\n}\nfunction unlistenArrayEvents(array, listener) {\n    const stub = array._chartjs;\n    if (!stub) {\n        return;\n    }\n    const listeners = stub.listeners;\n    const index = listeners.indexOf(listener);\n    if (index !== -1) {\n        listeners.splice(index, 1);\n    }\n    if (listeners.length > 0) {\n        return;\n    }\n    arrayEvents.forEach((key)=>{\n        delete array[key];\n    });\n    delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n    const set = new Set();\n    let i, ilen;\n    for(i = 0, ilen = items.length; i < ilen; ++i){\n        set.add(items[i]);\n    }\n    if (set.size === ilen) {\n        return items;\n    }\n    return Array.from(set);\n}\nfunction fontString(pixelSize, fontStyle, fontFamily) {\n    return fontStyle + \" \" + pixelSize + \"px \" + fontFamily;\n}\nconst requestAnimFrame = function() {\n    if (true) {\n        return function(callback) {\n            return callback();\n        };\n    }\n    return window.requestAnimationFrame;\n}();\nfunction throttled(fn, thisArg, updateFn) {\n    const updateArgs = updateFn || ((args)=>Array.prototype.slice.call(args));\n    let ticking = false;\n    let args = [];\n    return function(...rest) {\n        args = updateArgs(rest);\n        if (!ticking) {\n            ticking = true;\n            requestAnimFrame.call(window, ()=>{\n                ticking = false;\n                fn.apply(thisArg, args);\n            });\n        }\n    };\n}\nfunction debounce(fn, delay) {\n    let timeout;\n    return function(...args) {\n        if (delay) {\n            clearTimeout(timeout);\n            timeout = setTimeout(fn, delay, args);\n        } else {\n            fn.apply(this, args);\n        }\n        return delay;\n    };\n}\nconst _toLeftRightCenter = (align)=>align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\nconst _alignStartEnd = (align, start, end)=>align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\nconst _textX = (align, left, right, rtl)=>{\n    const check = rtl ? \"left\" : \"right\";\n    return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n    const pointCount = points.length;\n    let start = 0;\n    let count = pointCount;\n    if (meta._sorted) {\n        const { iScale, _parsed } = meta;\n        const axis = iScale.axis;\n        const { min, max, minDefined, maxDefined } = iScale.getUserBounds();\n        if (minDefined) {\n            start = _limitValue(Math.min(_lookupByKey(_parsed, iScale.axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);\n        }\n        if (maxDefined) {\n            count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start;\n        } else {\n            count = pointCount - start;\n        }\n    }\n    return {\n        start,\n        count\n    };\n}\nfunction _scaleRangesChanged(meta) {\n    const { xScale, yScale, _scaleRanges } = meta;\n    const newRanges = {\n        xmin: xScale.min,\n        xmax: xScale.max,\n        ymin: yScale.min,\n        ymax: yScale.max\n    };\n    if (!_scaleRanges) {\n        meta._scaleRanges = newRanges;\n        return true;\n    }\n    const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n    Object.assign(_scaleRanges, newRanges);\n    return changed;\n}\nconst atEdge = (t)=>t === 0 || t === 1;\nconst elasticIn = (t, s, p)=>-(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t, s, p)=>Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nconst effects = {\n    linear: (t)=>t,\n    easeInQuad: (t)=>t * t,\n    easeOutQuad: (t)=>-t * (t - 2),\n    easeInOutQuad: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n    easeInCubic: (t)=>t * t * t,\n    easeOutCubic: (t)=>(t -= 1) * t * t + 1,\n    easeInOutCubic: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n    easeInQuart: (t)=>t * t * t * t,\n    easeOutQuart: (t)=>-((t -= 1) * t * t * t - 1),\n    easeInOutQuart: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n    easeInQuint: (t)=>t * t * t * t * t,\n    easeOutQuint: (t)=>(t -= 1) * t * t * t * t + 1,\n    easeInOutQuint: (t)=>(t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n    easeInSine: (t)=>-Math.cos(t * HALF_PI) + 1,\n    easeOutSine: (t)=>Math.sin(t * HALF_PI),\n    easeInOutSine: (t)=>-0.5 * (Math.cos(PI * t) - 1),\n    easeInExpo: (t)=>t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n    easeOutExpo: (t)=>t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n    easeInOutExpo: (t)=>atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n    easeInCirc: (t)=>t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n    easeOutCirc: (t)=>Math.sqrt(1 - (t -= 1) * t),\n    easeInOutCirc: (t)=>(t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n    easeInElastic: (t)=>atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n    easeOutElastic: (t)=>atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n    easeInOutElastic (t) {\n        const s = 0.1125;\n        const p = 0.45;\n        return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n    },\n    easeInBack (t) {\n        const s = 1.70158;\n        return t * t * ((s + 1) * t - s);\n    },\n    easeOutBack (t) {\n        const s = 1.70158;\n        return (t -= 1) * t * ((s + 1) * t + s) + 1;\n    },\n    easeInOutBack (t) {\n        let s = 1.70158;\n        if ((t /= 0.5) < 1) {\n            return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n        }\n        return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n    },\n    easeInBounce: (t)=>1 - effects.easeOutBounce(1 - t),\n    easeOutBounce (t) {\n        const m = 7.5625;\n        const d = 2.75;\n        if (t < 1 / d) {\n            return m * t * t;\n        }\n        if (t < 2 / d) {\n            return m * (t -= 1.5 / d) * t + 0.75;\n        }\n        if (t < 2.5 / d) {\n            return m * (t -= 2.25 / d) * t + 0.9375;\n        }\n        return m * (t -= 2.625 / d) * t + 0.984375;\n    },\n    easeInOutBounce: (t)=>t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\n/*!\n * @kurkle/color v0.2.1\n * https://github.com/kurkle/color#readme\n * (c) 2022 Jukka Kurkela\n * Released under the MIT License\n */ function round(v) {\n    return v + 0.5 | 0;\n}\nconst lim = (v, l, h)=>Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n    return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n    return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n    return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n    return lim(round(v * 100), 0, 100);\n}\nconst map$1 = {\n    0: 0,\n    1: 1,\n    2: 2,\n    3: 3,\n    4: 4,\n    5: 5,\n    6: 6,\n    7: 7,\n    8: 8,\n    9: 9,\n    A: 10,\n    B: 11,\n    C: 12,\n    D: 13,\n    E: 14,\n    F: 15,\n    a: 10,\n    b: 11,\n    c: 12,\n    d: 13,\n    e: 14,\n    f: 15\n};\nconst hex = [\n    ...\"0123456789ABCDEF\"\n];\nconst h1 = (b)=>hex[b & 0xF];\nconst h2 = (b)=>hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = (b)=>(b & 0xF0) >> 4 === (b & 0xF);\nconst isShort = (v)=>eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n    var len = str.length;\n    var ret;\n    if (str[0] === \"#\") {\n        if (len === 4 || len === 5) {\n            ret = {\n                r: 255 & map$1[str[1]] * 17,\n                g: 255 & map$1[str[2]] * 17,\n                b: 255 & map$1[str[3]] * 17,\n                a: len === 5 ? map$1[str[4]] * 17 : 255\n            };\n        } else if (len === 7 || len === 9) {\n            ret = {\n                r: map$1[str[1]] << 4 | map$1[str[2]],\n                g: map$1[str[3]] << 4 | map$1[str[4]],\n                b: map$1[str[5]] << 4 | map$1[str[6]],\n                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255\n            };\n        }\n    }\n    return ret;\n}\nconst alpha = (a, f)=>a < 255 ? f(a) : \"\";\nfunction hexString(v) {\n    var f = isShort(v) ? h1 : h2;\n    return v ? \"#\" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;\n}\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n    const a = s * Math.min(l, 1 - l);\n    const f = (n, k = (n + h / 30) % 12)=>l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return [\n        f(0),\n        f(8),\n        f(4)\n    ];\n}\nfunction hsv2rgbn(h, s, v) {\n    const f = (n, k = (n + h / 60) % 6)=>v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n    return [\n        f(5),\n        f(3),\n        f(1)\n    ];\n}\nfunction hwb2rgbn(h, w, b) {\n    const rgb = hsl2rgbn(h, 1, 0.5);\n    let i;\n    if (w + b > 1) {\n        i = 1 / (w + b);\n        w *= i;\n        b *= i;\n    }\n    for(i = 0; i < 3; i++){\n        rgb[i] *= 1 - w - b;\n        rgb[i] += w;\n    }\n    return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n    if (r === max) {\n        return (g - b) / d + (g < b ? 6 : 0);\n    }\n    if (g === max) {\n        return (b - r) / d + 2;\n    }\n    return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n    const range = 255;\n    const r = v.r / range;\n    const g = v.g / range;\n    const b = v.b / range;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const l = (max + min) / 2;\n    let h, s, d;\n    if (max !== min) {\n        d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        h = hueValue(r, g, b, d, max);\n        h = h * 60 + 0.5;\n    }\n    return [\n        h | 0,\n        s || 0,\n        l\n    ];\n}\nfunction calln(f, a, b, c) {\n    return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n    return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n    return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n    return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n    return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n    const m = HUE_RE.exec(str);\n    let a = 255;\n    let v;\n    if (!m) {\n        return;\n    }\n    if (m[5] !== v) {\n        a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n    }\n    const h = hue(+m[2]);\n    const p1 = +m[3] / 100;\n    const p2 = +m[4] / 100;\n    if (m[1] === \"hwb\") {\n        v = hwb2rgb(h, p1, p2);\n    } else if (m[1] === \"hsv\") {\n        v = hsv2rgb(h, p1, p2);\n    } else {\n        v = hsl2rgb(h, p1, p2);\n    }\n    return {\n        r: v[0],\n        g: v[1],\n        b: v[2],\n        a: a\n    };\n}\nfunction rotate(v, deg) {\n    var h = rgb2hsl(v);\n    h[0] = hue(h[0] + deg);\n    h = hsl2rgb(h);\n    v.r = h[0];\n    v.g = h[1];\n    v.b = h[2];\n}\nfunction hslString(v) {\n    if (!v) {\n        return;\n    }\n    const a = rgb2hsl(v);\n    const h = a[0];\n    const s = n2p(a[1]);\n    const l = n2p(a[2]);\n    return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;\n}\nconst map = {\n    x: \"dark\",\n    Z: \"light\",\n    Y: \"re\",\n    X: \"blu\",\n    W: \"gr\",\n    V: \"medium\",\n    U: \"slate\",\n    A: \"ee\",\n    T: \"ol\",\n    S: \"or\",\n    B: \"ra\",\n    C: \"lateg\",\n    D: \"ights\",\n    R: \"in\",\n    Q: \"turquois\",\n    E: \"hi\",\n    P: \"ro\",\n    O: \"al\",\n    N: \"le\",\n    M: \"de\",\n    L: \"yello\",\n    F: \"en\",\n    K: \"ch\",\n    G: \"arks\",\n    H: \"ea\",\n    I: \"ightg\",\n    J: \"wh\"\n};\nconst names$1 = {\n    OiceXe: \"f0f8ff\",\n    antiquewEte: \"faebd7\",\n    aqua: \"ffff\",\n    aquamarRe: \"7fffd4\",\n    azuY: \"f0ffff\",\n    beige: \"f5f5dc\",\n    bisque: \"ffe4c4\",\n    black: \"0\",\n    blanKedOmond: \"ffebcd\",\n    Xe: \"ff\",\n    XeviTet: \"8a2be2\",\n    bPwn: \"a52a2a\",\n    burlywood: \"deb887\",\n    caMtXe: \"5f9ea0\",\n    KartYuse: \"7fff00\",\n    KocTate: \"d2691e\",\n    cSO: \"ff7f50\",\n    cSnflowerXe: \"6495ed\",\n    cSnsilk: \"fff8dc\",\n    crimson: \"dc143c\",\n    cyan: \"ffff\",\n    xXe: \"8b\",\n    xcyan: \"8b8b\",\n    xgTMnPd: \"b8860b\",\n    xWay: \"a9a9a9\",\n    xgYF: \"6400\",\n    xgYy: \"a9a9a9\",\n    xkhaki: \"bdb76b\",\n    xmagFta: \"8b008b\",\n    xTivegYF: \"556b2f\",\n    xSange: \"ff8c00\",\n    xScEd: \"9932cc\",\n    xYd: \"8b0000\",\n    xsOmon: \"e9967a\",\n    xsHgYF: \"8fbc8f\",\n    xUXe: \"483d8b\",\n    xUWay: \"2f4f4f\",\n    xUgYy: \"2f4f4f\",\n    xQe: \"ced1\",\n    xviTet: \"9400d3\",\n    dAppRk: \"ff1493\",\n    dApskyXe: \"bfff\",\n    dimWay: \"696969\",\n    dimgYy: \"696969\",\n    dodgerXe: \"1e90ff\",\n    fiYbrick: \"b22222\",\n    flSOwEte: \"fffaf0\",\n    foYstWAn: \"228b22\",\n    fuKsia: \"ff00ff\",\n    gaRsbSo: \"dcdcdc\",\n    ghostwEte: \"f8f8ff\",\n    gTd: \"ffd700\",\n    gTMnPd: \"daa520\",\n    Way: \"808080\",\n    gYF: \"8000\",\n    gYFLw: \"adff2f\",\n    gYy: \"808080\",\n    honeyMw: \"f0fff0\",\n    hotpRk: \"ff69b4\",\n    RdianYd: \"cd5c5c\",\n    Rdigo: \"4b0082\",\n    ivSy: \"fffff0\",\n    khaki: \"f0e68c\",\n    lavFMr: \"e6e6fa\",\n    lavFMrXsh: \"fff0f5\",\n    lawngYF: \"7cfc00\",\n    NmoncEffon: \"fffacd\",\n    ZXe: \"add8e6\",\n    ZcSO: \"f08080\",\n    Zcyan: \"e0ffff\",\n    ZgTMnPdLw: \"fafad2\",\n    ZWay: \"d3d3d3\",\n    ZgYF: \"90ee90\",\n    ZgYy: \"d3d3d3\",\n    ZpRk: \"ffb6c1\",\n    ZsOmon: \"ffa07a\",\n    ZsHgYF: \"20b2aa\",\n    ZskyXe: \"87cefa\",\n    ZUWay: \"778899\",\n    ZUgYy: \"778899\",\n    ZstAlXe: \"b0c4de\",\n    ZLw: \"ffffe0\",\n    lime: \"ff00\",\n    limegYF: \"32cd32\",\n    lRF: \"faf0e6\",\n    magFta: \"ff00ff\",\n    maPon: \"800000\",\n    VaquamarRe: \"66cdaa\",\n    VXe: \"cd\",\n    VScEd: \"ba55d3\",\n    VpurpN: \"9370db\",\n    VsHgYF: \"3cb371\",\n    VUXe: \"7b68ee\",\n    VsprRggYF: \"fa9a\",\n    VQe: \"48d1cc\",\n    VviTetYd: \"c71585\",\n    midnightXe: \"191970\",\n    mRtcYam: \"f5fffa\",\n    mistyPse: \"ffe4e1\",\n    moccasR: \"ffe4b5\",\n    navajowEte: \"ffdead\",\n    navy: \"80\",\n    Tdlace: \"fdf5e6\",\n    Tive: \"808000\",\n    TivedBb: \"6b8e23\",\n    Sange: \"ffa500\",\n    SangeYd: \"ff4500\",\n    ScEd: \"da70d6\",\n    pOegTMnPd: \"eee8aa\",\n    pOegYF: \"98fb98\",\n    pOeQe: \"afeeee\",\n    pOeviTetYd: \"db7093\",\n    papayawEp: \"ffefd5\",\n    pHKpuff: \"ffdab9\",\n    peru: \"cd853f\",\n    pRk: \"ffc0cb\",\n    plum: \"dda0dd\",\n    powMrXe: \"b0e0e6\",\n    purpN: \"800080\",\n    YbeccapurpN: \"663399\",\n    Yd: \"ff0000\",\n    Psybrown: \"bc8f8f\",\n    PyOXe: \"4169e1\",\n    saddNbPwn: \"8b4513\",\n    sOmon: \"fa8072\",\n    sandybPwn: \"f4a460\",\n    sHgYF: \"2e8b57\",\n    sHshell: \"fff5ee\",\n    siFna: \"a0522d\",\n    silver: \"c0c0c0\",\n    skyXe: \"87ceeb\",\n    UXe: \"6a5acd\",\n    UWay: \"708090\",\n    UgYy: \"708090\",\n    snow: \"fffafa\",\n    sprRggYF: \"ff7f\",\n    stAlXe: \"4682b4\",\n    tan: \"d2b48c\",\n    teO: \"8080\",\n    tEstN: \"d8bfd8\",\n    tomato: \"ff6347\",\n    Qe: \"40e0d0\",\n    viTet: \"ee82ee\",\n    JHt: \"f5deb3\",\n    wEte: \"ffffff\",\n    wEtesmoke: \"f5f5f5\",\n    Lw: \"ffff00\",\n    LwgYF: \"9acd32\"\n};\nfunction unpack() {\n    const unpacked = {};\n    const keys = Object.keys(names$1);\n    const tkeys = Object.keys(map);\n    let i, j, k, ok, nk;\n    for(i = 0; i < keys.length; i++){\n        ok = nk = keys[i];\n        for(j = 0; j < tkeys.length; j++){\n            k = tkeys[j];\n            nk = nk.replace(k, map[k]);\n        }\n        k = parseInt(names$1[ok], 16);\n        unpacked[nk] = [\n            k >> 16 & 0xFF,\n            k >> 8 & 0xFF,\n            k & 0xFF\n        ];\n    }\n    return unpacked;\n}\nlet names;\nfunction nameParse(str) {\n    if (!names) {\n        names = unpack();\n        names.transparent = [\n            0,\n            0,\n            0,\n            0\n        ];\n    }\n    const a = names[str.toLowerCase()];\n    return a && {\n        r: a[0],\n        g: a[1],\n        b: a[2],\n        a: a.length === 4 ? a[3] : 255\n    };\n}\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n    const m = RGB_RE.exec(str);\n    let a = 255;\n    let r, g, b;\n    if (!m) {\n        return;\n    }\n    if (m[7] !== r) {\n        const v = +m[7];\n        a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n    }\n    r = +m[1];\n    g = +m[3];\n    b = +m[5];\n    r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n    g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n    b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n    return {\n        r: r,\n        g: g,\n        b: b,\n        a: a\n    };\n}\nfunction rgbString(v) {\n    return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);\n}\nconst to = (v)=>v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = (v)=>v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n    const r = from(b2n(rgb1.r));\n    const g = from(b2n(rgb1.g));\n    const b = from(b2n(rgb1.b));\n    return {\n        r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n        g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n        b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n        a: rgb1.a + t * (rgb2.a - rgb1.a)\n    };\n}\nfunction modHSL(v, i, ratio) {\n    if (v) {\n        let tmp = rgb2hsl(v);\n        tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n        tmp = hsl2rgb(tmp);\n        v.r = tmp[0];\n        v.g = tmp[1];\n        v.b = tmp[2];\n    }\n}\nfunction clone(v, proto) {\n    return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n    var v = {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 255\n    };\n    if (Array.isArray(input)) {\n        if (input.length >= 3) {\n            v = {\n                r: input[0],\n                g: input[1],\n                b: input[2],\n                a: 255\n            };\n            if (input.length > 3) {\n                v.a = n2b(input[3]);\n            }\n        }\n    } else {\n        v = clone(input, {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1\n        });\n        v.a = n2b(v.a);\n    }\n    return v;\n}\nfunction functionParse(str) {\n    if (str.charAt(0) === \"r\") {\n        return rgbParse(str);\n    }\n    return hueParse(str);\n}\nclass Color {\n    constructor(input){\n        if (input instanceof Color) {\n            return input;\n        }\n        const type = typeof input;\n        let v;\n        if (type === \"object\") {\n            v = fromObject(input);\n        } else if (type === \"string\") {\n            v = hexParse(input) || nameParse(input) || functionParse(input);\n        }\n        this._rgb = v;\n        this._valid = !!v;\n    }\n    get valid() {\n        return this._valid;\n    }\n    get rgb() {\n        var v = clone(this._rgb);\n        if (v) {\n            v.a = b2n(v.a);\n        }\n        return v;\n    }\n    set rgb(obj) {\n        this._rgb = fromObject(obj);\n    }\n    rgbString() {\n        return this._valid ? rgbString(this._rgb) : undefined;\n    }\n    hexString() {\n        return this._valid ? hexString(this._rgb) : undefined;\n    }\n    hslString() {\n        return this._valid ? hslString(this._rgb) : undefined;\n    }\n    mix(color, weight) {\n        if (color) {\n            const c1 = this.rgb;\n            const c2 = color.rgb;\n            let w2;\n            const p = weight === w2 ? 0.5 : weight;\n            const w = 2 * p - 1;\n            const a = c1.a - c2.a;\n            const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n            w2 = 1 - w1;\n            c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n            c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n            c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n            c1.a = p * c1.a + (1 - p) * c2.a;\n            this.rgb = c1;\n        }\n        return this;\n    }\n    interpolate(color, t) {\n        if (color) {\n            this._rgb = interpolate(this._rgb, color._rgb, t);\n        }\n        return this;\n    }\n    clone() {\n        return new Color(this.rgb);\n    }\n    alpha(a) {\n        this._rgb.a = n2b(a);\n        return this;\n    }\n    clearer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 - ratio;\n        return this;\n    }\n    greyscale() {\n        const rgb = this._rgb;\n        const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n        rgb.r = rgb.g = rgb.b = val;\n        return this;\n    }\n    opaquer(ratio) {\n        const rgb = this._rgb;\n        rgb.a *= 1 + ratio;\n        return this;\n    }\n    negate() {\n        const v = this._rgb;\n        v.r = 255 - v.r;\n        v.g = 255 - v.g;\n        v.b = 255 - v.b;\n        return this;\n    }\n    lighten(ratio) {\n        modHSL(this._rgb, 2, ratio);\n        return this;\n    }\n    darken(ratio) {\n        modHSL(this._rgb, 2, -ratio);\n        return this;\n    }\n    saturate(ratio) {\n        modHSL(this._rgb, 1, ratio);\n        return this;\n    }\n    desaturate(ratio) {\n        modHSL(this._rgb, 1, -ratio);\n        return this;\n    }\n    rotate(deg) {\n        rotate(this._rgb, deg);\n        return this;\n    }\n}\nfunction index_esm(input) {\n    return new Color(input);\n}\nfunction isPatternOrGradient(value) {\n    if (value && typeof value === \"object\") {\n        const type = value.toString();\n        return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n    }\n    return false;\n}\nfunction color(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value);\n}\nfunction getHoverColor(value) {\n    return isPatternOrGradient(value) ? value : index_esm(value).saturate(0.5).darken(0.1).hexString();\n}\nconst overrides = Object.create(null);\nconst descriptors = Object.create(null);\nfunction getScope$1(node, key) {\n    if (!key) {\n        return node;\n    }\n    const keys = key.split(\".\");\n    for(let i = 0, n = keys.length; i < n; ++i){\n        const k = keys[i];\n        node = node[k] || (node[k] = Object.create(null));\n    }\n    return node;\n}\nfunction set(root, scope, values) {\n    if (typeof scope === \"string\") {\n        return merge(getScope$1(root, scope), values);\n    }\n    return merge(getScope$1(root, \"\"), scope);\n}\nclass Defaults {\n    constructor(_descriptors){\n        this.animation = undefined;\n        this.backgroundColor = \"rgba(0,0,0,0.1)\";\n        this.borderColor = \"rgba(0,0,0,0.1)\";\n        this.color = \"#666\";\n        this.datasets = {};\n        this.devicePixelRatio = (context)=>context.chart.platform.getDevicePixelRatio();\n        this.elements = {};\n        this.events = [\n            \"mousemove\",\n            \"mouseout\",\n            \"click\",\n            \"touchstart\",\n            \"touchmove\"\n        ];\n        this.font = {\n            family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n            size: 12,\n            style: \"normal\",\n            lineHeight: 1.2,\n            weight: null\n        };\n        this.hover = {};\n        this.hoverBackgroundColor = (ctx, options)=>getHoverColor(options.backgroundColor);\n        this.hoverBorderColor = (ctx, options)=>getHoverColor(options.borderColor);\n        this.hoverColor = (ctx, options)=>getHoverColor(options.color);\n        this.indexAxis = \"x\";\n        this.interaction = {\n            mode: \"nearest\",\n            intersect: true,\n            includeInvisible: false\n        };\n        this.maintainAspectRatio = true;\n        this.onHover = null;\n        this.onClick = null;\n        this.parsing = true;\n        this.plugins = {};\n        this.responsive = true;\n        this.scale = undefined;\n        this.scales = {};\n        this.showLine = true;\n        this.drawActiveElementsOnTop = true;\n        this.describe(_descriptors);\n    }\n    set(scope, values) {\n        return set(this, scope, values);\n    }\n    get(scope) {\n        return getScope$1(this, scope);\n    }\n    describe(scope, values) {\n        return set(descriptors, scope, values);\n    }\n    override(scope, values) {\n        return set(overrides, scope, values);\n    }\n    route(scope, name, targetScope, targetName) {\n        const scopeObject = getScope$1(this, scope);\n        const targetScopeObject = getScope$1(this, targetScope);\n        const privateName = \"_\" + name;\n        Object.defineProperties(scopeObject, {\n            [privateName]: {\n                value: scopeObject[name],\n                writable: true\n            },\n            [name]: {\n                enumerable: true,\n                get () {\n                    const local = this[privateName];\n                    const target = targetScopeObject[targetName];\n                    if (isObject(local)) {\n                        return Object.assign({}, target, local);\n                    }\n                    return valueOrDefault(local, target);\n                },\n                set (value) {\n                    this[privateName] = value;\n                }\n            }\n        });\n    }\n}\nvar defaults = new Defaults({\n    _scriptable: (name)=>!name.startsWith(\"on\"),\n    _indexable: (name)=>name !== \"events\",\n    hover: {\n        _fallback: \"interaction\"\n    },\n    interaction: {\n        _scriptable: false,\n        _indexable: false\n    }\n});\nfunction toFontString(font) {\n    if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n        return null;\n    }\n    return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n    let textWidth = data[string];\n    if (!textWidth) {\n        textWidth = data[string] = ctx.measureText(string).width;\n        gc.push(string);\n    }\n    if (textWidth > longest) {\n        longest = textWidth;\n    }\n    return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n    cache = cache || {};\n    let data = cache.data = cache.data || {};\n    let gc = cache.garbageCollect = cache.garbageCollect || [];\n    if (cache.font !== font) {\n        data = cache.data = {};\n        gc = cache.garbageCollect = [];\n        cache.font = font;\n    }\n    ctx.save();\n    ctx.font = font;\n    let longest = 0;\n    const ilen = arrayOfThings.length;\n    let i, j, jlen, thing, nestedThing;\n    for(i = 0; i < ilen; i++){\n        thing = arrayOfThings[i];\n        if (thing !== undefined && thing !== null && isArray(thing) !== true) {\n            longest = _measureText(ctx, data, gc, longest, thing);\n        } else if (isArray(thing)) {\n            for(j = 0, jlen = thing.length; j < jlen; j++){\n                nestedThing = thing[j];\n                if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n                    longest = _measureText(ctx, data, gc, longest, nestedThing);\n                }\n            }\n        }\n    }\n    ctx.restore();\n    const gcLen = gc.length / 2;\n    if (gcLen > arrayOfThings.length) {\n        for(i = 0; i < gcLen; i++){\n            delete data[gc[i]];\n        }\n        gc.splice(0, gcLen);\n    }\n    return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n    const devicePixelRatio = chart.currentDevicePixelRatio;\n    const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n    ctx = ctx || canvas.getContext(\"2d\");\n    ctx.save();\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n    drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n    let type, xOffset, yOffset, size, cornerRadius, width;\n    const style = options.pointStyle;\n    const rotation = options.rotation;\n    const radius = options.radius;\n    let rad = (rotation || 0) * RAD_PER_DEG;\n    if (style && typeof style === \"object\") {\n        type = style.toString();\n        if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n            ctx.save();\n            ctx.translate(x, y);\n            ctx.rotate(rad);\n            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n            ctx.restore();\n            return;\n        }\n    }\n    if (isNaN(radius) || radius <= 0) {\n        return;\n    }\n    ctx.beginPath();\n    switch(style){\n        default:\n            if (w) {\n                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n            } else {\n                ctx.arc(x, y, radius, 0, TAU);\n            }\n            ctx.closePath();\n            break;\n        case \"triangle\":\n            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            rad += TWO_THIRDS_PI;\n            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);\n            ctx.closePath();\n            break;\n        case \"rectRounded\":\n            cornerRadius = radius * 0.516;\n            size = radius - cornerRadius;\n            xOffset = Math.cos(rad + QUARTER_PI) * size;\n            yOffset = Math.sin(rad + QUARTER_PI) * size;\n            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n            ctx.closePath();\n            break;\n        case \"rect\":\n            if (!rotation) {\n                size = Math.SQRT1_2 * radius;\n                width = w ? w / 2 : size;\n                ctx.rect(x - width, y - size, 2 * width, 2 * size);\n                break;\n            }\n            rad += QUARTER_PI;\n        case \"rectRot\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            ctx.closePath();\n            break;\n        case \"crossRot\":\n            rad += QUARTER_PI;\n        case \"cross\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"star\":\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            rad += QUARTER_PI;\n            xOffset = Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            ctx.moveTo(x + yOffset, y - xOffset);\n            ctx.lineTo(x - yOffset, y + xOffset);\n            break;\n        case \"line\":\n            xOffset = w ? w / 2 : Math.cos(rad) * radius;\n            yOffset = Math.sin(rad) * radius;\n            ctx.moveTo(x - xOffset, y - yOffset);\n            ctx.lineTo(x + xOffset, y + yOffset);\n            break;\n        case \"dash\":\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);\n            break;\n    }\n    ctx.fill();\n    if (options.borderWidth > 0) {\n        ctx.stroke();\n    }\n}\nfunction _isPointInArea(point, area, margin) {\n    margin = margin || 0.5;\n    return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n    ctx.save();\n    ctx.beginPath();\n    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n    ctx.clip();\n}\nfunction unclipArea(ctx) {\n    ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    if (mode === \"middle\") {\n        const midpoint = (previous.x + target.x) / 2.0;\n        ctx.lineTo(midpoint, previous.y);\n        ctx.lineTo(midpoint, target.y);\n    } else if (mode === \"after\" !== !!flip) {\n        ctx.lineTo(previous.x, target.y);\n    } else {\n        ctx.lineTo(target.x, previous.y);\n    }\n    ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n    if (!previous) {\n        return ctx.lineTo(target.x, target.y);\n    }\n    ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n    const lines = isArray(text) ? text : [\n        text\n    ];\n    const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n    let i, line;\n    ctx.save();\n    ctx.font = font.string;\n    setRenderOpts(ctx, opts);\n    for(i = 0; i < lines.length; ++i){\n        line = lines[i];\n        if (stroke) {\n            if (opts.strokeColor) {\n                ctx.strokeStyle = opts.strokeColor;\n            }\n            if (!isNullOrUndef(opts.strokeWidth)) {\n                ctx.lineWidth = opts.strokeWidth;\n            }\n            ctx.strokeText(line, x, y, opts.maxWidth);\n        }\n        ctx.fillText(line, x, y, opts.maxWidth);\n        decorateText(ctx, x, y, line, opts);\n        y += font.lineHeight;\n    }\n    ctx.restore();\n}\nfunction setRenderOpts(ctx, opts) {\n    if (opts.translation) {\n        ctx.translate(opts.translation[0], opts.translation[1]);\n    }\n    if (!isNullOrUndef(opts.rotation)) {\n        ctx.rotate(opts.rotation);\n    }\n    if (opts.color) {\n        ctx.fillStyle = opts.color;\n    }\n    if (opts.textAlign) {\n        ctx.textAlign = opts.textAlign;\n    }\n    if (opts.textBaseline) {\n        ctx.textBaseline = opts.textBaseline;\n    }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n    if (opts.strikethrough || opts.underline) {\n        const metrics = ctx.measureText(line);\n        const left = x - metrics.actualBoundingBoxLeft;\n        const right = x + metrics.actualBoundingBoxRight;\n        const top = y - metrics.actualBoundingBoxAscent;\n        const bottom = y + metrics.actualBoundingBoxDescent;\n        const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n        ctx.strokeStyle = ctx.fillStyle;\n        ctx.beginPath();\n        ctx.lineWidth = opts.decorationWidth || 2;\n        ctx.moveTo(left, yDecoration);\n        ctx.lineTo(right, yDecoration);\n        ctx.stroke();\n    }\n}\nfunction addRoundedRectPath(ctx, rect) {\n    const { x, y, w, h, radius } = rect;\n    ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, -HALF_PI, PI, true);\n    ctx.lineTo(x, y + h - radius.bottomLeft);\n    ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n    ctx.lineTo(x + w - radius.bottomRight, y + h);\n    ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n    ctx.lineTo(x + w, y + radius.topRight);\n    ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n    ctx.lineTo(x + radius.topLeft, y);\n}\nconst LINE_HEIGHT = new RegExp(/^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/);\nconst FONT_STYLE = new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);\nfunction toLineHeight(value, size) {\n    const matches = (\"\" + value).match(LINE_HEIGHT);\n    if (!matches || matches[1] === \"normal\") {\n        return size * 1.2;\n    }\n    value = +matches[2];\n    switch(matches[3]){\n        case \"px\":\n            return value;\n        case \"%\":\n            value /= 100;\n            break;\n    }\n    return size * value;\n}\nconst numberOrZero = (v)=>+v || 0;\nfunction _readValueToProps(value, props) {\n    const ret = {};\n    const objProps = isObject(props);\n    const keys = objProps ? Object.keys(props) : props;\n    const read = isObject(value) ? objProps ? (prop)=>valueOrDefault(value[prop], value[props[prop]]) : (prop)=>value[prop] : ()=>value;\n    for (const prop of keys){\n        ret[prop] = numberOrZero(read(prop));\n    }\n    return ret;\n}\nfunction toTRBL(value) {\n    return _readValueToProps(value, {\n        top: \"y\",\n        right: \"x\",\n        bottom: \"y\",\n        left: \"x\"\n    });\n}\nfunction toTRBLCorners(value) {\n    return _readValueToProps(value, [\n        \"topLeft\",\n        \"topRight\",\n        \"bottomLeft\",\n        \"bottomRight\"\n    ]);\n}\nfunction toPadding(value) {\n    const obj = toTRBL(value);\n    obj.width = obj.left + obj.right;\n    obj.height = obj.top + obj.bottom;\n    return obj;\n}\nfunction toFont(options, fallback) {\n    options = options || {};\n    fallback = fallback || defaults.font;\n    let size = valueOrDefault(options.size, fallback.size);\n    if (typeof size === \"string\") {\n        size = parseInt(size, 10);\n    }\n    let style = valueOrDefault(options.style, fallback.style);\n    if (style && !(\"\" + style).match(FONT_STYLE)) {\n        console.warn('Invalid font style specified: \"' + style + '\"');\n        style = \"\";\n    }\n    const font = {\n        family: valueOrDefault(options.family, fallback.family),\n        lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n        size,\n        style,\n        weight: valueOrDefault(options.weight, fallback.weight),\n        string: \"\"\n    };\n    font.string = toFontString(font);\n    return font;\n}\nfunction resolve(inputs, context, index, info) {\n    let cacheable = true;\n    let i, ilen, value;\n    for(i = 0, ilen = inputs.length; i < ilen; ++i){\n        value = inputs[i];\n        if (value === undefined) {\n            continue;\n        }\n        if (context !== undefined && typeof value === \"function\") {\n            value = value(context);\n            cacheable = false;\n        }\n        if (index !== undefined && isArray(value)) {\n            value = value[index % value.length];\n            cacheable = false;\n        }\n        if (value !== undefined) {\n            if (info && !cacheable) {\n                info.cacheable = false;\n            }\n            return value;\n        }\n    }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n    const { min, max } = minmax;\n    const change = toDimension(grace, (max - min) / 2);\n    const keepZero = (value, add)=>beginAtZero && value === 0 ? 0 : value + add;\n    return {\n        min: keepZero(min, -Math.abs(change)),\n        max: keepZero(max, change)\n    };\n}\nfunction createContext(parentContext, context) {\n    return Object.assign(Object.create(parentContext), context);\n}\nfunction _createResolver(scopes, prefixes = [\n    \"\"\n], rootScopes = scopes, fallback, getTarget = ()=>scopes[0]) {\n    if (!defined(fallback)) {\n        fallback = _resolve(\"_fallback\", scopes);\n    }\n    const cache = {\n        [Symbol.toStringTag]: \"Object\",\n        _cacheable: true,\n        _scopes: scopes,\n        _rootScopes: rootScopes,\n        _fallback: fallback,\n        _getTarget: getTarget,\n        override: (scope)=>_createResolver([\n                scope,\n                ...scopes\n            ], prefixes, rootScopes, fallback)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete target._keys;\n            delete scopes[0][prop];\n            return true;\n        },\n        get (target, prop) {\n            return _cached(target, prop, ()=>_resolveWithPrefixes(prop, prefixes, scopes, target));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(scopes[0]);\n        },\n        has (target, prop) {\n            return getKeysFromAllScopes(target).includes(prop);\n        },\n        ownKeys (target) {\n            return getKeysFromAllScopes(target);\n        },\n        set (target, prop, value) {\n            const storage = target._storage || (target._storage = getTarget());\n            target[prop] = storage[prop] = value;\n            delete target._keys;\n            return true;\n        }\n    });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n    const cache = {\n        _cacheable: false,\n        _proxy: proxy,\n        _context: context,\n        _subProxy: subProxy,\n        _stack: new Set(),\n        _descriptors: _descriptors(proxy, descriptorDefaults),\n        setContext: (ctx)=>_attachContext(proxy, ctx, subProxy, descriptorDefaults),\n        override: (scope)=>_attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n    };\n    return new Proxy(cache, {\n        deleteProperty (target, prop) {\n            delete target[prop];\n            delete proxy[prop];\n            return true;\n        },\n        get (target, prop, receiver) {\n            return _cached(target, prop, ()=>_resolveWithContext(target, prop, receiver));\n        },\n        getOwnPropertyDescriptor (target, prop) {\n            return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n                enumerable: true,\n                configurable: true\n            } : undefined : Reflect.getOwnPropertyDescriptor(proxy, prop);\n        },\n        getPrototypeOf () {\n            return Reflect.getPrototypeOf(proxy);\n        },\n        has (target, prop) {\n            return Reflect.has(proxy, prop);\n        },\n        ownKeys () {\n            return Reflect.ownKeys(proxy);\n        },\n        set (target, prop, value) {\n            proxy[prop] = value;\n            delete target[prop];\n            return true;\n        }\n    });\n}\nfunction _descriptors(proxy, defaults = {\n    scriptable: true,\n    indexable: true\n}) {\n    const { _scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys } = proxy;\n    return {\n        allKeys: _allKeys,\n        scriptable: _scriptable,\n        indexable: _indexable,\n        isScriptable: isFunction(_scriptable) ? _scriptable : ()=>_scriptable,\n        isIndexable: isFunction(_indexable) ? _indexable : ()=>_indexable\n    };\n}\nconst readKey = (prefix, name)=>prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop, value)=>isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve) {\n    if (Object.prototype.hasOwnProperty.call(target, prop)) {\n        return target[prop];\n    }\n    const value = resolve();\n    target[prop] = value;\n    return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    let value = _proxy[prop];\n    if (isFunction(value) && descriptors.isScriptable(prop)) {\n        value = _resolveScriptable(prop, value, target, receiver);\n    }\n    if (isArray(value) && value.length) {\n        value = _resolveArray(prop, value, target, descriptors.isIndexable);\n    }\n    if (needsSubResolver(prop, value)) {\n        value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n    }\n    return value;\n}\nfunction _resolveScriptable(prop, value, target, receiver) {\n    const { _proxy, _context, _subProxy, _stack } = target;\n    if (_stack.has(prop)) {\n        throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n    }\n    _stack.add(prop);\n    value = value(_context, _subProxy || receiver);\n    _stack.delete(prop);\n    if (needsSubResolver(prop, value)) {\n        value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n    }\n    return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n    const { _proxy, _context, _subProxy, _descriptors: descriptors } = target;\n    if (defined(_context.index) && isIndexable(prop)) {\n        value = value[_context.index % value.length];\n    } else if (isObject(value[0])) {\n        const arr = value;\n        const scopes = _proxy._scopes.filter((s)=>s !== arr);\n        value = [];\n        for (const item of arr){\n            const resolver = createSubResolver(scopes, _proxy, prop, item);\n            value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n        }\n    }\n    return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n    return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nconst getScope = (key, parent)=>key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : undefined;\nfunction addScopes(set, parentScopes, key, parentFallback, value) {\n    for (const parent of parentScopes){\n        const scope = getScope(key, parent);\n        if (scope) {\n            set.add(scope);\n            const fallback = resolveFallback(scope._fallback, key, value);\n            if (defined(fallback) && fallback !== key && fallback !== parentFallback) {\n                return fallback;\n            }\n        } else if (scope === false && defined(parentFallback) && key !== parentFallback) {\n            return null;\n        }\n    }\n    return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n    const rootScopes = resolver._rootScopes;\n    const fallback = resolveFallback(resolver._fallback, prop, value);\n    const allScopes = [\n        ...parentScopes,\n        ...rootScopes\n    ];\n    const set = new Set();\n    set.add(value);\n    let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n    if (key === null) {\n        return false;\n    }\n    if (defined(fallback) && fallback !== prop) {\n        key = addScopesFromKey(set, allScopes, fallback, key, value);\n        if (key === null) {\n            return false;\n        }\n    }\n    return _createResolver(Array.from(set), [\n        \"\"\n    ], rootScopes, fallback, ()=>subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set, allScopes, key, fallback, item) {\n    while(key){\n        key = addScopes(set, allScopes, key, fallback, item);\n    }\n    return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n    const parent = resolver._getTarget();\n    if (!(prop in parent)) {\n        parent[prop] = {};\n    }\n    const target = parent[prop];\n    if (isArray(target) && isObject(value)) {\n        return value;\n    }\n    return target;\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n    let value;\n    for (const prefix of prefixes){\n        value = _resolve(readKey(prefix, prop), scopes);\n        if (defined(value)) {\n            return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n        }\n    }\n}\nfunction _resolve(key, scopes) {\n    for (const scope of scopes){\n        if (!scope) {\n            continue;\n        }\n        const value = scope[key];\n        if (defined(value)) {\n            return value;\n        }\n    }\n}\nfunction getKeysFromAllScopes(target) {\n    let keys = target._keys;\n    if (!keys) {\n        keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n    }\n    return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n    const set = new Set();\n    for (const scope of scopes){\n        for (const key of Object.keys(scope).filter((k)=>!k.startsWith(\"_\"))){\n            set.add(key);\n        }\n    }\n    return Array.from(set);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n    const { iScale } = meta;\n    const { key = \"r\" } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n    for(i = 0, ilen = count; i < ilen; ++i){\n        index = i + start;\n        item = data[index];\n        parsed[i] = {\n            r: iScale.parse(resolveObjectKey(item, key), index)\n        };\n    }\n    return parsed;\n}\nconst EPSILON = Number.EPSILON || 1e-14;\nconst getPoint = (points, i)=>i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis)=>indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n    const previous = firstPoint.skip ? middlePoint : firstPoint;\n    const current = middlePoint;\n    const next = afterPoint.skip ? middlePoint : afterPoint;\n    const d01 = distanceBetweenPoints(current, previous);\n    const d12 = distanceBetweenPoints(next, current);\n    let s01 = d01 / (d01 + d12);\n    let s12 = d12 / (d01 + d12);\n    s01 = isNaN(s01) ? 0 : s01;\n    s12 = isNaN(s12) ? 0 : s12;\n    const fa = t * s01;\n    const fb = t * s12;\n    return {\n        previous: {\n            x: current.x - fa * (next.x - previous.x),\n            y: current.y - fa * (next.y - previous.y)\n        },\n        next: {\n            x: current.x + fb * (next.x - previous.x),\n            y: current.y + fb * (next.y - previous.y)\n        }\n    };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n    const pointsLen = points.length;\n    let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen - 1; ++i){\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent || !pointAfter) {\n            continue;\n        }\n        if (almostEquals(deltaK[i], 0, EPSILON)) {\n            mK[i] = mK[i + 1] = 0;\n            continue;\n        }\n        alphaK = mK[i] / deltaK[i];\n        betaK = mK[i + 1] / deltaK[i];\n        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n        if (squaredMagnitude <= 9) {\n            continue;\n        }\n        tauK = 3 / Math.sqrt(squaredMagnitude);\n        mK[i] = alphaK * tauK * deltaK[i];\n        mK[i + 1] = betaK * tauK * deltaK[i];\n    }\n}\nfunction monotoneCompute(points, mK, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    let delta, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(let i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        const iPixel = pointCurrent[indexAxis];\n        const vPixel = pointCurrent[valueAxis];\n        if (pointBefore) {\n            delta = (iPixel - pointBefore[indexAxis]) / 3;\n            pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n            pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n        }\n        if (pointAfter) {\n            delta = (pointAfter[indexAxis] - iPixel) / 3;\n            pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n            pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n        }\n    }\n}\nfunction splineCurveMonotone(points, indexAxis = \"x\") {\n    const valueAxis = getValueAxis(indexAxis);\n    const pointsLen = points.length;\n    const deltaK = Array(pointsLen).fill(0);\n    const mK = Array(pointsLen);\n    let i, pointBefore, pointCurrent;\n    let pointAfter = getPoint(points, 0);\n    for(i = 0; i < pointsLen; ++i){\n        pointBefore = pointCurrent;\n        pointCurrent = pointAfter;\n        pointAfter = getPoint(points, i + 1);\n        if (!pointCurrent) {\n            continue;\n        }\n        if (pointAfter) {\n            const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n            deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n        }\n        mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n    }\n    monotoneAdjust(points, deltaK, mK);\n    monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n    return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n    let i, ilen, point, inArea, inAreaPrev;\n    let inAreaNext = _isPointInArea(points[0], area);\n    for(i = 0, ilen = points.length; i < ilen; ++i){\n        inAreaPrev = inArea;\n        inArea = inAreaNext;\n        inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n        if (!inArea) {\n            continue;\n        }\n        point = points[i];\n        if (inAreaPrev) {\n            point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n            point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n        }\n        if (inAreaNext) {\n            point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n            point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n        }\n    }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n    let i, ilen, point, controlPoints;\n    if (options.spanGaps) {\n        points = points.filter((pt)=>!pt.skip);\n    }\n    if (options.cubicInterpolationMode === \"monotone\") {\n        splineCurveMonotone(points, indexAxis);\n    } else {\n        let prev = loop ? points[points.length - 1] : points[0];\n        for(i = 0, ilen = points.length; i < ilen; ++i){\n            point = points[i];\n            controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n            point.cp1x = controlPoints.previous.x;\n            point.cp1y = controlPoints.previous.y;\n            point.cp2x = controlPoints.next.x;\n            point.cp2y = controlPoints.next.y;\n            prev = point;\n        }\n    }\n    if (options.capBezierPoints) {\n        capBezierPoints(points, area);\n    }\n}\nfunction _isDomSupported() {\n    return  false && 0;\n}\nfunction _getParentNode(domNode) {\n    let parent = domNode.parentNode;\n    if (parent && parent.toString() === \"[object ShadowRoot]\") {\n        parent = parent.host;\n    }\n    return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n    let valueInPixels;\n    if (typeof styleValue === \"string\") {\n        valueInPixels = parseInt(styleValue, 10);\n        if (styleValue.indexOf(\"%\") !== -1) {\n            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n        }\n    } else {\n        valueInPixels = styleValue;\n    }\n    return valueInPixels;\n}\nconst getComputedStyle = (element)=>window.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n    return getComputedStyle(el).getPropertyValue(property);\n}\nconst positions = [\n    \"top\",\n    \"right\",\n    \"bottom\",\n    \"left\"\n];\nfunction getPositionedStyle(styles, style, suffix) {\n    const result = {};\n    suffix = suffix ? \"-\" + suffix : \"\";\n    for(let i = 0; i < 4; i++){\n        const pos = positions[i];\n        result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n    }\n    result.width = result.left + result.right;\n    result.height = result.top + result.bottom;\n    return result;\n}\nconst useOffsetPos = (x, y, target)=>(x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n    const touches = e.touches;\n    const source = touches && touches.length ? touches[0] : e;\n    const { offsetX, offsetY } = source;\n    let box = false;\n    let x, y;\n    if (useOffsetPos(offsetX, offsetY, e.target)) {\n        x = offsetX;\n        y = offsetY;\n    } else {\n        const rect = canvas.getBoundingClientRect();\n        x = source.clientX - rect.left;\n        y = source.clientY - rect.top;\n        box = true;\n    }\n    return {\n        x,\n        y,\n        box\n    };\n}\nfunction getRelativePosition(evt, chart) {\n    if (\"native\" in evt) {\n        return evt;\n    }\n    const { canvas, currentDevicePixelRatio } = chart;\n    const style = getComputedStyle(canvas);\n    const borderBox = style.boxSizing === \"border-box\";\n    const paddings = getPositionedStyle(style, \"padding\");\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const { x, y, box } = getCanvasPosition(evt, canvas);\n    const xOffset = paddings.left + (box && borders.left);\n    const yOffset = paddings.top + (box && borders.top);\n    let { width, height } = chart;\n    if (borderBox) {\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    return {\n        x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n        y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n    };\n}\nfunction getContainerSize(canvas, width, height) {\n    let maxWidth, maxHeight;\n    if (width === undefined || height === undefined) {\n        const container = _getParentNode(canvas);\n        if (!container) {\n            width = canvas.clientWidth;\n            height = canvas.clientHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n            const containerStyle = getComputedStyle(container);\n            const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n            const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n            width = rect.width - containerPadding.width - containerBorder.width;\n            height = rect.height - containerPadding.height - containerBorder.height;\n            maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n            maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n        }\n    }\n    return {\n        width,\n        height,\n        maxWidth: maxWidth || INFINITY,\n        maxHeight: maxHeight || INFINITY\n    };\n}\nconst round1 = (v)=>Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n    const style = getComputedStyle(canvas);\n    const margins = getPositionedStyle(style, \"margin\");\n    const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n    const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n    const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n    let { width, height } = containerSize;\n    if (style.boxSizing === \"content-box\") {\n        const borders = getPositionedStyle(style, \"border\", \"width\");\n        const paddings = getPositionedStyle(style, \"padding\");\n        width -= paddings.width + borders.width;\n        height -= paddings.height + borders.height;\n    }\n    width = Math.max(0, width - margins.width);\n    height = Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height - margins.height);\n    width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n    height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n    if (width && !height) {\n        height = round1(width / 2);\n    }\n    return {\n        width,\n        height\n    };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n    const pixelRatio = forceRatio || 1;\n    const deviceHeight = Math.floor(chart.height * pixelRatio);\n    const deviceWidth = Math.floor(chart.width * pixelRatio);\n    chart.height = deviceHeight / pixelRatio;\n    chart.width = deviceWidth / pixelRatio;\n    const canvas = chart.canvas;\n    if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n        canvas.style.height = `${chart.height}px`;\n        canvas.style.width = `${chart.width}px`;\n    }\n    if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n        chart.currentDevicePixelRatio = pixelRatio;\n        canvas.height = deviceHeight;\n        canvas.width = deviceWidth;\n        chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n        return true;\n    }\n    return false;\n}\nconst supportsEventListenerOptions = function() {\n    let passiveSupported = false;\n    try {\n        const options = {\n            get passive () {\n                passiveSupported = true;\n                return false;\n            }\n        };\n        window.addEventListener(\"test\", null, options);\n        window.removeEventListener(\"test\", null, options);\n    } catch (e) {}\n    return passiveSupported;\n}();\nfunction readUsedSize(element, property) {\n    const value = getStyle(element, property);\n    const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n    return matches ? +matches[1] : undefined;\n}\nfunction _pointInLine(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: p1.y + t * (p2.y - p1.y)\n    };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n    return {\n        x: p1.x + t * (p2.x - p1.x),\n        y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n    };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n    const cp1 = {\n        x: p1.cp2x,\n        y: p1.cp2y\n    };\n    const cp2 = {\n        x: p2.cp1x,\n        y: p2.cp1y\n    };\n    const a = _pointInLine(p1, cp1, t);\n    const b = _pointInLine(cp1, cp2, t);\n    const c = _pointInLine(cp2, p2, t);\n    const d = _pointInLine(a, b, t);\n    const e = _pointInLine(b, c, t);\n    return _pointInLine(d, e, t);\n}\nconst intlCache = new Map();\nfunction getNumberFormat(locale, options) {\n    options = options || {};\n    const cacheKey = locale + JSON.stringify(options);\n    let formatter = intlCache.get(cacheKey);\n    if (!formatter) {\n        formatter = new Intl.NumberFormat(locale, options);\n        intlCache.set(cacheKey, formatter);\n    }\n    return formatter;\n}\nfunction formatNumber(num, locale, options) {\n    return getNumberFormat(locale, options).format(num);\n}\nconst getRightToLeftAdapter = function(rectX, width) {\n    return {\n        x (x) {\n            return rectX + rectX + width - x;\n        },\n        setWidth (w) {\n            width = w;\n        },\n        textAlign (align) {\n            if (align === \"center\") {\n                return align;\n            }\n            return align === \"right\" ? \"left\" : \"right\";\n        },\n        xPlus (x, value) {\n            return x - value;\n        },\n        leftForLtr (x, itemWidth) {\n            return x - itemWidth;\n        }\n    };\n};\nconst getLeftToRightAdapter = function() {\n    return {\n        x (x) {\n            return x;\n        },\n        setWidth (w) {},\n        textAlign (align) {\n            return align;\n        },\n        xPlus (x, value) {\n            return x + value;\n        },\n        leftForLtr (x, _itemWidth) {\n            return x;\n        }\n    };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n    return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n    let style, original;\n    if (direction === \"ltr\" || direction === \"rtl\") {\n        style = ctx.canvas.style;\n        original = [\n            style.getPropertyValue(\"direction\"),\n            style.getPropertyPriority(\"direction\")\n        ];\n        style.setProperty(\"direction\", direction, \"important\");\n        ctx.prevTextDirection = original;\n    }\n}\nfunction restoreTextDirection(ctx, original) {\n    if (original !== undefined) {\n        delete ctx.prevTextDirection;\n        ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n    }\n}\nfunction propertyFn(property) {\n    if (property === \"angle\") {\n        return {\n            between: _angleBetween,\n            compare: _angleDiff,\n            normalize: _normalizeAngle\n        };\n    }\n    return {\n        between: _isBetween,\n        compare: (a, b)=>a - b,\n        normalize: (x)=>x\n    };\n}\nfunction normalizeSegment({ start, end, count, loop, style }) {\n    return {\n        start: start % count,\n        end: end % count,\n        loop: loop && (end - start + 1) % count === 0,\n        style\n    };\n}\nfunction getSegment(segment, points, bounds) {\n    const { property, start: startBound, end: endBound } = bounds;\n    const { between, normalize } = propertyFn(property);\n    const count = points.length;\n    let { start, end, loop } = segment;\n    let i, ilen;\n    if (loop) {\n        start += count;\n        end += count;\n        for(i = 0, ilen = count; i < ilen; ++i){\n            if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n                break;\n            }\n            start--;\n            end--;\n        }\n        start %= count;\n        end %= count;\n    }\n    if (end < start) {\n        end += count;\n    }\n    return {\n        start,\n        end,\n        loop,\n        style: segment.style\n    };\n}\nfunction _boundSegment(segment, points, bounds) {\n    if (!bounds) {\n        return [\n            segment\n        ];\n    }\n    const { property, start: startBound, end: endBound } = bounds;\n    const count = points.length;\n    const { compare, between, normalize } = propertyFn(property);\n    const { start, end, loop, style } = getSegment(segment, points, bounds);\n    const result = [];\n    let inside = false;\n    let subStart = null;\n    let value, point, prevValue;\n    const startIsBefore = ()=>between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n    const endIsBefore = ()=>compare(endBound, value) === 0 || between(endBound, prevValue, value);\n    const shouldStart = ()=>inside || startIsBefore();\n    const shouldStop = ()=>!inside || endIsBefore();\n    for(let i = start, prev = start; i <= end; ++i){\n        point = points[i % count];\n        if (point.skip) {\n            continue;\n        }\n        value = normalize(point[property]);\n        if (value === prevValue) {\n            continue;\n        }\n        inside = between(value, startBound, endBound);\n        if (subStart === null && shouldStart()) {\n            subStart = compare(value, startBound) === 0 ? i : prev;\n        }\n        if (subStart !== null && shouldStop()) {\n            result.push(normalizeSegment({\n                start: subStart,\n                end: i,\n                loop,\n                count,\n                style\n            }));\n            subStart = null;\n        }\n        prev = i;\n        prevValue = value;\n    }\n    if (subStart !== null) {\n        result.push(normalizeSegment({\n            start: subStart,\n            end,\n            loop,\n            count,\n            style\n        }));\n    }\n    return result;\n}\nfunction _boundSegments(line, bounds) {\n    const result = [];\n    const segments = line.segments;\n    for(let i = 0; i < segments.length; i++){\n        const sub = _boundSegment(segments[i], line.points, bounds);\n        if (sub.length) {\n            result.push(...sub);\n        }\n    }\n    return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n    let start = 0;\n    let end = count - 1;\n    if (loop && !spanGaps) {\n        while(start < count && !points[start].skip){\n            start++;\n        }\n    }\n    while(start < count && points[start].skip){\n        start++;\n    }\n    start %= count;\n    if (loop) {\n        end += start;\n    }\n    while(end > start && points[end % count].skip){\n        end--;\n    }\n    end %= count;\n    return {\n        start,\n        end\n    };\n}\nfunction solidSegments(points, start, max, loop) {\n    const count = points.length;\n    const result = [];\n    let last = start;\n    let prev = points[start];\n    let end;\n    for(end = start + 1; end <= max; ++end){\n        const cur = points[end % count];\n        if (cur.skip || cur.stop) {\n            if (!prev.skip) {\n                loop = false;\n                result.push({\n                    start: start % count,\n                    end: (end - 1) % count,\n                    loop\n                });\n                start = last = cur.stop ? end : null;\n            }\n        } else {\n            last = end;\n            if (prev.skip) {\n                start = end;\n            }\n        }\n        prev = cur;\n    }\n    if (last !== null) {\n        result.push({\n            start: start % count,\n            end: last % count,\n            loop\n        });\n    }\n    return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n    const points = line.points;\n    const spanGaps = line.options.spanGaps;\n    const count = points.length;\n    if (!count) {\n        return [];\n    }\n    const loop = !!line._loop;\n    const { start, end } = findStartAndEnd(points, count, loop, spanGaps);\n    if (spanGaps === true) {\n        return splitByStyles(line, [\n            {\n                start,\n                end,\n                loop\n            }\n        ], points, segmentOptions);\n    }\n    const max = end < start ? end + count : end;\n    const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n    return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n    if (!segmentOptions || !segmentOptions.setContext || !points) {\n        return segments;\n    }\n    return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n    const chartContext = line._chart.getContext();\n    const baseStyle = readStyle(line.options);\n    const { _datasetIndex: datasetIndex, options: { spanGaps } } = line;\n    const count = points.length;\n    const result = [];\n    let prevStyle = baseStyle;\n    let start = segments[0].start;\n    let i = start;\n    function addStyle(s, e, l, st) {\n        const dir = spanGaps ? -1 : 1;\n        if (s === e) {\n            return;\n        }\n        s += count;\n        while(points[s % count].skip){\n            s -= dir;\n        }\n        while(points[e % count].skip){\n            e += dir;\n        }\n        if (s % count !== e % count) {\n            result.push({\n                start: s % count,\n                end: e % count,\n                loop: l,\n                style: st\n            });\n            prevStyle = st;\n            start = e % count;\n        }\n    }\n    for (const segment of segments){\n        start = spanGaps ? start : segment.start;\n        let prev = points[start % count];\n        let style;\n        for(i = start + 1; i <= segment.end; i++){\n            const pt = points[i % count];\n            style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n                type: \"segment\",\n                p0: prev,\n                p1: pt,\n                p0DataIndex: (i - 1) % count,\n                p1DataIndex: i % count,\n                datasetIndex\n            })));\n            if (styleChanged(style, prevStyle)) {\n                addStyle(start, i - 1, segment.loop, prevStyle);\n            }\n            prev = pt;\n            prevStyle = style;\n        }\n        if (start < i - 1) {\n            addStyle(start, i - 1, segment.loop, prevStyle);\n        }\n    }\n    return result;\n}\nfunction readStyle(options) {\n    return {\n        backgroundColor: options.backgroundColor,\n        borderCapStyle: options.borderCapStyle,\n        borderDash: options.borderDash,\n        borderDashOffset: options.borderDashOffset,\n        borderJoinStyle: options.borderJoinStyle,\n        borderWidth: options.borderWidth,\n        borderColor: options.borderColor\n    };\n}\nfunction styleChanged(style, prevStyle) {\n    return prevStyle && JSON.stringify(style) !== JSON.stringify(prevStyle);\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9jaHVua3MvaGVscGVycy5zZWdtZW50Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxTQUFTQSxRQUFRO0FBQ2pCLE1BQU1DLE1BQU87SUFDWCxJQUFJQyxLQUFLO0lBQ1QsT0FBTztRQUNMLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNDLGNBQWNDLEtBQUs7SUFDMUIsT0FBT0EsVUFBVSxRQUFRLE9BQU9BLFVBQVU7QUFDNUM7QUFDQSxTQUFTQyxRQUFRRCxLQUFLO0lBQ3BCLElBQUlFLE1BQU1ELE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxDQUFDRCxRQUFRO1FBQ3pDLE9BQU87SUFDVDtJQUNBLE1BQU1HLE9BQU9DLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNQO0lBQzVDLElBQUlHLEtBQUtLLEtBQUssQ0FBQyxHQUFHLE9BQU8sYUFBYUwsS0FBS0ssS0FBSyxDQUFDLENBQUMsT0FBTyxVQUFVO1FBQ2pFLE9BQU87SUFDVDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFNBQVNULEtBQUs7SUFDckIsT0FBT0EsVUFBVSxRQUFRSSxPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDUCxXQUFXO0FBQ3JFO0FBQ0EsTUFBTVUsaUJBQWlCLENBQUNWLFFBQVUsQ0FBQyxPQUFPQSxVQUFVLFlBQVlBLGlCQUFpQlcsTUFBSyxLQUFNQyxTQUFTLENBQUNaO0FBQ3RHLFNBQVNhLGdCQUFnQmIsS0FBSyxFQUFFYyxZQUFZO0lBQzFDLE9BQU9KLGVBQWVWLFNBQVNBLFFBQVFjO0FBQ3pDO0FBQ0EsU0FBU0MsZUFBZWYsS0FBSyxF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Q1BDLEtBQUs7SUFDTEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsVUFBVTtJQUNWQyxVQUFVO0lBQ1ZDLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxTQUFTO0lBQ1RDLFdBQVc7SUFDWEMsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLEtBQUs7SUFDTEMsS0FBSztJQUNMQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsU0FBUztJQUNUQyxRQUFRO0lBQ1JDLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsWUFBWTtJQUNaQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsT0FBTztJQUNQQyxXQUFXO0lBQ1hDLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEMsS0FBSztJQUNMQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsS0FBSztJQUNMQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxLQUFLO0lBQ0xDLFVBQVU7SUFDVkMsWUFBWTtJQUNaQyxTQUFTO0lBQ1RDLFVBQVU7SUFDVkMsU0FBUztJQUNUQyxZQUFZO0lBQ1pDLE1BQU07SUFDTkMsUUFBUTtJQUNSQyxNQUFNO0lBQ05DLFNBQVM7SUFDVEMsT0FBTztJQUNQQyxTQUFTO0lBQ1RDLE1BQU07SUFDTkMsV0FBVztJQUNYQyxRQUFRO0lBQ1JDLE9BQU87SUFDUEMsWUFBWTtJQUNaQyxXQUFXO0lBQ1hDLFNBQVM7SUFDVEMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE1BQU07SUFDTkMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLGFBQWE7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Q3hCLE9BQU87UUFDTGlnQixpQkFBaUJqZ0IsUUFBUWlnQixlQUFlO1FBQ3hDc2IsZ0JBQWdCdjdCLFFBQVF1N0IsY0FBYztRQUN0Q0MsWUFBWXg3QixRQUFRdzdCLFVBQVU7UUFDOUJDLGtCQUFrQno3QixRQUFReTdCLGdCQUFnQjtRQUMxQ0MsaUJBQWlCMTdCLFFBQVEwN0IsZUFBZTtRQUN4Q3BWLGFBQWF0bUIsUUFBUXNtQixXQUFXO1FBQ2hDcEcsYUFBYWxnQixRQUFRa2dCLFdBQVc7SUFDbEM7QUFDRjtBQUNBLFNBQVNvYixhQUFhemEsS0FBSyxFQUFFa2EsU0FBUztJQUNwQyxPQUFPQSxhQUFhN0QsS0FBS0MsU0FBUyxDQUFDdFcsV0FBV3FXLEtBQUtDLFNBQVMsQ0FBQzREO0FBQy9EO0FBRXE0RSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzPzlhZDciXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiBub29wKCkge31cbmNvbnN0IHVpZCA9IChmdW5jdGlvbigpIHtcbiAgbGV0IGlkID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBpZCsrO1xuICB9O1xufSgpKTtcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWYodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh0eXBlLnNsaWNlKDAsIDcpID09PSAnW29iamVjdCcgJiYgdHlwZS5zbGljZSgtNikgPT09ICdBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuY29uc3QgaXNOdW1iZXJGaW5pdGUgPSAodmFsdWUpID0+ICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAmJiBpc0Zpbml0ZSgrdmFsdWUpO1xuZnVuY3Rpb24gZmluaXRlT3JEZWZhdWx0KHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlO1xufVxuY29uc3QgdG9QZXJjZW50YWdlID0gKHZhbHVlLCBkaW1lbnNpb24pID0+XG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/XG4gICAgcGFyc2VGbG9hdCh2YWx1ZSkgLyAxMDBcbiAgICA6IHZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbikgPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aCgnJScpID9cbiAgICBwYXJzZUZsb2F0KHZhbHVlKSAvIDEwMCAqIGRpbWVuc2lvblxuICAgIDogK3ZhbHVlO1xuZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBmbi5jYWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBlYWNoKGxvb3BhYmxlLCBmbiwgdGhpc0FyZywgcmV2ZXJzZSkge1xuICBsZXQgaSwgbGVuLCBrZXlzO1xuICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICBsZW4gPSBsb29wYWJsZS5sZW5ndGg7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGZuLmNhbGwodGhpc0FyZywgbG9vcGFibGVbaV0sIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhsb29wYWJsZSk7XG4gICAgbGVuID0ga2V5cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmbi5jYWxsKHRoaXNBcmcsIGxvb3BhYmxlW2tleXNbaV1dLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9lbGVtZW50c0VxdWFsKGEwLCBhMSkge1xuICBsZXQgaSwgaWxlbiwgdjAsIHYxO1xuICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGkgPSAwLCBpbGVuID0gYTAubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgdjAgPSBhMFtpXTtcbiAgICB2MSA9IGExW2ldO1xuICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBjbG9uZSQxKHNvdXJjZSkge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUkMSk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIGNvbnN0IGtsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICBsZXQgayA9IDA7XG4gICAgZm9yICg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgIHRhcmdldFtrZXlzW2tdXSA9IGNsb25lJDEoc291cmNlW2tleXNba11dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgcmV0dXJuIFsnX19wcm90b19fJywgJ3Byb3RvdHlwZScsICdjb25zdHJ1Y3RvciddLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG5mdW5jdGlvbiBfbWVyZ2VyKGtleSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlKHR2YWwsIHN2YWwsIG9wdGlvbnMpO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldFtrZXldID0gY2xvbmUkMShzdmFsKTtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtzb3VyY2VdO1xuICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG4gIGlmICghaXNPYmplY3QodGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc291cmNlID0gc291cmNlc1tpXTtcbiAgICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGxldCBrID0gMCwga2xlbiA9IGtleXMubGVuZ3RoOyBrIDwga2xlbjsgKytrKSB7XG4gICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VJZih0YXJnZXQsIHNvdXJjZSkge1xuICByZXR1cm4gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHttZXJnZXI6IF9tZXJnZXJJZn0pO1xufVxuZnVuY3Rpb24gX21lcmdlcklmKGtleSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKCFpc1ZhbGlkS2V5KGtleSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICBjb25zdCBzdmFsID0gc291cmNlW2tleV07XG4gIGlmIChpc09iamVjdCh0dmFsKSAmJiBpc09iamVjdChzdmFsKSkge1xuICAgIG1lcmdlSWYodHZhbCwgc3ZhbCk7XG4gIH0gZWxzZSBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICB0YXJnZXRba2V5XSA9IGNsb25lJDEoc3ZhbCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArXG5cdFx0XHQnXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcIicgKyBjdXJyZW50ICsgJ1wiIGluc3RlYWQnKTtcbiAgfVxufVxuY29uc3Qga2V5UmVzb2x2ZXJzID0ge1xuICAnJzogdiA9PiB2LFxuICB4OiBvID0+IG8ueCxcbiAgeTogbyA9PiBvLnlcbn07XG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XG4gIGNvbnN0IHJlc29sdmVyID0ga2V5UmVzb2x2ZXJzW2tleV0gfHwgKGtleVJlc29sdmVyc1trZXldID0gX2dldEtleVJlc29sdmVyKGtleSkpO1xuICByZXR1cm4gcmVzb2x2ZXIob2JqKTtcbn1cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXkpIHtcbiAgY29uc3Qga2V5cyA9IF9zcGxpdEtleShrZXkpO1xuICByZXR1cm4gb2JqID0+IHtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgaWYgKGsgPT09ICcnKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zcGxpdEtleShrZXkpIHtcbiAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgY29uc3Qga2V5cyA9IFtdO1xuICBsZXQgdG1wID0gJyc7XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIHRtcCArPSBwYXJ0O1xuICAgIGlmICh0bXAuZW5kc1dpdGgoJ1xcXFwnKSkge1xuICAgICAgdG1wID0gdG1wLnNsaWNlKDAsIC0xKSArICcuJztcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICB0bXAgPSAnJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG5jb25zdCBzZXRzRXF1YWwgPSAoYSwgYikgPT4ge1xuICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICBpZiAoIWIuaGFzKGl0ZW0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIF9pc0NsaWNrRXZlbnQoZSkge1xuICByZXR1cm4gZS50eXBlID09PSAnbW91c2V1cCcgfHwgZS50eXBlID09PSAnY2xpY2snIHx8IGUudHlwZSA9PT0gJ2NvbnRleHRtZW51Jztcbn1cblxuY29uc3QgUEkgPSBNYXRoLlBJO1xuY29uc3QgVEFVID0gMiAqIFBJO1xuY29uc3QgUElUQVUgPSBUQVUgKyBQSTtcbmNvbnN0IElORklOSVRZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuY29uc3QgUkFEX1BFUl9ERUcgPSBQSSAvIDE4MDtcbmNvbnN0IEhBTEZfUEkgPSBQSSAvIDI7XG5jb25zdCBRVUFSVEVSX1BJID0gUEkgLyA0O1xuY29uc3QgVFdPX1RISVJEU19QSSA9IFBJICogMiAvIDM7XG5jb25zdCBsb2cxMCA9IE1hdGgubG9nMTA7XG5jb25zdCBzaWduID0gTWF0aC5zaWduO1xuZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICBjb25zdCByb3VuZGVkUmFuZ2UgPSBNYXRoLnJvdW5kKHJhbmdlKTtcbiAgcmFuZ2UgPSBhbG1vc3RFcXVhbHMocmFuZ2UsIHJvdW5kZWRSYW5nZSwgcmFuZ2UgLyAxMDAwKSA/IHJvdW5kZWRSYW5nZSA6IHJhbmdlO1xuICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgY29uc3QgZnJhY3Rpb24gPSByYW5nZSAvIG5pY2VSYW5nZTtcbiAgY29uc3QgbmljZUZyYWN0aW9uID0gZnJhY3Rpb24gPD0gMSA/IDEgOiBmcmFjdGlvbiA8PSAyID8gMiA6IGZyYWN0aW9uIDw9IDUgPyA1IDogMTA7XG4gIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG5mdW5jdGlvbiBfZmFjdG9yaXplKHZhbHVlKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgbGV0IGk7XG4gIGZvciAoaSA9IDE7IGkgPCBzcXJ0OyBpKyspIHtcbiAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgfVxuICB9XG4gIGlmIChzcXJ0ID09PSAoc3FydCB8IDApKSB7XG4gICAgcmVzdWx0LnB1c2goc3FydCk7XG4gIH1cbiAgcmVzdWx0LnNvcnQoKGEsIGIpID0+IGEgLSBiKS5wb3AoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gIHJldHVybiBNYXRoLmFicyh4IC0geSkgPCBlcHNpbG9uO1xufVxuZnVuY3Rpb24gYWxtb3N0V2hvbGUoeCwgZXBzaWxvbikge1xuICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgcmV0dXJuICgocm91bmRlZCAtIGVwc2lsb24pIDw9IHgpICYmICgocm91bmRlZCArIGVwc2lsb24pID49IHgpO1xufVxuZnVuY3Rpb24gX3NldE1pbkFuZE1heEJ5S2V5KGFycmF5LCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsZW47IGkrKykge1xuICAgIHZhbHVlID0gYXJyYXlbaV1bcHJvcGVydHldO1xuICAgIGlmICghaXNOYU4odmFsdWUpKSB7XG4gICAgICB0YXJnZXQubWluID0gTWF0aC5taW4odGFyZ2V0Lm1pbiwgdmFsdWUpO1xuICAgICAgdGFyZ2V0Lm1heCA9IE1hdGgubWF4KHRhcmdldC5tYXgsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRvUmFkaWFucyhkZWdyZWVzKSB7XG4gIHJldHVybiBkZWdyZWVzICogKFBJIC8gMTgwKTtcbn1cbmZ1bmN0aW9uIHRvRGVncmVlcyhyYWRpYW5zKSB7XG4gIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbmZ1bmN0aW9uIF9kZWNpbWFsUGxhY2VzKHgpIHtcbiAgaWYgKCFpc051bWJlckZpbml0ZSh4KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZSA9IDE7XG4gIGxldCBwID0gMDtcbiAgd2hpbGUgKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCkge1xuICAgIGUgKj0gMTA7XG4gICAgcCsrO1xuICB9XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgY29uc3QgZGlzdGFuY2VGcm9tWENlbnRlciA9IGFuZ2xlUG9pbnQueCAtIGNlbnRyZVBvaW50Lng7XG4gIGNvbnN0IGRpc3RhbmNlRnJvbVlDZW50ZXIgPSBhbmdsZVBvaW50LnkgLSBjZW50cmVQb2ludC55O1xuICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gIGxldCBhbmdsZSA9IE1hdGguYXRhbjIoZGlzdGFuY2VGcm9tWUNlbnRlciwgZGlzdGFuY2VGcm9tWENlbnRlcik7XG4gIGlmIChhbmdsZSA8ICgtMC41ICogUEkpKSB7XG4gICAgYW5nbGUgKz0gVEFVO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5nbGUsXG4gICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICB9O1xufVxuZnVuY3Rpb24gZGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHB0MSwgcHQyKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3cocHQyLnggLSBwdDEueCwgMikgKyBNYXRoLnBvdyhwdDIueSAtIHB0MS55LCAyKSk7XG59XG5mdW5jdGlvbiBfYW5nbGVEaWZmKGEsIGIpIHtcbiAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuZnVuY3Rpb24gX25vcm1hbGl6ZUFuZ2xlKGEpIHtcbiAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbmZ1bmN0aW9uIF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0LCBlbmQsIHNhbWVBbmdsZUlzRnVsbENpcmNsZSkge1xuICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgY29uc3QgcyA9IF9ub3JtYWxpemVBbmdsZShzdGFydCk7XG4gIGNvbnN0IGUgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgY29uc3QgYW5nbGVUb0VuZCA9IF9ub3JtYWxpemVBbmdsZShlIC0gYSk7XG4gIGNvbnN0IHN0YXJ0VG9BbmdsZSA9IF9ub3JtYWxpemVBbmdsZShhIC0gcyk7XG4gIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICByZXR1cm4gYSA9PT0gcyB8fCBhID09PSBlIHx8IChzYW1lQW5nbGVJc0Z1bGxDaXJjbGUgJiYgcyA9PT0gZSlcbiAgICB8fCAoYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlKTtcbn1cbmZ1bmN0aW9uIF9saW1pdFZhbHVlKHZhbHVlLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBfaW50MTZSYW5nZSh2YWx1ZSkge1xuICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuZnVuY3Rpb24gX2lzQmV0d2Vlbih2YWx1ZSwgc3RhcnQsIGVuZCwgZXBzaWxvbiA9IDFlLTYpIHtcbiAgcmV0dXJuIHZhbHVlID49IE1hdGgubWluKHN0YXJ0LCBlbmQpIC0gZXBzaWxvbiAmJiB2YWx1ZSA8PSBNYXRoLm1heChzdGFydCwgZW5kKSArIGVwc2lsb247XG59XG5cbmZ1bmN0aW9uIF9sb29rdXAodGFibGUsIHZhbHVlLCBjbXApIHtcbiAgY21wID0gY21wIHx8ICgoaW5kZXgpID0+IHRhYmxlW2luZGV4XSA8IHZhbHVlKTtcbiAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gMDtcbiAgbGV0IG1pZDtcbiAgd2hpbGUgKGhpIC0gbG8gPiAxKSB7XG4gICAgbWlkID0gKGxvICsgaGkpID4+IDE7XG4gICAgaWYgKGNtcChtaWQpKSB7XG4gICAgICBsbyA9IG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaGkgPSBtaWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB7bG8sIGhpfTtcbn1cbmNvbnN0IF9sb29rdXBCeUtleSA9ICh0YWJsZSwga2V5LCB2YWx1ZSwgbGFzdCkgPT5cbiAgX2xvb2t1cCh0YWJsZSwgdmFsdWUsIGxhc3RcbiAgICA/IGluZGV4ID0+IHRhYmxlW2luZGV4XVtrZXldIDw9IHZhbHVlXG4gICAgOiBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA8IHZhbHVlKTtcbmNvbnN0IF9ybG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpID0+XG4gIF9sb29rdXAodGFibGUsIHZhbHVlLCBpbmRleCA9PiB0YWJsZVtpbmRleF1ba2V5XSA+PSB2YWx1ZSk7XG5mdW5jdGlvbiBfZmlsdGVyQmV0d2Vlbih2YWx1ZXMsIG1pbiwgbWF4KSB7XG4gIGxldCBzdGFydCA9IDA7XG4gIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuICB3aGlsZSAoc3RhcnQgPCBlbmQgJiYgdmFsdWVzW3N0YXJ0XSA8IG1pbikge1xuICAgIHN0YXJ0Kys7XG4gIH1cbiAgd2hpbGUgKGVuZCA+IHN0YXJ0ICYmIHZhbHVlc1tlbmQgLSAxXSA+IG1heCkge1xuICAgIGVuZC0tO1xuICB9XG4gIHJldHVybiBzdGFydCA+IDAgfHwgZW5kIDwgdmFsdWVzLmxlbmd0aFxuICAgID8gdmFsdWVzLnNsaWNlKHN0YXJ0LCBlbmQpXG4gICAgOiB2YWx1ZXM7XG59XG5jb25zdCBhcnJheUV2ZW50cyA9IFsncHVzaCcsICdwb3AnLCAnc2hpZnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXTtcbmZ1bmN0aW9uIGxpc3RlbkFycmF5RXZlbnRzKGFycmF5LCBsaXN0ZW5lcikge1xuICBpZiAoYXJyYXkuX2NoYXJ0anMpIHtcbiAgICBhcnJheS5fY2hhcnRqcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhcnJheSwgJ19jaGFydGpzJywge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZToge1xuICAgICAgbGlzdGVuZXJzOiBbbGlzdGVuZXJdXG4gICAgfVxuICB9KTtcbiAgYXJyYXlFdmVudHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgbWV0aG9kID0gJ19vbkRhdGEnICsgX2NhcGl0YWxpemUoa2V5KTtcbiAgICBjb25zdCBiYXNlID0gYXJyYXlba2V5XTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5mb3JFYWNoKChvYmplY3QpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9iamVjdFttZXRob2RdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvYmplY3RbbWV0aG9kXSguLi5hcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gIGNvbnN0IHN0dWIgPSBhcnJheS5fY2hhcnRqcztcbiAgaWYgKCFzdHViKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuICBjb25zdCBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG4gIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBkZWxldGUgYXJyYXlba2V5XTtcbiAgfSk7XG4gIGRlbGV0ZSBhcnJheS5fY2hhcnRqcztcbn1cbmZ1bmN0aW9uIF9hcnJheVVuaXF1ZShpdGVtcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBpLCBpbGVuO1xuICBmb3IgKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgc2V0LmFkZChpdGVtc1tpXSk7XG4gIH1cbiAgaWYgKHNldC5zaXplID09PSBpbGVuKSB7XG4gICAgcmV0dXJuIGl0ZW1zO1xuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcbiAgcmV0dXJuIGZvbnRTdHlsZSArICcgJyArIHBpeGVsU2l6ZSArICdweCAnICsgZm9udEZhbWlseTtcbn1cbmNvbnN0IHJlcXVlc3RBbmltRnJhbWUgPSAoZnVuY3Rpb24oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbn0oKSk7XG5mdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcsIHVwZGF0ZUZuKSB7XG4gIGNvbnN0IHVwZGF0ZUFyZ3MgPSB1cGRhdGVGbiB8fCAoKGFyZ3MpID0+IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpKTtcbiAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcbiAgbGV0IGFyZ3MgPSBbXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLnJlc3QpIHtcbiAgICBhcmdzID0gdXBkYXRlQXJncyhyZXN0KTtcbiAgICBpZiAoIXRpY2tpbmcpIHtcbiAgICAgIHRpY2tpbmcgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1GcmFtZS5jYWxsKHdpbmRvdywgKCkgPT4ge1xuICAgICAgICB0aWNraW5nID0gZmFsc2U7XG4gICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCB0aW1lb3V0O1xuICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgIGlmIChkZWxheSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZm4sIGRlbGF5LCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBkZWxheTtcbiAgfTtcbn1cbmNvbnN0IF90b0xlZnRSaWdodENlbnRlciA9IChhbGlnbikgPT4gYWxpZ24gPT09ICdzdGFydCcgPyAnbGVmdCcgOiBhbGlnbiA9PT0gJ2VuZCcgPyAncmlnaHQnIDogJ2NlbnRlcic7XG5jb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbiwgc3RhcnQsIGVuZCkgPT4gYWxpZ24gPT09ICdzdGFydCcgPyBzdGFydCA6IGFsaWduID09PSAnZW5kJyA/IGVuZCA6IChzdGFydCArIGVuZCkgLyAyO1xuY29uc3QgX3RleHRYID0gKGFsaWduLCBsZWZ0LCByaWdodCwgcnRsKSA9PiB7XG4gIGNvbnN0IGNoZWNrID0gcnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgcmV0dXJuIGFsaWduID09PSBjaGVjayA/IHJpZ2h0IDogYWxpZ24gPT09ICdjZW50ZXInID8gKGxlZnQgKyByaWdodCkgLyAyIDogbGVmdDtcbn07XG5mdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICBjb25zdCBwb2ludENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMDtcbiAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcbiAgaWYgKG1ldGEuX3NvcnRlZCkge1xuICAgIGNvbnN0IHtpU2NhbGUsIF9wYXJzZWR9ID0gbWV0YTtcbiAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgY29uc3Qge21pbiwgbWF4LCBtaW5EZWZpbmVkLCBtYXhEZWZpbmVkfSA9IGlTY2FsZS5nZXRVc2VyQm91bmRzKCk7XG4gICAgaWYgKG1pbkRlZmluZWQpIHtcbiAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoTWF0aC5taW4oXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWluKS5sbyxcbiAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gcG9pbnRDb3VudCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1pbikpLmxvKSxcbiAgICAgIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgIGNvdW50ID0gX2xpbWl0VmFsdWUoTWF0aC5tYXgoXG4gICAgICAgIF9sb29rdXBCeUtleShfcGFyc2VkLCBpU2NhbGUuYXhpcywgbWF4LCB0cnVlKS5oaSArIDEsXG4gICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IDAgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtYXgpLCB0cnVlKS5oaSArIDEpLFxuICAgICAgc3RhcnQsIHBvaW50Q291bnQpIC0gc3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBjb3VudH07XG59XG5mdW5jdGlvbiBfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpIHtcbiAgY29uc3Qge3hTY2FsZSwgeVNjYWxlLCBfc2NhbGVSYW5nZXN9ID0gbWV0YTtcbiAgY29uc3QgbmV3UmFuZ2VzID0ge1xuICAgIHhtaW46IHhTY2FsZS5taW4sXG4gICAgeG1heDogeFNjYWxlLm1heCxcbiAgICB5bWluOiB5U2NhbGUubWluLFxuICAgIHltYXg6IHlTY2FsZS5tYXhcbiAgfTtcbiAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICBtZXRhLl9zY2FsZVJhbmdlcyA9IG5ld1JhbmdlcztcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW5cblx0XHR8fCBfc2NhbGVSYW5nZXMueG1heCAhPT0geFNjYWxlLm1heFxuXHRcdHx8IF9zY2FsZVJhbmdlcy55bWluICE9PSB5U2NhbGUubWluXG5cdFx0fHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gIE9iamVjdC5hc3NpZ24oX3NjYWxlUmFuZ2VzLCBuZXdSYW5nZXMpO1xuICByZXR1cm4gY2hhbmdlZDtcbn1cblxuY29uc3QgYXRFZGdlID0gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMTtcbmNvbnN0IGVsYXN0aWNJbiA9ICh0LCBzLCBwKSA9PiAtKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCkgPT4gTWF0aC5wb3coMiwgLTEwICogdCkgKiBNYXRoLnNpbigodCAtIHMpICogVEFVIC8gcCkgKyAxO1xuY29uc3QgZWZmZWN0cyA9IHtcbiAgbGluZWFyOiB0ID0+IHQsXG4gIGVhc2VJblF1YWQ6IHQgPT4gdCAqIHQsXG4gIGVhc2VPdXRRdWFkOiB0ID0+IC10ICogKHQgLSAyKSxcbiAgZWFzZUluT3V0UXVhZDogdCA9PiAoKHQgLz0gMC41KSA8IDEpXG4gICAgPyAwLjUgKiB0ICogdFxuICAgIDogLTAuNSAqICgoLS10KSAqICh0IC0gMikgLSAxKSxcbiAgZWFzZUluQ3ViaWM6IHQgPT4gdCAqIHQgKiB0LFxuICBlYXNlT3V0Q3ViaWM6IHQgPT4gKHQgLT0gMSkgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dEN1YmljOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdFxuICAgIDogMC41ICogKCh0IC09IDIpICogdCAqIHQgKyAyKSxcbiAgZWFzZUluUXVhcnQ6IHQgPT4gdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1YXJ0OiB0ID0+IC0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcbiAgZWFzZUluT3V0UXVhcnQ6IHQgPT4gKCh0IC89IDAuNSkgPCAxKVxuICAgID8gMC41ICogdCAqIHQgKiB0ICogdFxuICAgIDogLTAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAtIDIpLFxuICBlYXNlSW5RdWludDogdCA9PiB0ICogdCAqIHQgKiB0ICogdCxcbiAgZWFzZU91dFF1aW50OiB0ID0+ICh0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG4gIGVhc2VJbk91dFF1aW50OiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IDAuNSAqIHQgKiB0ICogdCAqIHQgKiB0XG4gICAgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCAqIHQgKiB0ICsgMiksXG4gIGVhc2VJblNpbmU6IHQgPT4gLU1hdGguY29zKHQgKiBIQUxGX1BJKSArIDEsXG4gIGVhc2VPdXRTaW5lOiB0ID0+IE1hdGguc2luKHQgKiBIQUxGX1BJKSxcbiAgZWFzZUluT3V0U2luZTogdCA9PiAtMC41ICogKE1hdGguY29zKFBJICogdCkgLSAxKSxcbiAgZWFzZUluRXhwbzogdCA9PiAodCA9PT0gMCkgPyAwIDogTWF0aC5wb3coMiwgMTAgKiAodCAtIDEpKSxcbiAgZWFzZU91dEV4cG86IHQgPT4gKHQgPT09IDEpID8gMSA6IC1NYXRoLnBvdygyLCAtMTAgKiB0KSArIDEsXG4gIGVhc2VJbk91dEV4cG86IHQgPT4gYXRFZGdlKHQpID8gdCA6IHQgPCAwLjVcbiAgICA/IDAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgKiAyIC0gMSkpXG4gICAgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuICBlYXNlSW5DaXJjOiB0ID0+ICh0ID49IDEpID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcbiAgZWFzZU91dENpcmM6IHQgPT4gTWF0aC5zcXJ0KDEgLSAodCAtPSAxKSAqIHQpLFxuICBlYXNlSW5PdXRDaXJjOiB0ID0+ICgodCAvPSAwLjUpIDwgMSlcbiAgICA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKVxuICAgIDogMC41ICogKE1hdGguc3FydCgxIC0gKHQgLT0gMikgKiB0KSArIDEpLFxuICBlYXNlSW5FbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG4gIGVhc2VPdXRFbGFzdGljOiB0ID0+IGF0RWRnZSh0KSA/IHQgOiBlbGFzdGljT3V0KHQsIDAuMDc1LCAwLjMpLFxuICBlYXNlSW5PdXRFbGFzdGljKHQpIHtcbiAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgIGNvbnN0IHAgPSAwLjQ1O1xuICAgIHJldHVybiBhdEVkZ2UodCkgPyB0IDpcbiAgICAgIHQgPCAwLjVcbiAgICAgICAgPyAwLjUgKiBlbGFzdGljSW4odCAqIDIsIHMsIHApXG4gICAgICAgIDogMC41ICsgMC41ICogZWxhc3RpY091dCh0ICogMiAtIDEsIHMsIHApO1xuICB9LFxuICBlYXNlSW5CYWNrKHQpIHtcbiAgICBjb25zdCBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gdCAqIHQgKiAoKHMgKyAxKSAqIHQgLSBzKTtcbiAgfSxcbiAgZWFzZU91dEJhY2sodCkge1xuICAgIGNvbnN0IHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gIH0sXG4gIGVhc2VJbk91dEJhY2sodCkge1xuICAgIGxldCBzID0gMS43MDE1ODtcbiAgICBpZiAoKHQgLz0gMC41KSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiAodCAqIHQgKiAoKChzICo9ICgxLjUyNSkpICsgMSkgKiB0IC0gcykpO1xuICAgIH1cbiAgICByZXR1cm4gMC41ICogKCh0IC09IDIpICogdCAqICgoKHMgKj0gKDEuNTI1KSkgKyAxKSAqIHQgKyBzKSArIDIpO1xuICB9LFxuICBlYXNlSW5Cb3VuY2U6IHQgPT4gMSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG4gIGVhc2VPdXRCb3VuY2UodCkge1xuICAgIGNvbnN0IG0gPSA3LjU2MjU7XG4gICAgY29uc3QgZCA9IDIuNzU7XG4gICAgaWYgKHQgPCAoMSAvIGQpKSB7XG4gICAgICByZXR1cm4gbSAqIHQgKiB0O1xuICAgIH1cbiAgICBpZiAodCA8ICgyIC8gZCkpIHtcbiAgICAgIHJldHVybiBtICogKHQgLT0gKDEuNSAvIGQpKSAqIHQgKyAwLjc1O1xuICAgIH1cbiAgICBpZiAodCA8ICgyLjUgLyBkKSkge1xuICAgICAgcmV0dXJuIG0gKiAodCAtPSAoMi4yNSAvIGQpKSAqIHQgKyAwLjkzNzU7XG4gICAgfVxuICAgIHJldHVybiBtICogKHQgLT0gKDIuNjI1IC8gZCkpICogdCArIDAuOTg0Mzc1O1xuICB9LFxuICBlYXNlSW5PdXRCb3VuY2U6IHQgPT4gKHQgPCAwLjUpXG4gICAgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjVcbiAgICA6IGVmZmVjdHMuZWFzZU91dEJvdW5jZSh0ICogMiAtIDEpICogMC41ICsgMC41LFxufTtcblxuLyohXG4gKiBAa3Vya2xlL2NvbG9yIHYwLjIuMVxuICogaHR0cHM6Ly9naXRodWIuY29tL2t1cmtsZS9jb2xvciNyZWFkbWVcbiAqIChjKSAyMDIyIEp1a2thIEt1cmtlbGFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5mdW5jdGlvbiByb3VuZCh2KSB7XG4gIHJldHVybiB2ICsgMC41IHwgMDtcbn1cbmNvbnN0IGxpbSA9ICh2LCBsLCBoKSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBoKSwgbCk7XG5mdW5jdGlvbiBwMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyLjU1KSwgMCwgMjU1KTtcbn1cbmZ1bmN0aW9uIG4yYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDI1NSksIDAsIDI1NSk7XG59XG5mdW5jdGlvbiBiMm4odikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgLyAyLjU1KSAvIDEwMCwgMCwgMSk7XG59XG5mdW5jdGlvbiBuMnAodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAxMDApLCAwLCAxMDApO1xufVxuY29uc3QgbWFwJDEgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSBbLi4uJzAxMjM0NTY3ODlBQkNERUYnXTtcbmNvbnN0IGgxID0gYiA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IGIgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IGIgPT4gKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKTtcbmNvbnN0IGlzU2hvcnQgPSB2ID0+IGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciByZXQ7XG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IDI1NSAmIG1hcCQxW3N0clsxXV0gKiAxNyxcbiAgICAgICAgZzogMjU1ICYgbWFwJDFbc3RyWzJdXSAqIDE3LFxuICAgICAgICBiOiAyNTUgJiBtYXAkMVtzdHJbM11dICogMTcsXG4gICAgICAgIGE6IGxlbiA9PT0gNSA/IG1hcCQxW3N0cls0XV0gKiAxNyA6IDI1NVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gNyB8fCBsZW4gPT09IDkpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogbWFwJDFbc3RyWzFdXSA8PCA0IHwgbWFwJDFbc3RyWzJdXSxcbiAgICAgICAgZzogbWFwJDFbc3RyWzNdXSA8PCA0IHwgbWFwJDFbc3RyWzRdXSxcbiAgICAgICAgYjogbWFwJDFbc3RyWzVdXSA8PCA0IHwgbWFwJDFbc3RyWzZdXSxcbiAgICAgICAgYTogbGVuID09PSA5ID8gKG1hcCQxW3N0cls3XV0gPDwgNCB8IG1hcCQxW3N0cls4XV0pIDogMjU1XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY29uc3QgYWxwaGEgPSAoYSwgZikgPT4gYSA8IDI1NSA/IGYoYSkgOiAnJztcbmZ1bmN0aW9uIGhleFN0cmluZyh2KSB7XG4gIHZhciBmID0gaXNTaG9ydCh2KSA/IGgxIDogaDI7XG4gIHJldHVybiB2XG4gICAgPyAnIycgKyBmKHYucikgKyBmKHYuZykgKyBmKHYuYikgKyBhbHBoYSh2LmEsIGYpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5jb25zdCBIVUVfUkUgPSAvXihoc2xhP3xod2J8aHN2KVxcKFxccyooWy0rLmVcXGRdKykoPzpkZWcpP1tcXHMsXSsoWy0rLmVcXGRdKyklW1xccyxdKyhbLSsuZVxcZF0rKSUoPzpbXFxzLF0rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gaHNsMnJnYm4oaCwgcywgbCkge1xuICBjb25zdCBhID0gcyAqIE1hdGgubWluKGwsIDEgLSBsKTtcbiAgY29uc3QgZiA9IChuLCBrID0gKG4gKyBoIC8gMzApICUgMTIpID0+IGwgLSBhICogTWF0aC5tYXgoTWF0aC5taW4oayAtIDMsIDkgLSBrLCAxKSwgLTEpO1xuICByZXR1cm4gW2YoMCksIGYoOCksIGYoNCldO1xufVxuZnVuY3Rpb24gaHN2MnJnYm4oaCwgcywgdikge1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyA2MCkgJSA2KSA9PiB2IC0gdiAqIHMgKiBNYXRoLm1heChNYXRoLm1pbihrLCA0IC0gaywgMSksIDApO1xuICByZXR1cm4gW2YoNSksIGYoMyksIGYoMSldO1xufVxuZnVuY3Rpb24gaHdiMnJnYm4oaCwgdywgYikge1xuICBjb25zdCByZ2IgPSBoc2wycmdibihoLCAxLCAwLjUpO1xuICBsZXQgaTtcbiAgaWYgKHcgKyBiID4gMSkge1xuICAgIGkgPSAxIC8gKHcgKyBiKTtcbiAgICB3ICo9IGk7XG4gICAgYiAqPSBpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICByZ2JbaV0gKj0gMSAtIHcgLSBiO1xuICAgIHJnYltpXSArPSB3O1xuICB9XG4gIHJldHVybiByZ2I7XG59XG5mdW5jdGlvbiBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpIHtcbiAgaWYgKHIgPT09IG1heCkge1xuICAgIHJldHVybiAoKGcgLSBiKSAvIGQpICsgKGcgPCBiID8gNiA6IDApO1xuICB9XG4gIGlmIChnID09PSBtYXgpIHtcbiAgICByZXR1cm4gKGIgLSByKSAvIGQgKyAyO1xuICB9XG4gIHJldHVybiAociAtIGcpIC8gZCArIDQ7XG59XG5mdW5jdGlvbiByZ2IyaHNsKHYpIHtcbiAgY29uc3QgcmFuZ2UgPSAyNTU7XG4gIGNvbnN0IHIgPSB2LnIgLyByYW5nZTtcbiAgY29uc3QgZyA9IHYuZyAvIHJhbmdlO1xuICBjb25zdCBiID0gdi5iIC8gcmFuZ2U7XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgbGV0IGgsIHMsIGQ7XG4gIGlmIChtYXggIT09IG1pbikge1xuICAgIGQgPSBtYXggLSBtaW47XG4gICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xuICAgIGggPSBodWVWYWx1ZShyLCBnLCBiLCBkLCBtYXgpO1xuICAgIGggPSBoICogNjAgKyAwLjU7XG4gIH1cbiAgcmV0dXJuIFtoIHwgMCwgcyB8fCAwLCBsXTtcbn1cbmZ1bmN0aW9uIGNhbGxuKGYsIGEsIGIsIGMpIHtcbiAgcmV0dXJuIChcbiAgICBBcnJheS5pc0FycmF5KGEpXG4gICAgICA/IGYoYVswXSwgYVsxXSwgYVsyXSlcbiAgICAgIDogZihhLCBiLCBjKVxuICApLm1hcChuMmIpO1xufVxuZnVuY3Rpb24gaHNsMnJnYihoLCBzLCBsKSB7XG4gIHJldHVybiBjYWxsbihoc2wycmdibiwgaCwgcywgbCk7XG59XG5mdW5jdGlvbiBod2IycmdiKGgsIHcsIGIpIHtcbiAgcmV0dXJuIGNhbGxuKGh3YjJyZ2JuLCBoLCB3LCBiKTtcbn1cbmZ1bmN0aW9uIGhzdjJyZ2IoaCwgcywgdikge1xuICByZXR1cm4gY2FsbG4oaHN2MnJnYm4sIGgsIHMsIHYpO1xufVxuZnVuY3Rpb24gaHVlKGgpIHtcbiAgcmV0dXJuIChoICUgMzYwICsgMzYwKSAlIDM2MDtcbn1cbmZ1bmN0aW9uIGh1ZVBhcnNlKHN0cikge1xuICBjb25zdCBtID0gSFVFX1JFLmV4ZWMoc3RyKTtcbiAgbGV0IGEgPSAyNTU7XG4gIGxldCB2O1xuICBpZiAoIW0pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1bNV0gIT09IHYpIHtcbiAgICBhID0gbVs2XSA/IHAyYigrbVs1XSkgOiBuMmIoK21bNV0pO1xuICB9XG4gIGNvbnN0IGggPSBodWUoK21bMl0pO1xuICBjb25zdCBwMSA9ICttWzNdIC8gMTAwO1xuICBjb25zdCBwMiA9ICttWzRdIC8gMTAwO1xuICBpZiAobVsxXSA9PT0gJ2h3YicpIHtcbiAgICB2ID0gaHdiMnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2UgaWYgKG1bMV0gPT09ICdoc3YnKSB7XG4gICAgdiA9IGhzdjJyZ2IoaCwgcDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICB2ID0gaHNsMnJnYihoLCBwMSwgcDIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgcjogdlswXSxcbiAgICBnOiB2WzFdLFxuICAgIGI6IHZbMl0sXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcm90YXRlKHYsIGRlZykge1xuICB2YXIgaCA9IHJnYjJoc2wodik7XG4gIGhbMF0gPSBodWUoaFswXSArIGRlZyk7XG4gIGggPSBoc2wycmdiKGgpO1xuICB2LnIgPSBoWzBdO1xuICB2LmcgPSBoWzFdO1xuICB2LmIgPSBoWzJdO1xufVxuZnVuY3Rpb24gaHNsU3RyaW5nKHYpIHtcbiAgaWYgKCF2KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSByZ2IyaHNsKHYpO1xuICBjb25zdCBoID0gYVswXTtcbiAgY29uc3QgcyA9IG4ycChhWzFdKTtcbiAgY29uc3QgbCA9IG4ycChhWzJdKTtcbiAgcmV0dXJuIHYuYSA8IDI1NVxuICAgID8gYGhzbGEoJHtofSwgJHtzfSUsICR7bH0lLCAke2Iybih2LmEpfSlgXG4gICAgOiBgaHNsKCR7aH0sICR7c30lLCAke2x9JSlgO1xufVxuY29uc3QgbWFwID0ge1xuICB4OiAnZGFyaycsXG4gIFo6ICdsaWdodCcsXG4gIFk6ICdyZScsXG4gIFg6ICdibHUnLFxuICBXOiAnZ3InLFxuICBWOiAnbWVkaXVtJyxcbiAgVTogJ3NsYXRlJyxcbiAgQTogJ2VlJyxcbiAgVDogJ29sJyxcbiAgUzogJ29yJyxcbiAgQjogJ3JhJyxcbiAgQzogJ2xhdGVnJyxcbiAgRDogJ2lnaHRzJyxcbiAgUjogJ2luJyxcbiAgUTogJ3R1cnF1b2lzJyxcbiAgRTogJ2hpJyxcbiAgUDogJ3JvJyxcbiAgTzogJ2FsJyxcbiAgTjogJ2xlJyxcbiAgTTogJ2RlJyxcbiAgTDogJ3llbGxvJyxcbiAgRjogJ2VuJyxcbiAgSzogJ2NoJyxcbiAgRzogJ2Fya3MnLFxuICBIOiAnZWEnLFxuICBJOiAnaWdodGcnLFxuICBKOiAnd2gnXG59O1xuY29uc3QgbmFtZXMkMSA9IHtcbiAgT2ljZVhlOiAnZjBmOGZmJyxcbiAgYW50aXF1ZXdFdGU6ICdmYWViZDcnLFxuICBhcXVhOiAnZmZmZicsXG4gIGFxdWFtYXJSZTogJzdmZmZkNCcsXG4gIGF6dVk6ICdmMGZmZmYnLFxuICBiZWlnZTogJ2Y1ZjVkYycsXG4gIGJpc3F1ZTogJ2ZmZTRjNCcsXG4gIGJsYWNrOiAnMCcsXG4gIGJsYW5LZWRPbW9uZDogJ2ZmZWJjZCcsXG4gIFhlOiAnZmYnLFxuICBYZXZpVGV0OiAnOGEyYmUyJyxcbiAgYlB3bjogJ2E1MmEyYScsXG4gIGJ1cmx5d29vZDogJ2RlYjg4NycsXG4gIGNhTXRYZTogJzVmOWVhMCcsXG4gIEthcnRZdXNlOiAnN2ZmZjAwJyxcbiAgS29jVGF0ZTogJ2QyNjkxZScsXG4gIGNTTzogJ2ZmN2Y1MCcsXG4gIGNTbmZsb3dlclhlOiAnNjQ5NWVkJyxcbiAgY1Nuc2lsazogJ2ZmZjhkYycsXG4gIGNyaW1zb246ICdkYzE0M2MnLFxuICBjeWFuOiAnZmZmZicsXG4gIHhYZTogJzhiJyxcbiAgeGN5YW46ICc4YjhiJyxcbiAgeGdUTW5QZDogJ2I4ODYwYicsXG4gIHhXYXk6ICdhOWE5YTknLFxuICB4Z1lGOiAnNjQwMCcsXG4gIHhnWXk6ICdhOWE5YTknLFxuICB4a2hha2k6ICdiZGI3NmInLFxuICB4bWFnRnRhOiAnOGIwMDhiJyxcbiAgeFRpdmVnWUY6ICc1NTZiMmYnLFxuICB4U2FuZ2U6ICdmZjhjMDAnLFxuICB4U2NFZDogJzk5MzJjYycsXG4gIHhZZDogJzhiMDAwMCcsXG4gIHhzT21vbjogJ2U5OTY3YScsXG4gIHhzSGdZRjogJzhmYmM4ZicsXG4gIHhVWGU6ICc0ODNkOGInLFxuICB4VVdheTogJzJmNGY0ZicsXG4gIHhVZ1l5OiAnMmY0ZjRmJyxcbiAgeFFlOiAnY2VkMScsXG4gIHh2aVRldDogJzk0MDBkMycsXG4gIGRBcHBSazogJ2ZmMTQ5MycsXG4gIGRBcHNreVhlOiAnYmZmZicsXG4gIGRpbVdheTogJzY5Njk2OScsXG4gIGRpbWdZeTogJzY5Njk2OScsXG4gIGRvZGdlclhlOiAnMWU5MGZmJyxcbiAgZmlZYnJpY2s6ICdiMjIyMjInLFxuICBmbFNPd0V0ZTogJ2ZmZmFmMCcsXG4gIGZvWXN0V0FuOiAnMjI4YjIyJyxcbiAgZnVLc2lhOiAnZmYwMGZmJyxcbiAgZ2FSc2JTbzogJ2RjZGNkYycsXG4gIGdob3N0d0V0ZTogJ2Y4ZjhmZicsXG4gIGdUZDogJ2ZmZDcwMCcsXG4gIGdUTW5QZDogJ2RhYTUyMCcsXG4gIFdheTogJzgwODA4MCcsXG4gIGdZRjogJzgwMDAnLFxuICBnWUZMdzogJ2FkZmYyZicsXG4gIGdZeTogJzgwODA4MCcsXG4gIGhvbmV5TXc6ICdmMGZmZjAnLFxuICBob3RwUms6ICdmZjY5YjQnLFxuICBSZGlhbllkOiAnY2Q1YzVjJyxcbiAgUmRpZ286ICc0YjAwODInLFxuICBpdlN5OiAnZmZmZmYwJyxcbiAga2hha2k6ICdmMGU2OGMnLFxuICBsYXZGTXI6ICdlNmU2ZmEnLFxuICBsYXZGTXJYc2g6ICdmZmYwZjUnLFxuICBsYXduZ1lGOiAnN2NmYzAwJyxcbiAgTm1vbmNFZmZvbjogJ2ZmZmFjZCcsXG4gIFpYZTogJ2FkZDhlNicsXG4gIFpjU086ICdmMDgwODAnLFxuICBaY3lhbjogJ2UwZmZmZicsXG4gIFpnVE1uUGRMdzogJ2ZhZmFkMicsXG4gIFpXYXk6ICdkM2QzZDMnLFxuICBaZ1lGOiAnOTBlZTkwJyxcbiAgWmdZeTogJ2QzZDNkMycsXG4gIFpwUms6ICdmZmI2YzEnLFxuICBac09tb246ICdmZmEwN2EnLFxuICBac0hnWUY6ICcyMGIyYWEnLFxuICBac2t5WGU6ICc4N2NlZmEnLFxuICBaVVdheTogJzc3ODg5OScsXG4gIFpVZ1l5OiAnNzc4ODk5JyxcbiAgWnN0QWxYZTogJ2IwYzRkZScsXG4gIFpMdzogJ2ZmZmZlMCcsXG4gIGxpbWU6ICdmZjAwJyxcbiAgbGltZWdZRjogJzMyY2QzMicsXG4gIGxSRjogJ2ZhZjBlNicsXG4gIG1hZ0Z0YTogJ2ZmMDBmZicsXG4gIG1hUG9uOiAnODAwMDAwJyxcbiAgVmFxdWFtYXJSZTogJzY2Y2RhYScsXG4gIFZYZTogJ2NkJyxcbiAgVlNjRWQ6ICdiYTU1ZDMnLFxuICBWcHVycE46ICc5MzcwZGInLFxuICBWc0hnWUY6ICczY2IzNzEnLFxuICBWVVhlOiAnN2I2OGVlJyxcbiAgVnNwclJnZ1lGOiAnZmE5YScsXG4gIFZRZTogJzQ4ZDFjYycsXG4gIFZ2aVRldFlkOiAnYzcxNTg1JyxcbiAgbWlkbmlnaHRYZTogJzE5MTk3MCcsXG4gIG1SdGNZYW06ICdmNWZmZmEnLFxuICBtaXN0eVBzZTogJ2ZmZTRlMScsXG4gIG1vY2Nhc1I6ICdmZmU0YjUnLFxuICBuYXZham93RXRlOiAnZmZkZWFkJyxcbiAgbmF2eTogJzgwJyxcbiAgVGRsYWNlOiAnZmRmNWU2JyxcbiAgVGl2ZTogJzgwODAwMCcsXG4gIFRpdmVkQmI6ICc2YjhlMjMnLFxuICBTYW5nZTogJ2ZmYTUwMCcsXG4gIFNhbmdlWWQ6ICdmZjQ1MDAnLFxuICBTY0VkOiAnZGE3MGQ2JyxcbiAgcE9lZ1RNblBkOiAnZWVlOGFhJyxcbiAgcE9lZ1lGOiAnOThmYjk4JyxcbiAgcE9lUWU6ICdhZmVlZWUnLFxuICBwT2V2aVRldFlkOiAnZGI3MDkzJyxcbiAgcGFwYXlhd0VwOiAnZmZlZmQ1JyxcbiAgcEhLcHVmZjogJ2ZmZGFiOScsXG4gIHBlcnU6ICdjZDg1M2YnLFxuICBwUms6ICdmZmMwY2InLFxuICBwbHVtOiAnZGRhMGRkJyxcbiAgcG93TXJYZTogJ2IwZTBlNicsXG4gIHB1cnBOOiAnODAwMDgwJyxcbiAgWWJlY2NhcHVycE46ICc2NjMzOTknLFxuICBZZDogJ2ZmMDAwMCcsXG4gIFBzeWJyb3duOiAnYmM4ZjhmJyxcbiAgUHlPWGU6ICc0MTY5ZTEnLFxuICBzYWRkTmJQd246ICc4YjQ1MTMnLFxuICBzT21vbjogJ2ZhODA3MicsXG4gIHNhbmR5YlB3bjogJ2Y0YTQ2MCcsXG4gIHNIZ1lGOiAnMmU4YjU3JyxcbiAgc0hzaGVsbDogJ2ZmZjVlZScsXG4gIHNpRm5hOiAnYTA1MjJkJyxcbiAgc2lsdmVyOiAnYzBjMGMwJyxcbiAgc2t5WGU6ICc4N2NlZWInLFxuICBVWGU6ICc2YTVhY2QnLFxuICBVV2F5OiAnNzA4MDkwJyxcbiAgVWdZeTogJzcwODA5MCcsXG4gIHNub3c6ICdmZmZhZmEnLFxuICBzcHJSZ2dZRjogJ2ZmN2YnLFxuICBzdEFsWGU6ICc0NjgyYjQnLFxuICB0YW46ICdkMmI0OGMnLFxuICB0ZU86ICc4MDgwJyxcbiAgdEVzdE46ICdkOGJmZDgnLFxuICB0b21hdG86ICdmZjYzNDcnLFxuICBRZTogJzQwZTBkMCcsXG4gIHZpVGV0OiAnZWU4MmVlJyxcbiAgSkh0OiAnZjVkZWIzJyxcbiAgd0V0ZTogJ2ZmZmZmZicsXG4gIHdFdGVzbW9rZTogJ2Y1ZjVmNScsXG4gIEx3OiAnZmZmZjAwJyxcbiAgTHdnWUY6ICc5YWNkMzInXG59O1xuZnVuY3Rpb24gdW5wYWNrKCkge1xuICBjb25zdCB1bnBhY2tlZCA9IHt9O1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobmFtZXMkMSk7XG4gIGNvbnN0IHRrZXlzID0gT2JqZWN0LmtleXMobWFwKTtcbiAgbGV0IGksIGosIGssIG9rLCBuaztcbiAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBvayA9IG5rID0ga2V5c1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgdGtleXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGsgPSB0a2V5c1tqXTtcbiAgICAgIG5rID0gbmsucmVwbGFjZShrLCBtYXBba10pO1xuICAgIH1cbiAgICBrID0gcGFyc2VJbnQobmFtZXMkMVtva10sIDE2KTtcbiAgICB1bnBhY2tlZFtua10gPSBbayA+PiAxNiAmIDB4RkYsIGsgPj4gOCAmIDB4RkYsIGsgJiAweEZGXTtcbiAgfVxuICByZXR1cm4gdW5wYWNrZWQ7XG59XG5sZXQgbmFtZXM7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG4gIGlmICghbmFtZXMpIHtcbiAgICBuYW1lcyA9IHVucGFjaygpO1xuICAgIG5hbWVzLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuICB9XG4gIGNvbnN0IGEgPSBuYW1lc1tzdHIudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhICYmIHtcbiAgICByOiBhWzBdLFxuICAgIGc6IGFbMV0sXG4gICAgYjogYVsyXSxcbiAgICBhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcbiAgfTtcbn1cbmNvbnN0IFJHQl9SRSA9IC9ecmdiYT9cXChcXHMqKFstKy5cXGRdKykoJSk/W1xccyxdKyhbLSsuZVxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpPyg/OltcXHMsL10rKFstKy5lXFxkXSspKCUpPyk/XFxzKlxcKSQvO1xuZnVuY3Rpb24gcmdiUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBSR0JfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHIsIGcsIGI7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs3XSAhPT0gcikge1xuICAgIGNvbnN0IHYgPSArbVs3XTtcbiAgICBhID0gbVs4XSA/IHAyYih2KSA6IGxpbSh2ICogMjU1LCAwLCAyNTUpO1xuICB9XG4gIHIgPSArbVsxXTtcbiAgZyA9ICttWzNdO1xuICBiID0gK21bNV07XG4gIHIgPSAyNTUgJiAobVsyXSA/IHAyYihyKSA6IGxpbShyLCAwLCAyNTUpKTtcbiAgZyA9IDI1NSAmIChtWzRdID8gcDJiKGcpIDogbGltKGcsIDAsIDI1NSkpO1xuICBiID0gMjU1ICYgKG1bNl0gPyBwMmIoYikgOiBsaW0oYiwgMCwgMjU1KSk7XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxuZnVuY3Rpb24gcmdiU3RyaW5nKHYpIHtcbiAgcmV0dXJuIHYgJiYgKFxuICAgIHYuYSA8IDI1NVxuICAgICAgPyBgcmdiYSgke3Yucn0sICR7di5nfSwgJHt2LmJ9LCAke2Iybih2LmEpfSlgXG4gICAgICA6IGByZ2IoJHt2LnJ9LCAke3YuZ30sICR7di5ifSlgXG4gICk7XG59XG5jb25zdCB0byA9IHYgPT4gdiA8PSAwLjAwMzEzMDggPyB2ICogMTIuOTIgOiBNYXRoLnBvdyh2LCAxLjAgLyAyLjQpICogMS4wNTUgLSAwLjA1NTtcbmNvbnN0IGZyb20gPSB2ID0+IHYgPD0gMC4wNDA0NSA/IHYgLyAxMi45MiA6IE1hdGgucG93KCh2ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShyZ2IxLCByZ2IyLCB0KSB7XG4gIGNvbnN0IHIgPSBmcm9tKGIybihyZ2IxLnIpKTtcbiAgY29uc3QgZyA9IGZyb20oYjJuKHJnYjEuZykpO1xuICBjb25zdCBiID0gZnJvbShiMm4ocmdiMS5iKSk7XG4gIHJldHVybiB7XG4gICAgcjogbjJiKHRvKHIgKyB0ICogKGZyb20oYjJuKHJnYjIucikpIC0gcikpKSxcbiAgICBnOiBuMmIodG8oZyArIHQgKiAoZnJvbShiMm4ocmdiMi5nKSkgLSBnKSkpLFxuICAgIGI6IG4yYih0byhiICsgdCAqIChmcm9tKGIybihyZ2IyLmIpKSAtIGIpKSksXG4gICAgYTogcmdiMS5hICsgdCAqIChyZ2IyLmEgLSByZ2IxLmEpXG4gIH07XG59XG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcbiAgaWYgKHYpIHtcbiAgICBsZXQgdG1wID0gcmdiMmhzbCh2KTtcbiAgICB0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcbiAgICB0bXAgPSBoc2wycmdiKHRtcCk7XG4gICAgdi5yID0gdG1wWzBdO1xuICAgIHYuZyA9IHRtcFsxXTtcbiAgICB2LmIgPSB0bXBbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lKHYsIHByb3RvKSB7XG4gIHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuICB2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG4gICAgICAgIHYuYSA9IG4yYihpbnB1dFszXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBjbG9uZShpbnB1dCwge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9KTtcbiAgICB2LmEgPSBuMmIodi5hKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApID09PSAncicpIHtcbiAgICByZXR1cm4gcmdiUGFyc2Uoc3RyKTtcbiAgfVxuICByZXR1cm4gaHVlUGFyc2Uoc3RyKTtcbn1cbmNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIGxldCB2O1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdiA9IGZyb21PYmplY3QoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSBoZXhQYXJzZShpbnB1dCkgfHwgbmFtZVBhcnNlKGlucHV0KSB8fCBmdW5jdGlvblBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhpcy5fcmdiID0gdjtcbiAgICB0aGlzLl92YWxpZCA9ICEhdjtcbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICB9XG4gIGdldCByZ2IoKSB7XG4gICAgdmFyIHYgPSBjbG9uZSh0aGlzLl9yZ2IpO1xuICAgIGlmICh2KSB7XG4gICAgICB2LmEgPSBiMm4odi5hKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgc2V0IHJnYihvYmopIHtcbiAgICB0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XG4gIH1cbiAgcmdiU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhleFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoc2xTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbWl4KGNvbG9yLCB3ZWlnaHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5yZ2I7XG4gICAgICBjb25zdCBjMiA9IGNvbG9yLnJnYjtcbiAgICAgIGxldCB3MjtcbiAgICAgIGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuICAgICAgY29uc3QgdyA9IDIgKiBwIC0gMTtcbiAgICAgIGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcbiAgICAgIGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgdzIgPSAxIC0gdzE7XG4gICAgICBjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcbiAgICAgIGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuICAgICAgYzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG4gICAgICBjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcbiAgICAgIHRoaXMucmdiID0gYzE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludGVycG9sYXRlKGNvbG9yLCB0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBpbnRlcnBvbGF0ZSh0aGlzLl9yZ2IsIGNvbG9yLl9yZ2IsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKTtcbiAgfVxuICBhbHBoYShhKSB7XG4gICAgdGhpcy5fcmdiLmEgPSBuMmIoYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxIC0gcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JleXNjYWxlKCkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICBjb25zdCB2YWwgPSByb3VuZChyZ2IuciAqIDAuMyArIHJnYi5nICogMC41OSArIHJnYi5iICogMC4xMSk7XG4gICAgcmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9wYXF1ZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSArIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5fcmdiO1xuICAgIHYuciA9IDI1NSAtIHYucjtcbiAgICB2LmcgPSAyNTUgLSB2Lmc7XG4gICAgdi5iID0gMjU1IC0gdi5iO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpZ2h0ZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGFya2VuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3RhdGUoZGVnKSB7XG4gICAgcm90YXRlKHRoaXMuX3JnYiwgZGVnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuZnVuY3Rpb24gaW5kZXhfZXNtKGlucHV0KSB7XG4gIHJldHVybiBuZXcgQ29sb3IoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgY29uc3QgdHlwZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc1BhdHRlcm5dJyB8fCB0eXBlID09PSAnW29iamVjdCBDYW52YXNHcmFkaWVudF0nO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogaW5kZXhfZXNtKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEhvdmVyQ29sb3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpXG4gICAgPyB2YWx1ZVxuICAgIDogaW5kZXhfZXNtKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuXG5jb25zdCBvdmVycmlkZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcbiAgaWYgKCFrZXkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCBrZXlzID0ga2V5LnNwbGl0KCcuJyk7XG4gIGZvciAobGV0IGkgPSAwLCBuID0ga2V5cy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gc2V0KHJvb3QsIHNjb3BlLCB2YWx1ZXMpIHtcbiAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCBzY29wZSksIHZhbHVlcyk7XG4gIH1cbiAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgJycpLCBzY29wZSk7XG59XG5jbGFzcyBEZWZhdWx0cyB7XG4gIGNvbnN0cnVjdG9yKF9kZXNjcmlwdG9ycykge1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwwLDAsMC4xKSc7XG4gICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgIHRoaXMuY29sb3IgPSAnIzY2Nic7XG4gICAgdGhpcy5kYXRhc2V0cyA9IHt9O1xuICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KSA9PiBjb250ZXh0LmNoYXJ0LnBsYXRmb3JtLmdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICdtb3VzZW91dCcsXG4gICAgICAnY2xpY2snLFxuICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgJ3RvdWNobW92ZSdcbiAgICBdO1xuICAgIHRoaXMuZm9udCA9IHtcbiAgICAgIGZhbWlseTogXCInSGVsdmV0aWNhIE5ldWUnLCAnSGVsdmV0aWNhJywgJ0FyaWFsJywgc2Fucy1zZXJpZlwiLFxuICAgICAgc2l6ZTogMTIsXG4gICAgICBzdHlsZTogJ25vcm1hbCcsXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXG4gICAgICB3ZWlnaHQ6IG51bGxcbiAgICB9O1xuICAgIHRoaXMuaG92ZXIgPSB7fTtcbiAgICB0aGlzLmhvdmVyQmFja2dyb3VuZENvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgdGhpcy5ob3ZlckJvcmRlckNvbG9yID0gKGN0eCwgb3B0aW9ucykgPT4gZ2V0SG92ZXJDb2xvcihvcHRpb25zLmJvcmRlckNvbG9yKTtcbiAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKSA9PiBnZXRIb3ZlckNvbG9yKG9wdGlvbnMuY29sb3IpO1xuICAgIHRoaXMuaW5kZXhBeGlzID0gJ3gnO1xuICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5tYWludGFpbkFzcGVjdFJhdGlvID0gdHJ1ZTtcbiAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgIHRoaXMub25DbGljayA9IG51bGw7XG4gICAgdGhpcy5wYXJzaW5nID0gdHJ1ZTtcbiAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICB0aGlzLnJlc3BvbnNpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICB0aGlzLnNob3dMaW5lID0gdHJ1ZTtcbiAgICB0aGlzLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdHJ1ZTtcbiAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gIH1cbiAgc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICByZXR1cm4gc2V0KHRoaXMsIHNjb3BlLCB2YWx1ZXMpO1xuICB9XG4gIGdldChzY29wZSkge1xuICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgfVxuICBkZXNjcmliZShzY29wZSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHNldChkZXNjcmlwdG9ycywgc2NvcGUsIHZhbHVlcyk7XG4gIH1cbiAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgIHJldHVybiBzZXQob3ZlcnJpZGVzLCBzY29wZSwgdmFsdWVzKTtcbiAgfVxuICByb3V0ZShzY29wZSwgbmFtZSwgdGFyZ2V0U2NvcGUsIHRhcmdldE5hbWUpIHtcbiAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgIGNvbnN0IHRhcmdldFNjb3BlT2JqZWN0ID0gZ2V0U2NvcGUkMSh0aGlzLCB0YXJnZXRTY29wZSk7XG4gICAgY29uc3QgcHJpdmF0ZU5hbWUgPSAnXycgKyBuYW1lO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgIHZhbHVlOiBzY29wZU9iamVjdFtuYW1lXSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBbbmFtZV06IHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IGxvY2FsID0gdGhpc1twcml2YXRlTmFtZV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0U2NvcGVPYmplY3RbdGFyZ2V0TmFtZV07XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQobG9jYWwsIHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIHRoaXNbcHJpdmF0ZU5hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxudmFyIGRlZmF1bHRzID0gbmV3IERlZmF1bHRzKHtcbiAgX3NjcmlwdGFibGU6IChuYW1lKSA9PiAhbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICBfaW5kZXhhYmxlOiAobmFtZSkgPT4gbmFtZSAhPT0gJ2V2ZW50cycsXG4gIGhvdmVyOiB7XG4gICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gIH0sXG4gIGludGVyYWN0aW9uOiB7XG4gICAgX3NjcmlwdGFibGU6IGZhbHNlLFxuICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICB9XG59KTtcblxuZnVuY3Rpb24gdG9Gb250U3RyaW5nKGZvbnQpIHtcbiAgaWYgKCFmb250IHx8IGlzTnVsbE9yVW5kZWYoZm9udC5zaXplKSB8fCBpc051bGxPclVuZGVmKGZvbnQuZmFtaWx5KSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJylcblx0XHQrIChmb250LndlaWdodCA/IGZvbnQud2VpZ2h0ICsgJyAnIDogJycpXG5cdFx0KyBmb250LnNpemUgKyAncHggJ1xuXHRcdCsgZm9udC5mYW1pbHk7XG59XG5mdW5jdGlvbiBfbWVhc3VyZVRleHQoY3R4LCBkYXRhLCBnYywgbG9uZ2VzdCwgc3RyaW5nKSB7XG4gIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gIGlmICghdGV4dFdpZHRoKSB7XG4gICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgZ2MucHVzaChzdHJpbmcpO1xuICB9XG4gIGlmICh0ZXh0V2lkdGggPiBsb25nZXN0KSB7XG4gICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gIGNhY2hlID0gY2FjaGUgfHwge307XG4gIGxldCBkYXRhID0gY2FjaGUuZGF0YSA9IGNhY2hlLmRhdGEgfHwge307XG4gIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gIGlmIChjYWNoZS5mb250ICE9PSBmb250KSB7XG4gICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gW107XG4gICAgY2FjaGUuZm9udCA9IGZvbnQ7XG4gIH1cbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmZvbnQgPSBmb250O1xuICBsZXQgbG9uZ2VzdCA9IDA7XG4gIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgbGV0IGksIGosIGpsZW4sIHRoaW5nLCBuZXN0ZWRUaGluZztcbiAgZm9yIChpID0gMDsgaSA8IGlsZW47IGkrKykge1xuICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCAmJiB0aGluZyAhPT0gbnVsbCAmJiBpc0FycmF5KHRoaW5nKSAhPT0gdHJ1ZSkge1xuICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHRoaW5nKSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKykge1xuICAgICAgICBuZXN0ZWRUaGluZyA9IHRoaW5nW2pdO1xuICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICBsb25nZXN0ID0gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIG5lc3RlZFRoaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBjdHgucmVzdG9yZSgpO1xuICBjb25zdCBnY0xlbiA9IGdjLmxlbmd0aCAvIDI7XG4gIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGdjTGVuOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBkYXRhW2djW2ldXTtcbiAgICB9XG4gICAgZ2Muc3BsaWNlKDAsIGdjTGVuKTtcbiAgfVxuICByZXR1cm4gbG9uZ2VzdDtcbn1cbmZ1bmN0aW9uIF9hbGlnblBpeGVsKGNoYXJ0LCBwaXhlbCwgd2lkdGgpIHtcbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICBjb25zdCBoYWxmV2lkdGggPSB3aWR0aCAhPT0gMCA/IE1hdGgubWF4KHdpZHRoIC8gMiwgMC41KSA6IDA7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwaXhlbCAtIGhhbGZXaWR0aCkgKiBkZXZpY2VQaXhlbFJhdGlvKSAvIGRldmljZVBpeGVsUmF0aW8gKyBoYWxmV2lkdGg7XG59XG5mdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXMsIGN0eCkge1xuICBjdHggPSBjdHggfHwgY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBkcmF3UG9pbnQoY3R4LCBvcHRpb25zLCB4LCB5KSB7XG4gIGRyYXdQb2ludExlZ2VuZChjdHgsIG9wdGlvbnMsIHgsIHksIG51bGwpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGVnZW5kKGN0eCwgb3B0aW9ucywgeCwgeSwgdykge1xuICBsZXQgdHlwZSwgeE9mZnNldCwgeU9mZnNldCwgc2l6ZSwgY29ybmVyUmFkaXVzLCB3aWR0aDtcbiAgY29uc3Qgc3R5bGUgPSBvcHRpb25zLnBvaW50U3R5bGU7XG4gIGNvbnN0IHJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbjtcbiAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gIGxldCByYWQgPSAocm90YXRpb24gfHwgMCkgKiBSQURfUEVSX0RFRztcbiAgaWYgKHN0eWxlICYmIHR5cGVvZiBzdHlsZSA9PT0gJ29iamVjdCcpIHtcbiAgICB0eXBlID0gc3R5bGUudG9TdHJpbmcoKTtcbiAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGlzTmFOKHJhZGl1cykgfHwgcmFkaXVzIDw9IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBzd2l0Y2ggKHN0eWxlKSB7XG4gIGRlZmF1bHQ6XG4gICAgaWYgKHcpIHtcbiAgICAgIGN0eC5lbGxpcHNlKHgsIHksIHcgLyAyLCByYWRpdXMsIDAsIDAsIFRBVSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCAwLCBUQVUpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3RyaWFuZ2xlJzpcbiAgICBjdHgubW92ZVRvKHggKyBNYXRoLnNpbihyYWQpICogcmFkaXVzLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cywgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguc2luKHJhZCkgKiByYWRpdXMsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3RSb3VuZGVkJzpcbiAgICBjb3JuZXJSYWRpdXMgPSByYWRpdXMgKiAwLjUxNjtcbiAgICBzaXplID0gcmFkaXVzIC0gY29ybmVyUmFkaXVzO1xuICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICBjdHguYXJjKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgLSBQSSwgcmFkIC0gSEFMRl9QSSk7XG4gICAgY3R4LmFyYyh4ICsgeU9mZnNldCwgeSAtIHhPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gSEFMRl9QSSwgcmFkKTtcbiAgICBjdHguYXJjKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQsIHJhZCArIEhBTEZfUEkpO1xuICAgIGN0eC5hcmMoeCAtIHlPZmZzZXQsIHkgKyB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCArIEhBTEZfUEksIHJhZCArIFBJKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JlY3QnOlxuICAgIGlmICghcm90YXRpb24pIHtcbiAgICAgIHNpemUgPSBNYXRoLlNRUlQxXzIgKiByYWRpdXM7XG4gICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICBjdHgucmVjdCh4IC0gd2lkdGgsIHkgLSBzaXplLCAyICogd2lkdGgsIDIgKiBzaXplKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgY2FzZSAncmVjdFJvdCc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBicmVhaztcbiAgY2FzZSAnY3Jvc3NSb3QnOlxuICAgIHJhZCArPSBRVUFSVEVSX1BJO1xuICBjYXNlICdjcm9zcyc6XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdzdGFyJzpcbiAgICB4T2Zmc2V0ID0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGN0eC5tb3ZlVG8oeCArIHlPZmZzZXQsIHkgLSB4T2Zmc2V0KTtcbiAgICBjdHgubGluZVRvKHggLSB5T2Zmc2V0LCB5ICsgeE9mZnNldCk7XG4gICAgcmFkICs9IFFVQVJURVJfUEk7XG4gICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldCwgeSAtIHlPZmZzZXQpO1xuICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXQsIHkgKyB5T2Zmc2V0KTtcbiAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0LCB5IC0geE9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldCwgeSArIHhPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdsaW5lJzpcbiAgICB4T2Zmc2V0ID0gdyA/IHcgLyAyIDogTWF0aC5jb3MocmFkKSAqIHJhZGl1cztcbiAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgeE9mZnNldCwgeSArIHlPZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkYXNoJzpcbiAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgIGN0eC5saW5lVG8oeCArIE1hdGguY29zKHJhZCkgKiByYWRpdXMsIHkgKyBNYXRoLnNpbihyYWQpICogcmFkaXVzKTtcbiAgICBicmVhaztcbiAgfVxuICBjdHguZmlsbCgpO1xuICBpZiAob3B0aW9ucy5ib3JkZXJXaWR0aCA+IDApIHtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc1BvaW50SW5BcmVhKHBvaW50LCBhcmVhLCBtYXJnaW4pIHtcbiAgbWFyZ2luID0gbWFyZ2luIHx8IDAuNTtcbiAgcmV0dXJuICFhcmVhIHx8IChwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmXG5cdFx0cG9pbnQueSA+IGFyZWEudG9wIC0gbWFyZ2luICYmIHBvaW50LnkgPCBhcmVhLmJvdHRvbSArIG1hcmdpbik7XG59XG5mdW5jdGlvbiBjbGlwQXJlYShjdHgsIGFyZWEpIHtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgY3R4LmNsaXAoKTtcbn1cbmZ1bmN0aW9uIHVuY2xpcEFyZWEoY3R4KSB7XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBfc3RlcHBlZExpbmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXAsIG1vZGUpIHtcbiAgaWYgKCFwcmV2aW91cykge1xuICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gIH1cbiAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgY29uc3QgbWlkcG9pbnQgPSAocHJldmlvdXMueCArIHRhcmdldC54KSAvIDIuMDtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCBwcmV2aW91cy55KTtcbiAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gJ2FmdGVyJyAhPT0gISFmbGlwKSB7XG4gICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gIH0gZWxzZSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gIH1cbiAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gX2JlemllckN1cnZlVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0LCBmbGlwKSB7XG4gIGlmICghcHJldmlvdXMpIHtcbiAgICByZXR1cm4gY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xuICB9XG4gIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgIGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCxcbiAgICBmbGlwID8gcHJldmlvdXMuY3AxeSA6IHByZXZpb3VzLmNwMnksXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ4IDogdGFyZ2V0LmNwMXgsXG4gICAgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksXG4gICAgdGFyZ2V0LngsXG4gICAgdGFyZ2V0LnkpO1xufVxuZnVuY3Rpb24gcmVuZGVyVGV4dChjdHgsIHRleHQsIHgsIHksIGZvbnQsIG9wdHMgPSB7fSkge1xuICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW3RleHRdO1xuICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgbGV0IGksIGxpbmU7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gIHNldFJlbmRlck9wdHMoY3R4LCBvcHRzKTtcbiAgZm9yIChpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGlmIChzdHJva2UpIHtcbiAgICAgIGlmIChvcHRzLnN0cm9rZUNvbG9yKSB7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdHMuc3Ryb2tlQ29sb3I7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTnVsbE9yVW5kZWYob3B0cy5zdHJva2VXaWR0aCkpIHtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICB9XG4gICAgY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHksIG9wdHMubWF4V2lkdGgpO1xuICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuICAgIHkgKz0gZm9udC5saW5lSGVpZ2h0O1xuICB9XG4gIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cykge1xuICBpZiAob3B0cy50cmFuc2xhdGlvbikge1xuICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gIH1cbiAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMucm90YXRpb24pKSB7XG4gICAgY3R4LnJvdGF0ZShvcHRzLnJvdGF0aW9uKTtcbiAgfVxuICBpZiAob3B0cy5jb2xvcikge1xuICAgIGN0eC5maWxsU3R5bGUgPSBvcHRzLmNvbG9yO1xuICB9XG4gIGlmIChvcHRzLnRleHRBbGlnbikge1xuICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgfVxuICBpZiAob3B0cy50ZXh0QmFzZWxpbmUpIHtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0cy50ZXh0QmFzZWxpbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpIHtcbiAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQobGluZSk7XG4gICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICBjb25zdCByaWdodCA9IHggKyBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQ7XG4gICAgY29uc3QgdG9wID0geSAtIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgIGNvbnN0IHlEZWNvcmF0aW9uID0gb3B0cy5zdHJpa2V0aHJvdWdoID8gKHRvcCArIGJvdHRvbSkgLyAyIDogYm90dG9tO1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5saW5lV2lkdGggPSBvcHRzLmRlY29yYXRpb25XaWR0aCB8fCAyO1xuICAgIGN0eC5tb3ZlVG8obGVmdCwgeURlY29yYXRpb24pO1xuICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHJlY3QpIHtcbiAgY29uc3Qge3gsIHksIHcsIGgsIHJhZGl1c30gPSByZWN0O1xuICBjdHguYXJjKHggKyByYWRpdXMudG9wTGVmdCwgeSArIHJhZGl1cy50b3BMZWZ0LCByYWRpdXMudG9wTGVmdCwgLUhBTEZfUEksIFBJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcbiAgY3R4LmFyYyh4ICsgcmFkaXVzLmJvdHRvbUxlZnQsIHkgKyBoIC0gcmFkaXVzLmJvdHRvbUxlZnQsIHJhZGl1cy5ib3R0b21MZWZ0LCBQSSwgSEFMRl9QSSwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcgLSByYWRpdXMuYm90dG9tUmlnaHQsIHkgKyBoKTtcbiAgY3R4LmFyYyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGggLSByYWRpdXMuYm90dG9tUmlnaHQsIHJhZGl1cy5ib3R0b21SaWdodCwgSEFMRl9QSSwgMCwgdHJ1ZSk7XG4gIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcbiAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuXG5jb25zdCBMSU5FX0hFSUdIVCA9IG5ldyBSZWdFeHAoL14obm9ybWFsfChcXGQrKD86XFwuXFxkKyk/KShweHxlbXwlKT8pJC8pO1xuY29uc3QgRk9OVF9TVFlMRSA9IG5ldyBSZWdFeHAoL14obm9ybWFsfGl0YWxpY3xpbml0aWFsfGluaGVyaXR8dW5zZXR8KG9ibGlxdWUoIC0/WzAtOV0/WzAtOV1kZWcpPykpJC8pO1xuZnVuY3Rpb24gdG9MaW5lSGVpZ2h0KHZhbHVlLCBzaXplKSB7XG4gIGNvbnN0IG1hdGNoZXMgPSAoJycgKyB2YWx1ZSkubWF0Y2goTElORV9IRUlHSFQpO1xuICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICByZXR1cm4gc2l6ZSAqIDEuMjtcbiAgfVxuICB2YWx1ZSA9ICttYXRjaGVzWzJdO1xuICBzd2l0Y2ggKG1hdGNoZXNbM10pIHtcbiAgY2FzZSAncHgnOlxuICAgIHJldHVybiB2YWx1ZTtcbiAgY2FzZSAnJSc6XG4gICAgdmFsdWUgLz0gMTAwO1xuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBzaXplICogdmFsdWU7XG59XG5jb25zdCBudW1iZXJPclplcm8gPSB2ID0+ICt2IHx8IDA7XG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGNvbnN0IG9ialByb3BzID0gaXNPYmplY3QocHJvcHMpO1xuICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgY29uc3QgcmVhZCA9IGlzT2JqZWN0KHZhbHVlKVxuICAgID8gb2JqUHJvcHNcbiAgICAgID8gcHJvcCA9PiB2YWx1ZU9yRGVmYXVsdCh2YWx1ZVtwcm9wXSwgdmFsdWVbcHJvcHNbcHJvcF1dKVxuICAgICAgOiBwcm9wID0+IHZhbHVlW3Byb3BdXG4gICAgOiAoKSA9PiB2YWx1ZTtcbiAgZm9yIChjb25zdCBwcm9wIG9mIGtleXMpIHtcbiAgICByZXRbcHJvcF0gPSBudW1iZXJPclplcm8ocmVhZChwcm9wKSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIHRvVFJCTCh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIHt0b3A6ICd5JywgcmlnaHQ6ICd4JywgYm90dG9tOiAneScsIGxlZnQ6ICd4J30pO1xufVxuZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICByZXR1cm4gX3JlYWRWYWx1ZVRvUHJvcHModmFsdWUsIFsndG9wTGVmdCcsICd0b3BSaWdodCcsICdib3R0b21MZWZ0JywgJ2JvdHRvbVJpZ2h0J10pO1xufVxuZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gIGNvbnN0IG9iaiA9IHRvVFJCTCh2YWx1ZSk7XG4gIG9iai53aWR0aCA9IG9iai5sZWZ0ICsgb2JqLnJpZ2h0O1xuICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiB0b0ZvbnQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgbGV0IHNpemUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnNpemUsIGZhbGxiYWNrLnNpemUpO1xuICBpZiAodHlwZW9mIHNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2l6ZSA9IHBhcnNlSW50KHNpemUsIDEwKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gIGlmIChzdHlsZSAmJiAhKCcnICsgc3R5bGUpLm1hdGNoKEZPTlRfU1RZTEUpKSB7XG4gICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgIHN0eWxlID0gJyc7XG4gIH1cbiAgY29uc3QgZm9udCA9IHtcbiAgICBmYW1pbHk6IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuZmFtaWx5LCBmYWxsYmFjay5mYW1pbHkpLFxuICAgIGxpbmVIZWlnaHQ6IHRvTGluZUhlaWdodCh2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmxpbmVIZWlnaHQsIGZhbGxiYWNrLmxpbmVIZWlnaHQpLCBzaXplKSxcbiAgICBzaXplLFxuICAgIHN0eWxlLFxuICAgIHdlaWdodDogdmFsdWVPckRlZmF1bHQob3B0aW9ucy53ZWlnaHQsIGZhbGxiYWNrLndlaWdodCksXG4gICAgc3RyaW5nOiAnJ1xuICB9O1xuICBmb250LnN0cmluZyA9IHRvRm9udFN0cmluZyhmb250KTtcbiAgcmV0dXJuIGZvbnQ7XG59XG5mdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgbGV0IGNhY2hlYWJsZSA9IHRydWU7XG4gIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGlucHV0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGlucHV0c1tpXTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb250ZXh0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGNvbnRleHQpO1xuICAgICAgY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkICYmIGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlW2luZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICAgIGNhY2hlYWJsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICBpbmZvLmNhY2hlYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2FkZEdyYWNlKG1pbm1heCwgZ3JhY2UsIGJlZ2luQXRaZXJvKSB7XG4gIGNvbnN0IHttaW4sIG1heH0gPSBtaW5tYXg7XG4gIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICBjb25zdCBrZWVwWmVybyA9ICh2YWx1ZSwgYWRkKSA9PiBiZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgcmV0dXJuIHtcbiAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgIG1heDoga2VlcFplcm8obWF4LCBjaGFuZ2UpXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShwYXJlbnRDb250ZXh0KSwgY29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVSZXNvbHZlcihzY29wZXMsIHByZWZpeGVzID0gWycnXSwgcm9vdFNjb3BlcyA9IHNjb3BlcywgZmFsbGJhY2ssIGdldFRhcmdldCA9ICgpID0+IHNjb3Blc1swXSkge1xuICBpZiAoIWRlZmluZWQoZmFsbGJhY2spKSB7XG4gICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgfVxuICBjb25zdCBjYWNoZSA9IHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXTogJ09iamVjdCcsXG4gICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICBfc2NvcGVzOiBzY29wZXMsXG4gICAgX3Jvb3RTY29wZXM6IHJvb3RTY29wZXMsXG4gICAgX2ZhbGxiYWNrOiBmYWxsYmFjayxcbiAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgb3ZlcnJpZGU6IChzY29wZSkgPT4gX2NyZWF0ZVJlc29sdmVyKFtzY29wZSwgLi4uc2NvcGVzXSwgcHJlZml4ZXMsIHJvb3RTY29wZXMsIGZhbGxiYWNrKSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICBkZWxldGUgc2NvcGVzWzBdW3Byb3BdO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXQodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gX2NhY2hlZCh0YXJnZXQsIHByb3AsXG4gICAgICAgICgpID0+IF9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgIH0sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldC5fc2NvcGVzWzBdLCBwcm9wKTtcbiAgICB9LFxuICAgIGdldFByb3RvdHlwZU9mKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0UHJvdG90eXBlT2Yoc2NvcGVzWzBdKTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgIH0sXG4gICAgb3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgIH0sXG4gICAgc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2F0dGFjaENvbnRleHQocHJveHksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgY29uc3QgY2FjaGUgPSB7XG4gICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgX3Byb3h5OiBwcm94eSxcbiAgICBfY29udGV4dDogY29udGV4dCxcbiAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgIF9zdGFjazogbmV3IFNldCgpLFxuICAgIF9kZXNjcmlwdG9yczogX2Rlc2NyaXB0b3JzKHByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIHNldENvbnRleHQ6IChjdHgpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5LCBjdHgsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpLFxuICAgIG92ZXJyaWRlOiAoc2NvcGUpID0+IF9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgfTtcbiAgcmV0dXJuIG5ldyBQcm94eShjYWNoZSwge1xuICAgIGRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCkge1xuICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTtcbiAgICAgIGRlbGV0ZSBwcm94eVtwcm9wXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCxcbiAgICAgICAgKCkgPT4gX3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgfSxcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0Ll9kZXNjcmlwdG9ycy5hbGxLZXlzXG4gICAgICAgID8gUmVmbGVjdC5oYXMocHJveHksIHByb3ApID8ge2VudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZX0gOiB1bmRlZmluZWRcbiAgICAgICAgOiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBnZXRQcm90b3R5cGVPZigpIHtcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICB9LFxuICAgIGhhcyh0YXJnZXQsIHByb3ApIHtcbiAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyhwcm94eSwgcHJvcCk7XG4gICAgfSxcbiAgICBvd25LZXlzKCkge1xuICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwcm94eSk7XG4gICAgfSxcbiAgICBzZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgcHJveHlbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbcHJvcF07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHByb3h5LCBkZWZhdWx0cyA9IHtzY3JpcHRhYmxlOiB0cnVlLCBpbmRleGFibGU6IHRydWV9KSB7XG4gIGNvbnN0IHtfc2NyaXB0YWJsZSA9IGRlZmF1bHRzLnNjcmlwdGFibGUsIF9pbmRleGFibGUgPSBkZWZhdWx0cy5pbmRleGFibGUsIF9hbGxLZXlzID0gZGVmYXVsdHMuYWxsS2V5c30gPSBwcm94eTtcbiAgcmV0dXJuIHtcbiAgICBhbGxLZXlzOiBfYWxsS2V5cyxcbiAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICBpbmRleGFibGU6IF9pbmRleGFibGUsXG4gICAgaXNTY3JpcHRhYmxlOiBpc0Z1bmN0aW9uKF9zY3JpcHRhYmxlKSA/IF9zY3JpcHRhYmxlIDogKCkgPT4gX3NjcmlwdGFibGUsXG4gICAgaXNJbmRleGFibGU6IGlzRnVuY3Rpb24oX2luZGV4YWJsZSkgPyBfaW5kZXhhYmxlIDogKCkgPT4gX2luZGV4YWJsZVxuICB9O1xufVxuY29uc3QgcmVhZEtleSA9IChwcmVmaXgsIG5hbWUpID0+IHByZWZpeCA/IHByZWZpeCArIF9jYXBpdGFsaXplKG5hbWUpIDogbmFtZTtcbmNvbnN0IG5lZWRzU3ViUmVzb2x2ZXIgPSAocHJvcCwgdmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmXG4gIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIHByb3ApKSB7XG4gICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgfVxuICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIF9yZXNvbHZlV2l0aENvbnRleHQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICBjb25zdCB7X3Byb3h5LCBfY29udGV4dCwgX3N1YlByb3h5LCBfZGVzY3JpcHRvcnM6IGRlc2NyaXB0b3JzfSA9IHRhcmdldDtcbiAgbGV0IHZhbHVlID0gX3Byb3h5W3Byb3BdO1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkgJiYgZGVzY3JpcHRvcnMuaXNTY3JpcHRhYmxlKHByb3ApKSB7XG4gICAgdmFsdWUgPSBfcmVzb2x2ZVNjcmlwdGFibGUocHJvcCwgdmFsdWUsIHRhcmdldCwgcmVjZWl2ZXIpO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICB2YWx1ZSA9IF9yZXNvbHZlQXJyYXkocHJvcCwgdmFsdWUsIHRhcmdldCwgZGVzY3JpcHRvcnMuaXNJbmRleGFibGUpO1xuICB9XG4gIGlmIChuZWVkc1N1YlJlc29sdmVyKHByb3AsIHZhbHVlKSkge1xuICAgIHZhbHVlID0gX2F0dGFjaENvbnRleHQodmFsdWUsIF9jb250ZXh0LCBfc3ViUHJveHkgJiYgX3N1YlByb3h5W3Byb3BdLCBkZXNjcmlwdG9ycyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIHZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9zdGFja30gPSB0YXJnZXQ7XG4gIGlmIChfc3RhY2suaGFzKHByb3ApKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZWN1cnNpb24gZGV0ZWN0ZWQ6ICcgKyBBcnJheS5mcm9tKF9zdGFjaykuam9pbignLT4nKSArICctPicgKyBwcm9wKTtcbiAgfVxuICBfc3RhY2suYWRkKHByb3ApO1xuICB2YWx1ZSA9IHZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICBfc3RhY2suZGVsZXRlKHByb3ApO1xuICBpZiAobmVlZHNTdWJSZXNvbHZlcihwcm9wLCB2YWx1ZSkpIHtcbiAgICB2YWx1ZSA9IGNyZWF0ZVN1YlJlc29sdmVyKF9wcm94eS5fc2NvcGVzLCBfcHJveHksIHByb3AsIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGlzSW5kZXhhYmxlKSB7XG4gIGNvbnN0IHtfcHJveHksIF9jb250ZXh0LCBfc3ViUHJveHksIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnN9ID0gdGFyZ2V0O1xuICBpZiAoZGVmaW5lZChfY29udGV4dC5pbmRleCkgJiYgaXNJbmRleGFibGUocHJvcCkpIHtcbiAgICB2YWx1ZSA9IHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZVswXSkpIHtcbiAgICBjb25zdCBhcnIgPSB2YWx1ZTtcbiAgICBjb25zdCBzY29wZXMgPSBfcHJveHkuX3Njb3Blcy5maWx0ZXIocyA9PiBzICE9PSBhcnIpO1xuICAgIHZhbHVlID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgY29uc3QgcmVzb2x2ZXIgPSBjcmVhdGVTdWJSZXNvbHZlcihzY29wZXMsIF9wcm94eSwgcHJvcCwgaXRlbSk7XG4gICAgICB2YWx1ZS5wdXNoKF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBfY29udGV4dCwgX3N1YlByb3h5ICYmIF9zdWJQcm94eVtwcm9wXSwgZGVzY3JpcHRvcnMpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKGZhbGxiYWNrLCBwcm9wLCB2YWx1ZSkge1xuICByZXR1cm4gaXNGdW5jdGlvbihmYWxsYmFjaykgPyBmYWxsYmFjayhwcm9wLCB2YWx1ZSkgOiBmYWxsYmFjaztcbn1cbmNvbnN0IGdldFNjb3BlID0gKGtleSwgcGFyZW50KSA9PiBrZXkgPT09IHRydWUgPyBwYXJlbnRcbiAgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYWRkU2NvcGVzKHNldCwgcGFyZW50U2NvcGVzLCBrZXksIHBhcmVudEZhbGxiYWNrLCB2YWx1ZSkge1xuICBmb3IgKGNvbnN0IHBhcmVudCBvZiBwYXJlbnRTY29wZXMpIHtcbiAgICBjb25zdCBzY29wZSA9IGdldFNjb3BlKGtleSwgcGFyZW50KTtcbiAgICBpZiAoc2NvcGUpIHtcbiAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0ga2V5ICYmIGZhbGxiYWNrICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzY29wZSA9PT0gZmFsc2UgJiYgZGVmaW5lZChwYXJlbnRGYWxsYmFjaykgJiYga2V5ICE9PSBwYXJlbnRGYWxsYmFjaykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN1YlJlc29sdmVyKHBhcmVudFNjb3BlcywgcmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHJvb3RTY29wZXMgPSByZXNvbHZlci5fcm9vdFNjb3BlcztcbiAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2socmVzb2x2ZXIuX2ZhbGxiYWNrLCBwcm9wLCB2YWx1ZSk7XG4gIGNvbnN0IGFsbFNjb3BlcyA9IFsuLi5wYXJlbnRTY29wZXMsIC4uLnJvb3RTY29wZXNdO1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIHNldC5hZGQodmFsdWUpO1xuICBsZXQga2V5ID0gYWRkU2NvcGVzRnJvbUtleShzZXQsIGFsbFNjb3BlcywgcHJvcCwgZmFsbGJhY2sgfHwgcHJvcCwgdmFsdWUpO1xuICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkZWZpbmVkKGZhbGxiYWNrKSAmJiBmYWxsYmFjayAhPT0gcHJvcCkge1xuICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbJyddLCByb290U2NvcGVzLCBmYWxsYmFjayxcbiAgICAoKSA9PiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKSB7XG4gIHdoaWxlIChrZXkpIHtcbiAgICBrZXkgPSBhZGRTY29wZXMoc2V0LCBhbGxTY29wZXMsIGtleSwgZmFsbGJhY2ssIGl0ZW0pO1xuICB9XG4gIHJldHVybiBrZXk7XG59XG5mdW5jdGlvbiBzdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSB7XG4gIGNvbnN0IHBhcmVudCA9IHJlc29sdmVyLl9nZXRUYXJnZXQoKTtcbiAgaWYgKCEocHJvcCBpbiBwYXJlbnQpKSB7XG4gICAgcGFyZW50W3Byb3BdID0ge307XG4gIH1cbiAgY29uc3QgdGFyZ2V0ID0gcGFyZW50W3Byb3BdO1xuICBpZiAoaXNBcnJheSh0YXJnZXQpICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3Jlc29sdmVXaXRoUHJlZml4ZXMocHJvcCwgcHJlZml4ZXMsIHNjb3BlcywgcHJveHkpIHtcbiAgbGV0IHZhbHVlO1xuICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xuICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgIGlmIChkZWZpbmVkKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpXG4gICAgICAgID8gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBwcm94eSwgcHJvcCwgdmFsdWUpXG4gICAgICAgIDogdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xuICBmb3IgKGNvbnN0IHNjb3BlIG9mIHNjb3Blcykge1xuICAgIGlmICghc2NvcGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHNjb3BlW2tleV07XG4gICAgaWYgKGRlZmluZWQodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpIHtcbiAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XG4gIGlmICgha2V5cykge1xuICAgIGtleXMgPSB0YXJnZXQuX2tleXMgPSByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXModGFyZ2V0Ll9zY29wZXMpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUtleXNGcm9tQWxsU2NvcGVzKHNjb3Blcykge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NvcGUpLmZpbHRlcihrID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpIHtcbiAgICAgIHNldC5hZGQoa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgY29uc3Qge2lTY2FsZX0gPSBtZXRhO1xuICBjb25zdCB7a2V5ID0gJ3InfSA9IHRoaXMuX3BhcnNpbmc7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBBcnJheShjb3VudCk7XG4gIGxldCBpLCBpbGVuLCBpbmRleCwgaXRlbTtcbiAgZm9yIChpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5kZXggPSBpICsgc3RhcnQ7XG4gICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgIHI6IGlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIGtleSksIGluZGV4KVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHBhcnNlZDtcbn1cblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzLCBpKSA9PiBpIDwgcG9pbnRzLmxlbmd0aCAmJiAhcG9pbnRzW2ldLnNraXAgJiYgcG9pbnRzW2ldO1xuY29uc3QgZ2V0VmFsdWVBeGlzID0gKGluZGV4QXhpcykgPT4gaW5kZXhBeGlzID09PSAneCcgPyAneScgOiAneCc7XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZShmaXJzdFBvaW50LCBtaWRkbGVQb2ludCwgYWZ0ZXJQb2ludCwgdCkge1xuICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgY29uc3QgY3VycmVudCA9IG1pZGRsZVBvaW50O1xuICBjb25zdCBuZXh0ID0gYWZ0ZXJQb2ludC5za2lwID8gbWlkZGxlUG9pbnQgOiBhZnRlclBvaW50O1xuICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICBjb25zdCBkMTIgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMobmV4dCwgY3VycmVudCk7XG4gIGxldCBzMDEgPSBkMDEgLyAoZDAxICsgZDEyKTtcbiAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgczEyID0gaXNOYU4oczEyKSA/IDAgOiBzMTI7XG4gIGNvbnN0IGZhID0gdCAqIHMwMTtcbiAgY29uc3QgZmIgPSB0ICogczEyO1xuICByZXR1cm4ge1xuICAgIHByZXZpb3VzOiB7XG4gICAgICB4OiBjdXJyZW50LnggLSBmYSAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSAtIGZhICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfSxcbiAgICBuZXh0OiB7XG4gICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKSB7XG4gIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gIGxldCBhbHBoYUssIGJldGFLLCB0YXVLLCBzcXVhcmVkTWFnbml0dWRlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW4gLSAxOyArK2kpIHtcbiAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgIHBvaW50QWZ0ZXIgPSBnZXRQb2ludChwb2ludHMsIGkgKyAxKTtcbiAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbG1vc3RFcXVhbHMoZGVsdGFLW2ldLCAwLCBFUFNJTE9OKSkge1xuICAgICAgbUtbaV0gPSBtS1tpICsgMV0gPSAwO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGFscGhhSyA9IG1LW2ldIC8gZGVsdGFLW2ldO1xuICAgIGJldGFLID0gbUtbaSArIDFdIC8gZGVsdGFLW2ldO1xuICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgIGlmIChzcXVhcmVkTWFnbml0dWRlIDw9IDkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICBtS1tpXSA9IGFscGhhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgbUtbaSArIDFdID0gYmV0YUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICB9XG59XG5mdW5jdGlvbiBtb25vdG9uZUNvbXB1dGUocG9pbnRzLCBtSywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBsZXQgZGVsdGEsIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSkge1xuICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgIHBvaW50Q3VycmVudCA9IHBvaW50QWZ0ZXI7XG4gICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgY29uc3QgdlBpeGVsID0gcG9pbnRDdXJyZW50W3ZhbHVlQXhpc107XG4gICAgaWYgKHBvaW50QmVmb3JlKSB7XG4gICAgICBkZWx0YSA9IChpUGl4ZWwgLSBwb2ludEJlZm9yZVtpbmRleEF4aXNdKSAvIDM7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7aW5kZXhBeGlzfWBdID0gaVBpeGVsIC0gZGVsdGE7XG4gICAgICBwb2ludEN1cnJlbnRbYGNwMSR7dmFsdWVBeGlzfWBdID0gdlBpeGVsIC0gZGVsdGEgKiBtS1tpXTtcbiAgICB9XG4gICAgaWYgKHBvaW50QWZ0ZXIpIHtcbiAgICAgIGRlbHRhID0gKHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIGlQaXhlbCkgLyAzO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke2luZGV4QXhpc31gXSA9IGlQaXhlbCArIGRlbHRhO1xuICAgICAgcG9pbnRDdXJyZW50W2BjcDIke3ZhbHVlQXhpc31gXSA9IHZQaXhlbCArIGRlbHRhICogbUtbaV07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICBjb25zdCBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCBkZWx0YUsgPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gIGNvbnN0IG1LID0gQXJyYXkocG9pbnRzTGVuKTtcbiAgbGV0IGksIHBvaW50QmVmb3JlLCBwb2ludEN1cnJlbnQ7XG4gIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgZm9yIChpID0gMDsgaSA8IHBvaW50c0xlbjsgKytpKSB7XG4gICAgcG9pbnRCZWZvcmUgPSBwb2ludEN1cnJlbnQ7XG4gICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgaWYgKCFwb2ludEN1cnJlbnQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgICAgZGVsdGFLW2ldID0gc2xvcGVEZWx0YSAhPT0gMCA/IChwb2ludEFmdGVyW3ZhbHVlQXhpc10gLSBwb2ludEN1cnJlbnRbdmFsdWVBeGlzXSkgLyBzbG9wZURlbHRhIDogMDtcbiAgICB9XG4gICAgbUtbaV0gPSAhcG9pbnRCZWZvcmUgPyBkZWx0YUtbaV1cbiAgICAgIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdXG4gICAgICA6IChzaWduKGRlbHRhS1tpIC0gMV0pICE9PSBzaWduKGRlbHRhS1tpXSkpID8gMFxuICAgICAgOiAoZGVsdGFLW2kgLSAxXSArIGRlbHRhS1tpXSkgLyAyO1xuICB9XG4gIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG4gIG1vbm90b25lQ29tcHV0ZShwb2ludHMsIG1LLCBpbmRleEF4aXMpO1xufVxuZnVuY3Rpb24gY2FwQ29udHJvbFBvaW50KHB0LCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4ocHQsIG1heCksIG1pbik7XG59XG5mdW5jdGlvbiBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKSB7XG4gIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICBsZXQgaW5BcmVhTmV4dCA9IF9pc1BvaW50SW5BcmVhKHBvaW50c1swXSwgYXJlYSk7XG4gIGZvciAoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICBpbkFyZWEgPSBpbkFyZWFOZXh0O1xuICAgIGluQXJlYU5leHQgPSBpIDwgaWxlbiAtIDEgJiYgX2lzUG9pbnRJbkFyZWEocG9pbnRzW2kgKyAxXSwgYXJlYSk7XG4gICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBwb2ludCA9IHBvaW50c1tpXTtcbiAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgICBpZiAoaW5BcmVhTmV4dCkge1xuICAgICAgcG9pbnQuY3AyeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgcG9pbnQuY3AyeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDJ5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMocG9pbnRzLCBvcHRpb25zLCBhcmVhLCBsb29wLCBpbmRleEF4aXMpIHtcbiAgbGV0IGksIGlsZW4sIHBvaW50LCBjb250cm9sUG9pbnRzO1xuICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgIHBvaW50cyA9IHBvaW50cy5maWx0ZXIoKHB0KSA9PiAhcHQuc2tpcCk7XG4gIH1cbiAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgIHNwbGluZUN1cnZlTW9ub3RvbmUocG9pbnRzLCBpbmRleEF4aXMpO1xuICB9IGVsc2Uge1xuICAgIGxldCBwcmV2ID0gbG9vcCA/IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gOiBwb2ludHNbMF07XG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKFxuICAgICAgICBwcmV2LFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcG9pbnRzW01hdGgubWluKGkgKyAxLCBpbGVuIC0gKGxvb3AgPyAwIDogMSkpICUgaWxlbl0sXG4gICAgICAgIG9wdGlvbnMudGVuc2lvblxuICAgICAgKTtcbiAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgcHJldiA9IHBvaW50O1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5jYXBCZXppZXJQb2ludHMpIHtcbiAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuZnVuY3Rpb24gX2dldFBhcmVudE5vZGUoZG9tTm9kZSkge1xuICBsZXQgcGFyZW50ID0gZG9tTm9kZS5wYXJlbnROb2RlO1xuICBpZiAocGFyZW50ICYmIHBhcmVudC50b1N0cmluZygpID09PSAnW29iamVjdCBTaGFkb3dSb290XScpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgfVxuICByZXR1cm4gcGFyZW50O1xufVxuZnVuY3Rpb24gcGFyc2VNYXhTdHlsZShzdHlsZVZhbHVlLCBub2RlLCBwYXJlbnRQcm9wZXJ0eSkge1xuICBsZXQgdmFsdWVJblBpeGVscztcbiAgaWYgKHR5cGVvZiBzdHlsZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG4gICAgaWYgKHN0eWxlVmFsdWUuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgdmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZUluUGl4ZWxzID0gc3R5bGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWVJblBpeGVscztcbn1cbmNvbnN0IGdldENvbXB1dGVkU3R5bGUgPSAoZWxlbWVudCkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUoZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xufVxuY29uc3QgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcbmZ1bmN0aW9uIGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZXMsIHN0eWxlLCBzdWZmaXgpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIHN1ZmZpeCA9IHN1ZmZpeCA/ICctJyArIHN1ZmZpeCA6ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICByZXN1bHRbcG9zXSA9IHBhcnNlRmxvYXQoc3R5bGVzW3N0eWxlICsgJy0nICsgcG9zICsgc3VmZml4XSkgfHwgMDtcbiAgfVxuICByZXN1bHQud2lkdGggPSByZXN1bHQubGVmdCArIHJlc3VsdC5yaWdodDtcbiAgcmVzdWx0LmhlaWdodCA9IHJlc3VsdC50b3AgKyByZXN1bHQuYm90dG9tO1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHgsIHksIHRhcmdldCkgPT4gKHggPiAwIHx8IHkgPiAwKSAmJiAoIXRhcmdldCB8fCAhdGFyZ2V0LnNoYWRvd1Jvb3QpO1xuZnVuY3Rpb24gZ2V0Q2FudmFzUG9zaXRpb24oZSwgY2FudmFzKSB7XG4gIGNvbnN0IHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gIGNvbnN0IHNvdXJjZSA9IHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGggPyB0b3VjaGVzWzBdIDogZTtcbiAgY29uc3Qge29mZnNldFgsIG9mZnNldFl9ID0gc291cmNlO1xuICBsZXQgYm94ID0gZmFsc2U7XG4gIGxldCB4LCB5O1xuICBpZiAodXNlT2Zmc2V0UG9zKG9mZnNldFgsIG9mZnNldFksIGUudGFyZ2V0KSkge1xuICAgIHggPSBvZmZzZXRYO1xuICAgIHkgPSBvZmZzZXRZO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgeCA9IHNvdXJjZS5jbGllbnRYIC0gcmVjdC5sZWZ0O1xuICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgIGJveCA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHt4LCB5LCBib3h9O1xufVxuZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihldnQsIGNoYXJ0KSB7XG4gIGlmICgnbmF0aXZlJyBpbiBldnQpIHtcbiAgICByZXR1cm4gZXZ0O1xuICB9XG4gIGNvbnN0IHtjYW52YXMsIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvfSA9IGNoYXJ0O1xuICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoY2FudmFzKTtcbiAgY29uc3QgYm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09PSAnYm9yZGVyLWJveCc7XG4gIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gIGNvbnN0IHt4LCB5LCBib3h9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZ0LCBjYW52YXMpO1xuICBjb25zdCB4T2Zmc2V0ID0gcGFkZGluZ3MubGVmdCArIChib3ggJiYgYm9yZGVycy5sZWZ0KTtcbiAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICBsZXQge3dpZHRoLCBoZWlnaHR9ID0gY2hhcnQ7XG4gIGlmIChib3JkZXJCb3gpIHtcbiAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgaGVpZ2h0IC09IHBhZGRpbmdzLmhlaWdodCArIGJvcmRlcnMuaGVpZ2h0O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgeTogTWF0aC5yb3VuZCgoeSAtIHlPZmZzZXQpIC8gaGVpZ2h0ICogY2FudmFzLmhlaWdodCAvIGN1cnJlbnREZXZpY2VQaXhlbFJhdGlvKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IG1heFdpZHRoLCBtYXhIZWlnaHQ7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkIHx8IGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgY29udGFpbmVyID0gX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgd2lkdGggPSBjYW52YXMuY2xpZW50V2lkdGg7XG4gICAgICBoZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIG1heFdpZHRoOiBtYXhXaWR0aCB8fCBJTkZJTklUWSxcbiAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICB9O1xufVxuY29uc3Qgcm91bmQxID0gdiA9PiBNYXRoLnJvdW5kKHYgKiAxMCkgLyAxMDtcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICBjb25zdCBtYXJnaW5zID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnbWFyZ2luJyk7XG4gIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgY29uc3QgbWF4SGVpZ2h0ID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhIZWlnaHQsIGNhbnZhcywgJ2NsaWVudEhlaWdodCcpIHx8IElORklOSVRZO1xuICBjb25zdCBjb250YWluZXJTaXplID0gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIGJiV2lkdGgsIGJiSGVpZ2h0KTtcbiAgbGV0IHt3aWR0aCwgaGVpZ2h0fSA9IGNvbnRhaW5lclNpemU7XG4gIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICBjb25zdCBib3JkZXJzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAnYm9yZGVyJywgJ3dpZHRoJyk7XG4gICAgY29uc3QgcGFkZGluZ3MgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdwYWRkaW5nJyk7XG4gICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gbWFyZ2lucy53aWR0aCk7XG4gIGhlaWdodCA9IE1hdGgubWF4KDAsIGFzcGVjdFJhdGlvID8gTWF0aC5mbG9vcih3aWR0aCAvIGFzcGVjdFJhdGlvKSA6IGhlaWdodCAtIG1hcmdpbnMuaGVpZ2h0KTtcbiAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gIGhlaWdodCA9IHJvdW5kMShNYXRoLm1pbihoZWlnaHQsIG1heEhlaWdodCwgY29udGFpbmVyU2l6ZS5tYXhIZWlnaHQpKTtcbiAgaWYgKHdpZHRoICYmICFoZWlnaHQpIHtcbiAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gcmV0aW5hU2NhbGUoY2hhcnQsIGZvcmNlUmF0aW8sIGZvcmNlU3R5bGUpIHtcbiAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgY29uc3QgZGV2aWNlSGVpZ2h0ID0gTWF0aC5mbG9vcihjaGFydC5oZWlnaHQgKiBwaXhlbFJhdGlvKTtcbiAgY29uc3QgZGV2aWNlV2lkdGggPSBNYXRoLmZsb29yKGNoYXJ0LndpZHRoICogcGl4ZWxSYXRpbyk7XG4gIGNoYXJ0LmhlaWdodCA9IGRldmljZUhlaWdodCAvIHBpeGVsUmF0aW87XG4gIGNoYXJ0LndpZHRoID0gZGV2aWNlV2lkdGggLyBwaXhlbFJhdGlvO1xuICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gIGlmIChjYW52YXMuc3R5bGUgJiYgKGZvcmNlU3R5bGUgfHwgKCFjYW52YXMuc3R5bGUuaGVpZ2h0ICYmICFjYW52YXMuc3R5bGUud2lkdGgpKSkge1xuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtjaGFydC5oZWlnaHR9cHhgO1xuICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke2NoYXJ0LndpZHRofXB4YDtcbiAgfVxuICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW9cbiAgICAgIHx8IGNhbnZhcy5oZWlnaHQgIT09IGRldmljZUhlaWdodFxuICAgICAgfHwgY2FudmFzLndpZHRoICE9PSBkZXZpY2VXaWR0aCkge1xuICAgIGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgIGNhbnZhcy53aWR0aCA9IGRldmljZVdpZHRoO1xuICAgIGNoYXJ0LmN0eC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucyA9IChmdW5jdGlvbigpIHtcbiAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuICByZXR1cm4gcGFzc2l2ZVN1cHBvcnRlZDtcbn0oKSk7XG5mdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRTdHlsZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gIGNvbnN0IG1hdGNoZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXihcXGQrKShcXC5cXGQrKT9weCQvKTtcbiAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gX3BvaW50SW5MaW5lKHAxLCBwMiwgdCwgbW9kZSkge1xuICByZXR1cm4ge1xuICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICB5OiBwMS55ICsgdCAqIChwMi55IC0gcDEueSlcbiAgfTtcbn1cbmZ1bmN0aW9uIF9zdGVwcGVkSW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnlcbiAgICA6IG1vZGUgPT09ICdhZnRlcicgPyB0IDwgMSA/IHAxLnkgOiBwMi55XG4gICAgOiB0ID4gMCA/IHAyLnkgOiBwMS55XG4gIH07XG59XG5mdW5jdGlvbiBfYmV6aWVySW50ZXJwb2xhdGlvbihwMSwgcDIsIHQsIG1vZGUpIHtcbiAgY29uc3QgY3AxID0ge3g6IHAxLmNwMngsIHk6IHAxLmNwMnl9O1xuICBjb25zdCBjcDIgPSB7eDogcDIuY3AxeCwgeTogcDIuY3AxeX07XG4gIGNvbnN0IGEgPSBfcG9pbnRJbkxpbmUocDEsIGNwMSwgdCk7XG4gIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICBjb25zdCBjID0gX3BvaW50SW5MaW5lKGNwMiwgcDIsIHQpO1xuICBjb25zdCBkID0gX3BvaW50SW5MaW5lKGEsIGIsIHQpO1xuICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICByZXR1cm4gX3BvaW50SW5MaW5lKGQsIGUsIHQpO1xufVxuXG5jb25zdCBpbnRsQ2FjaGUgPSBuZXcgTWFwKCk7XG5mdW5jdGlvbiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICBsZXQgZm9ybWF0dGVyID0gaW50bENhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmICghZm9ybWF0dGVyKSB7XG4gICAgZm9ybWF0dGVyID0gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgb3B0aW9ucyk7XG4gICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0dGVyO1xufVxuZnVuY3Rpb24gZm9ybWF0TnVtYmVyKG51bSwgbG9jYWxlLCBvcHRpb25zKSB7XG4gIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgZ2V0UmlnaHRUb0xlZnRBZGFwdGVyID0gZnVuY3Rpb24ocmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiB7XG4gICAgeCh4KSB7XG4gICAgICByZXR1cm4gcmVjdFggKyByZWN0WCArIHdpZHRoIC0geDtcbiAgICB9LFxuICAgIHNldFdpZHRoKHcpIHtcbiAgICAgIHdpZHRoID0gdztcbiAgICB9LFxuICAgIHRleHRBbGlnbihhbGlnbikge1xuICAgICAgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICB9XG4gICAgICByZXR1cm4gYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIH0sXG4gICAgeFBsdXMoeCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiB4IC0gdmFsdWU7XG4gICAgfSxcbiAgICBsZWZ0Rm9yTHRyKHgsIGl0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHggLSBpdGVtV2lkdGg7XG4gICAgfSxcbiAgfTtcbn07XG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB4KHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG4gICAgc2V0V2lkdGgodykge1xuICAgIH0sXG4gICAgdGV4dEFsaWduKGFsaWduKSB7XG4gICAgICByZXR1cm4gYWxpZ247XG4gICAgfSxcbiAgICB4UGx1cyh4LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICB9LFxuICAgIGxlZnRGb3JMdHIoeCwgX2l0ZW1XaWR0aCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcbiAgfTtcbn07XG5mdW5jdGlvbiBnZXRSdGxBZGFwdGVyKHJ0bCwgcmVjdFgsIHdpZHRoKSB7XG4gIHJldHVybiBydGwgPyBnZXRSaWdodFRvTGVmdEFkYXB0ZXIocmVjdFgsIHdpZHRoKSA6IGdldExlZnRUb1JpZ2h0QWRhcHRlcigpO1xufVxuZnVuY3Rpb24gb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKGN0eCwgZGlyZWN0aW9uKSB7XG4gIGxldCBzdHlsZSwgb3JpZ2luYWw7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdsdHInIHx8IGRpcmVjdGlvbiA9PT0gJ3J0bCcpIHtcbiAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgb3JpZ2luYWwgPSBbXG4gICAgICBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSxcbiAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkoJ2RpcmVjdGlvbicpLFxuICAgIF07XG4gICAgc3R5bGUuc2V0UHJvcGVydHkoJ2RpcmVjdGlvbicsIGRpcmVjdGlvbiwgJ2ltcG9ydGFudCcpO1xuICAgIGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlVGV4dERpcmVjdGlvbihjdHgsIG9yaWdpbmFsKSB7XG4gIGlmIChvcmlnaW5hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVsZXRlIGN0eC5wcmV2VGV4dERpcmVjdGlvbjtcbiAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BlcnR5Rm4ocHJvcGVydHkpIHtcbiAgaWYgKHByb3BlcnR5ID09PSAnYW5nbGUnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJldHdlZW46IF9hbmdsZUJldHdlZW4sXG4gICAgICBjb21wYXJlOiBfYW5nbGVEaWZmLFxuICAgICAgbm9ybWFsaXplOiBfbm9ybWFsaXplQW5nbGUsXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJldHdlZW46IF9pc0JldHdlZW4sXG4gICAgY29tcGFyZTogKGEsIGIpID0+IGEgLSBiLFxuICAgIG5vcm1hbGl6ZTogeCA9PiB4XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHtzdGFydCwgZW5kLCBjb3VudCwgbG9vcCwgc3R5bGV9KSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgZW5kOiBlbmQgJSBjb3VudCxcbiAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgc3R5bGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgY29uc3Qge3Byb3BlcnR5LCBzdGFydDogc3RhcnRCb3VuZCwgZW5kOiBlbmRCb3VuZH0gPSBib3VuZHM7XG4gIGNvbnN0IHtiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgbGV0IHtzdGFydCwgZW5kLCBsb29wfSA9IHNlZ21lbnQ7XG4gIGxldCBpLCBpbGVuO1xuICBpZiAobG9vcCkge1xuICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgIGVuZCArPSBjb3VudDtcbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXJ0LS07XG4gICAgICBlbmQtLTtcbiAgICB9XG4gICAgc3RhcnQgJT0gY291bnQ7XG4gICAgZW5kICU9IGNvdW50O1xuICB9XG4gIGlmIChlbmQgPCBzdGFydCkge1xuICAgIGVuZCArPSBjb3VudDtcbiAgfVxuICByZXR1cm4ge3N0YXJ0LCBlbmQsIGxvb3AsIHN0eWxlOiBzZWdtZW50LnN0eWxlfTtcbn1cbmZ1bmN0aW9uIF9ib3VuZFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgaWYgKCFib3VuZHMpIHtcbiAgICByZXR1cm4gW3NlZ21lbnRdO1xuICB9XG4gIGNvbnN0IHtwcm9wZXJ0eSwgc3RhcnQ6IHN0YXJ0Qm91bmQsIGVuZDogZW5kQm91bmR9ID0gYm91bmRzO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHtjb21wYXJlLCBiZXR3ZWVuLCBub3JtYWxpemV9ID0gcHJvcGVydHlGbihwcm9wZXJ0eSk7XG4gIGNvbnN0IHtzdGFydCwgZW5kLCBsb29wLCBzdHlsZX0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBpbnNpZGUgPSBmYWxzZTtcbiAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgbGV0IHZhbHVlLCBwb2ludCwgcHJldlZhbHVlO1xuICBjb25zdCBzdGFydElzQmVmb3JlID0gKCkgPT4gYmV0d2VlbihzdGFydEJvdW5kLCBwcmV2VmFsdWUsIHZhbHVlKSAmJiBjb21wYXJlKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSkgIT09IDA7XG4gIGNvbnN0IGVuZElzQmVmb3JlID0gKCkgPT4gY29tcGFyZShlbmRCb3VuZCwgdmFsdWUpID09PSAwIHx8IGJldHdlZW4oZW5kQm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpO1xuICBjb25zdCBzaG91bGRTdGFydCA9ICgpID0+IGluc2lkZSB8fCBzdGFydElzQmVmb3JlKCk7XG4gIGNvbnN0IHNob3VsZFN0b3AgPSAoKSA9PiAhaW5zaWRlIHx8IGVuZElzQmVmb3JlKCk7XG4gIGZvciAobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2VmFsdWUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG4gICAgaWYgKHN1YlN0YXJ0ID09PSBudWxsICYmIHNob3VsZFN0YXJ0KCkpIHtcbiAgICAgIHN1YlN0YXJ0ID0gY29tcGFyZSh2YWx1ZSwgc3RhcnRCb3VuZCkgPT09IDAgPyBpIDogcHJldjtcbiAgICB9XG4gICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQ6IGksIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgICAgIHN1YlN0YXJ0ID0gbnVsbDtcbiAgICB9XG4gICAgcHJldiA9IGk7XG4gICAgcHJldlZhbHVlID0gdmFsdWU7XG4gIH1cbiAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsKSB7XG4gICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7c3RhcnQ6IHN1YlN0YXJ0LCBlbmQsIGxvb3AsIGNvdW50LCBzdHlsZX0pKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdWIgPSBfYm91bmRTZWdtZW50KHNlZ21lbnRzW2ldLCBsaW5lLnBvaW50cywgYm91bmRzKTtcbiAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gY291bnQgLSAxO1xuICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKSB7XG4gICAgICBzdGFydCsrO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApIHtcbiAgICBzdGFydCsrO1xuICB9XG4gIHN0YXJ0ICU9IGNvdW50O1xuICBpZiAobG9vcCkge1xuICAgIGVuZCArPSBzdGFydDtcbiAgfVxuICB3aGlsZSAoZW5kID4gc3RhcnQgJiYgcG9pbnRzW2VuZCAlIGNvdW50XS5za2lwKSB7XG4gICAgZW5kLS07XG4gIH1cbiAgZW5kICU9IGNvdW50O1xuICByZXR1cm4ge3N0YXJ0LCBlbmR9O1xufVxuZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGxhc3QgPSBzdGFydDtcbiAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnRdO1xuICBsZXQgZW5kO1xuICBmb3IgKGVuZCA9IHN0YXJ0ICsgMTsgZW5kIDw9IG1heDsgKytlbmQpIHtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbZW5kICUgY291bnRdO1xuICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXN1bHQucHVzaCh7c3RhcnQ6IHN0YXJ0ICUgY291bnQsIGVuZDogKGVuZCAtIDEpICUgY291bnQsIGxvb3B9KTtcbiAgICAgICAgc3RhcnQgPSBsYXN0ID0gY3VyLnN0b3AgPyBlbmQgOiBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0ID0gZW5kO1xuICAgICAgaWYgKHByZXYuc2tpcCkge1xuICAgICAgICBzdGFydCA9IGVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJldiA9IGN1cjtcbiAgfVxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHJlc3VsdC5wdXNoKHtzdGFydDogc3RhcnQgJSBjb3VudCwgZW5kOiBsYXN0ICUgY291bnQsIGxvb3B9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICBjb25zdCBwb2ludHMgPSBsaW5lLnBvaW50cztcbiAgY29uc3Qgc3BhbkdhcHMgPSBsaW5lLm9wdGlvbnMuc3BhbkdhcHM7XG4gIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgaWYgKCFjb3VudCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBjb25zdCBsb29wID0gISFsaW5lLl9sb29wO1xuICBjb25zdCB7c3RhcnQsIGVuZH0gPSBmaW5kU3RhcnRBbmRFbmQocG9pbnRzLCBjb3VudCwgbG9vcCwgc3BhbkdhcHMpO1xuICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICByZXR1cm4gc3BsaXRCeVN0eWxlcyhsaW5lLCBbe3N0YXJ0LCBlbmQsIGxvb3B9XSwgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG4gIH1cbiAgY29uc3QgbWF4ID0gZW5kIDwgc3RhcnQgPyBlbmQgKyBjb3VudCA6IGVuZDtcbiAgY29uc3QgY29tcGxldGVMb29wID0gISFsaW5lLl9mdWxsTG9vcCAmJiBzdGFydCA9PT0gMCAmJiBlbmQgPT09IGNvdW50IC0gMTtcbiAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuZnVuY3Rpb24gc3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucykge1xuICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgcmV0dXJuIGRvU3BsaXRCeVN0eWxlcyhsaW5lLCBzZWdtZW50cywgcG9pbnRzLCBzZWdtZW50T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgY29uc3QgY2hhcnRDb250ZXh0ID0gbGluZS5fY2hhcnQuZ2V0Q29udGV4dCgpO1xuICBjb25zdCBiYXNlU3R5bGUgPSByZWFkU3R5bGUobGluZS5vcHRpb25zKTtcbiAgY29uc3Qge19kYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleCwgb3B0aW9uczoge3NwYW5HYXBzfX0gPSBsaW5lO1xuICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgcHJldlN0eWxlID0gYmFzZVN0eWxlO1xuICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgbGV0IGkgPSBzdGFydDtcbiAgZnVuY3Rpb24gYWRkU3R5bGUocywgZSwgbCwgc3QpIHtcbiAgICBjb25zdCBkaXIgPSBzcGFuR2FwcyA/IC0xIDogMTtcbiAgICBpZiAocyA9PT0gZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzICs9IGNvdW50O1xuICAgIHdoaWxlIChwb2ludHNbcyAlIGNvdW50XS5za2lwKSB7XG4gICAgICBzIC09IGRpcjtcbiAgICB9XG4gICAgd2hpbGUgKHBvaW50c1tlICUgY291bnRdLnNraXApIHtcbiAgICAgIGUgKz0gZGlyO1xuICAgIH1cbiAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtzdGFydDogcyAlIGNvdW50LCBlbmQ6IGUgJSBjb3VudCwgbG9vcDogbCwgc3R5bGU6IHN0fSk7XG4gICAgICBwcmV2U3R5bGUgPSBzdDtcbiAgICAgIHN0YXJ0ID0gZSAlIGNvdW50O1xuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBzdGFydCA9IHNwYW5HYXBzID8gc3RhcnQgOiBzZWdtZW50LnN0YXJ0O1xuICAgIGxldCBwcmV2ID0gcG9pbnRzW3N0YXJ0ICUgY291bnRdO1xuICAgIGxldCBzdHlsZTtcbiAgICBmb3IgKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKykge1xuICAgICAgY29uc3QgcHQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgIHN0eWxlID0gcmVhZFN0eWxlKHNlZ21lbnRPcHRpb25zLnNldENvbnRleHQoY3JlYXRlQ29udGV4dChjaGFydENvbnRleHQsIHtcbiAgICAgICAgdHlwZTogJ3NlZ21lbnQnLFxuICAgICAgICBwMDogcHJldixcbiAgICAgICAgcDE6IHB0LFxuICAgICAgICBwMERhdGFJbmRleDogKGkgLSAxKSAlIGNvdW50LFxuICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICBkYXRhc2V0SW5kZXhcbiAgICAgIH0pKSk7XG4gICAgICBpZiAoc3R5bGVDaGFuZ2VkKHN0eWxlLCBwcmV2U3R5bGUpKSB7XG4gICAgICAgIGFkZFN0eWxlKHN0YXJ0LCBpIC0gMSwgc2VnbWVudC5sb29wLCBwcmV2U3R5bGUpO1xuICAgICAgfVxuICAgICAgcHJldiA9IHB0O1xuICAgICAgcHJldlN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHJlYWRTdHlsZShvcHRpb25zKSB7XG4gIHJldHVybiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcbiAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICBib3JkZXJEYXNoOiBvcHRpb25zLmJvcmRlckRhc2gsXG4gICAgYm9yZGVyRGFzaE9mZnNldDogb3B0aW9ucy5ib3JkZXJEYXNoT2Zmc2V0LFxuICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgYm9yZGVyV2lkdGg6IG9wdGlvbnMuYm9yZGVyV2lkdGgsXG4gICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuYm9yZGVyQ29sb3JcbiAgfTtcbn1cbmZ1bmN0aW9uIHN0eWxlQ2hhbmdlZChzdHlsZSwgcHJldlN0eWxlKSB7XG4gIHJldHVybiBwcmV2U3R5bGUgJiYgSlNPTi5zdHJpbmdpZnkoc3R5bGUpICE9PSBKU09OLnN0cmluZ2lmeShwcmV2U3R5bGUpO1xufVxuXG5leHBvcnQgeyBfaXNQb2ludEluQXJlYSBhcyAkLCBfZmFjdG9yaXplIGFzIEEsIGZpbml0ZU9yRGVmYXVsdCBhcyBCLCBjYWxsYmFjayBhcyBDLCBfYWRkR3JhY2UgYXMgRCwgX2xpbWl0VmFsdWUgYXMgRSwgdG9EZWdyZWVzIGFzIEYsIF9tZWFzdXJlVGV4dCBhcyBHLCBIQUxGX1BJIGFzIEgsIF9pbnQxNlJhbmdlIGFzIEksIF9hbGlnblBpeGVsIGFzIEosIHRvUGFkZGluZyBhcyBLLCBjbGlwQXJlYSBhcyBMLCByZW5kZXJUZXh0IGFzIE0sIHVuY2xpcEFyZWEgYXMgTiwgdG9Gb250IGFzIE8sIFBJIGFzIFAsIGVhY2ggYXMgUSwgX3RvTGVmdFJpZ2h0Q2VudGVyIGFzIFIsIF9hbGlnblN0YXJ0RW5kIGFzIFMsIFRBVSBhcyBULCBvdmVycmlkZXMgYXMgVSwgbWVyZ2UgYXMgViwgX2NhcGl0YWxpemUgYXMgVywgZ2V0UmVsYXRpdmVQb3NpdGlvbiBhcyBYLCBfcmxvb2t1cEJ5S2V5IGFzIFksIF9sb29rdXBCeUtleSBhcyBaLCBfYXJyYXlVbmlxdWUgYXMgXywgcmVzb2x2ZSBhcyBhLCB0b0xpbmVIZWlnaHQgYXMgYSQsIGdldEFuZ2xlRnJvbVBvaW50IGFzIGEwLCBnZXRNYXhpbXVtU2l6ZSBhcyBhMSwgX2dldFBhcmVudE5vZGUgYXMgYTIsIHJlYWRVc2VkU2l6ZSBhcyBhMywgdGhyb3R0bGVkIGFzIGE0LCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIGFzIGE1LCBfaXNEb21TdXBwb3J0ZWQgYXMgYTYsIGRlc2NyaXB0b3JzIGFzIGE3LCBpc0Z1bmN0aW9uIGFzIGE4LCBfYXR0YWNoQ29udGV4dCBhcyBhOSwgZ2V0UnRsQWRhcHRlciBhcyBhQSwgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uIGFzIGFCLCBfdGV4dFggYXMgYUMsIHJlc3RvcmVUZXh0RGlyZWN0aW9uIGFzIGFELCBkcmF3UG9pbnRMZWdlbmQgYXMgYUUsIG5vb3AgYXMgYUYsIGRpc3RhbmNlQmV0d2VlblBvaW50cyBhcyBhRywgX3NldE1pbkFuZE1heEJ5S2V5IGFzIGFILCBuaWNlTnVtIGFzIGFJLCBhbG1vc3RXaG9sZSBhcyBhSiwgYWxtb3N0RXF1YWxzIGFzIGFLLCBfZGVjaW1hbFBsYWNlcyBhcyBhTCwgX2xvbmdlc3RUZXh0IGFzIGFNLCBfZmlsdGVyQmV0d2VlbiBhcyBhTiwgX2xvb2t1cCBhcyBhTywgaXNQYXR0ZXJuT3JHcmFkaWVudCBhcyBhUCwgZ2V0SG92ZXJDb2xvciBhcyBhUSwgY2xvbmUkMSBhcyBhUiwgX21lcmdlciBhcyBhUywgX21lcmdlcklmIGFzIGFULCBfZGVwcmVjYXRlZCBhcyBhVSwgX3NwbGl0S2V5IGFzIGFWLCB0b0ZvbnRTdHJpbmcgYXMgYVcsIHNwbGluZUN1cnZlIGFzIGFYLCBzcGxpbmVDdXJ2ZU1vbm90b25lIGFzIGFZLCBnZXRTdHlsZSBhcyBhWiwgZm9udFN0cmluZyBhcyBhXywgX2NyZWF0ZVJlc29sdmVyIGFzIGFhLCBfZGVzY3JpcHRvcnMgYXMgYWIsIG1lcmdlSWYgYXMgYWMsIHVpZCBhcyBhZCwgZGVib3VuY2UgYXMgYWUsIHJldGluYVNjYWxlIGFzIGFmLCBjbGVhckNhbnZhcyBhcyBhZywgc2V0c0VxdWFsIGFzIGFoLCBfZWxlbWVudHNFcXVhbCBhcyBhaSwgX2lzQ2xpY2tFdmVudCBhcyBhaiwgX2lzQmV0d2VlbiBhcyBhaywgX3JlYWRWYWx1ZVRvUHJvcHMgYXMgYWwsIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIGFzIGFtLCBfY29tcHV0ZVNlZ21lbnRzIGFzIGFuLCBfYm91bmRTZWdtZW50cyBhcyBhbywgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIGFzIGFwLCBfYmV6aWVySW50ZXJwb2xhdGlvbiBhcyBhcSwgX3BvaW50SW5MaW5lIGFzIGFyLCBfc3RlcHBlZExpbmVUbyBhcyBhcywgX2JlemllckN1cnZlVG8gYXMgYXQsIGRyYXdQb2ludCBhcyBhdSwgYWRkUm91bmRlZFJlY3RQYXRoIGFzIGF2LCB0b1RSQkwgYXMgYXcsIHRvVFJCTENvcm5lcnMgYXMgYXgsIF9ib3VuZFNlZ21lbnQgYXMgYXksIF9ub3JtYWxpemVBbmdsZSBhcyBheiwgaXNBcnJheSBhcyBiLCBQSVRBVSBhcyBiMCwgSU5GSU5JVFkgYXMgYjEsIFJBRF9QRVJfREVHIGFzIGIyLCBRVUFSVEVSX1BJIGFzIGIzLCBUV09fVEhJUkRTX1BJIGFzIGI0LCBfYW5nbGVEaWZmIGFzIGI1LCBjb2xvciBhcyBjLCBkZWZhdWx0cyBhcyBkLCBlZmZlY3RzIGFzIGUsIHJlc29sdmVPYmplY3RLZXkgYXMgZiwgaXNOdW1iZXJGaW5pdGUgYXMgZywgY3JlYXRlQ29udGV4dCBhcyBoLCBpc09iamVjdCBhcyBpLCBkZWZpbmVkIGFzIGosIGlzTnVsbE9yVW5kZWYgYXMgaywgbGlzdGVuQXJyYXlFdmVudHMgYXMgbCwgdG9QZXJjZW50YWdlIGFzIG0sIHRvRGltZW5zaW9uIGFzIG4sIGZvcm1hdE51bWJlciBhcyBvLCBfYW5nbGVCZXR3ZWVuIGFzIHAsIF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIGFzIHEsIHJlcXVlc3RBbmltRnJhbWUgYXMgciwgc2lnbiBhcyBzLCB0b1JhZGlhbnMgYXMgdCwgdW5saXN0ZW5BcnJheUV2ZW50cyBhcyB1LCB2YWx1ZU9yRGVmYXVsdCBhcyB2LCBfc2NhbGVSYW5nZXNDaGFuZ2VkIGFzIHcsIGlzTnVtYmVyIGFzIHgsIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSBhcyB5LCBsb2cxMCBhcyB6IH07XG4iXSwibmFtZXMiOlsibm9vcCIsInVpZCIsImlkIiwiaXNOdWxsT3JVbmRlZiIsInZhbHVlIiwiaXNBcnJheSIsIkFycmF5IiwidHlwZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsInNsaWNlIiwiaXNPYmplY3QiLCJpc051bWJlckZpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiZmluaXRlT3JEZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwidmFsdWVPckRlZmF1bHQiLCJ0b1BlcmNlbnRhZ2UiLCJkaW1lbnNpb24iLCJlbmRzV2l0aCIsInBhcnNlRmxvYXQiLCJ0b0RpbWVuc2lvbiIsImNhbGxiYWNrIiwiZm4iLCJhcmdzIiwidGhpc0FyZyIsImFwcGx5IiwiZWFjaCIsImxvb3BhYmxlIiwicmV2ZXJzZSIsImkiLCJsZW4iLCJrZXlzIiwibGVuZ3RoIiwiX2VsZW1lbnRzRXF1YWwiLCJhMCIsImExIiwiaWxlbiIsInYwIiwidjEiLCJkYXRhc2V0SW5kZXgiLCJpbmRleCIsImNsb25lJDEiLCJzb3VyY2UiLCJtYXAiLCJ0YXJnZXQiLCJjcmVhdGUiLCJrbGVuIiwiayIsImlzVmFsaWRLZXkiLCJrZXkiLCJpbmRleE9mIiwiX21lcmdlciIsIm9wdGlvbnMiLCJ0dmFsIiwic3ZhbCIsIm1lcmdlIiwic291cmNlcyIsIm1lcmdlciIsIm1lcmdlSWYiLCJfbWVyZ2VySWYiLCJoYXNPd25Qcm9wZXJ0eSIsIl9kZXByZWNhdGVkIiwic2NvcGUiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJ1bmRlZmluZWQiLCJjb25zb2xlIiwid2FybiIsImtleVJlc29sdmVycyIsInYiLCJ4IiwibyIsInkiLCJyZXNvbHZlT2JqZWN0S2V5Iiwib2JqIiwicmVzb2x2ZXIiLCJfZ2V0S2V5UmVzb2x2ZXIiLCJfc3BsaXRLZXkiLCJwYXJ0cyIsInNwbGl0IiwidG1wIiwicGFydCIsInB1c2giLCJfY2FwaXRhbGl6ZSIsInN0ciIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiZGVmaW5lZCIsImlzRnVuY3Rpb24iLCJzZXRzRXF1YWwiLCJhIiwiYiIsInNpemUiLCJpdGVtIiwiaGFzIiwiX2lzQ2xpY2tFdmVudCIsImUiLCJQSSIsIk1hdGgiLCJUQVUiLCJQSVRBVSIsIklORklOSVRZIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJSQURfUEVSX0RFRyIsIkhBTEZfUEkiLCJRVUFSVEVSX1BJIiwiVFdPX1RISVJEU19QSSIsImxvZzEwIiwic2lnbiIsIm5pY2VOdW0iLCJyYW5nZSIsInJvdW5kZWRSYW5nZSIsInJvdW5kIiwiYWxtb3N0RXF1YWxzIiwibmljZVJhbmdlIiwicG93IiwiZmxvb3IiLCJmcmFjdGlvbiIsIm5pY2VGcmFjdGlvbiIsIl9mYWN0b3JpemUiLCJyZXN1bHQiLCJzcXJ0Iiwic29ydCIsInBvcCIsImlzTnVtYmVyIiwibiIsImlzTmFOIiwiZXBzaWxvbiIsImFicyIsImFsbW9zdFdob2xlIiwicm91bmRlZCIsIl9zZXRNaW5BbmRNYXhCeUtleSIsImFycmF5IiwicHJvcGVydHkiLCJtaW4iLCJtYXgiLCJ0b1JhZGlhbnMiLCJkZWdyZWVzIiwidG9EZWdyZWVzIiwicmFkaWFucyIsIl9kZWNpbWFsUGxhY2VzIiwicCIsImdldEFuZ2xlRnJvbVBvaW50IiwiY2VudHJlUG9pbnQiLCJhbmdsZVBvaW50IiwiZGlzdGFuY2VGcm9tWENlbnRlciIsImRpc3RhbmNlRnJvbVlDZW50ZXIiLCJyYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIiLCJhbmdsZSIsImF0YW4yIiwiZGlzdGFuY2UiLCJkaXN0YW5jZUJldHdlZW5Qb2ludHMiLCJwdDEiLCJwdDIiLCJfYW5nbGVEaWZmIiwiX25vcm1hbGl6ZUFuZ2xlIiwiX2FuZ2xlQmV0d2VlbiIsInN0YXJ0IiwiZW5kIiwic2FtZUFuZ2xlSXNGdWxsQ2lyY2xlIiwicyIsImFuZ2xlVG9TdGFydCIsImFuZ2xlVG9FbmQiLCJzdGFydFRvQW5nbGUiLCJlbmRUb0FuZ2xlIiwiX2xpbWl0VmFsdWUiLCJfaW50MTZSYW5nZSIsIl9pc0JldHdlZW4iLCJfbG9va3VwIiwidGFibGUiLCJjbXAiLCJoaSIsImxvIiwibWlkIiwiX2xvb2t1cEJ5S2V5IiwibGFzdCIsIl9ybG9va3VwQnlLZXkiLCJfZmlsdGVyQmV0d2VlbiIsInZhbHVlcyIsImFycmF5RXZlbnRzIiwibGlzdGVuQXJyYXlFdmVudHMiLCJsaXN0ZW5lciIsIl9jaGFydGpzIiwibGlzdGVuZXJzIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwiZm9yRWFjaCIsIm1ldGhvZCIsImJhc2UiLCJyZXMiLCJvYmplY3QiLCJ1bmxpc3RlbkFycmF5RXZlbnRzIiwic3R1YiIsInNwbGljZSIsIl9hcnJheVVuaXF1ZSIsIml0ZW1zIiwic2V0IiwiU2V0IiwiYWRkIiwiZnJvbSIsImZvbnRTdHJpbmciLCJwaXhlbFNpemUiLCJmb250U3R5bGUiLCJmb250RmFtaWx5IiwicmVxdWVzdEFuaW1GcmFtZSIsIndpbmRvdyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInRocm90dGxlZCIsInVwZGF0ZUZuIiwidXBkYXRlQXJncyIsInRpY2tpbmciLCJyZXN0IiwiZGVib3VuY2UiLCJkZWxheSIsInRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiX3RvTGVmdFJpZ2h0Q2VudGVyIiwiYWxpZ24iLCJfYWxpZ25TdGFydEVuZCIsIl90ZXh0WCIsImxlZnQiLCJyaWdodCIsInJ0bCIsImNoZWNrIiwiX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMiLCJtZXRhIiwicG9pbnRzIiwiYW5pbWF0aW9uc0Rpc2FibGVkIiwicG9pbnRDb3VudCIsImNvdW50IiwiX3NvcnRlZCIsImlTY2FsZSIsIl9wYXJzZWQiLCJheGlzIiwibWluRGVmaW5lZCIsIm1heERlZmluZWQiLCJnZXRVc2VyQm91bmRzIiwiZ2V0UGl4ZWxGb3JWYWx1ZSIsIl9zY2FsZVJhbmdlc0NoYW5nZWQiLCJ4U2NhbGUiLCJ5U2NhbGUiLCJfc2NhbGVSYW5nZXMiLCJuZXdSYW5nZXMiLCJ4bWluIiwieG1heCIsInltaW4iLCJ5bWF4IiwiY2hhbmdlZCIsImFzc2lnbiIsImF0RWRnZSIsInQiLCJlbGFzdGljSW4iLCJzaW4iLCJlbGFzdGljT3V0IiwiZWZmZWN0cyIsImxpbmVhciIsImVhc2VJblF1YWQiLCJlYXNlT3V0UXVhZCIsImVhc2VJbk91dFF1YWQiLCJlYXNlSW5DdWJpYyIsImVhc2VPdXRDdWJpYyIsImVhc2VJbk91dEN1YmljIiwiZWFzZUluUXVhcnQiLCJlYXNlT3V0UXVhcnQiLCJlYXNlSW5PdXRRdWFydCIsImVhc2VJblF1aW50IiwiZWFzZU91dFF1aW50IiwiZWFzZUluT3V0UXVpbnQiLCJlYXNlSW5TaW5lIiwiY29zIiwiZWFzZU91dFNpbmUiLCJlYXNlSW5PdXRTaW5lIiwiZWFzZUluRXhwbyIsImVhc2VPdXRFeHBvIiwiZWFzZUluT3V0RXhwbyIsImVhc2VJbkNpcmMiLCJlYXNlT3V0Q2lyYyIsImVhc2VJbk91dENpcmMiLCJlYXNlSW5FbGFzdGljIiwiZWFzZU91dEVsYXN0aWMiLCJlYXNlSW5PdXRFbGFzdGljIiwiZWFzZUluQmFjayIsImVhc2VPdXRCYWNrIiwiZWFzZUluT3V0QmFjayIsImVhc2VJbkJvdW5jZSIsImVhc2VPdXRCb3VuY2UiLCJtIiwiZCIsImVhc2VJbk91dEJvdW5jZSIsImxpbSIsImwiLCJoIiwicDJiIiwibjJiIiwiYjJuIiwibjJwIiwibWFwJDEiLCJBIiwiQiIsIkMiLCJEIiwiRSIsIkYiLCJjIiwiZiIsImhleCIsImgxIiwiaDIiLCJlcSIsImlzU2hvcnQiLCJyIiwiZyIsImhleFBhcnNlIiwicmV0IiwiYWxwaGEiLCJoZXhTdHJpbmciLCJIVUVfUkUiLCJoc2wycmdibiIsImhzdjJyZ2JuIiwiaHdiMnJnYm4iLCJ3IiwicmdiIiwiaHVlVmFsdWUiLCJyZ2IyaHNsIiwiY2FsbG4iLCJoc2wycmdiIiwiaHdiMnJnYiIsImhzdjJyZ2IiLCJodWUiLCJodWVQYXJzZSIsImV4ZWMiLCJwMSIsInAyIiwicm90YXRlIiwiZGVnIiwiaHNsU3RyaW5nIiwiWiIsIlkiLCJYIiwiVyIsIlYiLCJVIiwiVCIsIlMiLCJSIiwiUSIsIlAiLCJPIiwiTiIsIk0iLCJMIiwiSyIsIkciLCJIIiwiSSIsIkoiLCJuYW1lcyQxIiwiT2ljZVhlIiwiYW50aXF1ZXdFdGUiLCJhcXVhIiwiYXF1YW1hclJlIiwiYXp1WSIsImJlaWdlIiwiYmlzcXVlIiwiYmxhY2siLCJibGFuS2VkT21vbmQiLCJYZSIsIlhldmlUZXQiLCJiUHduIiwiYnVybHl3b29kIiwiY2FNdFhlIiwiS2FydFl1c2UiLCJLb2NUYXRlIiwiY1NPIiwiY1NuZmxvd2VyWGUiLCJjU25zaWxrIiwiY3JpbXNvbiIsImN5YW4iLCJ4WGUiLCJ4Y3lhbiIsInhnVE1uUGQiLCJ4V2F5IiwieGdZRiIsInhnWXkiLCJ4a2hha2kiLCJ4bWFnRnRhIiwieFRpdmVnWUYiLCJ4U2FuZ2UiLCJ4U2NFZCIsInhZZCIsInhzT21vbiIsInhzSGdZRiIsInhVWGUiLCJ4VVdheSIsInhVZ1l5IiwieFFlIiwieHZpVGV0IiwiZEFwcFJrIiwiZEFwc2t5WGUiLCJkaW1XYXkiLCJkaW1nWXkiLCJkb2RnZXJYZSIsImZpWWJyaWNrIiwiZmxTT3dFdGUiLCJmb1lzdFdBbiIsImZ1S3NpYSIsImdhUnNiU28iLCJnaG9zdHdFdGUiLCJnVGQiLCJnVE1uUGQiLCJXYXkiLCJnWUYiLCJnWUZMdyIsImdZeSIsImhvbmV5TXciLCJob3RwUmsiLCJSZGlhbllkIiwiUmRpZ28iLCJpdlN5Iiwia2hha2kiLCJsYXZGTXIiLCJsYXZGTXJYc2giLCJsYXduZ1lGIiwiTm1vbmNFZmZvbiIsIlpYZSIsIlpjU08iLCJaY3lhbiIsIlpnVE1uUGRMdyIsIlpXYXkiLCJaZ1lGIiwiWmdZeSIsIlpwUmsiLCJac09tb24iLCJac0hnWUYiLCJac2t5WGUiLCJaVVdheSIsIlpVZ1l5IiwiWnN0QWxYZSIsIlpMdyIsImxpbWUiLCJsaW1lZ1lGIiwibFJGIiwibWFnRnRhIiwibWFQb24iLCJWYXF1YW1hclJlIiwiVlhlIiwiVlNjRWQiLCJWcHVycE4iLCJWc0hnWUYiLCJWVVhlIiwiVnNwclJnZ1lGIiwiVlFlIiwiVnZpVGV0WWQiLCJtaWRuaWdodFhlIiwibVJ0Y1lhbSIsIm1pc3R5UHNlIiwibW9jY2FzUiIsIm5hdmFqb3dFdGUiLCJuYXZ5IiwiVGRsYWNlIiwiVGl2ZSIsIlRpdmVkQmIiLCJTYW5nZSIsIlNhbmdlWWQiLCJTY0VkIiwicE9lZ1RNblBkIiwicE9lZ1lGIiwicE9lUWUiLCJwT2V2aVRldFlkIiwicGFwYXlhd0VwIiwicEhLcHVmZiIsInBlcnUiLCJwUmsiLCJwbHVtIiwicG93TXJYZSIsInB1cnBOIiwiWWJlY2NhcHVycE4iLCJZZCIsIlBzeWJyb3duIiwiUHlPWGUiLCJzYWRkTmJQd24iLCJzT21vbiIsInNhbmR5YlB3biIsInNIZ1lGIiwic0hzaGVsbCIsInNpRm5hIiwic2lsdmVyIiwic2t5WGUiLCJVWGUiLCJVV2F5IiwiVWdZeSIsInNub3ciLCJzcHJSZ2dZRiIsInN0QWxYZSIsInRhbiIsInRlTyIsInRFc3ROIiwidG9tYXRvIiwiUWUiLCJ2aVRldCIsIkpIdCIsIndFdGUiLCJ3RXRlc21va2UiLCJMdyIsIkx3Z1lGIiwidW5wYWNrIiwidW5wYWNrZWQiLCJ0a2V5cyIsImoiLCJvayIsIm5rIiwicmVwbGFjZSIsInBhcnNlSW50IiwibmFtZXMiLCJuYW1lUGFyc2UiLCJ0cmFuc3BhcmVudCIsInRvTG93ZXJDYXNlIiwiUkdCX1JFIiwicmdiUGFyc2UiLCJyZ2JTdHJpbmciLCJ0byIsImludGVycG9sYXRlIiwicmdiMSIsInJnYjIiLCJtb2RIU0wiLCJyYXRpbyIsImNsb25lIiwicHJvdG8iLCJmcm9tT2JqZWN0IiwiaW5wdXQiLCJmdW5jdGlvblBhcnNlIiwiQ29sb3IiLCJjb25zdHJ1Y3RvciIsIl9yZ2IiLCJfdmFsaWQiLCJ2YWxpZCIsIm1peCIsImNvbG9yIiwid2VpZ2h0IiwiYzEiLCJjMiIsIncyIiwidzEiLCJjbGVhcmVyIiwiZ3JleXNjYWxlIiwidmFsIiwib3BhcXVlciIsIm5lZ2F0ZSIsImxpZ2h0ZW4iLCJkYXJrZW4iLCJzYXR1cmF0ZSIsImRlc2F0dXJhdGUiLCJpbmRleF9lc20iLCJpc1BhdHRlcm5PckdyYWRpZW50IiwiZ2V0SG92ZXJDb2xvciIsIm92ZXJyaWRlcyIsImRlc2NyaXB0b3JzIiwiZ2V0U2NvcGUkMSIsIm5vZGUiLCJyb290IiwiRGVmYXVsdHMiLCJfZGVzY3JpcHRvcnMiLCJhbmltYXRpb24iLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsImRhdGFzZXRzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsImNvbnRleHQiLCJjaGFydCIsInBsYXRmb3JtIiwiZ2V0RGV2aWNlUGl4ZWxSYXRpbyIsImVsZW1lbnRzIiwiZXZlbnRzIiwiZm9udCIsImZhbWlseSIsInN0eWxlIiwibGluZUhlaWdodCIsImhvdmVyIiwiaG92ZXJCYWNrZ3JvdW5kQ29sb3IiLCJjdHgiLCJob3ZlckJvcmRlckNvbG9yIiwiaG92ZXJDb2xvciIsImluZGV4QXhpcyIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsImluY2x1ZGVJbnZpc2libGUiLCJtYWludGFpbkFzcGVjdFJhdGlvIiwib25Ib3ZlciIsIm9uQ2xpY2siLCJwYXJzaW5nIiwicGx1Z2lucyIsInJlc3BvbnNpdmUiLCJzY2FsZSIsInNjYWxlcyIsInNob3dMaW5lIiwiZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AiLCJkZXNjcmliZSIsImdldCIsIm92ZXJyaWRlIiwicm91dGUiLCJuYW1lIiwidGFyZ2V0U2NvcGUiLCJ0YXJnZXROYW1lIiwic2NvcGVPYmplY3QiLCJ0YXJnZXRTY29wZU9iamVjdCIsInByaXZhdGVOYW1lIiwiZGVmaW5lUHJvcGVydGllcyIsIndyaXRhYmxlIiwibG9jYWwiLCJkZWZhdWx0cyIsIl9zY3JpcHRhYmxlIiwic3RhcnRzV2l0aCIsIl9pbmRleGFibGUiLCJfZmFsbGJhY2siLCJ0b0ZvbnRTdHJpbmciLCJfbWVhc3VyZVRleHQiLCJkYXRhIiwiZ2MiLCJsb25nZXN0Iiwic3RyaW5nIiwidGV4dFdpZHRoIiwibWVhc3VyZVRleHQiLCJ3aWR0aCIsIl9sb25nZXN0VGV4dCIsImFycmF5T2ZUaGluZ3MiLCJjYWNoZSIsImdhcmJhZ2VDb2xsZWN0Iiwic2F2ZSIsImpsZW4iLCJ0aGluZyIsIm5lc3RlZFRoaW5nIiwicmVzdG9yZSIsImdjTGVuIiwiX2FsaWduUGl4ZWwiLCJwaXhlbCIsImN1cnJlbnREZXZpY2VQaXhlbFJhdGlvIiwiaGFsZldpZHRoIiwiY2xlYXJDYW52YXMiLCJjYW52YXMiLCJnZXRDb250ZXh0IiwicmVzZXRUcmFuc2Zvcm0iLCJjbGVhclJlY3QiLCJoZWlnaHQiLCJkcmF3UG9pbnQiLCJkcmF3UG9pbnRMZWdlbmQiLCJ4T2Zmc2V0IiwieU9mZnNldCIsImNvcm5lclJhZGl1cyIsInBvaW50U3R5bGUiLCJyb3RhdGlvbiIsInJhZGl1cyIsInJhZCIsInRyYW5zbGF0ZSIsImRyYXdJbWFnZSIsImJlZ2luUGF0aCIsImVsbGlwc2UiLCJhcmMiLCJjbG9zZVBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJTUVJUMV8yIiwicmVjdCIsImZpbGwiLCJib3JkZXJXaWR0aCIsInN0cm9rZSIsIl9pc1BvaW50SW5BcmVhIiwicG9pbnQiLCJhcmVhIiwibWFyZ2luIiwidG9wIiwiYm90dG9tIiwiY2xpcEFyZWEiLCJjbGlwIiwidW5jbGlwQXJlYSIsIl9zdGVwcGVkTGluZVRvIiwiZmxpcCIsIm1pZHBvaW50IiwiX2JlemllckN1cnZlVG8iLCJiZXppZXJDdXJ2ZVRvIiwiY3AxeCIsImNwMngiLCJjcDF5IiwiY3AyeSIsInJlbmRlclRleHQiLCJ0ZXh0Iiwib3B0cyIsImxpbmVzIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VDb2xvciIsImxpbmUiLCJzZXRSZW5kZXJPcHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lV2lkdGgiLCJzdHJva2VUZXh0IiwibWF4V2lkdGgiLCJmaWxsVGV4dCIsImRlY29yYXRlVGV4dCIsInRyYW5zbGF0aW9uIiwiZmlsbFN0eWxlIiwidGV4dEFsaWduIiwidGV4dEJhc2VsaW5lIiwic3RyaWtldGhyb3VnaCIsInVuZGVybGluZSIsIm1ldHJpY3MiLCJhY3R1YWxCb3VuZGluZ0JveExlZnQiLCJhY3R1YWxCb3VuZGluZ0JveFJpZ2h0IiwiYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQiLCJhY3R1YWxCb3VuZGluZ0JveERlc2NlbnQiLCJ5RGVjb3JhdGlvbiIsImRlY29yYXRpb25XaWR0aCIsImFkZFJvdW5kZWRSZWN0UGF0aCIsInRvcExlZnQiLCJib3R0b21MZWZ0IiwiYm90dG9tUmlnaHQiLCJ0b3BSaWdodCIsIkxJTkVfSEVJR0hUIiwiUmVnRXhwIiwiRk9OVF9TVFlMRSIsInRvTGluZUhlaWdodCIsIm1hdGNoZXMiLCJtYXRjaCIsIm51bWJlck9yWmVybyIsIl9yZWFkVmFsdWVUb1Byb3BzIiwicHJvcHMiLCJvYmpQcm9wcyIsInJlYWQiLCJwcm9wIiwidG9UUkJMIiwidG9UUkJMQ29ybmVycyIsInRvUGFkZGluZyIsInRvRm9udCIsImZhbGxiYWNrIiwicmVzb2x2ZSIsImlucHV0cyIsImluZm8iLCJjYWNoZWFibGUiLCJfYWRkR3JhY2UiLCJtaW5tYXgiLCJncmFjZSIsImJlZ2luQXRaZXJvIiwiY2hhbmdlIiwia2VlcFplcm8iLCJjcmVhdGVDb250ZXh0IiwicGFyZW50Q29udGV4dCIsIl9jcmVhdGVSZXNvbHZlciIsInNjb3BlcyIsInByZWZpeGVzIiwicm9vdFNjb3BlcyIsImdldFRhcmdldCIsIl9yZXNvbHZlIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJfY2FjaGVhYmxlIiwiX3Njb3BlcyIsIl9yb290U2NvcGVzIiwiX2dldFRhcmdldCIsIlByb3h5IiwiZGVsZXRlUHJvcGVydHkiLCJfa2V5cyIsIl9jYWNoZWQiLCJfcmVzb2x2ZVdpdGhQcmVmaXhlcyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIlJlZmxlY3QiLCJnZXRQcm90b3R5cGVPZiIsImdldEtleXNGcm9tQWxsU2NvcGVzIiwiaW5jbHVkZXMiLCJvd25LZXlzIiwic3RvcmFnZSIsIl9zdG9yYWdlIiwiX2F0dGFjaENvbnRleHQiLCJwcm94eSIsInN1YlByb3h5IiwiZGVzY3JpcHRvckRlZmF1bHRzIiwiX3Byb3h5IiwiX2NvbnRleHQiLCJfc3ViUHJveHkiLCJfc3RhY2siLCJzZXRDb250ZXh0IiwicmVjZWl2ZXIiLCJfcmVzb2x2ZVdpdGhDb250ZXh0IiwiYWxsS2V5cyIsInNjcmlwdGFibGUiLCJpbmRleGFibGUiLCJfYWxsS2V5cyIsImlzU2NyaXB0YWJsZSIsImlzSW5kZXhhYmxlIiwicmVhZEtleSIsInByZWZpeCIsIm5lZWRzU3ViUmVzb2x2ZXIiLCJfcmVzb2x2ZVNjcmlwdGFibGUiLCJfcmVzb2x2ZUFycmF5IiwiRXJyb3IiLCJqb2luIiwiZGVsZXRlIiwiY3JlYXRlU3ViUmVzb2x2ZXIiLCJhcnIiLCJmaWx0ZXIiLCJyZXNvbHZlRmFsbGJhY2siLCJnZXRTY29wZSIsInBhcmVudCIsImFkZFNjb3BlcyIsInBhcmVudFNjb3BlcyIsInBhcmVudEZhbGxiYWNrIiwiYWxsU2NvcGVzIiwiYWRkU2NvcGVzRnJvbUtleSIsInN1YkdldFRhcmdldCIsInJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyIsIl9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSIsIl9wYXJzaW5nIiwicGFyc2VkIiwicGFyc2UiLCJFUFNJTE9OIiwiZ2V0UG9pbnQiLCJza2lwIiwiZ2V0VmFsdWVBeGlzIiwic3BsaW5lQ3VydmUiLCJmaXJzdFBvaW50IiwibWlkZGxlUG9pbnQiLCJhZnRlclBvaW50IiwibmV4dCIsImQwMSIsImQxMiIsInMwMSIsInMxMiIsImZhIiwiZmIiLCJtb25vdG9uZUFkanVzdCIsImRlbHRhSyIsIm1LIiwicG9pbnRzTGVuIiwiYWxwaGFLIiwiYmV0YUsiLCJ0YXVLIiwic3F1YXJlZE1hZ25pdHVkZSIsInBvaW50Q3VycmVudCIsInBvaW50QWZ0ZXIiLCJtb25vdG9uZUNvbXB1dGUiLCJ2YWx1ZUF4aXMiLCJkZWx0YSIsInBvaW50QmVmb3JlIiwiaVBpeGVsIiwidlBpeGVsIiwic3BsaW5lQ3VydmVNb25vdG9uZSIsInNsb3BlRGVsdGEiLCJjYXBDb250cm9sUG9pbnQiLCJwdCIsImNhcEJlemllclBvaW50cyIsImluQXJlYSIsImluQXJlYVByZXYiLCJpbkFyZWFOZXh0IiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJsb29wIiwiY29udHJvbFBvaW50cyIsInNwYW5HYXBzIiwiY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSIsInByZXYiLCJ0ZW5zaW9uIiwiX2lzRG9tU3VwcG9ydGVkIiwiZG9jdW1lbnQiLCJfZ2V0UGFyZW50Tm9kZSIsImRvbU5vZGUiLCJwYXJlbnROb2RlIiwiaG9zdCIsInBhcnNlTWF4U3R5bGUiLCJzdHlsZVZhbHVlIiwicGFyZW50UHJvcGVydHkiLCJ2YWx1ZUluUGl4ZWxzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImVsZW1lbnQiLCJnZXRTdHlsZSIsImVsIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInBvc2l0aW9ucyIsImdldFBvc2l0aW9uZWRTdHlsZSIsInN0eWxlcyIsInN1ZmZpeCIsInBvcyIsInVzZU9mZnNldFBvcyIsInNoYWRvd1Jvb3QiLCJnZXRDYW52YXNQb3NpdGlvbiIsInRvdWNoZXMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsImJveCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0UmVsYXRpdmVQb3NpdGlvbiIsImV2dCIsImJvcmRlckJveCIsImJveFNpemluZyIsInBhZGRpbmdzIiwiYm9yZGVycyIsImdldENvbnRhaW5lclNpemUiLCJtYXhIZWlnaHQiLCJjb250YWluZXIiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImNvbnRhaW5lclN0eWxlIiwiY29udGFpbmVyQm9yZGVyIiwiY29udGFpbmVyUGFkZGluZyIsInJvdW5kMSIsImdldE1heGltdW1TaXplIiwiYmJXaWR0aCIsImJiSGVpZ2h0IiwiYXNwZWN0UmF0aW8iLCJtYXJnaW5zIiwiY29udGFpbmVyU2l6ZSIsInJldGluYVNjYWxlIiwiZm9yY2VSYXRpbyIsImZvcmNlU3R5bGUiLCJwaXhlbFJhdGlvIiwiZGV2aWNlSGVpZ2h0IiwiZGV2aWNlV2lkdGgiLCJzZXRUcmFuc2Zvcm0iLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwicGFzc2l2ZVN1cHBvcnRlZCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlYWRVc2VkU2l6ZSIsIl9wb2ludEluTGluZSIsIl9zdGVwcGVkSW50ZXJwb2xhdGlvbiIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiY3AxIiwiY3AyIiwiaW50bENhY2hlIiwiTWFwIiwiZ2V0TnVtYmVyRm9ybWF0IiwibG9jYWxlIiwiY2FjaGVLZXkiLCJKU09OIiwic3RyaW5naWZ5IiwiZm9ybWF0dGVyIiwiSW50bCIsIk51bWJlckZvcm1hdCIsImZvcm1hdE51bWJlciIsIm51bSIsImZvcm1hdCIsImdldFJpZ2h0VG9MZWZ0QWRhcHRlciIsInJlY3RYIiwic2V0V2lkdGgiLCJ4UGx1cyIsImxlZnRGb3JMdHIiLCJpdGVtV2lkdGgiLCJnZXRMZWZ0VG9SaWdodEFkYXB0ZXIiLCJfaXRlbVdpZHRoIiwiZ2V0UnRsQWRhcHRlciIsIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsImRpcmVjdGlvbiIsIm9yaWdpbmFsIiwiZ2V0UHJvcGVydHlQcmlvcml0eSIsInNldFByb3BlcnR5IiwicHJldlRleHREaXJlY3Rpb24iLCJyZXN0b3JlVGV4dERpcmVjdGlvbiIsInByb3BlcnR5Rm4iLCJiZXR3ZWVuIiwiY29tcGFyZSIsIm5vcm1hbGl6ZSIsIm5vcm1hbGl6ZVNlZ21lbnQiLCJnZXRTZWdtZW50Iiwic2VnbWVudCIsImJvdW5kcyIsInN0YXJ0Qm91bmQiLCJlbmRCb3VuZCIsIl9ib3VuZFNlZ21lbnQiLCJpbnNpZGUiLCJzdWJTdGFydCIsInByZXZWYWx1ZSIsInN0YXJ0SXNCZWZvcmUiLCJlbmRJc0JlZm9yZSIsInNob3VsZFN0YXJ0Iiwic2hvdWxkU3RvcCIsIl9ib3VuZFNlZ21lbnRzIiwic2VnbWVudHMiLCJzdWIiLCJmaW5kU3RhcnRBbmRFbmQiLCJzb2xpZFNlZ21lbnRzIiwiY3VyIiwic3RvcCIsIl9jb21wdXRlU2VnbWVudHMiLCJzZWdtZW50T3B0aW9ucyIsIl9sb29wIiwic3BsaXRCeVN0eWxlcyIsImNvbXBsZXRlTG9vcCIsIl9mdWxsTG9vcCIsImRvU3BsaXRCeVN0eWxlcyIsImNoYXJ0Q29udGV4dCIsIl9jaGFydCIsImJhc2VTdHlsZSIsInJlYWRTdHlsZSIsIl9kYXRhc2V0SW5kZXgiLCJwcmV2U3R5bGUiLCJhZGRTdHlsZSIsInN0IiwiZGlyIiwicDAiLCJwMERhdGFJbmRleCIsInAxRGF0YUluZGV4Iiwic3R5bGVDaGFuZ2VkIiwiYm9yZGVyQ2FwU3R5bGUiLCJib3JkZXJEYXNoIiwiYm9yZGVyRGFzaE9mZnNldCIsImJvcmRlckpvaW5TdHlsZSIsIiQiLCJfIiwiYSQiLCJhMiIsImEzIiwiYTQiLCJhNSIsImE2IiwiYTciLCJhOCIsImE5IiwiYUEiLCJhQiIsImFDIiwiYUQiLCJhRSIsImFGIiwiYUciLCJhSCIsImFJIiwiYUoiLCJhSyIsImFMIiwiYU0iLCJhTiIsImFPIiwiYVAiLCJhUSIsImFSIiwiYVMiLCJhVCIsImFVIiwiYVYiLCJhVyIsImFYIiwiYVkiLCJhWiIsImFfIiwiYWEiLCJhYiIsImFjIiwiYWQiLCJhZSIsImFmIiwiYWciLCJhaCIsImFpIiwiYWoiLCJhayIsImFsIiwiYW0iLCJhbiIsImFvIiwiYXAiLCJhcSIsImFyIiwiYXMiLCJhdCIsImF1IiwiYXYiLCJhdyIsImF4IiwiYXkiLCJheiIsImIwIiwiYjEiLCJiMiIsImIzIiwiYjQiLCJiNSIsInEiLCJ1IiwieiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/dist/helpers.mjs":
/*!************************************************!*\
  !*** ./node_modules/chart.js/dist/helpers.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.H),\n/* harmony export */   INFINITY: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b1),\n/* harmony export */   PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   PITAU: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b0),\n/* harmony export */   QUARTER_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b3),\n/* harmony export */   RAD_PER_DEG: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b2),\n/* harmony export */   TAU: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.T),\n/* harmony export */   TWO_THIRDS_PI: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b4),\n/* harmony export */   _addGrace: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   _alignPixel: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.J),\n/* harmony export */   _alignStartEnd: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.S),\n/* harmony export */   _angleBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   _angleDiff: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b5),\n/* harmony export */   _arrayUnique: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__._),\n/* harmony export */   _attachContext: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a9),\n/* harmony export */   _bezierCurveTo: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.at),\n/* harmony export */   _bezierInterpolation: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aq),\n/* harmony export */   _boundSegment: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ay),\n/* harmony export */   _boundSegments: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ao),\n/* harmony export */   _capitalize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.W),\n/* harmony export */   _computeSegments: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.an),\n/* harmony export */   _createResolver: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aa),\n/* harmony export */   _decimalPlaces: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aL),\n/* harmony export */   _deprecated: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aU),\n/* harmony export */   _descriptors: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ab),\n/* harmony export */   _elementsEqual: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ai),\n/* harmony export */   _factorize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   _filterBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aN),\n/* harmony export */   _getParentNode: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a2),\n/* harmony export */   _getStartAndCountOfVisiblePoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   _int16Range: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.I),\n/* harmony export */   _isBetween: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ak),\n/* harmony export */   _isClickEvent: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aj),\n/* harmony export */   _isDomSupported: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a6),\n/* harmony export */   _isPointInArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.$),\n/* harmony export */   _limitValue: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   _longestText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aM),\n/* harmony export */   _lookup: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aO),\n/* harmony export */   _lookupByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Z),\n/* harmony export */   _measureText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.G),\n/* harmony export */   _merger: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aS),\n/* harmony export */   _mergerIf: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aT),\n/* harmony export */   _normalizeAngle: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.az),\n/* harmony export */   _parseObjectDataRadialScale: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   _pointInLine: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ar),\n/* harmony export */   _readValueToProps: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.al),\n/* harmony export */   _rlookupByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Y),\n/* harmony export */   _scaleRangesChanged: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   _setMinAndMaxByKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aH),\n/* harmony export */   _splitKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aV),\n/* harmony export */   _steppedInterpolation: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ap),\n/* harmony export */   _steppedLineTo: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.as),\n/* harmony export */   _textX: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aC),\n/* harmony export */   _toLeftRightCenter: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.R),\n/* harmony export */   _updateBezierControlPoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.am),\n/* harmony export */   addRoundedRectPath: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.av),\n/* harmony export */   almostEquals: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aK),\n/* harmony export */   almostWhole: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aJ),\n/* harmony export */   callback: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   clearCanvas: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ag),\n/* harmony export */   clipArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.L),\n/* harmony export */   clone: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aR),\n/* harmony export */   color: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createContext: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   debounce: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ae),\n/* harmony export */   defined: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   distanceBetweenPoints: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aG),\n/* harmony export */   drawPoint: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.au),\n/* harmony export */   drawPointLegend: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aE),\n/* harmony export */   each: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.Q),\n/* harmony export */   easingEffects: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   finiteOrDefault: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.B),\n/* harmony export */   fontString: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a_),\n/* harmony export */   formatNumber: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   getAngleFromPoint: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a0),\n/* harmony export */   getHoverColor: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aQ),\n/* harmony export */   getMaximumSize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a1),\n/* harmony export */   getRelativePosition: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.X),\n/* harmony export */   getRtlAdapter: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aA),\n/* harmony export */   getStyle: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aZ),\n/* harmony export */   isArray: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   isFinite: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   isFunction: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a8),\n/* harmony export */   isNullOrUndef: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   isNumber: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   isObject: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   isPatternOrGradient: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aP),\n/* harmony export */   listenArrayEvents: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   log10: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.z),\n/* harmony export */   merge: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.V),\n/* harmony export */   mergeIf: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ac),\n/* harmony export */   niceNum: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aI),\n/* harmony export */   noop: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aF),\n/* harmony export */   overrideTextDirection: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aB),\n/* harmony export */   readUsedSize: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a3),\n/* harmony export */   renderText: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.M),\n/* harmony export */   requestAnimFrame: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   resolve: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a),\n/* harmony export */   resolveObjectKey: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   restoreTextDirection: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aD),\n/* harmony export */   retinaScale: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.af),\n/* harmony export */   setsEqual: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ah),\n/* harmony export */   sign: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   splineCurve: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aX),\n/* harmony export */   splineCurveMonotone: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aY),\n/* harmony export */   supportsEventListenerOptions: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a5),\n/* harmony export */   throttled: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a4),\n/* harmony export */   toDegrees: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.F),\n/* harmony export */   toDimension: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   toFont: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.O),\n/* harmony export */   toFontString: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aW),\n/* harmony export */   toLineHeight: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.a$),\n/* harmony export */   toPadding: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.K),\n/* harmony export */   toPercentage: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   toRadians: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   toTRBL: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.aw),\n/* harmony export */   toTRBLCorners: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ax),\n/* harmony export */   uid: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.ad),\n/* harmony export */   unclipArea: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   unlistenArrayEvents: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.u),\n/* harmony export */   valueOrDefault: () => (/* reexport safe */ _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__.v)\n/* harmony export */ });\n/* harmony import */ var _chunks_helpers_segment_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/helpers.segment.mjs */ \"(ssr)/./node_modules/chart.js/dist/chunks/helpers.segment.mjs\");\n/*!\n * Chart.js v3.9.1\n * https://www.chartjs.org\n * (c) 2022 Chart.js Contributors\n * Released under the MIT License\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvZGlzdC9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ28zRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2hlbHBlcnMubWpzPzFmZWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBDaGFydC5qcyB2My45LjFcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyMiBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5leHBvcnQgeyBIIGFzIEhBTEZfUEksIGIxIGFzIElORklOSVRZLCBQIGFzIFBJLCBiMCBhcyBQSVRBVSwgYjMgYXMgUVVBUlRFUl9QSSwgYjIgYXMgUkFEX1BFUl9ERUcsIFQgYXMgVEFVLCBiNCBhcyBUV09fVEhJUkRTX1BJLCBEIGFzIF9hZGRHcmFjZSwgSiBhcyBfYWxpZ25QaXhlbCwgUyBhcyBfYWxpZ25TdGFydEVuZCwgcCBhcyBfYW5nbGVCZXR3ZWVuLCBiNSBhcyBfYW5nbGVEaWZmLCBfIGFzIF9hcnJheVVuaXF1ZSwgYTkgYXMgX2F0dGFjaENvbnRleHQsIGF0IGFzIF9iZXppZXJDdXJ2ZVRvLCBhcSBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYXkgYXMgX2JvdW5kU2VnbWVudCwgYW8gYXMgX2JvdW5kU2VnbWVudHMsIFcgYXMgX2NhcGl0YWxpemUsIGFuIGFzIF9jb21wdXRlU2VnbWVudHMsIGFhIGFzIF9jcmVhdGVSZXNvbHZlciwgYUwgYXMgX2RlY2ltYWxQbGFjZXMsIGFVIGFzIF9kZXByZWNhdGVkLCBhYiBhcyBfZGVzY3JpcHRvcnMsIGFpIGFzIF9lbGVtZW50c0VxdWFsLCBBIGFzIF9mYWN0b3JpemUsIGFOIGFzIF9maWx0ZXJCZXR3ZWVuLCBhMiBhcyBfZ2V0UGFyZW50Tm9kZSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgSSBhcyBfaW50MTZSYW5nZSwgYWsgYXMgX2lzQmV0d2VlbiwgYWogYXMgX2lzQ2xpY2tFdmVudCwgYTYgYXMgX2lzRG9tU3VwcG9ydGVkLCAkIGFzIF9pc1BvaW50SW5BcmVhLCBFIGFzIF9saW1pdFZhbHVlLCBhTSBhcyBfbG9uZ2VzdFRleHQsIGFPIGFzIF9sb29rdXAsIFogYXMgX2xvb2t1cEJ5S2V5LCBHIGFzIF9tZWFzdXJlVGV4dCwgYVMgYXMgX21lcmdlciwgYVQgYXMgX21lcmdlcklmLCBheiBhcyBfbm9ybWFsaXplQW5nbGUsIHkgYXMgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLCBhciBhcyBfcG9pbnRJbkxpbmUsIGFsIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBZIGFzIF9ybG9va3VwQnlLZXksIHcgYXMgX3NjYWxlUmFuZ2VzQ2hhbmdlZCwgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhViBhcyBfc3BsaXRLZXksIGFwIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXMgYXMgX3N0ZXBwZWRMaW5lVG8sIGFDIGFzIF90ZXh0WCwgUiBhcyBfdG9MZWZ0UmlnaHRDZW50ZXIsIGFtIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhdiBhcyBhZGRSb3VuZGVkUmVjdFBhdGgsIGFLIGFzIGFsbW9zdEVxdWFscywgYUogYXMgYWxtb3N0V2hvbGUsIEMgYXMgY2FsbGJhY2ssIGFnIGFzIGNsZWFyQ2FudmFzLCBMIGFzIGNsaXBBcmVhLCBhUiBhcyBjbG9uZSwgYyBhcyBjb2xvciwgaCBhcyBjcmVhdGVDb250ZXh0LCBhZSBhcyBkZWJvdW5jZSwgaiBhcyBkZWZpbmVkLCBhRyBhcyBkaXN0YW5jZUJldHdlZW5Qb2ludHMsIGF1IGFzIGRyYXdQb2ludCwgYUUgYXMgZHJhd1BvaW50TGVnZW5kLCBRIGFzIGVhY2gsIGUgYXMgZWFzaW5nRWZmZWN0cywgQiBhcyBmaW5pdGVPckRlZmF1bHQsIGFfIGFzIGZvbnRTdHJpbmcsIG8gYXMgZm9ybWF0TnVtYmVyLCBhMCBhcyBnZXRBbmdsZUZyb21Qb2ludCwgYVEgYXMgZ2V0SG92ZXJDb2xvciwgYTEgYXMgZ2V0TWF4aW11bVNpemUsIFggYXMgZ2V0UmVsYXRpdmVQb3NpdGlvbiwgYUEgYXMgZ2V0UnRsQWRhcHRlciwgYVogYXMgZ2V0U3R5bGUsIGIgYXMgaXNBcnJheSwgZyBhcyBpc0Zpbml0ZSwgYTggYXMgaXNGdW5jdGlvbiwgayBhcyBpc051bGxPclVuZGVmLCB4IGFzIGlzTnVtYmVyLCBpIGFzIGlzT2JqZWN0LCBhUCBhcyBpc1BhdHRlcm5PckdyYWRpZW50LCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCB6IGFzIGxvZzEwLCBWIGFzIG1lcmdlLCBhYyBhcyBtZXJnZUlmLCBhSSBhcyBuaWNlTnVtLCBhRiBhcyBub29wLCBhQiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIGEzIGFzIHJlYWRVc2VkU2l6ZSwgTSBhcyByZW5kZXJUZXh0LCByIGFzIHJlcXVlc3RBbmltRnJhbWUsIGEgYXMgcmVzb2x2ZSwgZiBhcyByZXNvbHZlT2JqZWN0S2V5LCBhRCBhcyByZXN0b3JlVGV4dERpcmVjdGlvbiwgYWYgYXMgcmV0aW5hU2NhbGUsIGFoIGFzIHNldHNFcXVhbCwgcyBhcyBzaWduLCBhWCBhcyBzcGxpbmVDdXJ2ZSwgYVkgYXMgc3BsaW5lQ3VydmVNb25vdG9uZSwgYTUgYXMgc3VwcG9ydHNFdmVudExpc3RlbmVyT3B0aW9ucywgYTQgYXMgdGhyb3R0bGVkLCBGIGFzIHRvRGVncmVlcywgbiBhcyB0b0RpbWVuc2lvbiwgTyBhcyB0b0ZvbnQsIGFXIGFzIHRvRm9udFN0cmluZywgYSQgYXMgdG9MaW5lSGVpZ2h0LCBLIGFzIHRvUGFkZGluZywgbSBhcyB0b1BlcmNlbnRhZ2UsIHQgYXMgdG9SYWRpYW5zLCBhdyBhcyB0b1RSQkwsIGF4IGFzIHRvVFJCTENvcm5lcnMsIGFkIGFzIHVpZCwgTiBhcyB1bmNsaXBBcmVhLCB1IGFzIHVubGlzdGVuQXJyYXlFdmVudHMsIHYgYXMgdmFsdWVPckRlZmF1bHQgfSBmcm9tICcuL2NodW5rcy9oZWxwZXJzLnNlZ21lbnQubWpzJztcbiJdLCJuYW1lcyI6WyJIIiwiSEFMRl9QSSIsImIxIiwiSU5GSU5JVFkiLCJQIiwiUEkiLCJiMCIsIlBJVEFVIiwiYjMiLCJRVUFSVEVSX1BJIiwiYjIiLCJSQURfUEVSX0RFRyIsIlQiLCJUQVUiLCJiNCIsIlRXT19USElSRFNfUEkiLCJEIiwiX2FkZEdyYWNlIiwiSiIsIl9hbGlnblBpeGVsIiwiUyIsIl9hbGlnblN0YXJ0RW5kIiwicCIsIl9hbmdsZUJldHdlZW4iLCJiNSIsIl9hbmdsZURpZmYiLCJfIiwiX2FycmF5VW5pcXVlIiwiYTkiLCJfYXR0YWNoQ29udGV4dCIsImF0IiwiX2JlemllckN1cnZlVG8iLCJhcSIsIl9iZXppZXJJbnRlcnBvbGF0aW9uIiwiYXkiLCJfYm91bmRTZWdtZW50IiwiYW8iLCJfYm91bmRTZWdtZW50cyIsIlciLCJfY2FwaXRhbGl6ZSIsImFuIiwiX2NvbXB1dGVTZWdtZW50cyIsImFhIiwiX2NyZWF0ZVJlc29sdmVyIiwiYUwiLCJfZGVjaW1hbFBsYWNlcyIsImFVIiwiX2RlcHJlY2F0ZWQiLCJhYiIsIl9kZXNjcmlwdG9ycyIsImFpIiwiX2VsZW1lbnRzRXF1YWwiLCJBIiwiX2ZhY3Rvcml6ZSIsImFOIiwiX2ZpbHRlckJldHdlZW4iLCJhMiIsIl9nZXRQYXJlbnROb2RlIiwicSIsIl9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzIiwiSSIsIl9pbnQxNlJhbmdlIiwiYWsiLCJfaXNCZXR3ZWVuIiwiYWoiLCJfaXNDbGlja0V2ZW50IiwiYTYiLCJfaXNEb21TdXBwb3J0ZWQiLCIkIiwiX2lzUG9pbnRJbkFyZWEiLCJFIiwiX2xpbWl0VmFsdWUiLCJhTSIsIl9sb25nZXN0VGV4dCIsImFPIiwiX2xvb2t1cCIsIloiLCJfbG9va3VwQnlLZXkiLCJHIiwiX21lYXN1cmVUZXh0IiwiYVMiLCJfbWVyZ2VyIiwiYVQiLCJfbWVyZ2VySWYiLCJheiIsIl9ub3JtYWxpemVBbmdsZSIsInkiLCJfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUiLCJhciIsIl9wb2ludEluTGluZSIsImFsIiwiX3JlYWRWYWx1ZVRvUHJvcHMiLCJZIiwiX3Jsb29rdXBCeUtleSIsInciLCJfc2NhbGVSYW5nZXNDaGFuZ2VkIiwiYUgiLCJfc2V0TWluQW5kTWF4QnlLZXkiLCJhViIsIl9zcGxpdEtleSIsImFwIiwiX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIiwiYXMiLCJfc3RlcHBlZExpbmVUbyIsImFDIiwiX3RleHRYIiwiUiIsIl90b0xlZnRSaWdodENlbnRlciIsImFtIiwiX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMiLCJhdiIsImFkZFJvdW5kZWRSZWN0UGF0aCIsImFLIiwiYWxtb3N0RXF1YWxzIiwiYUoiLCJhbG1vc3RXaG9sZSIsIkMiLCJjYWxsYmFjayIsImFnIiwiY2xlYXJDYW52YXMiLCJMIiwiY2xpcEFyZWEiLCJhUiIsImNsb25lIiwiYyIsImNvbG9yIiwiaCIsImNyZWF0ZUNvbnRleHQiLCJhZSIsImRlYm91bmNlIiwiaiIsImRlZmluZWQiLCJhRyIsImRpc3RhbmNlQmV0d2VlblBvaW50cyIsImF1IiwiZHJhd1BvaW50IiwiYUUiLCJkcmF3UG9pbnRMZWdlbmQiLCJRIiwiZWFjaCIsImUiLCJlYXNpbmdFZmZlY3RzIiwiQiIsImZpbml0ZU9yRGVmYXVsdCIsImFfIiwiZm9udFN0cmluZyIsIm8iLCJmb3JtYXROdW1iZXIiLCJhMCIsImdldEFuZ2xlRnJvbVBvaW50IiwiYVEiLCJnZXRIb3ZlckNvbG9yIiwiYTEiLCJnZXRNYXhpbXVtU2l6ZSIsIlgiLCJnZXRSZWxhdGl2ZVBvc2l0aW9uIiwiYUEiLCJnZXRSdGxBZGFwdGVyIiwiYVoiLCJnZXRTdHlsZSIsImIiLCJpc0FycmF5IiwiZyIsImlzRmluaXRlIiwiYTgiLCJpc0Z1bmN0aW9uIiwiayIsImlzTnVsbE9yVW5kZWYiLCJ4IiwiaXNOdW1iZXIiLCJpIiwiaXNPYmplY3QiLCJhUCIsImlzUGF0dGVybk9yR3JhZGllbnQiLCJsIiwibGlzdGVuQXJyYXlFdmVudHMiLCJ6IiwibG9nMTAiLCJWIiwibWVyZ2UiLCJhYyIsIm1lcmdlSWYiLCJhSSIsIm5pY2VOdW0iLCJhRiIsIm5vb3AiLCJhQiIsIm92ZXJyaWRlVGV4dERpcmVjdGlvbiIsImEzIiwicmVhZFVzZWRTaXplIiwiTSIsInJlbmRlclRleHQiLCJyIiwicmVxdWVzdEFuaW1GcmFtZSIsImEiLCJyZXNvbHZlIiwiZiIsInJlc29sdmVPYmplY3RLZXkiLCJhRCIsInJlc3RvcmVUZXh0RGlyZWN0aW9uIiwiYWYiLCJyZXRpbmFTY2FsZSIsImFoIiwic2V0c0VxdWFsIiwicyIsInNpZ24iLCJhWCIsInNwbGluZUN1cnZlIiwiYVkiLCJzcGxpbmVDdXJ2ZU1vbm90b25lIiwiYTUiLCJzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zIiwiYTQiLCJ0aHJvdHRsZWQiLCJGIiwidG9EZWdyZWVzIiwibiIsInRvRGltZW5zaW9uIiwiTyIsInRvRm9udCIsImFXIiwidG9Gb250U3RyaW5nIiwiYSQiLCJ0b0xpbmVIZWlnaHQiLCJLIiwidG9QYWRkaW5nIiwibSIsInRvUGVyY2VudGFnZSIsInQiLCJ0b1JhZGlhbnMiLCJhdyIsInRvVFJCTCIsImF4IiwidG9UUkJMQ29ybmVycyIsImFkIiwidWlkIiwiTiIsInVuY2xpcEFyZWEiLCJ1IiwidW5saXN0ZW5BcnJheUV2ZW50cyIsInYiLCJ2YWx1ZU9yRGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/dist/helpers.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/chart.js/helpers/helpers.mjs":
/*!***************************************************!*\
  !*** ./node_modules/chart.js/helpers/helpers.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HALF_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.HALF_PI),\n/* harmony export */   INFINITY: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.INFINITY),\n/* harmony export */   PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PI),\n/* harmony export */   PITAU: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.PITAU),\n/* harmony export */   QUARTER_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI),\n/* harmony export */   RAD_PER_DEG: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG),\n/* harmony export */   TAU: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TAU),\n/* harmony export */   TWO_THIRDS_PI: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI),\n/* harmony export */   _addGrace: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._addGrace),\n/* harmony export */   _alignPixel: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignPixel),\n/* harmony export */   _alignStartEnd: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._alignStartEnd),\n/* harmony export */   _angleBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleBetween),\n/* harmony export */   _angleDiff: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._angleDiff),\n/* harmony export */   _arrayUnique: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._arrayUnique),\n/* harmony export */   _attachContext: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._attachContext),\n/* harmony export */   _bezierCurveTo: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierCurveTo),\n/* harmony export */   _bezierInterpolation: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._bezierInterpolation),\n/* harmony export */   _boundSegment: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegment),\n/* harmony export */   _boundSegments: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._boundSegments),\n/* harmony export */   _capitalize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._capitalize),\n/* harmony export */   _computeSegments: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._computeSegments),\n/* harmony export */   _createResolver: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._createResolver),\n/* harmony export */   _decimalPlaces: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._decimalPlaces),\n/* harmony export */   _deprecated: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._deprecated),\n/* harmony export */   _descriptors: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._descriptors),\n/* harmony export */   _elementsEqual: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._elementsEqual),\n/* harmony export */   _factorize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._factorize),\n/* harmony export */   _filterBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._filterBetween),\n/* harmony export */   _getParentNode: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getParentNode),\n/* harmony export */   _getStartAndCountOfVisiblePoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._getStartAndCountOfVisiblePoints),\n/* harmony export */   _int16Range: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._int16Range),\n/* harmony export */   _isBetween: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isBetween),\n/* harmony export */   _isClickEvent: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isClickEvent),\n/* harmony export */   _isDomSupported: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isDomSupported),\n/* harmony export */   _isPointInArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._isPointInArea),\n/* harmony export */   _limitValue: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._limitValue),\n/* harmony export */   _longestText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._longestText),\n/* harmony export */   _lookup: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookup),\n/* harmony export */   _lookupByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._lookupByKey),\n/* harmony export */   _measureText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._measureText),\n/* harmony export */   _merger: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._merger),\n/* harmony export */   _mergerIf: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._mergerIf),\n/* harmony export */   _normalizeAngle: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._normalizeAngle),\n/* harmony export */   _parseObjectDataRadialScale: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._parseObjectDataRadialScale),\n/* harmony export */   _pointInLine: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._pointInLine),\n/* harmony export */   _readValueToProps: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._readValueToProps),\n/* harmony export */   _rlookupByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._rlookupByKey),\n/* harmony export */   _scaleRangesChanged: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._scaleRangesChanged),\n/* harmony export */   _setMinAndMaxByKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._setMinAndMaxByKey),\n/* harmony export */   _splitKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._splitKey),\n/* harmony export */   _steppedInterpolation: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedInterpolation),\n/* harmony export */   _steppedLineTo: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._steppedLineTo),\n/* harmony export */   _textX: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._textX),\n/* harmony export */   _toLeftRightCenter: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._toLeftRightCenter),\n/* harmony export */   _updateBezierControlPoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__._updateBezierControlPoints),\n/* harmony export */   addRoundedRectPath: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.addRoundedRectPath),\n/* harmony export */   almostEquals: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostEquals),\n/* harmony export */   almostWhole: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.almostWhole),\n/* harmony export */   callback: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.callback),\n/* harmony export */   clearCanvas: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clearCanvas),\n/* harmony export */   clipArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clipArea),\n/* harmony export */   clone: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.clone),\n/* harmony export */   color: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.color),\n/* harmony export */   createContext: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.createContext),\n/* harmony export */   debounce: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.debounce),\n/* harmony export */   defined: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.defined),\n/* harmony export */   distanceBetweenPoints: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints),\n/* harmony export */   drawPoint: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPoint),\n/* harmony export */   drawPointLegend: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.drawPointLegend),\n/* harmony export */   each: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.each),\n/* harmony export */   easingEffects: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.easingEffects),\n/* harmony export */   finiteOrDefault: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.finiteOrDefault),\n/* harmony export */   fontString: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.fontString),\n/* harmony export */   formatNumber: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.formatNumber),\n/* harmony export */   getAngleFromPoint: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint),\n/* harmony export */   getHoverColor: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getHoverColor),\n/* harmony export */   getMaximumSize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getMaximumSize),\n/* harmony export */   getRelativePosition: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRelativePosition),\n/* harmony export */   getRtlAdapter: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getRtlAdapter),\n/* harmony export */   getStyle: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.getStyle),\n/* harmony export */   isArray: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isArray),\n/* harmony export */   isFinite: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFinite),\n/* harmony export */   isFunction: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction),\n/* harmony export */   isNullOrUndef: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef),\n/* harmony export */   isNumber: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isNumber),\n/* harmony export */   isObject: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject),\n/* harmony export */   isPatternOrGradient: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.isPatternOrGradient),\n/* harmony export */   listenArrayEvents: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.listenArrayEvents),\n/* harmony export */   log10: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.log10),\n/* harmony export */   merge: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.merge),\n/* harmony export */   mergeIf: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.mergeIf),\n/* harmony export */   niceNum: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.niceNum),\n/* harmony export */   noop: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.noop),\n/* harmony export */   overrideTextDirection: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.overrideTextDirection),\n/* harmony export */   readUsedSize: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.readUsedSize),\n/* harmony export */   renderText: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.renderText),\n/* harmony export */   requestAnimFrame: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.requestAnimFrame),\n/* harmony export */   resolve: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolve),\n/* harmony export */   resolveObjectKey: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.resolveObjectKey),\n/* harmony export */   restoreTextDirection: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.restoreTextDirection),\n/* harmony export */   retinaScale: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.retinaScale),\n/* harmony export */   setsEqual: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.setsEqual),\n/* harmony export */   sign: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.sign),\n/* harmony export */   splineCurve: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurve),\n/* harmony export */   splineCurveMonotone: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.splineCurveMonotone),\n/* harmony export */   supportsEventListenerOptions: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.supportsEventListenerOptions),\n/* harmony export */   throttled: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.throttled),\n/* harmony export */   toDegrees: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDegrees),\n/* harmony export */   toDimension: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toDimension),\n/* harmony export */   toFont: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFont),\n/* harmony export */   toFontString: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toFontString),\n/* harmony export */   toLineHeight: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toLineHeight),\n/* harmony export */   toPadding: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPadding),\n/* harmony export */   toPercentage: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toPercentage),\n/* harmony export */   toRadians: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toRadians),\n/* harmony export */   toTRBL: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBL),\n/* harmony export */   toTRBLCorners: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.toTRBLCorners),\n/* harmony export */   uid: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.uid),\n/* harmony export */   unclipArea: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unclipArea),\n/* harmony export */   unlistenArrayEvents: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.unlistenArrayEvents),\n/* harmony export */   valueOrDefault: () => (/* reexport safe */ _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)\n/* harmony export */ });\n/* harmony import */ var _dist_helpers_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dist/helpers.mjs */ \"(ssr)/./node_modules/chart.js/dist/helpers.mjs\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NsaWVudC8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9oZWxwZXJzL2hlbHBlcnMubWpzPzZhZDEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9oZWxwZXJzLm1qcyc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/chart.js/helpers/helpers.mjs\n");

/***/ })

};
;